/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/(pages)/calendar/page"],{

/***/ "(app-pages-browser)/../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fbryce%2FDocuments%2FRepos%2Ftimespark%2Ffrontend%2Fsrc%2Fapp%2F(pages)%2Fcalendar%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fbryce%2FDocuments%2FRepos%2Ftimespark%2Ffrontend%2Fsrc%2Fapp%2F(pages)%2Fcalendar%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/(pages)/calendar/page.js */ \"(app-pages-browser)/./src/app/(pages)/calendar/page.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGYnJ5Y2UlMkZEb2N1bWVudHMlMkZSZXBvcyUyRnRpbWVzcGFyayUyRmZyb250ZW5kJTJGc3JjJTJGYXBwJTJGKHBhZ2VzKSUyRmNhbGVuZGFyJTJGcGFnZS5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLDhMQUFxSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzAxZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvYnJ5Y2UvRG9jdW1lbnRzL1JlcG9zL3RpbWVzcGFyay9mcm9udGVuZC9zcmMvYXBwLyhwYWdlcykvY2FsZW5kYXIvcGFnZS5qc1wiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fbryce%2FDocuments%2FRepos%2Ftimespark%2Ffrontend%2Fsrc%2Fapp%2F(pages)%2Fcalendar%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/api/image.js":
/*!**********************************************!*\
  !*** ../node_modules/next/dist/api/image.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/image-external */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/image-external.js\");\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=image.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9pbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBdUQ7QUFDVjs7QUFFN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzPzRhZGMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCIuLi9zaGFyZWQvbGliL2ltYWdlLWV4dGVybmFsXCI7XG5leHBvcnQgKiBmcm9tIFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbFwiO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/api/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/api/link.js":
/*!*********************************************!*\
  !*** ../node_modules/next/dist/api/link.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _client_link__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/link */ \"(app-pages-browser)/../node_modules/next/dist/client/link.js\");\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_link__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_link__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_link__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=link.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9saW5rLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF5QztBQUNWOztBQUUvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9hcGkvbGluay5qcz82YjAxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLi4vY2xpZW50L2xpbmtcIjtcbmV4cG9ydCAqIGZyb20gXCIuLi9jbGllbnQvbGlua1wiO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/api/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/build/polyfills/process.js":
/*!************************************************************!*\
  !*** ../node_modules/next/dist/build/polyfills/process.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/../node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxxQ0FBcUMscUJBQU0saUZBQWlGLHFCQUFNLGtFQUFrRSxxQkFBTSxXQUFXLG1CQUFPLENBQUMsNkdBQTRCOztBQUV6UCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvcHJvY2Vzcy5qcz84OTJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9nbG9iYWxfcHJvY2VzcywgX2dsb2JhbF9wcm9jZXNzMTtcbm1vZHVsZS5leHBvcnRzID0gKChfZ2xvYmFsX3Byb2Nlc3MgPSBnbG9iYWwucHJvY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxfcHJvY2Vzcy5lbnYpICYmIHR5cGVvZiAoKF9nbG9iYWxfcHJvY2VzczEgPSBnbG9iYWwucHJvY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxfcHJvY2VzczEuZW52KSA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbC5wcm9jZXNzIDogcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzXCIpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9jZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!**********************************************************************************************!*\
  !*** ../node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \**********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={592:(e,r,t)=>{var n=t(722);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},722:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(592);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxhQUFhLE9BQU8sY0FBYyxhQUFhLDBCQUEwQixvQ0FBb0MsOEJBQThCLHVCQUF1QixRQUFRLGtCQUFrQixXQUFXLGdCQUFnQiw4QkFBOEIscUJBQXFCLGdCQUFnQixtQkFBbUIsaUJBQWlCLGdDQUFnQyxXQUFXLE9BQU8sMkJBQTJCLDZCQUE2QixLQUFLLDhDQUE4QyxvQkFBb0IsTUFBTSxTQUFTLE9BQU8sbUJBQW1CLE9BQU8sWUFBWSxnQ0FBZ0MsY0FBYyxPQUFPLGdDQUFnQyxPQUFPLGdDQUFnQyxxQ0FBcUMsNENBQTRDLDJDQUEyQyxTQUFTLGdCQUFnQixJQUFJLHdCQUF3QixPQUFPLFlBQVksT0FBTyx1QkFBdUIscUJBQXFCLE9BQU8sdUJBQXVCLE9BQU8sZ0NBQWdDLE9BQU8sZUFBZSxvQkFBb0IsaUJBQWlCLHNDQUFzQyxlQUFlLE9BQU8sZ0JBQWdCLDRCQUE0QixHQUFHLHVDQUF1QyxlQUFlLE9BQU8sZ0JBQWdCLDRCQUE0QixHQUFHLDJDQUEyQyxrQkFBa0IsMkNBQTJDLEtBQUssNkJBQTZCLDJCQUEyQixNQUFNLE9BQU8sZUFBZSxFQUFFLG9CQUFvQixvQkFBb0IsS0FBSyxHQUFHLFNBQVMsd0JBQXdCLE9BQU8sYUFBYSx3Q0FBd0MsWUFBWSxzQkFBc0IsWUFBWSxPQUFPLDZCQUE2QixxQkFBcUIsT0FBTyxxQkFBcUIsT0FBTyxNQUFNLGVBQWUsUUFBUSxHQUFHLFNBQVMscUJBQXFCLHdDQUF3QyxzQkFBc0IscUJBQXFCLE9BQU8sYUFBYSxHQUFHLHlCQUF5Qix5Q0FBeUMsYUFBYSxZQUFZLHdCQUF3QixNQUFNLDBEQUEwRCxZQUFZLDZCQUE2QixrQkFBa0Isb0JBQW9CLHFCQUFxQixhQUFhLGdFQUFnRSxZQUFZLE9BQU8sTUFBTSwrQ0FBK0MsS0FBSyxvQ0FBb0MsYUFBYSw0QkFBNEIsU0FBUyx5QkFBeUIsK0JBQStCLFVBQVUsaUJBQWlCLE1BQU0sY0FBYyxrQkFBa0IsU0FBUyxnQkFBZ0Isc0JBQXNCLFdBQVcsc0JBQXNCLFNBQVMsb0RBQW9ELGlEQUFpRCwyQ0FBMkMsUUFBUSxzQkFBc0IsZ0JBQWdCLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzP2MwMmYiXSwic291cmNlc0NvbnRlbnQiOlsiKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezU5MjooZSxyLHQpPT57dmFyIG49dCg3MjIpO3ZhciBpPU9iamVjdC5jcmVhdGUobnVsbCk7dmFyIGE9dHlwZW9mIGRvY3VtZW50PT09XCJ1bmRlZmluZWRcIjt2YXIgbz1BcnJheS5wcm90b3R5cGUuZm9yRWFjaDtmdW5jdGlvbiBkZWJvdW5jZShlLHIpe3ZhciB0PTA7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49dGhpczt2YXIgaT1hcmd1bWVudHM7dmFyIGE9ZnVuY3Rpb24gZnVuY3Rpb25DYWxsKCl7cmV0dXJuIGUuYXBwbHkobixpKX07Y2xlYXJUaW1lb3V0KHQpO3Q9c2V0VGltZW91dChhLHIpfX1mdW5jdGlvbiBub29wKCl7fWZ1bmN0aW9uIGdldEN1cnJlbnRTY3JpcHRVcmwoZSl7dmFyIHI9aVtlXTtpZighcil7aWYoZG9jdW1lbnQuY3VycmVudFNjcmlwdCl7cj1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY31lbHNle3ZhciB0PWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO3ZhciBhPXRbdC5sZW5ndGgtMV07aWYoYSl7cj1hLnNyY319aVtlXT1yfXJldHVybiBmdW5jdGlvbihlKXtpZighcil7cmV0dXJuIG51bGx9dmFyIHQ9ci5zcGxpdCgvKFteXFxcXC9dKylcXC5qcyQvKTt2YXIgaT10JiZ0WzFdO2lmKCFpKXtyZXR1cm5bci5yZXBsYWNlKFwiLmpzXCIsXCIuY3NzXCIpXX1pZighZSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19cmV0dXJuIGUuc3BsaXQoXCIsXCIpLm1hcCgoZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFJlZ0V4cChcIlwiLmNvbmNhdChpLFwiXFxcXC5qcyRcIiksXCJnXCIpO3JldHVybiBuKHIucmVwbGFjZSh0LFwiXCIuY29uY2F0KGUucmVwbGFjZSgve2ZpbGVOYW1lfS9nLGkpLFwiLmNzc1wiKSkpfSkpfX1mdW5jdGlvbiB1cGRhdGVDc3MoZSxyKXtpZighcil7aWYoIWUuaHJlZil7cmV0dXJufXI9ZS5ocmVmLnNwbGl0KFwiP1wiKVswXX1pZighaXNVcmxSZXF1ZXN0KHIpKXtyZXR1cm59aWYoZS5pc0xvYWRlZD09PWZhbHNlKXtyZXR1cm59aWYoIXJ8fCEoci5pbmRleE9mKFwiLmNzc1wiKT4tMSkpe3JldHVybn1lLnZpc2l0ZWQ9dHJ1ZTt2YXIgdD1lLmNsb25lTm9kZSgpO3QuaXNMb2FkZWQ9ZmFsc2U7dC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsKGZ1bmN0aW9uKCl7aWYodC5pc0xvYWRlZCl7cmV0dXJufXQuaXNMb2FkZWQ9dHJ1ZTtlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSl9KSk7dC5ocmVmPVwiXCIuY29uY2F0KHIsXCI/XCIpLmNvbmNhdChEYXRlLm5vdygpKTtpZihlLm5leHRTaWJsaW5nKXtlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsZS5uZXh0U2libGluZyl9ZWxzZXtlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodCl9fWZ1bmN0aW9uIGdldFJlbG9hZFVybChlLHIpe3ZhciB0O2U9bihlLHtzdHJpcFdXVzpmYWxzZX0pO3Iuc29tZSgoZnVuY3Rpb24obil7aWYoZS5pbmRleE9mKHIpPi0xKXt0PW59fSkpO3JldHVybiB0fWZ1bmN0aW9uIHJlbG9hZFN0eWxlKGUpe2lmKCFlKXtyZXR1cm4gZmFsc2V9dmFyIHI9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7dmFyIHQ9ZmFsc2U7by5jYWxsKHIsKGZ1bmN0aW9uKHIpe2lmKCFyLmhyZWYpe3JldHVybn12YXIgbj1nZXRSZWxvYWRVcmwoci5ocmVmLGUpO2lmKCFpc1VybFJlcXVlc3Qobikpe3JldHVybn1pZihyLnZpc2l0ZWQ9PT10cnVlKXtyZXR1cm59aWYobil7dXBkYXRlQ3NzKHIsbik7dD10cnVlfX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRBbGwoKXt2YXIgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1wiKTtvLmNhbGwoZSwoZnVuY3Rpb24oZSl7aWYoZS52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufXVwZGF0ZUNzcyhlKX0pKX1mdW5jdGlvbiBpc1VybFJlcXVlc3QoZSl7aWYoIS9eW2EtekEtWl1bYS16QS1aXFxkK1xcLS5dKjovLnRlc3QoZSkpe3JldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXtpZihhKXtjb25zb2xlLmxvZyhcIm5vIHdpbmRvdy5kb2N1bWVudCBmb3VuZCwgd2lsbCBub3QgSE1SIENTU1wiKTtyZXR1cm4gbm9vcH12YXIgdD1nZXRDdXJyZW50U2NyaXB0VXJsKGUpO2Z1bmN0aW9uIHVwZGF0ZSgpe3ZhciBlPXQoci5maWxlbmFtZSk7dmFyIG49cmVsb2FkU3R5bGUoZSk7aWYoci5sb2NhbHMpe2NvbnNvbGUubG9nKFwiW0hNUl0gRGV0ZWN0ZWQgbG9jYWwgY3NzIG1vZHVsZXMuIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpO3JldHVybn1pZihuKXtjb25zb2xlLmxvZyhcIltITVJdIGNzcyByZWxvYWQgJXNcIixlLmpvaW4oXCIgXCIpKX1lbHNle2NvbnNvbGUubG9nKFwiW0hNUl0gUmVsb2FkIGFsbCBjc3NcIik7cmVsb2FkQWxsKCl9fXJldHVybiBkZWJvdW5jZSh1cGRhdGUsNTApfX0sNzIyOmU9PntmdW5jdGlvbiBub3JtYWxpemVVcmwoZSl7cmV0dXJuIGUucmVkdWNlKChmdW5jdGlvbihlLHIpe3N3aXRjaChyKXtjYXNlXCIuLlwiOmUucG9wKCk7YnJlYWs7Y2FzZVwiLlwiOmJyZWFrO2RlZmF1bHQ6ZS5wdXNoKHIpfXJldHVybiBlfSksW10pLmpvaW4oXCIvXCIpfWUuZXhwb3J0cz1mdW5jdGlvbihlKXtlPWUudHJpbSgpO2lmKC9eZGF0YTovaS50ZXN0KGUpKXtyZXR1cm4gZX12YXIgcj1lLmluZGV4T2YoXCIvL1wiKSE9PS0xP2Uuc3BsaXQoXCIvL1wiKVswXStcIi8vXCI6XCJcIjt2YXIgdD1lLnJlcGxhY2UobmV3IFJlZ0V4cChyLFwiaVwiKSxcIlwiKS5zcGxpdChcIi9cIik7dmFyIG49dFswXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcLiQvLFwiXCIpO3RbMF09XCJcIjt2YXIgaT1ub3JtYWxpemVVcmwodCk7cmV0dXJuIHIrbitpfX19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIG49clt0XTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXJbdF09e2V4cG9ydHM6e319O3ZhciBhPXRydWU7dHJ5e2VbdF0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7YT1mYWxzZX1maW5hbGx5e2lmKGEpZGVsZXRlIHJbdF19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXyg1OTIpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/compiled/picomatch/index.js":
/*!*************************************************************!*\
  !*** ../node_modules/next/dist/compiled/picomatch/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../node_modules/next/dist/build/polyfills/process.js\");\n(()=>{\"use strict\";var t={170:(t,e,u)=>{const n=u(510);const isWindows=()=>{if(typeof navigator!==\"undefined\"&&navigator.platform){const t=navigator.platform.toLowerCase();return t===\"win32\"||t===\"windows\"}if(typeof process!==\"undefined\"&&process.platform){return process.platform===\"win32\"}return false};function picomatch(t,e,u=false){if(e&&(e.windows===null||e.windows===undefined)){e={...e,windows:isWindows()}}return n(t,e,u)}Object.assign(picomatch,n);t.exports=picomatch},154:t=>{const e=\"\\\\\\\\/\";const u=`[^${e}]`;const n=\"\\\\.\";const o=\"\\\\+\";const s=\"\\\\?\";const r=\"\\\\/\";const a=\"(?=.)\";const i=\"[^/]\";const c=`(?:${r}|$)`;const p=`(?:^|${r})`;const l=`${n}{1,2}${c}`;const f=`(?!${n})`;const A=`(?!${p}${l})`;const _=`(?!${n}{0,1}${c})`;const R=`(?!${l})`;const E=`[^.${r}]`;const h=`${i}*?`;const g=\"/\";const b={DOT_LITERAL:n,PLUS_LITERAL:o,QMARK_LITERAL:s,SLASH_LITERAL:r,ONE_CHAR:a,QMARK:i,END_ANCHOR:c,DOTS_SLASH:l,NO_DOT:f,NO_DOTS:A,NO_DOT_SLASH:_,NO_DOTS_SLASH:R,QMARK_NO_DOT:E,STAR:h,START_ANCHOR:p,SEP:g};const C={...b,SLASH_LITERAL:`[${e}]`,QMARK:u,STAR:`${u}*?`,DOTS_SLASH:`${n}{1,2}(?:[${e}]|$)`,NO_DOT:`(?!${n})`,NO_DOTS:`(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,NO_DOT_SLASH:`(?!${n}{0,1}(?:[${e}]|$))`,NO_DOTS_SLASH:`(?!${n}{1,2}(?:[${e}]|$))`,QMARK_NO_DOT:`[^.${e}]`,START_ANCHOR:`(?:^|[${e}])`,END_ANCHOR:`(?:[${e}]|$)`,SEP:\"\\\\\"};const y={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};t.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:y,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,extglobChars(t){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${t.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(t){return t===true?C:b}}},697:(t,e,u)=>{const n=u(154);const o=u(96);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:r,REGEX_NON_SPECIAL_CHARS:a,REGEX_SPECIAL_CHARS_BACKREF:i,REPLACEMENTS:c}=n;const expandRange=(t,e)=>{if(typeof e.expandRange===\"function\"){return e.expandRange(...t,e)}t.sort();const u=`[${t.join(\"-\")}]`;try{new RegExp(u)}catch(e){return t.map((t=>o.escapeRegex(t))).join(\"..\")}return u};const syntaxError=(t,e)=>`Missing ${t}: \"${e}\" - use \"\\\\\\\\${e}\" to match literal characters`;const parse=(t,e)=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected a string\")}t=c[t]||t;const u={...e};const p=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;let l=t.length;if(l>p){throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`)}const f={type:\"bos\",value:\"\",output:u.prepend||\"\"};const A=[f];const _=u.capture?\"\":\"?:\";const R=n.globChars(u.windows);const E=n.extglobChars(R);const{DOT_LITERAL:h,PLUS_LITERAL:g,SLASH_LITERAL:b,ONE_CHAR:C,DOTS_SLASH:y,NO_DOT:$,NO_DOT_SLASH:x,NO_DOTS_SLASH:S,QMARK:H,QMARK_NO_DOT:v,STAR:d,START_ANCHOR:L}=R;const globstar=t=>`(${_}(?:(?!${L}${t.dot?y:h}).)*?)`;const T=u.dot?\"\":$;const O=u.dot?H:v;let k=u.bash===true?globstar(u):d;if(u.capture){k=`(${k})`}if(typeof u.noext===\"boolean\"){u.noextglob=u.noext}const m={input:t,index:-1,start:0,dot:u.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};t=o.removePrefix(t,m);l=t.length;const w=[];const N=[];const I=[];let B=f;let G;const eos=()=>m.index===l-1;const D=m.peek=(e=1)=>t[m.index+e];const M=m.advance=()=>t[++m.index]||\"\";const remaining=()=>t.slice(m.index+1);const consume=(t=\"\",e=0)=>{m.consumed+=t;m.index+=e};const append=t=>{m.output+=t.output!=null?t.output:t.value;consume(t.value)};const negate=()=>{let t=1;while(D()===\"!\"&&(D(2)!==\"(\"||D(3)===\"?\")){M();m.start++;t++}if(t%2===0){return false}m.negated=true;m.start++;return true};const increment=t=>{m[t]++;I.push(t)};const decrement=t=>{m[t]--;I.pop()};const push=t=>{if(B.type===\"globstar\"){const e=m.braces>0&&(t.type===\"comma\"||t.type===\"brace\");const u=t.extglob===true||w.length&&(t.type===\"pipe\"||t.type===\"paren\");if(t.type!==\"slash\"&&t.type!==\"paren\"&&!e&&!u){m.output=m.output.slice(0,-B.output.length);B.type=\"star\";B.value=\"*\";B.output=k;m.output+=B.output}}if(w.length&&t.type!==\"paren\"){w[w.length-1].inner+=t.value}if(t.value||t.output)append(t);if(B&&B.type===\"text\"&&t.type===\"text\"){B.output=(B.output||B.value)+t.value;B.value+=t.value;return}t.prev=B;A.push(t);B=t};const extglobOpen=(t,e)=>{const n={...E[e],conditions:1,inner:\"\"};n.prev=B;n.parens=m.parens;n.output=m.output;const o=(u.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:t,value:e,output:m.output?\"\":C});push({type:\"paren\",extglob:true,value:M(),output:o});w.push(n)};const extglobClose=t=>{let n=t.close+(u.capture?\")\":\"\");let o;if(t.type===\"negate\"){let s=k;if(t.inner&&t.inner.length>1&&t.inner.includes(\"/\")){s=globstar(u)}if(s!==k||eos()||/^\\)+$/.test(remaining())){n=t.close=`)$))${s}`}if(t.inner.includes(\"*\")&&(o=remaining())&&/^\\.[^\\\\/.]+$/.test(o)){const u=parse(o,{...e,fastpaths:false}).output;n=t.close=`)${u})${s})`}if(t.prev.type===\"bos\"){m.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:G,output:n});decrement(\"parens\")};if(u.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(t)){let n=false;let s=t.replace(i,((t,e,u,o,s,r)=>{if(o===\"\\\\\"){n=true;return t}if(o===\"?\"){if(e){return e+o+(s?H.repeat(s.length):\"\")}if(r===0){return O+(s?H.repeat(s.length):\"\")}return H.repeat(u.length)}if(o===\".\"){return h.repeat(u.length)}if(o===\"*\"){if(e){return e+o+(s?k:\"\")}return k}return e?t:`\\\\${t}`}));if(n===true){if(u.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(t=>t.length%2===0?\"\\\\\\\\\":t?\"\\\\\":\"\"))}}if(s===t&&u.contains===true){m.output=t;return m}m.output=o.wrapOutput(s,m,e);return m}while(!eos()){G=M();if(G===\"\\0\"){continue}if(G===\"\\\\\"){const t=D();if(t===\"/\"&&u.bash!==true){continue}if(t===\".\"||t===\";\"){continue}if(!t){G+=\"\\\\\";push({type:\"text\",value:G});continue}const e=/^\\\\+/.exec(remaining());let n=0;if(e&&e[0].length>2){n=e[0].length;m.index+=n;if(n%2!==0){G+=\"\\\\\"}}if(u.unescape===true){G=M()}else{G+=M()}if(m.brackets===0){push({type:\"text\",value:G});continue}}if(m.brackets>0&&(G!==\"]\"||B.value===\"[\"||B.value===\"[^\")){if(u.posix!==false&&G===\":\"){const t=B.value.slice(1);if(t.includes(\"[\")){B.posix=true;if(t.includes(\":\")){const t=B.value.lastIndexOf(\"[\");const e=B.value.slice(0,t);const u=B.value.slice(t+2);const n=r[u];if(n){B.value=e+n;m.backtrack=true;M();if(!f.output&&A.indexOf(B)===1){f.output=C}continue}}}}if(G===\"[\"&&D()!==\":\"||G===\"-\"&&D()===\"]\"){G=`\\\\${G}`}if(G===\"]\"&&(B.value===\"[\"||B.value===\"[^\")){G=`\\\\${G}`}if(u.posix===true&&G===\"!\"&&B.value===\"[\"){G=\"^\"}B.value+=G;append({value:G});continue}if(m.quotes===1&&G!=='\"'){G=o.escapeRegex(G);B.value+=G;append({value:G});continue}if(G==='\"'){m.quotes=m.quotes===1?0:1;if(u.keepQuotes===true){push({type:\"text\",value:G})}continue}if(G===\"(\"){increment(\"parens\");push({type:\"paren\",value:G});continue}if(G===\")\"){if(m.parens===0&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const t=w[w.length-1];if(t&&m.parens===t.parens+1){extglobClose(w.pop());continue}push({type:\"paren\",value:G,output:m.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(G===\"[\"){if(u.nobracket===true||!remaining().includes(\"]\")){if(u.nobracket!==true&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}G=`\\\\${G}`}else{increment(\"brackets\")}push({type:\"bracket\",value:G});continue}if(G===\"]\"){if(u.nobracket===true||B&&B.type===\"bracket\"&&B.value.length===1){push({type:\"text\",value:G,output:`\\\\${G}`});continue}if(m.brackets===0){if(u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:G,output:`\\\\${G}`});continue}decrement(\"brackets\");const t=B.value.slice(1);if(B.posix!==true&&t[0]===\"^\"&&!t.includes(\"/\")){G=`/${G}`}B.value+=G;append({value:G});if(u.literalBrackets===false||o.hasRegexChars(t)){continue}const e=o.escapeRegex(B.value);m.output=m.output.slice(0,-B.value.length);if(u.literalBrackets===true){m.output+=e;B.value=e;continue}B.value=`(${_}${e}|${B.value})`;m.output+=B.value;continue}if(G===\"{\"&&u.nobrace!==true){increment(\"braces\");const t={type:\"brace\",value:G,output:\"(\",outputIndex:m.output.length,tokensIndex:m.tokens.length};N.push(t);push(t);continue}if(G===\"}\"){const t=N[N.length-1];if(u.nobrace===true||!t){push({type:\"text\",value:G,output:G});continue}let e=\")\";if(t.dots===true){const t=A.slice();const n=[];for(let e=t.length-1;e>=0;e--){A.pop();if(t[e].type===\"brace\"){break}if(t[e].type!==\"dots\"){n.unshift(t[e].value)}}e=expandRange(n,u);m.backtrack=true}if(t.comma!==true&&t.dots!==true){const u=m.output.slice(0,t.outputIndex);const n=m.tokens.slice(t.tokensIndex);t.value=t.output=\"\\\\{\";G=e=\"\\\\}\";m.output=u;for(const t of n){m.output+=t.output||t.value}}push({type:\"brace\",value:G,output:e});decrement(\"braces\");N.pop();continue}if(G===\"|\"){if(w.length>0){w[w.length-1].conditions++}push({type:\"text\",value:G});continue}if(G===\",\"){let t=G;const e=N[N.length-1];if(e&&I[I.length-1]===\"braces\"){e.comma=true;t=\"|\"}push({type:\"comma\",value:G,output:t});continue}if(G===\"/\"){if(B.type===\"dot\"&&m.index===m.start+1){m.start=m.index+1;m.consumed=\"\";m.output=\"\";A.pop();B=f;continue}push({type:\"slash\",value:G,output:b});continue}if(G===\".\"){if(m.braces>0&&B.type===\"dot\"){if(B.value===\".\")B.output=h;const t=N[N.length-1];B.type=\"dots\";B.output+=G;B.value+=G;t.dots=true;continue}if(m.braces+m.parens===0&&B.type!==\"bos\"&&B.type!==\"slash\"){push({type:\"text\",value:G,output:h});continue}push({type:\"dot\",value:G,output:h});continue}if(G===\"?\"){const t=B&&B.value===\"(\";if(!t&&u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"qmark\",G);continue}if(B&&B.type===\"paren\"){const t=D();let e=G;if(B.value===\"(\"&&!/[!=<:]/.test(t)||t===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){e=`\\\\${G}`}push({type:\"text\",value:G,output:e});continue}if(u.dot!==true&&(B.type===\"slash\"||B.type===\"bos\")){push({type:\"qmark\",value:G,output:v});continue}push({type:\"qmark\",value:G,output:H});continue}if(G===\"!\"){if(u.noextglob!==true&&D()===\"(\"){if(D(2)!==\"?\"||!/[!=<:]/.test(D(3))){extglobOpen(\"negate\",G);continue}}if(u.nonegate!==true&&m.index===0){negate();continue}}if(G===\"+\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"plus\",G);continue}if(B&&B.value===\"(\"||u.regex===false){push({type:\"plus\",value:G,output:g});continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\"||B.type===\"brace\")||m.parens>0){push({type:\"plus\",value:G});continue}push({type:\"plus\",value:g});continue}if(G===\"@\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){push({type:\"at\",extglob:true,value:G,output:\"\"});continue}push({type:\"text\",value:G});continue}if(G!==\"*\"){if(G===\"$\"||G===\"^\"){G=`\\\\${G}`}const t=a.exec(remaining());if(t){G+=t[0];m.index+=t[0].length}push({type:\"text\",value:G});continue}if(B&&(B.type===\"globstar\"||B.star===true)){B.type=\"star\";B.star=true;B.value+=G;B.output=k;m.backtrack=true;m.globstar=true;consume(G);continue}let e=remaining();if(u.noextglob!==true&&/^\\([^?]/.test(e)){extglobOpen(\"star\",G);continue}if(B.type===\"star\"){if(u.noglobstar===true){consume(G);continue}const n=B.prev;const o=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const r=o&&(o.type===\"star\"||o.type===\"globstar\");if(u.bash===true&&(!s||e[0]&&e[0]!==\"/\")){push({type:\"star\",value:G,output:\"\"});continue}const a=m.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const i=w.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!a&&!i){push({type:\"star\",value:G,output:\"\"});continue}while(e.slice(0,3)===\"/**\"){const u=t[m.index+4];if(u&&u!==\"/\"){break}e=e.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){B.type=\"globstar\";B.value+=G;B.output=globstar(u);m.output=B.output;m.globstar=true;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!r&&eos()){m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=globstar(u)+(u.strictSlashes?\")\":\"|$)\");B.value+=G;m.globstar=true;m.output+=n.output+B.output;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&e[0]===\"/\"){const t=e[1]!==void 0?\"|$\":\"\";m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=`${globstar(u)}${b}|${b}${t})`;B.value+=G;m.output+=n.output+B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&e[0]===\"/\"){B.type=\"globstar\";B.value+=G;B.output=`(?:^|${b}|${globstar(u)}${b})`;m.output=B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}m.output=m.output.slice(0,-B.output.length);B.type=\"globstar\";B.output=globstar(u);B.value+=G;m.output+=B.output;m.globstar=true;consume(G);continue}const n={type:\"star\",value:G,output:k};if(u.bash===true){n.output=\".*?\";if(B.type===\"bos\"||B.type===\"slash\"){n.output=T+n.output}push(n);continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\")&&u.regex===true){n.output=G;push(n);continue}if(m.index===m.start||B.type===\"slash\"||B.type===\"dot\"){if(B.type===\"dot\"){m.output+=x;B.output+=x}else if(u.dot===true){m.output+=S;B.output+=S}else{m.output+=T;B.output+=T}if(D()!==\"*\"){m.output+=C;B.output+=C}}push(n)}while(m.brackets>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));m.output=o.escapeLast(m.output,\"[\");decrement(\"brackets\")}while(m.parens>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));m.output=o.escapeLast(m.output,\"(\");decrement(\"parens\")}while(m.braces>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));m.output=o.escapeLast(m.output,\"{\");decrement(\"braces\")}if(u.strictSlashes!==true&&(B.type===\"star\"||B.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${b}?`})}if(m.backtrack===true){m.output=\"\";for(const t of m.tokens){m.output+=t.output!=null?t.output:t.value;if(t.suffix){m.output+=t.suffix}}}return m};parse.fastpaths=(t,e)=>{const u={...e};const r=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;const a=t.length;if(a>r){throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`)}t=c[t]||t;const{DOT_LITERAL:i,SLASH_LITERAL:p,ONE_CHAR:l,DOTS_SLASH:f,NO_DOT:A,NO_DOTS:_,NO_DOTS_SLASH:R,STAR:E,START_ANCHOR:h}=n.globChars(u.windows);const g=u.dot?_:A;const b=u.dot?R:A;const C=u.capture?\"\":\"?:\";const y={negated:false,prefix:\"\"};let $=u.bash===true?\".*?\":E;if(u.capture){$=`(${$})`}const globstar=t=>{if(t.noglobstar===true)return $;return`(${C}(?:(?!${h}${t.dot?f:i}).)*?)`};const create=t=>{switch(t){case\"*\":return`${g}${l}${$}`;case\".*\":return`${i}${l}${$}`;case\"*.*\":return`${g}${$}${i}${l}${$}`;case\"*/*\":return`${g}${$}${p}${l}${b}${$}`;case\"**\":return g+globstar(u);case\"**/*\":return`(?:${g}${globstar(u)}${p})?${b}${l}${$}`;case\"**/*.*\":return`(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;case\"**/.*\":return`(?:${g}${globstar(u)}${p})?${i}${l}${$}`;default:{const e=/^(.*?)\\.(\\w+)$/.exec(t);if(!e)return;const u=create(e[1]);if(!u)return;return u+i+e[2]}}};const x=o.removePrefix(t,y);let S=create(x);if(S&&u.strictSlashes!==true){S+=`${p}?`}return S};t.exports=parse},510:(t,e,u)=>{const n=u(716);const o=u(697);const s=u(96);const r=u(154);const isObject=t=>t&&typeof t===\"object\"&&!Array.isArray(t);const picomatch=(t,e,u=false)=>{if(Array.isArray(t)){const n=t.map((t=>picomatch(t,e,u)));const arrayMatcher=t=>{for(const e of n){const u=e(t);if(u)return u}return false};return arrayMatcher}const n=isObject(t)&&t.tokens&&t.input;if(t===\"\"||typeof t!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const o=e||{};const s=o.windows;const r=n?picomatch.compileRe(t,e):picomatch.makeRe(t,e,false,true);const a=r.state;delete r.state;let isIgnored=()=>false;if(o.ignore){const t={...e,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(o.ignore,t,u)}const matcher=(u,n=false)=>{const{isMatch:i,match:c,output:p}=picomatch.test(u,r,e,{glob:t,posix:s});const l={glob:t,state:a,regex:r,posix:s,input:u,output:p,match:c,isMatch:i};if(typeof o.onResult===\"function\"){o.onResult(l)}if(i===false){l.isMatch=false;return n?l:false}if(isIgnored(u)){if(typeof o.onIgnore===\"function\"){o.onIgnore(l)}l.isMatch=false;return n?l:false}if(typeof o.onMatch===\"function\"){o.onMatch(l)}return n?l:true};if(u){matcher.state=a}return matcher};picomatch.test=(t,e,u,{glob:n,posix:o}={})=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(t===\"\"){return{isMatch:false,output:\"\"}}const r=u||{};const a=r.format||(o?s.toPosixSlashes:null);let i=t===n;let c=i&&a?a(t):t;if(i===false){c=a?a(t):t;i=c===n}if(i===false||r.capture===true){if(r.matchBase===true||r.basename===true){i=picomatch.matchBase(t,e,u,o)}else{i=e.exec(c)}}return{isMatch:Boolean(i),match:i,output:c}};picomatch.matchBase=(t,e,u)=>{const n=e instanceof RegExp?e:picomatch.makeRe(e,u);return n.test(s.basename(t))};picomatch.isMatch=(t,e,u)=>picomatch(e,u)(t);picomatch.parse=(t,e)=>{if(Array.isArray(t))return t.map((t=>picomatch.parse(t,e)));return o(t,{...e,fastpaths:false})};picomatch.scan=(t,e)=>n(t,e);picomatch.compileRe=(t,e,u=false,n=false)=>{if(u===true){return t.output}const o=e||{};const s=o.contains?\"\":\"^\";const r=o.contains?\"\":\"$\";let a=`${s}(?:${t.output})${r}`;if(t&&t.negated===true){a=`^(?!${a}).*$`}const i=picomatch.toRegex(a,e);if(n===true){i.state=t}return i};picomatch.makeRe=(t,e={},u=false,n=false)=>{if(!t||typeof t!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}let s={negated:false,fastpaths:true};if(e.fastpaths!==false&&(t[0]===\".\"||t[0]===\"*\")){s.output=o.fastpaths(t,e)}if(!s.output){s=o(t,e)}return picomatch.compileRe(s,e,u,n)};picomatch.toRegex=(t,e)=>{try{const u=e||{};return new RegExp(t,u.flags||(u.nocase?\"i\":\"\"))}catch(t){if(e&&e.debug===true)throw t;return/$^/}};picomatch.constants=r;t.exports=picomatch},716:(t,e,u)=>{const n=u(96);const{CHAR_ASTERISK:o,CHAR_AT:s,CHAR_BACKWARD_SLASH:r,CHAR_COMMA:a,CHAR_DOT:i,CHAR_EXCLAMATION_MARK:c,CHAR_FORWARD_SLASH:p,CHAR_LEFT_CURLY_BRACE:l,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:_,CHAR_QUESTION_MARK:R,CHAR_RIGHT_CURLY_BRACE:E,CHAR_RIGHT_PARENTHESES:h,CHAR_RIGHT_SQUARE_BRACKET:g}=u(154);const isPathSeparator=t=>t===p||t===r;const depth=t=>{if(t.isPrefix!==true){t.depth=t.isGlobstar?Infinity:1}};const scan=(t,e)=>{const u=e||{};const b=t.length-1;const C=u.parts===true||u.scanToEnd===true;const y=[];const $=[];const x=[];let S=t;let H=-1;let v=0;let d=0;let L=false;let T=false;let O=false;let k=false;let m=false;let w=false;let N=false;let I=false;let B=false;let G=false;let D=0;let M;let P;let K={value:\"\",depth:0,isGlob:false};const eos=()=>H>=b;const peek=()=>S.charCodeAt(H+1);const advance=()=>{M=P;return S.charCodeAt(++H)};while(H<b){P=advance();let t;if(P===r){N=K.backslashes=true;P=advance();if(P===l){w=true}continue}if(w===true||P===l){D++;while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;advance();continue}if(P===l){D++;continue}if(w!==true&&P===i&&(P=advance())===i){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(w!==true&&P===a){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===E){D--;if(D===0){w=false;L=K.isBrace=true;G=true;break}}}if(C===true){continue}break}if(P===p){y.push(H);$.push(K);K={value:\"\",depth:0,isGlob:false};if(G===true)continue;if(M===i&&H===v+1){v+=2;continue}d=H+1;continue}if(u.noext!==true){const t=P===_||P===s||P===o||P===R||P===c;if(t===true&&peek()===f){O=K.isGlob=true;k=K.isExtglob=true;G=true;if(P===c&&H===v){B=true}if(C===true){while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;P=advance();continue}if(P===h){O=K.isGlob=true;G=true;break}}continue}break}}if(P===o){if(M===o)m=K.isGlobstar=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===R){O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===A){while(eos()!==true&&(t=advance())){if(t===r){N=K.backslashes=true;advance();continue}if(t===g){T=K.isBracket=true;O=K.isGlob=true;G=true;break}}if(C===true){continue}break}if(u.nonegate!==true&&P===c&&H===v){I=K.negated=true;v++;continue}if(u.noparen!==true&&P===f){O=K.isGlob=true;if(C===true){while(eos()!==true&&(P=advance())){if(P===f){N=K.backslashes=true;P=advance();continue}if(P===h){G=true;break}}continue}break}if(O===true){G=true;if(C===true){continue}break}}if(u.noext===true){k=false;O=false}let U=S;let X=\"\";let F=\"\";if(v>0){X=S.slice(0,v);S=S.slice(v);d-=v}if(U&&O===true&&d>0){U=S.slice(0,d);F=S.slice(d)}else if(O===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(u.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&N===true){U=n.removeBackslashes(U)}}const Q={prefix:X,input:t,start:v,base:U,glob:F,isBrace:L,isBracket:T,isGlob:O,isExtglob:k,isGlobstar:m,negated:I,negatedExtglob:B};if(u.tokens===true){Q.maxDepth=0;if(!isPathSeparator(P)){$.push(K)}Q.tokens=$}if(u.parts===true||u.tokens===true){let e;for(let n=0;n<y.length;n++){const o=e?e+1:v;const s=y[n];const r=t.slice(o,s);if(u.tokens){if(n===0&&v!==0){$[n].isPrefix=true;$[n].value=X}else{$[n].value=r}depth($[n]);Q.maxDepth+=$[n].depth}if(n!==0||r!==\"\"){x.push(r)}e=s}if(e&&e+1<t.length){const n=t.slice(e+1);x.push(n);if(u.tokens){$[$.length-1].value=n;depth($[$.length-1]);Q.maxDepth+=$[$.length-1].depth}}Q.slashes=y;Q.parts=x}return Q};t.exports=scan},96:(t,e,u)=>{const{REGEX_BACKSLASH:n,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:s,REGEX_SPECIAL_CHARS_GLOBAL:r}=u(154);e.isObject=t=>t!==null&&typeof t===\"object\"&&!Array.isArray(t);e.hasRegexChars=t=>s.test(t);e.isRegexChar=t=>t.length===1&&e.hasRegexChars(t);e.escapeRegex=t=>t.replace(r,\"\\\\$1\");e.toPosixSlashes=t=>t.replace(n,\"/\");e.removeBackslashes=t=>t.replace(o,(t=>t===\"\\\\\"?\"\":t));e.escapeLast=(t,u,n)=>{const o=t.lastIndexOf(u,n);if(o===-1)return t;if(t[o-1]===\"\\\\\")return e.escapeLast(t,u,o-1);return`${t.slice(0,o)}\\\\${t.slice(o)}`};e.removePrefix=(t,e={})=>{let u=t;if(u.startsWith(\"./\")){u=u.slice(2);e.prefix=\"./\"}return u};e.wrapOutput=(t,e={},u={})=>{const n=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let s=`${n}(?:${t})${o}`;if(e.negated===true){s=`(?:^(?!${s}).*$)`}return s};e.basename=(t,{windows:e}={})=>{const u=t.split(e?/[\\\\/]/:\"/\");const n=u[u.length-1];if(n===\"\"){return u[u.length-2]}return n}}};var e={};function __nccwpck_require__(u){var n=e[u];if(n!==undefined){return n.exports}var o=e[u]={exports:{}};var s=true;try{t[u](o,o.exports,__nccwpck_require__);s=false}finally{if(s)delete e[u]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var u=__nccwpck_require__(170);module.exports=u})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BpY29tYXRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBLE1BQU0sYUFBYSxPQUFPLGNBQWMsZUFBZSxxQkFBcUIsdURBQXVELHlDQUF5QyxrQ0FBa0MsVUFBVSxPQUFPLGdCQUFnQixPQUFPLFdBQVcsT0FBTyxPQUFPLG9CQUFvQixjQUFjLGdDQUFnQyxpREFBaUQsR0FBRywwQkFBMEIsZ0JBQWdCLDJCQUEyQixvQkFBb0IsU0FBUyxnQkFBZ0IsYUFBYSxFQUFFLEdBQUcsY0FBYyxjQUFjLGNBQWMsY0FBYyxnQkFBZ0IsZUFBZSxjQUFjLEVBQUUsS0FBSyxnQkFBZ0IsRUFBRSxHQUFHLFdBQVcsR0FBRyxJQUFJLEVBQUUsRUFBRSxFQUFFLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRSxFQUFFLEVBQUUsR0FBRyxjQUFjLEdBQUcsSUFBSSxFQUFFLEVBQUUsR0FBRyxjQUFjLEVBQUUsR0FBRyxjQUFjLEVBQUUsR0FBRyxXQUFXLEVBQUUsSUFBSSxZQUFZLFNBQVMsd01BQXdNLFNBQVMsdUJBQXVCLEVBQUUsbUJBQW1CLEVBQUUsa0JBQWtCLEdBQUcsSUFBSSxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsdUJBQXVCLEVBQUUsSUFBSSxHQUFHLElBQUksTUFBTSxFQUFFLDBCQUEwQixHQUFHLElBQUksTUFBTSxFQUFFLDJCQUEyQixHQUFHLElBQUksTUFBTSxFQUFFLDBCQUEwQixFQUFFLHlCQUF5QixFQUFFLHNCQUFzQixFQUFFLGdCQUFnQixTQUFTLHlMQUF5TCxhQUFhLEVBQUUsOEVBQThFLFdBQVcsc0VBQXNFLHFEQUFxRCx5Q0FBeUMsZ0dBQWdHLDRFQUE0RSx1Q0FBdUMsbTNCQUFtM0IsT0FBTyxLQUFLLDBDQUEwQyxPQUFPLEdBQUcsTUFBTSxtQ0FBbUMsTUFBTSxrQ0FBa0MsTUFBTSxrQ0FBa0MsTUFBTSxpQ0FBaUMsY0FBYyxzQkFBc0IsZUFBZSxlQUFlLGNBQWMsTUFBTSx5R0FBeUcsR0FBRywwQkFBMEIsc0NBQXNDLDZCQUE2QixTQUFTLFlBQVksWUFBWSxHQUFHLElBQUksY0FBYyxTQUFTLCtDQUErQyxVQUFVLG9DQUFvQyxFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsK0JBQStCLG9CQUFvQix3QkFBd0IseUNBQXlDLFVBQVUsU0FBUyxNQUFNLGdFQUFnRSxlQUFlLFFBQVEsdUNBQXVDLEVBQUUsb0NBQW9DLEVBQUUsR0FBRyxTQUFTLDBDQUEwQyxZQUFZLDBCQUEwQiwrQkFBK0IsMEJBQTBCLE1BQU0sMEpBQTBKLEdBQUcsc0JBQXNCLEVBQUUsUUFBUSxFQUFFLEVBQUUsVUFBVSxRQUFRLG1CQUFtQixrQkFBa0Isa0NBQWtDLGNBQWMsTUFBTSxFQUFFLEdBQUcsK0JBQStCLG9CQUFvQixTQUFTLHVLQUF1SyxzQkFBc0IsV0FBVyxXQUFXLFdBQVcsV0FBVyxRQUFRLE1BQU0sNEJBQTRCLG1DQUFtQyx1Q0FBdUMsdUNBQXVDLDJCQUEyQixjQUFjLFlBQVksaUJBQWlCLDBDQUEwQyxrQkFBa0Isa0JBQWtCLFFBQVEsMkNBQTJDLElBQUksVUFBVSxJQUFJLFlBQVksYUFBYSxlQUFlLFVBQVUsYUFBYSxvQkFBb0IsT0FBTyxXQUFXLG9CQUFvQixPQUFPLFNBQVMsZUFBZSx3QkFBd0IseURBQXlELHdFQUF3RSwrQ0FBK0MsNENBQTRDLGNBQWMsWUFBWSxXQUFXLG9CQUFvQiwrQkFBK0IsNkJBQTZCLCtCQUErQix3Q0FBd0MscUNBQXFDLGlCQUFpQixPQUFPLFNBQVMsVUFBVSxLQUFLLDBCQUEwQixTQUFTLCtCQUErQixTQUFTLGtCQUFrQixrQkFBa0Isa0NBQWtDLG9CQUFvQixNQUFNLG9DQUFvQyxFQUFFLE1BQU0sNkNBQTZDLEVBQUUsV0FBVyx1QkFBdUIsaUNBQWlDLE1BQU0sc0JBQXNCLFFBQVEscURBQXFELGNBQWMsNENBQTRDLGlCQUFpQixFQUFFLEVBQUUsbUVBQW1FLGlCQUFpQixxQkFBcUIsU0FBUyxjQUFjLEVBQUUsR0FBRyxFQUFFLEdBQUcsd0JBQXdCLHVCQUF1QixNQUFNLDJDQUEyQyxFQUFFLHFCQUFxQiwwQ0FBMEMsY0FBYyxZQUFZLG1DQUFtQyxhQUFhLE9BQU8sU0FBUyxZQUFZLE1BQU0scUNBQXFDLFVBQVUsbUNBQW1DLDBCQUEwQixZQUFZLDBCQUEwQixZQUFZLE1BQU0sb0JBQW9CLFNBQVMsZ0JBQWdCLEVBQUUsRUFBRSxHQUFHLGFBQWEsc0JBQXNCLHNCQUFzQixLQUFLLDBEQUEwRCw2QkFBNkIsV0FBVyxTQUFTLDZCQUE2QixTQUFTLGNBQWMsTUFBTSxhQUFhLFNBQVMsYUFBYSxZQUFZLDJCQUEyQixTQUFTLGtCQUFrQixHQUFHLFNBQVMsT0FBTyxRQUFRLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxpQ0FBaUMsUUFBUSxxQkFBcUIsY0FBYyxXQUFXLFlBQVksU0FBUyxzQkFBc0IsTUFBTSxLQUFLLE9BQU8sbUJBQW1CLE1BQU0sb0JBQW9CLEVBQUUsVUFBVSwyREFBMkQsNkJBQTZCLHlCQUF5QixvQkFBb0IsYUFBYSxvQkFBb0IsaUNBQWlDLDJCQUEyQiwyQkFBMkIsYUFBYSxNQUFNLFlBQVksaUJBQWlCLElBQUksZ0NBQWdDLFdBQVcsWUFBWSwyQ0FBMkMsT0FBTyxFQUFFLEVBQUUsNkNBQTZDLE9BQU8sRUFBRSxFQUFFLDJDQUEyQyxNQUFNLFdBQVcsUUFBUSxRQUFRLEVBQUUsU0FBUywwQkFBMEIsbUJBQW1CLFdBQVcsUUFBUSxRQUFRLEVBQUUsU0FBUyxZQUFZLDBCQUEwQix3QkFBd0IsTUFBTSxvQkFBb0IsRUFBRSxTQUFTLFlBQVksb0JBQW9CLE1BQU0scUJBQXFCLEVBQUUsU0FBUyxZQUFZLDBDQUEwQyxrREFBa0Qsc0JBQXNCLDZCQUE2QixzQkFBc0IsU0FBUyxNQUFNLCtDQUErQyxFQUFFLG9CQUFvQixTQUFTLFlBQVksbURBQW1ELGdEQUFnRCxrREFBa0QsT0FBTyxFQUFFLEVBQUUsS0FBSyxzQkFBc0IsTUFBTSx1QkFBdUIsRUFBRSxTQUFTLFlBQVksa0VBQWtFLE1BQU0sZ0NBQWdDLEVBQUUsRUFBRSxFQUFFLFNBQVMsbUJBQW1CLDRCQUE0QixrREFBa0QsTUFBTSxnQ0FBZ0MsRUFBRSxFQUFFLEVBQUUsU0FBUyxzQkFBc0IseUJBQXlCLGlEQUFpRCxNQUFNLEVBQUUsRUFBRSxXQUFXLFFBQVEsUUFBUSxFQUFFLGtEQUFrRCxTQUFTLCtCQUErQiwyQ0FBMkMsNkJBQTZCLFlBQVksVUFBVSxTQUFTLFlBQVksRUFBRSxFQUFFLEVBQUUsR0FBRyxRQUFRLEdBQUcsa0JBQWtCLFNBQVMsU0FBUyxxQkFBcUIsb0JBQW9CLFNBQVMseUZBQXlGLFVBQVUsUUFBUSxTQUFTLFNBQVMsR0FBRyxzQkFBc0IseUJBQXlCLE1BQU0sNkJBQTZCLEVBQUUsU0FBUyxVQUFVLGtCQUFrQixrQkFBa0IsV0FBVyxxQkFBcUIsS0FBSyxLQUFLLFFBQVEsd0JBQXdCLE1BQU0sdUJBQXVCLHVCQUF1QixtQkFBbUIsaUJBQWlCLGtDQUFrQyx3Q0FBd0Msc0NBQXNDLHFCQUFxQixFQUFFLFFBQVEsRUFBRSxXQUFXLGtCQUFrQiw2QkFBNkIsTUFBTSw4QkFBOEIsRUFBRSxvQkFBb0IsUUFBUSxTQUFTLFlBQVksZUFBZSwyQkFBMkIsTUFBTSxvQkFBb0IsRUFBRSxTQUFTLFlBQVksUUFBUSxzQkFBc0IsZ0NBQWdDLGFBQWEsTUFBTSxNQUFNLDhCQUE4QixFQUFFLFNBQVMsWUFBWSx3Q0FBd0Msa0JBQWtCLGNBQWMsWUFBWSxRQUFRLElBQUksU0FBUyxNQUFNLDhCQUE4QixFQUFFLFNBQVMsWUFBWSwrQkFBK0IsNEJBQTRCLHNCQUFzQixjQUFjLFlBQVksV0FBVyxZQUFZLFNBQVMsNERBQTRELE1BQU0sNkJBQTZCLEVBQUUsU0FBUyxNQUFNLDRCQUE0QixFQUFFLFNBQVMsWUFBWSx5QkFBeUIsa0RBQWtELHVCQUF1QixTQUFTLHdCQUF3QixZQUFZLFFBQVEsaUZBQWlGLE9BQU8sRUFBRSxFQUFFLE1BQU0sNkJBQTZCLEVBQUUsU0FBUyxxREFBcUQsTUFBTSw4QkFBOEIsRUFBRSxTQUFTLE1BQU0sOEJBQThCLEVBQUUsU0FBUyxZQUFZLGtDQUFrQyxxQ0FBcUMsd0JBQXdCLFVBQVUsbUNBQW1DLFNBQVMsVUFBVSxZQUFZLDhDQUE4QyxzQkFBc0IsU0FBUyxzQ0FBc0MsTUFBTSw2QkFBNkIsRUFBRSxTQUFTLDRFQUE0RSxNQUFNLG9CQUFvQixFQUFFLFNBQVMsTUFBTSxvQkFBb0IsRUFBRSxTQUFTLFlBQVksOENBQThDLE1BQU0seUNBQXlDLEVBQUUsU0FBUyxNQUFNLG9CQUFvQixFQUFFLFNBQVMsWUFBWSxxQkFBcUIsT0FBTyxFQUFFLEVBQUUsNEJBQTRCLE1BQU0sUUFBUSxxQkFBcUIsTUFBTSxvQkFBb0IsRUFBRSxTQUFTLDRDQUE0QyxjQUFjLFlBQVksV0FBVyxXQUFXLGlCQUFpQixnQkFBZ0IsV0FBVyxTQUFTLGtCQUFrQiwwQ0FBMEMsc0JBQXNCLFNBQVMsb0JBQW9CLHdCQUF3QixXQUFXLFNBQVMsZUFBZSxlQUFlLHlDQUF5QyxrREFBa0QsMENBQTBDLE1BQU0sOEJBQThCLEVBQUUsU0FBUyx5REFBeUQsc0RBQXNELGlDQUFpQyxNQUFNLDhCQUE4QixFQUFFLFNBQVMsNEJBQTRCLHFCQUFxQixlQUFlLE1BQU0sYUFBYSxpQkFBaUIsMEJBQTBCLGtCQUFrQixXQUFXLHFCQUFxQixrQkFBa0IsZ0JBQWdCLFdBQVcsU0FBUyxxREFBcUQsdURBQXVELGVBQWUsU0FBUyxFQUFFLGtCQUFrQixpREFBaUQsV0FBVyxnQkFBZ0IsNEJBQTRCLFdBQVcsU0FBUyxzREFBc0QsOEJBQThCLHVEQUF1RCxlQUFlLFNBQVMsRUFBRSxrQkFBa0IsWUFBWSxZQUFZLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsV0FBVyw0QkFBNEIsZ0JBQWdCLGVBQWUsTUFBTSxpQ0FBaUMsRUFBRSxTQUFTLCtCQUErQixrQkFBa0IsV0FBVyxpQkFBaUIsRUFBRSxHQUFHLFlBQVksRUFBRSxFQUFFLEdBQUcsa0JBQWtCLGdCQUFnQixlQUFlLE1BQU0saUNBQWlDLEVBQUUsU0FBUyw0Q0FBNEMsa0JBQWtCLHFCQUFxQixXQUFXLG1CQUFtQixnQkFBZ0IsV0FBVyxTQUFTLFNBQVMsOEJBQThCLGtCQUFrQixlQUFlLHFDQUFxQyxvQkFBb0IsUUFBUSxTQUFTLDhEQUE4RCxXQUFXLFFBQVEsU0FBUyx3REFBd0QsbUJBQW1CLFlBQVksWUFBWSxzQkFBc0IsWUFBWSxZQUFZLEtBQUssWUFBWSxZQUFZLGNBQWMsWUFBWSxhQUFhLFFBQVEsb0JBQW9CLDZFQUE2RSxvQ0FBb0Msc0JBQXNCLGtCQUFrQiw2RUFBNkUsb0NBQW9DLG9CQUFvQixrQkFBa0IseUVBQXlFLElBQUksaUNBQWlDLEdBQUcsb0JBQW9CLGtFQUFrRSxNQUFNLHNDQUFzQyxFQUFFLEdBQUcsRUFBRSx1QkFBdUIsWUFBWSx5QkFBeUIsMENBQTBDLGFBQWEscUJBQXFCLFVBQVUsd0JBQXdCLFNBQVMsTUFBTSxnRUFBZ0UsaUJBQWlCLFFBQVEsdUNBQXVDLEVBQUUsb0NBQW9DLEVBQUUsR0FBRyxVQUFVLE1BQU0sK0dBQStHLHdCQUF3QixrQkFBa0Isa0JBQWtCLDBCQUEwQixTQUFTLHlCQUF5Qiw0QkFBNEIsY0FBYyxNQUFNLEVBQUUsR0FBRyxtQkFBbUIsZ0NBQWdDLFVBQVUsRUFBRSxRQUFRLEVBQUUsRUFBRSxVQUFVLFNBQVMsaUJBQWlCLFVBQVUsaUJBQWlCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLGtCQUFrQixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxtQkFBbUIsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxtQkFBbUIsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsOEJBQThCLHVCQUF1QixFQUFFLEVBQUUsWUFBWSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSx5QkFBeUIsRUFBRSxFQUFFLFlBQVksRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSx3QkFBd0IsRUFBRSxFQUFFLFlBQVksRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsU0FBUyxpQ0FBaUMsYUFBYSxxQkFBcUIsYUFBYSxtQkFBbUIsNEJBQTRCLGdCQUFnQiw4QkFBOEIsTUFBTSxFQUFFLEdBQUcsVUFBVSxnQkFBZ0IsZUFBZSxlQUFlLGVBQWUsY0FBYyxlQUFlLDREQUE0RCxnQ0FBZ0MscUJBQXFCLHFDQUFxQyx1QkFBdUIsa0JBQWtCLGFBQWEsY0FBYyxjQUFjLG9CQUFvQix1Q0FBdUMsb0NBQW9DLGlFQUFpRSxjQUFjLGtCQUFrQixvRUFBb0UsZ0JBQWdCLGVBQWUsd0JBQXdCLGFBQWEsU0FBUyw2Q0FBNkMsa0NBQWtDLDRCQUE0QixNQUFNLDJCQUEyQix1QkFBdUIsZUFBZSxFQUFFLFNBQVMsbUVBQW1FLG1DQUFtQyxjQUFjLGNBQWMsZ0JBQWdCLGlCQUFpQixpQkFBaUIsbUNBQW1DLGNBQWMsZ0JBQWdCLGlCQUFpQixrQ0FBa0MsYUFBYSxpQkFBaUIsTUFBTSxnQkFBZ0IsZ0JBQWdCLHVCQUF1QixlQUFlLEdBQUcsSUFBSSx3QkFBd0IscURBQXFELFdBQVcsT0FBTyx5QkFBeUIsY0FBYyw0Q0FBNEMsWUFBWSxrQkFBa0IsY0FBYyxXQUFXLFFBQVEsZ0NBQWdDLDBDQUEwQywrQkFBK0IsS0FBSyxhQUFhLE9BQU8sc0NBQXNDLDhCQUE4QixvREFBb0QsOEJBQThCLDZDQUE2Qyx3QkFBd0IsNERBQTRELFlBQVkscUJBQXFCLEdBQUcsNkJBQTZCLDRDQUE0QyxhQUFhLGdCQUFnQixjQUFjLDBCQUEwQiwwQkFBMEIsU0FBUyxFQUFFLEtBQUssU0FBUyxHQUFHLEVBQUUsRUFBRSx3QkFBd0IsU0FBUyxFQUFFLE1BQU0sK0JBQStCLGFBQWEsVUFBVSxVQUFVLHdCQUF3QixvQkFBb0IsNEJBQTRCLG1EQUFtRCxPQUFPLDhCQUE4QixrREFBa0QsMEJBQTBCLGNBQWMsU0FBUyxxQ0FBcUMsMEJBQTBCLElBQUksY0FBYyxnREFBZ0QsU0FBUyw2QkFBNkIsYUFBYSxzQkFBc0Isb0JBQW9CLGVBQWUsY0FBYyxNQUFNLCtTQUErUyxRQUFRLHNDQUFzQyxnQkFBZ0Isc0JBQXNCLGtDQUFrQyxtQkFBbUIsY0FBYyxtQkFBbUIsMkNBQTJDLFdBQVcsV0FBVyxXQUFXLFFBQVEsU0FBUyxRQUFRLFFBQVEsWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxRQUFRLE1BQU0sTUFBTSxPQUFPLCtCQUErQixtQkFBbUIsaUNBQWlDLG1CQUFtQixJQUFJLDBCQUEwQixXQUFXLFlBQVksTUFBTSxVQUFVLHFCQUFxQixZQUFZLFVBQVUsT0FBTyxTQUFTLG9CQUFvQixJQUFJLG1DQUFtQyxVQUFVLHFCQUFxQixVQUFVLFNBQVMsVUFBVSxJQUFJLFNBQVMsdUNBQXVDLGlCQUFpQixnQkFBZ0IsT0FBTyxhQUFhLFNBQVMsTUFBTSxvQkFBb0IsaUJBQWlCLGdCQUFnQixPQUFPLGFBQWEsU0FBUyxNQUFNLFVBQVUsSUFBSSxVQUFVLFFBQVEsaUJBQWlCLE9BQU8sUUFBUSxhQUFhLFNBQVMsTUFBTSxVQUFVLFVBQVUsVUFBVSxHQUFHLCtCQUErQixxQkFBcUIsbUJBQW1CLEtBQUssU0FBUyxNQUFNLFNBQVMsbUJBQW1CLDBDQUEwQyx5QkFBeUIsZ0JBQWdCLG1CQUFtQixPQUFPLGlCQUFpQixPQUFPLGFBQWEsbUNBQW1DLFVBQVUscUJBQXFCLFlBQVksU0FBUyxVQUFVLGdCQUFnQixPQUFPLE9BQU8sU0FBUyxPQUFPLFVBQVUsNkJBQTZCLGdCQUFnQixPQUFPLGFBQWEsU0FBUyxNQUFNLFVBQVUsZ0JBQWdCLE9BQU8sYUFBYSxTQUFTLE1BQU0sVUFBVSxtQ0FBbUMsVUFBVSxxQkFBcUIsVUFBVSxTQUFTLFVBQVUsbUJBQW1CLGdCQUFnQixPQUFPLE9BQU8sYUFBYSxTQUFTLE1BQU0sb0NBQW9DLGlCQUFpQixJQUFJLFNBQVMsNEJBQTRCLGdCQUFnQixhQUFhLG1DQUFtQyxVQUFVLHFCQUFxQixZQUFZLFNBQVMsVUFBVSxPQUFPLE9BQU8sU0FBUyxNQUFNLGFBQWEsT0FBTyxhQUFhLFNBQVMsT0FBTyxtQkFBbUIsUUFBUSxRQUFRLFFBQVEsU0FBUyxTQUFTLFFBQVEsZUFBZSxhQUFhLEtBQUsscUJBQXFCLGVBQWUsYUFBYSxrQkFBa0IsS0FBSyxJQUFJLEtBQUssSUFBSSw4QkFBOEIsOENBQThDLGlCQUFpQixzQkFBc0IsOEJBQThCLGdCQUFnQiwwQkFBMEIsU0FBUywySEFBMkgsb0JBQW9CLGFBQWEsd0JBQXdCLFVBQVUsV0FBVyxvQ0FBb0MsTUFBTSxZQUFZLFdBQVcsS0FBSyxnQkFBZ0IsYUFBYSxxQkFBcUIsYUFBYSxpQkFBaUIsbUJBQW1CLGFBQWEsS0FBSyxhQUFhLFlBQVksdUJBQXVCLGtCQUFrQixVQUFVLElBQUksb0JBQW9CLHFCQUFxQixVQUFVLGFBQWEsc0JBQXNCLHFCQUFxQixpQ0FBaUMsWUFBWSxVQUFVLFVBQVUsZUFBZSxjQUFjLE1BQU0sOEZBQThGLFFBQVEsK0RBQStELDZCQUE2QixrREFBa0QscUNBQXFDLHFDQUFxQyx1REFBdUQsdUJBQXVCLDJCQUEyQixtQkFBbUIsOENBQThDLFNBQVMsYUFBYSxJQUFJLFdBQVcsR0FBRyxzQkFBc0IsSUFBSSxRQUFRLHVCQUF1QixhQUFhLGNBQWMsVUFBVSxvQkFBb0IsS0FBSyxJQUFJLDBCQUEwQiwwQkFBMEIsU0FBUyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsRUFBRSxxQkFBcUIsWUFBWSxFQUFFLE9BQU8sVUFBVSxlQUFlLFVBQVUsR0FBRyxJQUFJLCtCQUErQixzQkFBc0IsV0FBVyxxQkFBcUIsWUFBWSxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSywrQkFBK0IsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BpY29tYXRjaC9pbmRleC5qcz8zYjViIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciB0PXsxNzA6KHQsZSx1KT0+e2NvbnN0IG49dSg1MTApO2NvbnN0IGlzV2luZG93cz0oKT0+e2lmKHR5cGVvZiBuYXZpZ2F0b3IhPT1cInVuZGVmaW5lZFwiJiZuYXZpZ2F0b3IucGxhdGZvcm0pe2NvbnN0IHQ9bmF2aWdhdG9yLnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7cmV0dXJuIHQ9PT1cIndpbjMyXCJ8fHQ9PT1cIndpbmRvd3NcIn1pZih0eXBlb2YgcHJvY2VzcyE9PVwidW5kZWZpbmVkXCImJnByb2Nlc3MucGxhdGZvcm0pe3JldHVybiBwcm9jZXNzLnBsYXRmb3JtPT09XCJ3aW4zMlwifXJldHVybiBmYWxzZX07ZnVuY3Rpb24gcGljb21hdGNoKHQsZSx1PWZhbHNlKXtpZihlJiYoZS53aW5kb3dzPT09bnVsbHx8ZS53aW5kb3dzPT09dW5kZWZpbmVkKSl7ZT17Li4uZSx3aW5kb3dzOmlzV2luZG93cygpfX1yZXR1cm4gbih0LGUsdSl9T2JqZWN0LmFzc2lnbihwaWNvbWF0Y2gsbik7dC5leHBvcnRzPXBpY29tYXRjaH0sMTU0OnQ9Pntjb25zdCBlPVwiXFxcXFxcXFwvXCI7Y29uc3QgdT1gW14ke2V9XWA7Y29uc3Qgbj1cIlxcXFwuXCI7Y29uc3Qgbz1cIlxcXFwrXCI7Y29uc3Qgcz1cIlxcXFw/XCI7Y29uc3Qgcj1cIlxcXFwvXCI7Y29uc3QgYT1cIig/PS4pXCI7Y29uc3QgaT1cIlteL11cIjtjb25zdCBjPWAoPzoke3J9fCQpYDtjb25zdCBwPWAoPzpefCR7cn0pYDtjb25zdCBsPWAke259ezEsMn0ke2N9YDtjb25zdCBmPWAoPyEke259KWA7Y29uc3QgQT1gKD8hJHtwfSR7bH0pYDtjb25zdCBfPWAoPyEke259ezAsMX0ke2N9KWA7Y29uc3QgUj1gKD8hJHtsfSlgO2NvbnN0IEU9YFteLiR7cn1dYDtjb25zdCBoPWAke2l9Kj9gO2NvbnN0IGc9XCIvXCI7Y29uc3QgYj17RE9UX0xJVEVSQUw6bixQTFVTX0xJVEVSQUw6byxRTUFSS19MSVRFUkFMOnMsU0xBU0hfTElURVJBTDpyLE9ORV9DSEFSOmEsUU1BUks6aSxFTkRfQU5DSE9SOmMsRE9UU19TTEFTSDpsLE5PX0RPVDpmLE5PX0RPVFM6QSxOT19ET1RfU0xBU0g6XyxOT19ET1RTX1NMQVNIOlIsUU1BUktfTk9fRE9UOkUsU1RBUjpoLFNUQVJUX0FOQ0hPUjpwLFNFUDpnfTtjb25zdCBDPXsuLi5iLFNMQVNIX0xJVEVSQUw6YFske2V9XWAsUU1BUks6dSxTVEFSOmAke3V9Kj9gLERPVFNfU0xBU0g6YCR7bn17MSwyfSg/Olske2V9XXwkKWAsTk9fRE9UOmAoPyEke259KWAsTk9fRE9UUzpgKD8hKD86XnxbJHtlfV0pJHtufXsxLDJ9KD86WyR7ZX1dfCQpKWAsTk9fRE9UX1NMQVNIOmAoPyEke259ezAsMX0oPzpbJHtlfV18JCkpYCxOT19ET1RTX1NMQVNIOmAoPyEke259ezEsMn0oPzpbJHtlfV18JCkpYCxRTUFSS19OT19ET1Q6YFteLiR7ZX1dYCxTVEFSVF9BTkNIT1I6YCg/Ol58WyR7ZX1dKWAsRU5EX0FOQ0hPUjpgKD86WyR7ZX1dfCQpYCxTRVA6XCJcXFxcXCJ9O2NvbnN0IHk9e2FsbnVtOlwiYS16QS1aMC05XCIsYWxwaGE6XCJhLXpBLVpcIixhc2NpaTpcIlxcXFx4MDAtXFxcXHg3RlwiLGJsYW5rOlwiIFxcXFx0XCIsY250cmw6XCJcXFxceDAwLVxcXFx4MUZcXFxceDdGXCIsZGlnaXQ6XCIwLTlcIixncmFwaDpcIlxcXFx4MjEtXFxcXHg3RVwiLGxvd2VyOlwiYS16XCIscHJpbnQ6XCJcXFxceDIwLVxcXFx4N0UgXCIscHVuY3Q6XCJcXFxcLSFcXFwiIyQlJicoKVxcXFwqKywuLzo7PD0+P0BbXFxcXF1eX2B7fH1+XCIsc3BhY2U6XCIgXFxcXHRcXFxcclxcXFxuXFxcXHZcXFxcZlwiLHVwcGVyOlwiQS1aXCIsd29yZDpcIkEtWmEtejAtOV9cIix4ZGlnaXQ6XCJBLUZhLWYwLTlcIn07dC5leHBvcnRzPXtNQVhfTEVOR1RIOjEwMjQqNjQsUE9TSVhfUkVHRVhfU09VUkNFOnksUkVHRVhfQkFDS1NMQVNIOi9cXFxcKD8hWyorP14ke30ofClbXFxdXSkvZyxSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzovXlteQCFbXFxdLiwkKis/Xnt9KCl8XFxcXC9dKy8sUkVHRVhfU1BFQ0lBTF9DSEFSUzovWy0qKz8uXiR7fSh8KVtcXF1dLyxSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUY6LyhcXFxcPykoKFxcVykoXFwzKikpL2csUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUw6LyhbLSorPy5eJHt9KHwpW1xcXV0pL2csUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSDovKD86XFxbLio/W15cXFxcXVxcXXxcXFxcKD89LikpL2csUkVQTEFDRU1FTlRTOntcIioqKlwiOlwiKlwiLFwiKiovKipcIjpcIioqXCIsXCIqKi8qKi8qKlwiOlwiKipcIn0sQ0hBUl8wOjQ4LENIQVJfOTo1NyxDSEFSX1VQUEVSQ0FTRV9BOjY1LENIQVJfTE9XRVJDQVNFX0E6OTcsQ0hBUl9VUFBFUkNBU0VfWjo5MCxDSEFSX0xPV0VSQ0FTRV9aOjEyMixDSEFSX0xFRlRfUEFSRU5USEVTRVM6NDAsQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUzo0MSxDSEFSX0FTVEVSSVNLOjQyLENIQVJfQU1QRVJTQU5EOjM4LENIQVJfQVQ6NjQsQ0hBUl9CQUNLV0FSRF9TTEFTSDo5MixDSEFSX0NBUlJJQUdFX1JFVFVSTjoxMyxDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOjk0LENIQVJfQ09MT046NTgsQ0hBUl9DT01NQTo0NCxDSEFSX0RPVDo0NixDSEFSX0RPVUJMRV9RVU9URTozNCxDSEFSX0VRVUFMOjYxLENIQVJfRVhDTEFNQVRJT05fTUFSSzozMyxDSEFSX0ZPUk1fRkVFRDoxMixDSEFSX0ZPUldBUkRfU0xBU0g6NDcsQ0hBUl9HUkFWRV9BQ0NFTlQ6OTYsQ0hBUl9IQVNIOjM1LENIQVJfSFlQSEVOX01JTlVTOjQ1LENIQVJfTEVGVF9BTkdMRV9CUkFDS0VUOjYwLENIQVJfTEVGVF9DVVJMWV9CUkFDRToxMjMsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOjkxLENIQVJfTElORV9GRUVEOjEwLENIQVJfTk9fQlJFQUtfU1BBQ0U6MTYwLENIQVJfUEVSQ0VOVDozNyxDSEFSX1BMVVM6NDMsQ0hBUl9RVUVTVElPTl9NQVJLOjYzLENIQVJfUklHSFRfQU5HTEVfQlJBQ0tFVDo2MixDSEFSX1JJR0hUX0NVUkxZX0JSQUNFOjEyNSxDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUOjkzLENIQVJfU0VNSUNPTE9OOjU5LENIQVJfU0lOR0xFX1FVT1RFOjM5LENIQVJfU1BBQ0U6MzIsQ0hBUl9UQUI6OSxDSEFSX1VOREVSU0NPUkU6OTUsQ0hBUl9WRVJUSUNBTF9MSU5FOjEyNCxDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRTo2NTI3OSxleHRnbG9iQ2hhcnModCl7cmV0dXJue1wiIVwiOnt0eXBlOlwibmVnYXRlXCIsb3BlbjpcIig/Oig/ISg/OlwiLGNsb3NlOmApKSR7dC5TVEFSfSlgfSxcIj9cIjp7dHlwZTpcInFtYXJrXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKT9cIn0sXCIrXCI6e3R5cGU6XCJwbHVzXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKStcIn0sXCIqXCI6e3R5cGU6XCJzdGFyXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKSpcIn0sXCJAXCI6e3R5cGU6XCJhdFwiLG9wZW46XCIoPzpcIixjbG9zZTpcIilcIn19fSxnbG9iQ2hhcnModCl7cmV0dXJuIHQ9PT10cnVlP0M6Yn19fSw2OTc6KHQsZSx1KT0+e2NvbnN0IG49dSgxNTQpO2NvbnN0IG89dSg5Nik7Y29uc3R7TUFYX0xFTkdUSDpzLFBPU0lYX1JFR0VYX1NPVVJDRTpyLFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOmEsUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOmksUkVQTEFDRU1FTlRTOmN9PW47Y29uc3QgZXhwYW5kUmFuZ2U9KHQsZSk9PntpZih0eXBlb2YgZS5leHBhbmRSYW5nZT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGUuZXhwYW5kUmFuZ2UoLi4udCxlKX10LnNvcnQoKTtjb25zdCB1PWBbJHt0LmpvaW4oXCItXCIpfV1gO3RyeXtuZXcgUmVnRXhwKHUpfWNhdGNoKGUpe3JldHVybiB0Lm1hcCgodD0+by5lc2NhcGVSZWdleCh0KSkpLmpvaW4oXCIuLlwiKX1yZXR1cm4gdX07Y29uc3Qgc3ludGF4RXJyb3I9KHQsZSk9PmBNaXNzaW5nICR7dH06IFwiJHtlfVwiIC0gdXNlIFwiXFxcXFxcXFwke2V9XCIgdG8gbWF0Y2ggbGl0ZXJhbCBjaGFyYWN0ZXJzYDtjb25zdCBwYXJzZT0odCxlKT0+e2lmKHR5cGVvZiB0IT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpfXQ9Y1t0XXx8dDtjb25zdCB1PXsuLi5lfTtjb25zdCBwPXR5cGVvZiB1Lm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4ocyx1Lm1heExlbmd0aCk6cztsZXQgbD10Lmxlbmd0aDtpZihsPnApe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2x9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7cH1gKX1jb25zdCBmPXt0eXBlOlwiYm9zXCIsdmFsdWU6XCJcIixvdXRwdXQ6dS5wcmVwZW5kfHxcIlwifTtjb25zdCBBPVtmXTtjb25zdCBfPXUuY2FwdHVyZT9cIlwiOlwiPzpcIjtjb25zdCBSPW4uZ2xvYkNoYXJzKHUud2luZG93cyk7Y29uc3QgRT1uLmV4dGdsb2JDaGFycyhSKTtjb25zdHtET1RfTElURVJBTDpoLFBMVVNfTElURVJBTDpnLFNMQVNIX0xJVEVSQUw6YixPTkVfQ0hBUjpDLERPVFNfU0xBU0g6eSxOT19ET1Q6JCxOT19ET1RfU0xBU0g6eCxOT19ET1RTX1NMQVNIOlMsUU1BUks6SCxRTUFSS19OT19ET1Q6dixTVEFSOmQsU1RBUlRfQU5DSE9SOkx9PVI7Y29uc3QgZ2xvYnN0YXI9dD0+YCgke199KD86KD8hJHtMfSR7dC5kb3Q/eTpofSkuKSo/KWA7Y29uc3QgVD11LmRvdD9cIlwiOiQ7Y29uc3QgTz11LmRvdD9IOnY7bGV0IGs9dS5iYXNoPT09dHJ1ZT9nbG9ic3Rhcih1KTpkO2lmKHUuY2FwdHVyZSl7az1gKCR7a30pYH1pZih0eXBlb2YgdS5ub2V4dD09PVwiYm9vbGVhblwiKXt1Lm5vZXh0Z2xvYj11Lm5vZXh0fWNvbnN0IG09e2lucHV0OnQsaW5kZXg6LTEsc3RhcnQ6MCxkb3Q6dS5kb3Q9PT10cnVlLGNvbnN1bWVkOlwiXCIsb3V0cHV0OlwiXCIscHJlZml4OlwiXCIsYmFja3RyYWNrOmZhbHNlLG5lZ2F0ZWQ6ZmFsc2UsYnJhY2tldHM6MCxicmFjZXM6MCxwYXJlbnM6MCxxdW90ZXM6MCxnbG9ic3RhcjpmYWxzZSx0b2tlbnM6QX07dD1vLnJlbW92ZVByZWZpeCh0LG0pO2w9dC5sZW5ndGg7Y29uc3Qgdz1bXTtjb25zdCBOPVtdO2NvbnN0IEk9W107bGV0IEI9ZjtsZXQgRztjb25zdCBlb3M9KCk9Pm0uaW5kZXg9PT1sLTE7Y29uc3QgRD1tLnBlZWs9KGU9MSk9PnRbbS5pbmRleCtlXTtjb25zdCBNPW0uYWR2YW5jZT0oKT0+dFsrK20uaW5kZXhdfHxcIlwiO2NvbnN0IHJlbWFpbmluZz0oKT0+dC5zbGljZShtLmluZGV4KzEpO2NvbnN0IGNvbnN1bWU9KHQ9XCJcIixlPTApPT57bS5jb25zdW1lZCs9dDttLmluZGV4Kz1lfTtjb25zdCBhcHBlbmQ9dD0+e20ub3V0cHV0Kz10Lm91dHB1dCE9bnVsbD90Lm91dHB1dDp0LnZhbHVlO2NvbnN1bWUodC52YWx1ZSl9O2NvbnN0IG5lZ2F0ZT0oKT0+e2xldCB0PTE7d2hpbGUoRCgpPT09XCIhXCImJihEKDIpIT09XCIoXCJ8fEQoMyk9PT1cIj9cIikpe00oKTttLnN0YXJ0Kys7dCsrfWlmKHQlMj09PTApe3JldHVybiBmYWxzZX1tLm5lZ2F0ZWQ9dHJ1ZTttLnN0YXJ0Kys7cmV0dXJuIHRydWV9O2NvbnN0IGluY3JlbWVudD10PT57bVt0XSsrO0kucHVzaCh0KX07Y29uc3QgZGVjcmVtZW50PXQ9PnttW3RdLS07SS5wb3AoKX07Y29uc3QgcHVzaD10PT57aWYoQi50eXBlPT09XCJnbG9ic3RhclwiKXtjb25zdCBlPW0uYnJhY2VzPjAmJih0LnR5cGU9PT1cImNvbW1hXCJ8fHQudHlwZT09PVwiYnJhY2VcIik7Y29uc3QgdT10LmV4dGdsb2I9PT10cnVlfHx3Lmxlbmd0aCYmKHQudHlwZT09PVwicGlwZVwifHx0LnR5cGU9PT1cInBhcmVuXCIpO2lmKHQudHlwZSE9PVwic2xhc2hcIiYmdC50eXBlIT09XCJwYXJlblwiJiYhZSYmIXUpe20ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLUIub3V0cHV0Lmxlbmd0aCk7Qi50eXBlPVwic3RhclwiO0IudmFsdWU9XCIqXCI7Qi5vdXRwdXQ9azttLm91dHB1dCs9Qi5vdXRwdXR9fWlmKHcubGVuZ3RoJiZ0LnR5cGUhPT1cInBhcmVuXCIpe3dbdy5sZW5ndGgtMV0uaW5uZXIrPXQudmFsdWV9aWYodC52YWx1ZXx8dC5vdXRwdXQpYXBwZW5kKHQpO2lmKEImJkIudHlwZT09PVwidGV4dFwiJiZ0LnR5cGU9PT1cInRleHRcIil7Qi5vdXRwdXQ9KEIub3V0cHV0fHxCLnZhbHVlKSt0LnZhbHVlO0IudmFsdWUrPXQudmFsdWU7cmV0dXJufXQucHJldj1CO0EucHVzaCh0KTtCPXR9O2NvbnN0IGV4dGdsb2JPcGVuPSh0LGUpPT57Y29uc3Qgbj17Li4uRVtlXSxjb25kaXRpb25zOjEsaW5uZXI6XCJcIn07bi5wcmV2PUI7bi5wYXJlbnM9bS5wYXJlbnM7bi5vdXRwdXQ9bS5vdXRwdXQ7Y29uc3Qgbz0odS5jYXB0dXJlP1wiKFwiOlwiXCIpK24ub3BlbjtpbmNyZW1lbnQoXCJwYXJlbnNcIik7cHVzaCh7dHlwZTp0LHZhbHVlOmUsb3V0cHV0Om0ub3V0cHV0P1wiXCI6Q30pO3B1c2goe3R5cGU6XCJwYXJlblwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpNKCksb3V0cHV0Om99KTt3LnB1c2gobil9O2NvbnN0IGV4dGdsb2JDbG9zZT10PT57bGV0IG49dC5jbG9zZSsodS5jYXB0dXJlP1wiKVwiOlwiXCIpO2xldCBvO2lmKHQudHlwZT09PVwibmVnYXRlXCIpe2xldCBzPWs7aWYodC5pbm5lciYmdC5pbm5lci5sZW5ndGg+MSYmdC5pbm5lci5pbmNsdWRlcyhcIi9cIikpe3M9Z2xvYnN0YXIodSl9aWYocyE9PWt8fGVvcygpfHwvXlxcKSskLy50ZXN0KHJlbWFpbmluZygpKSl7bj10LmNsb3NlPWApJCkpJHtzfWB9aWYodC5pbm5lci5pbmNsdWRlcyhcIipcIikmJihvPXJlbWFpbmluZygpKSYmL15cXC5bXlxcXFwvLl0rJC8udGVzdChvKSl7Y29uc3QgdT1wYXJzZShvLHsuLi5lLGZhc3RwYXRoczpmYWxzZX0pLm91dHB1dDtuPXQuY2xvc2U9YCkke3V9KSR7c30pYH1pZih0LnByZXYudHlwZT09PVwiYm9zXCIpe20ubmVnYXRlZEV4dGdsb2I9dHJ1ZX19cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkcsb3V0cHV0Om59KTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9O2lmKHUuZmFzdHBhdGhzIT09ZmFsc2UmJiEvKF5bKiFdfFsvKClbXFxde31cIl0pLy50ZXN0KHQpKXtsZXQgbj1mYWxzZTtsZXQgcz10LnJlcGxhY2UoaSwoKHQsZSx1LG8scyxyKT0+e2lmKG89PT1cIlxcXFxcIil7bj10cnVlO3JldHVybiB0fWlmKG89PT1cIj9cIil7aWYoZSl7cmV0dXJuIGUrbysocz9ILnJlcGVhdChzLmxlbmd0aCk6XCJcIil9aWYocj09PTApe3JldHVybiBPKyhzP0gucmVwZWF0KHMubGVuZ3RoKTpcIlwiKX1yZXR1cm4gSC5yZXBlYXQodS5sZW5ndGgpfWlmKG89PT1cIi5cIil7cmV0dXJuIGgucmVwZWF0KHUubGVuZ3RoKX1pZihvPT09XCIqXCIpe2lmKGUpe3JldHVybiBlK28rKHM/azpcIlwiKX1yZXR1cm4ga31yZXR1cm4gZT90OmBcXFxcJHt0fWB9KSk7aWYobj09PXRydWUpe2lmKHUudW5lc2NhcGU9PT10cnVlKXtzPXMucmVwbGFjZSgvXFxcXC9nLFwiXCIpfWVsc2V7cz1zLnJlcGxhY2UoL1xcXFwrL2csKHQ9PnQubGVuZ3RoJTI9PT0wP1wiXFxcXFxcXFxcIjp0P1wiXFxcXFwiOlwiXCIpKX19aWYocz09PXQmJnUuY29udGFpbnM9PT10cnVlKXttLm91dHB1dD10O3JldHVybiBtfW0ub3V0cHV0PW8ud3JhcE91dHB1dChzLG0sZSk7cmV0dXJuIG19d2hpbGUoIWVvcygpKXtHPU0oKTtpZihHPT09XCJcXDBcIil7Y29udGludWV9aWYoRz09PVwiXFxcXFwiKXtjb25zdCB0PUQoKTtpZih0PT09XCIvXCImJnUuYmFzaCE9PXRydWUpe2NvbnRpbnVlfWlmKHQ9PT1cIi5cInx8dD09PVwiO1wiKXtjb250aW51ZX1pZighdCl7Rys9XCJcXFxcXCI7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9Y29uc3QgZT0vXlxcXFwrLy5leGVjKHJlbWFpbmluZygpKTtsZXQgbj0wO2lmKGUmJmVbMF0ubGVuZ3RoPjIpe249ZVswXS5sZW5ndGg7bS5pbmRleCs9bjtpZihuJTIhPT0wKXtHKz1cIlxcXFxcIn19aWYodS51bmVzY2FwZT09PXRydWUpe0c9TSgpfWVsc2V7Rys9TSgpfWlmKG0uYnJhY2tldHM9PT0wKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX19aWYobS5icmFja2V0cz4wJiYoRyE9PVwiXVwifHxCLnZhbHVlPT09XCJbXCJ8fEIudmFsdWU9PT1cIlteXCIpKXtpZih1LnBvc2l4IT09ZmFsc2UmJkc9PT1cIjpcIil7Y29uc3QgdD1CLnZhbHVlLnNsaWNlKDEpO2lmKHQuaW5jbHVkZXMoXCJbXCIpKXtCLnBvc2l4PXRydWU7aWYodC5pbmNsdWRlcyhcIjpcIikpe2NvbnN0IHQ9Qi52YWx1ZS5sYXN0SW5kZXhPZihcIltcIik7Y29uc3QgZT1CLnZhbHVlLnNsaWNlKDAsdCk7Y29uc3QgdT1CLnZhbHVlLnNsaWNlKHQrMik7Y29uc3Qgbj1yW3VdO2lmKG4pe0IudmFsdWU9ZStuO20uYmFja3RyYWNrPXRydWU7TSgpO2lmKCFmLm91dHB1dCYmQS5pbmRleE9mKEIpPT09MSl7Zi5vdXRwdXQ9Q31jb250aW51ZX19fX1pZihHPT09XCJbXCImJkQoKSE9PVwiOlwifHxHPT09XCItXCImJkQoKT09PVwiXVwiKXtHPWBcXFxcJHtHfWB9aWYoRz09PVwiXVwiJiYoQi52YWx1ZT09PVwiW1wifHxCLnZhbHVlPT09XCJbXlwiKSl7Rz1gXFxcXCR7R31gfWlmKHUucG9zaXg9PT10cnVlJiZHPT09XCIhXCImJkIudmFsdWU9PT1cIltcIil7Rz1cIl5cIn1CLnZhbHVlKz1HO2FwcGVuZCh7dmFsdWU6R30pO2NvbnRpbnVlfWlmKG0ucXVvdGVzPT09MSYmRyE9PSdcIicpe0c9by5lc2NhcGVSZWdleChHKTtCLnZhbHVlKz1HO2FwcGVuZCh7dmFsdWU6R30pO2NvbnRpbnVlfWlmKEc9PT0nXCInKXttLnF1b3Rlcz1tLnF1b3Rlcz09PTE/MDoxO2lmKHUua2VlcFF1b3Rlcz09PXRydWUpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pfWNvbnRpbnVlfWlmKEc9PT1cIihcIil7aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6XCJwYXJlblwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCIpXCIpe2lmKG0ucGFyZW5zPT09MCYmdS5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIihcIikpfWNvbnN0IHQ9d1t3Lmxlbmd0aC0xXTtpZih0JiZtLnBhcmVucz09PXQucGFyZW5zKzEpe2V4dGdsb2JDbG9zZSh3LnBvcCgpKTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpHLG91dHB1dDptLnBhcmVucz9cIilcIjpcIlxcXFwpXCJ9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIik7Y29udGludWV9aWYoRz09PVwiW1wiKXtpZih1Lm5vYnJhY2tldD09PXRydWV8fCFyZW1haW5pbmcoKS5pbmNsdWRlcyhcIl1cIikpe2lmKHUubm9icmFja2V0IT09dHJ1ZSYmdS5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpfUc9YFxcXFwke0d9YH1lbHNle2luY3JlbWVudChcImJyYWNrZXRzXCIpfXB1c2goe3R5cGU6XCJicmFja2V0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWlmKEc9PT1cIl1cIil7aWYodS5ub2JyYWNrZXQ9PT10cnVlfHxCJiZCLnR5cGU9PT1cImJyYWNrZXRcIiYmQi52YWx1ZS5sZW5ndGg9PT0xKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0OmBcXFxcJHtHfWB9KTtjb250aW51ZX1pZihtLmJyYWNrZXRzPT09MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIltcIikpfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6YFxcXFwke0d9YH0pO2NvbnRpbnVlfWRlY3JlbWVudChcImJyYWNrZXRzXCIpO2NvbnN0IHQ9Qi52YWx1ZS5zbGljZSgxKTtpZihCLnBvc2l4IT09dHJ1ZSYmdFswXT09PVwiXlwiJiYhdC5pbmNsdWRlcyhcIi9cIikpe0c9YC8ke0d9YH1CLnZhbHVlKz1HO2FwcGVuZCh7dmFsdWU6R30pO2lmKHUubGl0ZXJhbEJyYWNrZXRzPT09ZmFsc2V8fG8uaGFzUmVnZXhDaGFycyh0KSl7Y29udGludWV9Y29uc3QgZT1vLmVzY2FwZVJlZ2V4KEIudmFsdWUpO20ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLUIudmFsdWUubGVuZ3RoKTtpZih1LmxpdGVyYWxCcmFja2V0cz09PXRydWUpe20ub3V0cHV0Kz1lO0IudmFsdWU9ZTtjb250aW51ZX1CLnZhbHVlPWAoJHtffSR7ZX18JHtCLnZhbHVlfSlgO20ub3V0cHV0Kz1CLnZhbHVlO2NvbnRpbnVlfWlmKEc9PT1cIntcIiYmdS5ub2JyYWNlIT09dHJ1ZSl7aW5jcmVtZW50KFwiYnJhY2VzXCIpO2NvbnN0IHQ9e3R5cGU6XCJicmFjZVwiLHZhbHVlOkcsb3V0cHV0OlwiKFwiLG91dHB1dEluZGV4Om0ub3V0cHV0Lmxlbmd0aCx0b2tlbnNJbmRleDptLnRva2Vucy5sZW5ndGh9O04ucHVzaCh0KTtwdXNoKHQpO2NvbnRpbnVlfWlmKEc9PT1cIn1cIil7Y29uc3QgdD1OW04ubGVuZ3RoLTFdO2lmKHUubm9icmFjZT09PXRydWV8fCF0KXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0Okd9KTtjb250aW51ZX1sZXQgZT1cIilcIjtpZih0LmRvdHM9PT10cnVlKXtjb25zdCB0PUEuc2xpY2UoKTtjb25zdCBuPVtdO2ZvcihsZXQgZT10Lmxlbmd0aC0xO2U+PTA7ZS0tKXtBLnBvcCgpO2lmKHRbZV0udHlwZT09PVwiYnJhY2VcIil7YnJlYWt9aWYodFtlXS50eXBlIT09XCJkb3RzXCIpe24udW5zaGlmdCh0W2VdLnZhbHVlKX19ZT1leHBhbmRSYW5nZShuLHUpO20uYmFja3RyYWNrPXRydWV9aWYodC5jb21tYSE9PXRydWUmJnQuZG90cyE9PXRydWUpe2NvbnN0IHU9bS5vdXRwdXQuc2xpY2UoMCx0Lm91dHB1dEluZGV4KTtjb25zdCBuPW0udG9rZW5zLnNsaWNlKHQudG9rZW5zSW5kZXgpO3QudmFsdWU9dC5vdXRwdXQ9XCJcXFxce1wiO0c9ZT1cIlxcXFx9XCI7bS5vdXRwdXQ9dTtmb3IoY29uc3QgdCBvZiBuKXttLm91dHB1dCs9dC5vdXRwdXR8fHQudmFsdWV9fXB1c2goe3R5cGU6XCJicmFjZVwiLHZhbHVlOkcsb3V0cHV0OmV9KTtkZWNyZW1lbnQoXCJicmFjZXNcIik7Ti5wb3AoKTtjb250aW51ZX1pZihHPT09XCJ8XCIpe2lmKHcubGVuZ3RoPjApe3dbdy5sZW5ndGgtMV0uY29uZGl0aW9ucysrfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWlmKEc9PT1cIixcIil7bGV0IHQ9Rztjb25zdCBlPU5bTi5sZW5ndGgtMV07aWYoZSYmSVtJLmxlbmd0aC0xXT09PVwiYnJhY2VzXCIpe2UuY29tbWE9dHJ1ZTt0PVwifFwifXB1c2goe3R5cGU6XCJjb21tYVwiLHZhbHVlOkcsb3V0cHV0OnR9KTtjb250aW51ZX1pZihHPT09XCIvXCIpe2lmKEIudHlwZT09PVwiZG90XCImJm0uaW5kZXg9PT1tLnN0YXJ0KzEpe20uc3RhcnQ9bS5pbmRleCsxO20uY29uc3VtZWQ9XCJcIjttLm91dHB1dD1cIlwiO0EucG9wKCk7Qj1mO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOkcsb3V0cHV0OmJ9KTtjb250aW51ZX1pZihHPT09XCIuXCIpe2lmKG0uYnJhY2VzPjAmJkIudHlwZT09PVwiZG90XCIpe2lmKEIudmFsdWU9PT1cIi5cIilCLm91dHB1dD1oO2NvbnN0IHQ9TltOLmxlbmd0aC0xXTtCLnR5cGU9XCJkb3RzXCI7Qi5vdXRwdXQrPUc7Qi52YWx1ZSs9Rzt0LmRvdHM9dHJ1ZTtjb250aW51ZX1pZihtLmJyYWNlcyttLnBhcmVucz09PTAmJkIudHlwZSE9PVwiYm9zXCImJkIudHlwZSE9PVwic2xhc2hcIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpofSk7Y29udGludWV9cHVzaCh7dHlwZTpcImRvdFwiLHZhbHVlOkcsb3V0cHV0Omh9KTtjb250aW51ZX1pZihHPT09XCI/XCIpe2NvbnN0IHQ9QiYmQi52YWx1ZT09PVwiKFwiO2lmKCF0JiZ1Lm5vZXh0Z2xvYiE9PXRydWUmJkQoKT09PVwiKFwiJiZEKDIpIT09XCI/XCIpe2V4dGdsb2JPcGVuKFwicW1hcmtcIixHKTtjb250aW51ZX1pZihCJiZCLnR5cGU9PT1cInBhcmVuXCIpe2NvbnN0IHQ9RCgpO2xldCBlPUc7aWYoQi52YWx1ZT09PVwiKFwiJiYhL1shPTw6XS8udGVzdCh0KXx8dD09PVwiPFwiJiYhLzwoWyE9XXxcXHcrPikvLnRlc3QocmVtYWluaW5nKCkpKXtlPWBcXFxcJHtHfWB9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDplfSk7Y29udGludWV9aWYodS5kb3QhPT10cnVlJiYoQi50eXBlPT09XCJzbGFzaFwifHxCLnR5cGU9PT1cImJvc1wiKSl7cHVzaCh7dHlwZTpcInFtYXJrXCIsdmFsdWU6RyxvdXRwdXQ6dn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkcsb3V0cHV0Okh9KTtjb250aW51ZX1pZihHPT09XCIhXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCIpe2lmKEQoMikhPT1cIj9cInx8IS9bIT08Ol0vLnRlc3QoRCgzKSkpe2V4dGdsb2JPcGVuKFwibmVnYXRlXCIsRyk7Y29udGludWV9fWlmKHUubm9uZWdhdGUhPT10cnVlJiZtLmluZGV4PT09MCl7bmVnYXRlKCk7Y29udGludWV9fWlmKEc9PT1cIitcIil7aWYodS5ub2V4dGdsb2IhPT10cnVlJiZEKCk9PT1cIihcIiYmRCgyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInBsdXNcIixHKTtjb250aW51ZX1pZihCJiZCLnZhbHVlPT09XCIoXCJ8fHUucmVnZXg9PT1mYWxzZSl7cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpHLG91dHB1dDpnfSk7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiYnJhY2tldFwifHxCLnR5cGU9PT1cInBhcmVuXCJ8fEIudHlwZT09PVwiYnJhY2VcIil8fG0ucGFyZW5zPjApe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6R30pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Z30pO2NvbnRpbnVlfWlmKEc9PT1cIkBcIil7aWYodS5ub2V4dGdsb2IhPT10cnVlJiZEKCk9PT1cIihcIiYmRCgyKSE9PVwiP1wiKXtwdXNoKHt0eXBlOlwiYXRcIixleHRnbG9iOnRydWUsdmFsdWU6RyxvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWlmKEchPT1cIipcIil7aWYoRz09PVwiJFwifHxHPT09XCJeXCIpe0c9YFxcXFwke0d9YH1jb25zdCB0PWEuZXhlYyhyZW1haW5pbmcoKSk7aWYodCl7Rys9dFswXTttLmluZGV4Kz10WzBdLmxlbmd0aH1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihCJiYoQi50eXBlPT09XCJnbG9ic3RhclwifHxCLnN0YXI9PT10cnVlKSl7Qi50eXBlPVwic3RhclwiO0Iuc3Rhcj10cnVlO0IudmFsdWUrPUc7Qi5vdXRwdXQ9azttLmJhY2t0cmFjaz10cnVlO20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcpO2NvbnRpbnVlfWxldCBlPXJlbWFpbmluZygpO2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmL15cXChbXj9dLy50ZXN0KGUpKXtleHRnbG9iT3BlbihcInN0YXJcIixHKTtjb250aW51ZX1pZihCLnR5cGU9PT1cInN0YXJcIil7aWYodS5ub2dsb2JzdGFyPT09dHJ1ZSl7Y29uc3VtZShHKTtjb250aW51ZX1jb25zdCBuPUIucHJldjtjb25zdCBvPW4ucHJldjtjb25zdCBzPW4udHlwZT09PVwic2xhc2hcInx8bi50eXBlPT09XCJib3NcIjtjb25zdCByPW8mJihvLnR5cGU9PT1cInN0YXJcInx8by50eXBlPT09XCJnbG9ic3RhclwiKTtpZih1LmJhc2g9PT10cnVlJiYoIXN8fGVbMF0mJmVbMF0hPT1cIi9cIikpe3B1c2goe3R5cGU6XCJzdGFyXCIsdmFsdWU6RyxvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWNvbnN0IGE9bS5icmFjZXM+MCYmKG4udHlwZT09PVwiY29tbWFcInx8bi50eXBlPT09XCJicmFjZVwiKTtjb25zdCBpPXcubGVuZ3RoJiYobi50eXBlPT09XCJwaXBlXCJ8fG4udHlwZT09PVwicGFyZW5cIik7aWYoIXMmJm4udHlwZSE9PVwicGFyZW5cIiYmIWEmJiFpKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX13aGlsZShlLnNsaWNlKDAsMyk9PT1cIi8qKlwiKXtjb25zdCB1PXRbbS5pbmRleCs0XTtpZih1JiZ1IT09XCIvXCIpe2JyZWFrfWU9ZS5zbGljZSgzKTtjb25zdW1lKFwiLyoqXCIsMyl9aWYobi50eXBlPT09XCJib3NcIiYmZW9zKCkpe0IudHlwZT1cImdsb2JzdGFyXCI7Qi52YWx1ZSs9RztCLm91dHB1dD1nbG9ic3Rhcih1KTttLm91dHB1dD1CLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1pZihuLnR5cGU9PT1cInNsYXNoXCImJm4ucHJldi50eXBlIT09XCJib3NcIiYmIXImJmVvcygpKXttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrQi5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtCLnR5cGU9XCJnbG9ic3RhclwiO0Iub3V0cHV0PWdsb2JzdGFyKHUpKyh1LnN0cmljdFNsYXNoZXM/XCIpXCI6XCJ8JClcIik7Qi52YWx1ZSs9RzttLmdsb2JzdGFyPXRydWU7bS5vdXRwdXQrPW4ub3V0cHV0K0Iub3V0cHV0O2NvbnN1bWUoRyk7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJmVbMF09PT1cIi9cIil7Y29uc3QgdD1lWzFdIT09dm9pZCAwP1wifCRcIjpcIlwiO20ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLShuLm91dHB1dCtCLm91dHB1dCkubGVuZ3RoKTtuLm91dHB1dD1gKD86JHtuLm91dHB1dH1gO0IudHlwZT1cImdsb2JzdGFyXCI7Qi5vdXRwdXQ9YCR7Z2xvYnN0YXIodSl9JHtifXwke2J9JHt0fSlgO0IudmFsdWUrPUc7bS5vdXRwdXQrPW4ub3V0cHV0K0Iub3V0cHV0O20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcrTSgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWlmKG4udHlwZT09PVwiYm9zXCImJmVbMF09PT1cIi9cIil7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLnZhbHVlKz1HO0Iub3V0cHV0PWAoPzpefCR7Yn18JHtnbG9ic3Rhcih1KX0ke2J9KWA7bS5vdXRwdXQ9Qi5vdXRwdXQ7bS5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoRytNKCkpO3B1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOlwiL1wiLG91dHB1dDpcIlwifSk7Y29udGludWV9bS5vdXRwdXQ9bS5vdXRwdXQuc2xpY2UoMCwtQi5vdXRwdXQubGVuZ3RoKTtCLnR5cGU9XCJnbG9ic3RhclwiO0Iub3V0cHV0PWdsb2JzdGFyKHUpO0IudmFsdWUrPUc7bS5vdXRwdXQrPUIub3V0cHV0O20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcpO2NvbnRpbnVlfWNvbnN0IG49e3R5cGU6XCJzdGFyXCIsdmFsdWU6RyxvdXRwdXQ6a307aWYodS5iYXNoPT09dHJ1ZSl7bi5vdXRwdXQ9XCIuKj9cIjtpZihCLnR5cGU9PT1cImJvc1wifHxCLnR5cGU9PT1cInNsYXNoXCIpe24ub3V0cHV0PVQrbi5vdXRwdXR9cHVzaChuKTtjb250aW51ZX1pZihCJiYoQi50eXBlPT09XCJicmFja2V0XCJ8fEIudHlwZT09PVwicGFyZW5cIikmJnUucmVnZXg9PT10cnVlKXtuLm91dHB1dD1HO3B1c2gobik7Y29udGludWV9aWYobS5pbmRleD09PW0uc3RhcnR8fEIudHlwZT09PVwic2xhc2hcInx8Qi50eXBlPT09XCJkb3RcIil7aWYoQi50eXBlPT09XCJkb3RcIil7bS5vdXRwdXQrPXg7Qi5vdXRwdXQrPXh9ZWxzZSBpZih1LmRvdD09PXRydWUpe20ub3V0cHV0Kz1TO0Iub3V0cHV0Kz1TfWVsc2V7bS5vdXRwdXQrPVQ7Qi5vdXRwdXQrPVR9aWYoRCgpIT09XCIqXCIpe20ub3V0cHV0Kz1DO0Iub3V0cHV0Kz1DfX1wdXNoKG4pfXdoaWxlKG0uYnJhY2tldHM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiXVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwiW1wiKTtkZWNyZW1lbnQoXCJicmFja2V0c1wiKX13aGlsZShtLnBhcmVucz4wKXtpZih1LnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCIpXCIpKTttLm91dHB1dD1vLmVzY2FwZUxhc3QobS5vdXRwdXQsXCIoXCIpO2RlY3JlbWVudChcInBhcmVuc1wiKX13aGlsZShtLmJyYWNlcz4wKXtpZih1LnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJ9XCIpKTttLm91dHB1dD1vLmVzY2FwZUxhc3QobS5vdXRwdXQsXCJ7XCIpO2RlY3JlbWVudChcImJyYWNlc1wiKX1pZih1LnN0cmljdFNsYXNoZXMhPT10cnVlJiYoQi50eXBlPT09XCJzdGFyXCJ8fEIudHlwZT09PVwiYnJhY2tldFwiKSl7cHVzaCh7dHlwZTpcIm1heWJlX3NsYXNoXCIsdmFsdWU6XCJcIixvdXRwdXQ6YCR7Yn0/YH0pfWlmKG0uYmFja3RyYWNrPT09dHJ1ZSl7bS5vdXRwdXQ9XCJcIjtmb3IoY29uc3QgdCBvZiBtLnRva2Vucyl7bS5vdXRwdXQrPXQub3V0cHV0IT1udWxsP3Qub3V0cHV0OnQudmFsdWU7aWYodC5zdWZmaXgpe20ub3V0cHV0Kz10LnN1ZmZpeH19fXJldHVybiBtfTtwYXJzZS5mYXN0cGF0aHM9KHQsZSk9Pntjb25zdCB1PXsuLi5lfTtjb25zdCByPXR5cGVvZiB1Lm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4ocyx1Lm1heExlbmd0aCk6cztjb25zdCBhPXQubGVuZ3RoO2lmKGE+cil7dGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7YX0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHtyfWApfXQ9Y1t0XXx8dDtjb25zdHtET1RfTElURVJBTDppLFNMQVNIX0xJVEVSQUw6cCxPTkVfQ0hBUjpsLERPVFNfU0xBU0g6ZixOT19ET1Q6QSxOT19ET1RTOl8sTk9fRE9UU19TTEFTSDpSLFNUQVI6RSxTVEFSVF9BTkNIT1I6aH09bi5nbG9iQ2hhcnModS53aW5kb3dzKTtjb25zdCBnPXUuZG90P186QTtjb25zdCBiPXUuZG90P1I6QTtjb25zdCBDPXUuY2FwdHVyZT9cIlwiOlwiPzpcIjtjb25zdCB5PXtuZWdhdGVkOmZhbHNlLHByZWZpeDpcIlwifTtsZXQgJD11LmJhc2g9PT10cnVlP1wiLio/XCI6RTtpZih1LmNhcHR1cmUpeyQ9YCgkeyR9KWB9Y29uc3QgZ2xvYnN0YXI9dD0+e2lmKHQubm9nbG9ic3Rhcj09PXRydWUpcmV0dXJuICQ7cmV0dXJuYCgke0N9KD86KD8hJHtofSR7dC5kb3Q/ZjppfSkuKSo/KWB9O2NvbnN0IGNyZWF0ZT10PT57c3dpdGNoKHQpe2Nhc2VcIipcIjpyZXR1cm5gJHtnfSR7bH0keyR9YDtjYXNlXCIuKlwiOnJldHVybmAke2l9JHtsfSR7JH1gO2Nhc2VcIiouKlwiOnJldHVybmAke2d9JHskfSR7aX0ke2x9JHskfWA7Y2FzZVwiKi8qXCI6cmV0dXJuYCR7Z30keyR9JHtwfSR7bH0ke2J9JHskfWA7Y2FzZVwiKipcIjpyZXR1cm4gZytnbG9ic3Rhcih1KTtjYXNlXCIqKi8qXCI6cmV0dXJuYCg/OiR7Z30ke2dsb2JzdGFyKHUpfSR7cH0pPyR7Yn0ke2x9JHskfWA7Y2FzZVwiKiovKi4qXCI6cmV0dXJuYCg/OiR7Z30ke2dsb2JzdGFyKHUpfSR7cH0pPyR7Yn0keyR9JHtpfSR7bH0keyR9YDtjYXNlXCIqKi8uKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2l9JHtsfSR7JH1gO2RlZmF1bHQ6e2NvbnN0IGU9L14oLio/KVxcLihcXHcrKSQvLmV4ZWModCk7aWYoIWUpcmV0dXJuO2NvbnN0IHU9Y3JlYXRlKGVbMV0pO2lmKCF1KXJldHVybjtyZXR1cm4gdStpK2VbMl19fX07Y29uc3QgeD1vLnJlbW92ZVByZWZpeCh0LHkpO2xldCBTPWNyZWF0ZSh4KTtpZihTJiZ1LnN0cmljdFNsYXNoZXMhPT10cnVlKXtTKz1gJHtwfT9gfXJldHVybiBTfTt0LmV4cG9ydHM9cGFyc2V9LDUxMDoodCxlLHUpPT57Y29uc3Qgbj11KDcxNik7Y29uc3Qgbz11KDY5Nyk7Y29uc3Qgcz11KDk2KTtjb25zdCByPXUoMTU0KTtjb25zdCBpc09iamVjdD10PT50JiZ0eXBlb2YgdD09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KHQpO2NvbnN0IHBpY29tYXRjaD0odCxlLHU9ZmFsc2UpPT57aWYoQXJyYXkuaXNBcnJheSh0KSl7Y29uc3Qgbj10Lm1hcCgodD0+cGljb21hdGNoKHQsZSx1KSkpO2NvbnN0IGFycmF5TWF0Y2hlcj10PT57Zm9yKGNvbnN0IGUgb2Ygbil7Y29uc3QgdT1lKHQpO2lmKHUpcmV0dXJuIHV9cmV0dXJuIGZhbHNlfTtyZXR1cm4gYXJyYXlNYXRjaGVyfWNvbnN0IG49aXNPYmplY3QodCkmJnQudG9rZW5zJiZ0LmlucHV0O2lmKHQ9PT1cIlwifHx0eXBlb2YgdCE9PVwic3RyaW5nXCImJiFuKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9Y29uc3Qgbz1lfHx7fTtjb25zdCBzPW8ud2luZG93cztjb25zdCByPW4/cGljb21hdGNoLmNvbXBpbGVSZSh0LGUpOnBpY29tYXRjaC5tYWtlUmUodCxlLGZhbHNlLHRydWUpO2NvbnN0IGE9ci5zdGF0ZTtkZWxldGUgci5zdGF0ZTtsZXQgaXNJZ25vcmVkPSgpPT5mYWxzZTtpZihvLmlnbm9yZSl7Y29uc3QgdD17Li4uZSxpZ25vcmU6bnVsbCxvbk1hdGNoOm51bGwsb25SZXN1bHQ6bnVsbH07aXNJZ25vcmVkPXBpY29tYXRjaChvLmlnbm9yZSx0LHUpfWNvbnN0IG1hdGNoZXI9KHUsbj1mYWxzZSk9Pntjb25zdHtpc01hdGNoOmksbWF0Y2g6YyxvdXRwdXQ6cH09cGljb21hdGNoLnRlc3QodSxyLGUse2dsb2I6dCxwb3NpeDpzfSk7Y29uc3QgbD17Z2xvYjp0LHN0YXRlOmEscmVnZXg6cixwb3NpeDpzLGlucHV0OnUsb3V0cHV0OnAsbWF0Y2g6Yyxpc01hdGNoOml9O2lmKHR5cGVvZiBvLm9uUmVzdWx0PT09XCJmdW5jdGlvblwiKXtvLm9uUmVzdWx0KGwpfWlmKGk9PT1mYWxzZSl7bC5pc01hdGNoPWZhbHNlO3JldHVybiBuP2w6ZmFsc2V9aWYoaXNJZ25vcmVkKHUpKXtpZih0eXBlb2Ygby5vbklnbm9yZT09PVwiZnVuY3Rpb25cIil7by5vbklnbm9yZShsKX1sLmlzTWF0Y2g9ZmFsc2U7cmV0dXJuIG4/bDpmYWxzZX1pZih0eXBlb2Ygby5vbk1hdGNoPT09XCJmdW5jdGlvblwiKXtvLm9uTWF0Y2gobCl9cmV0dXJuIG4/bDp0cnVlfTtpZih1KXttYXRjaGVyLnN0YXRlPWF9cmV0dXJuIG1hdGNoZXJ9O3BpY29tYXRjaC50ZXN0PSh0LGUsdSx7Z2xvYjpuLHBvc2l4Om99PXt9KT0+e2lmKHR5cGVvZiB0IT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGlucHV0IHRvIGJlIGEgc3RyaW5nXCIpfWlmKHQ9PT1cIlwiKXtyZXR1cm57aXNNYXRjaDpmYWxzZSxvdXRwdXQ6XCJcIn19Y29uc3Qgcj11fHx7fTtjb25zdCBhPXIuZm9ybWF0fHwobz9zLnRvUG9zaXhTbGFzaGVzOm51bGwpO2xldCBpPXQ9PT1uO2xldCBjPWkmJmE/YSh0KTp0O2lmKGk9PT1mYWxzZSl7Yz1hP2EodCk6dDtpPWM9PT1ufWlmKGk9PT1mYWxzZXx8ci5jYXB0dXJlPT09dHJ1ZSl7aWYoci5tYXRjaEJhc2U9PT10cnVlfHxyLmJhc2VuYW1lPT09dHJ1ZSl7aT1waWNvbWF0Y2gubWF0Y2hCYXNlKHQsZSx1LG8pfWVsc2V7aT1lLmV4ZWMoYyl9fXJldHVybntpc01hdGNoOkJvb2xlYW4oaSksbWF0Y2g6aSxvdXRwdXQ6Y319O3BpY29tYXRjaC5tYXRjaEJhc2U9KHQsZSx1KT0+e2NvbnN0IG49ZSBpbnN0YW5jZW9mIFJlZ0V4cD9lOnBpY29tYXRjaC5tYWtlUmUoZSx1KTtyZXR1cm4gbi50ZXN0KHMuYmFzZW5hbWUodCkpfTtwaWNvbWF0Y2guaXNNYXRjaD0odCxlLHUpPT5waWNvbWF0Y2goZSx1KSh0KTtwaWNvbWF0Y2gucGFyc2U9KHQsZSk9PntpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0Lm1hcCgodD0+cGljb21hdGNoLnBhcnNlKHQsZSkpKTtyZXR1cm4gbyh0LHsuLi5lLGZhc3RwYXRoczpmYWxzZX0pfTtwaWNvbWF0Y2guc2Nhbj0odCxlKT0+bih0LGUpO3BpY29tYXRjaC5jb21waWxlUmU9KHQsZSx1PWZhbHNlLG49ZmFsc2UpPT57aWYodT09PXRydWUpe3JldHVybiB0Lm91dHB1dH1jb25zdCBvPWV8fHt9O2NvbnN0IHM9by5jb250YWlucz9cIlwiOlwiXlwiO2NvbnN0IHI9by5jb250YWlucz9cIlwiOlwiJFwiO2xldCBhPWAke3N9KD86JHt0Lm91dHB1dH0pJHtyfWA7aWYodCYmdC5uZWdhdGVkPT09dHJ1ZSl7YT1gXig/ISR7YX0pLiokYH1jb25zdCBpPXBpY29tYXRjaC50b1JlZ2V4KGEsZSk7aWYobj09PXRydWUpe2kuc3RhdGU9dH1yZXR1cm4gaX07cGljb21hdGNoLm1ha2VSZT0odCxlPXt9LHU9ZmFsc2Usbj1mYWxzZSk9PntpZighdHx8dHlwZW9mIHQhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBub24tZW1wdHkgc3RyaW5nXCIpfWxldCBzPXtuZWdhdGVkOmZhbHNlLGZhc3RwYXRoczp0cnVlfTtpZihlLmZhc3RwYXRocyE9PWZhbHNlJiYodFswXT09PVwiLlwifHx0WzBdPT09XCIqXCIpKXtzLm91dHB1dD1vLmZhc3RwYXRocyh0LGUpfWlmKCFzLm91dHB1dCl7cz1vKHQsZSl9cmV0dXJuIHBpY29tYXRjaC5jb21waWxlUmUocyxlLHUsbil9O3BpY29tYXRjaC50b1JlZ2V4PSh0LGUpPT57dHJ5e2NvbnN0IHU9ZXx8e307cmV0dXJuIG5ldyBSZWdFeHAodCx1LmZsYWdzfHwodS5ub2Nhc2U/XCJpXCI6XCJcIikpfWNhdGNoKHQpe2lmKGUmJmUuZGVidWc9PT10cnVlKXRocm93IHQ7cmV0dXJuLyReL319O3BpY29tYXRjaC5jb25zdGFudHM9cjt0LmV4cG9ydHM9cGljb21hdGNofSw3MTY6KHQsZSx1KT0+e2NvbnN0IG49dSg5Nik7Y29uc3R7Q0hBUl9BU1RFUklTSzpvLENIQVJfQVQ6cyxDSEFSX0JBQ0tXQVJEX1NMQVNIOnIsQ0hBUl9DT01NQTphLENIQVJfRE9UOmksQ0hBUl9FWENMQU1BVElPTl9NQVJLOmMsQ0hBUl9GT1JXQVJEX1NMQVNIOnAsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOmwsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOmYsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOkEsQ0hBUl9QTFVTOl8sQ0hBUl9RVUVTVElPTl9NQVJLOlIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpFLENIQVJfUklHSFRfUEFSRU5USEVTRVM6aCxDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUOmd9PXUoMTU0KTtjb25zdCBpc1BhdGhTZXBhcmF0b3I9dD0+dD09PXB8fHQ9PT1yO2NvbnN0IGRlcHRoPXQ9PntpZih0LmlzUHJlZml4IT09dHJ1ZSl7dC5kZXB0aD10LmlzR2xvYnN0YXI/SW5maW5pdHk6MX19O2NvbnN0IHNjYW49KHQsZSk9Pntjb25zdCB1PWV8fHt9O2NvbnN0IGI9dC5sZW5ndGgtMTtjb25zdCBDPXUucGFydHM9PT10cnVlfHx1LnNjYW5Ub0VuZD09PXRydWU7Y29uc3QgeT1bXTtjb25zdCAkPVtdO2NvbnN0IHg9W107bGV0IFM9dDtsZXQgSD0tMTtsZXQgdj0wO2xldCBkPTA7bGV0IEw9ZmFsc2U7bGV0IFQ9ZmFsc2U7bGV0IE89ZmFsc2U7bGV0IGs9ZmFsc2U7bGV0IG09ZmFsc2U7bGV0IHc9ZmFsc2U7bGV0IE49ZmFsc2U7bGV0IEk9ZmFsc2U7bGV0IEI9ZmFsc2U7bGV0IEc9ZmFsc2U7bGV0IEQ9MDtsZXQgTTtsZXQgUDtsZXQgSz17dmFsdWU6XCJcIixkZXB0aDowLGlzR2xvYjpmYWxzZX07Y29uc3QgZW9zPSgpPT5IPj1iO2NvbnN0IHBlZWs9KCk9PlMuY2hhckNvZGVBdChIKzEpO2NvbnN0IGFkdmFuY2U9KCk9PntNPVA7cmV0dXJuIFMuY2hhckNvZGVBdCgrK0gpfTt3aGlsZShIPGIpe1A9YWR2YW5jZSgpO2xldCB0O2lmKFA9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTtQPWFkdmFuY2UoKTtpZihQPT09bCl7dz10cnVlfWNvbnRpbnVlfWlmKHc9PT10cnVlfHxQPT09bCl7RCsrO3doaWxlKGVvcygpIT09dHJ1ZSYmKFA9YWR2YW5jZSgpKSl7aWYoUD09PXIpe049Sy5iYWNrc2xhc2hlcz10cnVlO2FkdmFuY2UoKTtjb250aW51ZX1pZihQPT09bCl7RCsrO2NvbnRpbnVlfWlmKHchPT10cnVlJiZQPT09aSYmKFA9YWR2YW5jZSgpKT09PWkpe0w9Sy5pc0JyYWNlPXRydWU7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYodyE9PXRydWUmJlA9PT1hKXtMPUsuaXNCcmFjZT10cnVlO089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1FKXtELS07aWYoRD09PTApe3c9ZmFsc2U7TD1LLmlzQnJhY2U9dHJ1ZTtHPXRydWU7YnJlYWt9fX1pZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoUD09PXApe3kucHVzaChIKTskLnB1c2goSyk7Sz17dmFsdWU6XCJcIixkZXB0aDowLGlzR2xvYjpmYWxzZX07aWYoRz09PXRydWUpY29udGludWU7aWYoTT09PWkmJkg9PT12KzEpe3YrPTI7Y29udGludWV9ZD1IKzE7Y29udGludWV9aWYodS5ub2V4dCE9PXRydWUpe2NvbnN0IHQ9UD09PV98fFA9PT1zfHxQPT09b3x8UD09PVJ8fFA9PT1jO2lmKHQ9PT10cnVlJiZwZWVrKCk9PT1mKXtPPUsuaXNHbG9iPXRydWU7az1LLmlzRXh0Z2xvYj10cnVlO0c9dHJ1ZTtpZihQPT09YyYmSD09PXYpe0I9dHJ1ZX1pZihDPT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoUD1hZHZhbmNlKCkpKXtpZihQPT09cil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWgpe089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7YnJlYWt9fWNvbnRpbnVlfWJyZWFrfX1pZihQPT09byl7aWYoTT09PW8pbT1LLmlzR2xvYnN0YXI9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZihQPT09Uil7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoUD09PUEpe3doaWxlKGVvcygpIT09dHJ1ZSYmKHQ9YWR2YW5jZSgpKSl7aWYodD09PXIpe049Sy5iYWNrc2xhc2hlcz10cnVlO2FkdmFuY2UoKTtjb250aW51ZX1pZih0PT09Zyl7VD1LLmlzQnJhY2tldD10cnVlO089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7YnJlYWt9fWlmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZih1Lm5vbmVnYXRlIT09dHJ1ZSYmUD09PWMmJkg9PT12KXtJPUsubmVnYXRlZD10cnVlO3YrKztjb250aW51ZX1pZih1Lm5vcGFyZW4hPT10cnVlJiZQPT09Zil7Tz1LLmlzR2xvYj10cnVlO2lmKEM9PT10cnVlKXt3aGlsZShlb3MoKSE9PXRydWUmJihQPWFkdmFuY2UoKSkpe2lmKFA9PT1mKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTtQPWFkdmFuY2UoKTtjb250aW51ZX1pZihQPT09aCl7Rz10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha31pZihPPT09dHJ1ZSl7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha319aWYodS5ub2V4dD09PXRydWUpe2s9ZmFsc2U7Tz1mYWxzZX1sZXQgVT1TO2xldCBYPVwiXCI7bGV0IEY9XCJcIjtpZih2PjApe1g9Uy5zbGljZSgwLHYpO1M9Uy5zbGljZSh2KTtkLT12fWlmKFUmJk89PT10cnVlJiZkPjApe1U9Uy5zbGljZSgwLGQpO0Y9Uy5zbGljZShkKX1lbHNlIGlmKE89PT10cnVlKXtVPVwiXCI7Rj1TfWVsc2V7VT1TfWlmKFUmJlUhPT1cIlwiJiZVIT09XCIvXCImJlUhPT1TKXtpZihpc1BhdGhTZXBhcmF0b3IoVS5jaGFyQ29kZUF0KFUubGVuZ3RoLTEpKSl7VT1VLnNsaWNlKDAsLTEpfX1pZih1LnVuZXNjYXBlPT09dHJ1ZSl7aWYoRilGPW4ucmVtb3ZlQmFja3NsYXNoZXMoRik7aWYoVSYmTj09PXRydWUpe1U9bi5yZW1vdmVCYWNrc2xhc2hlcyhVKX19Y29uc3QgUT17cHJlZml4OlgsaW5wdXQ6dCxzdGFydDp2LGJhc2U6VSxnbG9iOkYsaXNCcmFjZTpMLGlzQnJhY2tldDpULGlzR2xvYjpPLGlzRXh0Z2xvYjprLGlzR2xvYnN0YXI6bSxuZWdhdGVkOkksbmVnYXRlZEV4dGdsb2I6Qn07aWYodS50b2tlbnM9PT10cnVlKXtRLm1heERlcHRoPTA7aWYoIWlzUGF0aFNlcGFyYXRvcihQKSl7JC5wdXNoKEspfVEudG9rZW5zPSR9aWYodS5wYXJ0cz09PXRydWV8fHUudG9rZW5zPT09dHJ1ZSl7bGV0IGU7Zm9yKGxldCBuPTA7bjx5Lmxlbmd0aDtuKyspe2NvbnN0IG89ZT9lKzE6djtjb25zdCBzPXlbbl07Y29uc3Qgcj10LnNsaWNlKG8scyk7aWYodS50b2tlbnMpe2lmKG49PT0wJiZ2IT09MCl7JFtuXS5pc1ByZWZpeD10cnVlOyRbbl0udmFsdWU9WH1lbHNleyRbbl0udmFsdWU9cn1kZXB0aCgkW25dKTtRLm1heERlcHRoKz0kW25dLmRlcHRofWlmKG4hPT0wfHxyIT09XCJcIil7eC5wdXNoKHIpfWU9c31pZihlJiZlKzE8dC5sZW5ndGgpe2NvbnN0IG49dC5zbGljZShlKzEpO3gucHVzaChuKTtpZih1LnRva2Vucyl7JFskLmxlbmd0aC0xXS52YWx1ZT1uO2RlcHRoKCRbJC5sZW5ndGgtMV0pO1EubWF4RGVwdGgrPSRbJC5sZW5ndGgtMV0uZGVwdGh9fVEuc2xhc2hlcz15O1EucGFydHM9eH1yZXR1cm4gUX07dC5leHBvcnRzPXNjYW59LDk2Oih0LGUsdSk9Pntjb25zdHtSRUdFWF9CQUNLU0xBU0g6bixSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOm8sUkVHRVhfU1BFQ0lBTF9DSEFSUzpzLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOnJ9PXUoMTU0KTtlLmlzT2JqZWN0PXQ9PnQhPT1udWxsJiZ0eXBlb2YgdD09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KHQpO2UuaGFzUmVnZXhDaGFycz10PT5zLnRlc3QodCk7ZS5pc1JlZ2V4Q2hhcj10PT50Lmxlbmd0aD09PTEmJmUuaGFzUmVnZXhDaGFycyh0KTtlLmVzY2FwZVJlZ2V4PXQ9PnQucmVwbGFjZShyLFwiXFxcXCQxXCIpO2UudG9Qb3NpeFNsYXNoZXM9dD0+dC5yZXBsYWNlKG4sXCIvXCIpO2UucmVtb3ZlQmFja3NsYXNoZXM9dD0+dC5yZXBsYWNlKG8sKHQ9PnQ9PT1cIlxcXFxcIj9cIlwiOnQpKTtlLmVzY2FwZUxhc3Q9KHQsdSxuKT0+e2NvbnN0IG89dC5sYXN0SW5kZXhPZih1LG4pO2lmKG89PT0tMSlyZXR1cm4gdDtpZih0W28tMV09PT1cIlxcXFxcIilyZXR1cm4gZS5lc2NhcGVMYXN0KHQsdSxvLTEpO3JldHVybmAke3Quc2xpY2UoMCxvKX1cXFxcJHt0LnNsaWNlKG8pfWB9O2UucmVtb3ZlUHJlZml4PSh0LGU9e30pPT57bGV0IHU9dDtpZih1LnN0YXJ0c1dpdGgoXCIuL1wiKSl7dT11LnNsaWNlKDIpO2UucHJlZml4PVwiLi9cIn1yZXR1cm4gdX07ZS53cmFwT3V0cHV0PSh0LGU9e30sdT17fSk9Pntjb25zdCBuPXUuY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCBvPXUuY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgcz1gJHtufSg/OiR7dH0pJHtvfWA7aWYoZS5uZWdhdGVkPT09dHJ1ZSl7cz1gKD86Xig/ISR7c30pLiokKWB9cmV0dXJuIHN9O2UuYmFzZW5hbWU9KHQse3dpbmRvd3M6ZX09e30pPT57Y29uc3QgdT10LnNwbGl0KGU/L1tcXFxcL10vOlwiL1wiKTtjb25zdCBuPXVbdS5sZW5ndGgtMV07aWYobj09PVwiXCIpe3JldHVybiB1W3UubGVuZ3RoLTJdfXJldHVybiBufX19O3ZhciBlPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odSl7dmFyIG49ZVt1XTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBvPWVbdV09e2V4cG9ydHM6e319O3ZhciBzPXRydWU7dHJ5e3RbdV0obyxvLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7cz1mYWxzZX1maW5hbGx5e2lmKHMpZGVsZXRlIGVbdV19cmV0dXJuIG8uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHU9X19uY2N3cGNrX3JlcXVpcmVfXygxNzApO21vZHVsZS5leHBvcnRzPXV9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/compiled/picomatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/compiled/process/browser.js":
/*!*************************************************************!*\
  !*** ../node_modules/next/dist/compiled/process/browser.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixtQkFBbUIsTUFBTSxNQUFNLDRCQUE0QixtREFBbUQsK0JBQStCLHFEQUFxRCxZQUFZLElBQUksbUNBQW1DLGFBQWEsS0FBSyxvQkFBb0IsU0FBUyxtQkFBbUIsSUFBSSxxQ0FBcUMsZUFBZSxLQUFLLHVCQUF1QixTQUFTLHVCQUF1QixJQUFJLHVCQUF1QixtQkFBbUIsdUJBQXVCLDJDQUEyQyxhQUFhLHVCQUF1QixJQUFJLGNBQWMsU0FBUyxJQUFJLHdCQUF3QixTQUFTLDBCQUEwQiw0QkFBNEIscUJBQXFCLHVCQUF1QixnREFBZ0QsZUFBZSx1QkFBdUIsSUFBSSxZQUFZLFNBQVMsSUFBSSxzQkFBc0IsU0FBUyx3QkFBd0IsU0FBUyxZQUFZLE1BQU0sU0FBUywyQkFBMkIsV0FBVyxPQUFPLFFBQVEsYUFBYSxjQUFjLEtBQUssS0FBSyxhQUFhLGNBQWMsc0JBQXNCLE1BQU0sT0FBTyxrQ0FBa0MsT0FBTyxlQUFlLFNBQVMsSUFBSSxLQUFLLGFBQWEsTUFBTSxZQUFZLEtBQUssV0FBVyxPQUFPLFFBQVEsbUJBQW1CLHVCQUF1QixvQ0FBb0MsdUJBQXVCLFlBQVksbUJBQW1CLEtBQUsscUJBQXFCLHNCQUFzQixxQkFBcUIseUJBQXlCLG1CQUFtQixXQUFXLGFBQWEsOEJBQThCLGlDQUFpQyxrQkFBa0IsZUFBZSxTQUFTLFVBQVUsYUFBYSxjQUFjLGlCQUFpQixVQUFVLG1CQUFtQixZQUFZLFdBQVcsc0JBQXNCLDBCQUEwQixZQUFZLHVCQUF1QiwyQkFBMkIsd0JBQXdCLFVBQVUsc0JBQXNCLHFEQUFxRCxpQkFBaUIsV0FBVyxvQkFBb0IsbURBQW1ELG1CQUFtQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzPzYyNDciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/preact/compat/dist/compat.module.js":
/*!***********************************************************!*\
  !*** ../node_modules/preact/compat/dist/compat.module.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Children: function() { return /* binding */ O; },\n/* harmony export */   Component: function() { return /* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.Component; },\n/* harmony export */   Fragment: function() { return /* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.Fragment; },\n/* harmony export */   PureComponent: function() { return /* binding */ w; },\n/* harmony export */   StrictMode: function() { return /* binding */ vn; },\n/* harmony export */   Suspense: function() { return /* binding */ D; },\n/* harmony export */   SuspenseList: function() { return /* binding */ V; },\n/* harmony export */   __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: function() { return /* binding */ rn; },\n/* harmony export */   cloneElement: function() { return /* binding */ cn; },\n/* harmony export */   createContext: function() { return /* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.createContext; },\n/* harmony export */   createElement: function() { return /* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.createElement; },\n/* harmony export */   createFactory: function() { return /* binding */ on; },\n/* harmony export */   createPortal: function() { return /* binding */ j; },\n/* harmony export */   createRef: function() { return /* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.createRef; },\n/* harmony export */   \"default\": function() { return /* binding */ bn; },\n/* harmony export */   findDOMNode: function() { return /* binding */ an; },\n/* harmony export */   flushSync: function() { return /* binding */ hn; },\n/* harmony export */   forwardRef: function() { return /* binding */ k; },\n/* harmony export */   hydrate: function() { return /* binding */ q; },\n/* harmony export */   isValidElement: function() { return /* binding */ ln; },\n/* harmony export */   lazy: function() { return /* binding */ M; },\n/* harmony export */   memo: function() { return /* binding */ R; },\n/* harmony export */   render: function() { return /* binding */ Y; },\n/* harmony export */   startTransition: function() { return /* binding */ dn; },\n/* harmony export */   unmountComponentAtNode: function() { return /* binding */ fn; },\n/* harmony export */   unstable_batchedUpdates: function() { return /* binding */ sn; },\n/* harmony export */   useCallback: function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useCallback; },\n/* harmony export */   useContext: function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useContext; },\n/* harmony export */   useDebugValue: function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useDebugValue; },\n/* harmony export */   useDeferredValue: function() { return /* binding */ pn; },\n/* harmony export */   useEffect: function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useEffect; },\n/* harmony export */   useErrorBoundary: function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useErrorBoundary; },\n/* harmony export */   useId: function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useId; },\n/* harmony export */   useImperativeHandle: function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle; },\n/* harmony export */   useInsertionEffect: function() { return /* binding */ yn; },\n/* harmony export */   useLayoutEffect: function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect; },\n/* harmony export */   useMemo: function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useMemo; },\n/* harmony export */   useReducer: function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useReducer; },\n/* harmony export */   useRef: function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useRef; },\n/* harmony export */   useState: function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useState; },\n/* harmony export */   useSyncExternalStore: function() { return /* binding */ _n; },\n/* harmony export */   useTransition: function() { return /* binding */ mn; },\n/* harmony export */   version: function() { return /* binding */ un; }\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"(app-pages-browser)/../node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/hooks */ \"(app-pages-browser)/../node_modules/preact/hooks/dist/hooks.module.js\");\nfunction g(n,t){for(var e in t)n[e]=t[e];return n}function C(n,t){for(var e in n)if(\"__source\"!==e&&!(e in t))return!0;for(var r in t)if(\"__source\"!==r&&n[r]!==t[r])return!0;return!1}function E(n,t){return n===t&&(0!==n||1/n==1/t)||n!=n&&t!=t}function w(n){this.props=n}function R(n,e){function r(n){var t=this.props.ref,r=t==n.ref;return!r&&t&&(t.call?t(null):t.current=null),e?!e(this.props,n)||!r:C(this.props,n)}function u(e){return this.shouldComponentUpdate=r,(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(n,e)}return u.displayName=\"Memo(\"+(n.displayName||n.name)+\")\",u.prototype.isReactComponent=!0,u.__f=!0,u}(w.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component).isPureReactComponent=!0,w.prototype.shouldComponentUpdate=function(n,t){return C(this.props,n)||C(this.state,t)};var x=preact__WEBPACK_IMPORTED_MODULE_0__.options.__b;preact__WEBPACK_IMPORTED_MODULE_0__.options.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),x&&x(n)};var N=\"undefined\"!=typeof Symbol&&Symbol.for&&Symbol.for(\"react.forward_ref\")||3911;function k(n){function t(t){var e=g({},t);return delete e.ref,n(e,t.ref||null)}return t.$$typeof=N,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName=\"ForwardRef(\"+(n.displayName||n.name)+\")\",t}var A=function(n,t){return null==n?null:(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)((0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n).map(t))},O={map:A,forEach:A,count:function(n){return n?(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n).length:0},only:function(n){var t=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n);if(1!==t.length)throw\"Children.only\";return t[0]},toArray:preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray},T=preact__WEBPACK_IMPORTED_MODULE_0__.options.__e;preact__WEBPACK_IMPORTED_MODULE_0__.options.__e=function(n,t,e,r){if(n.then)for(var u,o=t;o=o.__;)if((u=o.__c)&&u.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),u.__c(n,t);T(n,t,e,r)};var I=preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount;function L(n,t,e){return n&&(n.__c&&n.__c.__H&&(n.__c.__H.__.forEach(function(n){\"function\"==typeof n.__c&&n.__c()}),n.__c.__H=null),null!=(n=g({},n)).__c&&(n.__c.__P===e&&(n.__c.__P=t),n.__c=null),n.__k=n.__k&&n.__k.map(function(n){return L(n,t,e)})),n}function U(n,t,e){return n&&(n.__v=null,n.__k=n.__k&&n.__k.map(function(n){return U(n,t,e)}),n.__c&&n.__c.__P===t&&(n.__e&&e.insertBefore(n.__e,n.__d),n.__c.__e=!0,n.__c.__P=e)),n}function D(){this.__u=0,this.t=null,this.__b=null}function F(n){var t=n.__.__c;return t&&t.__a&&t.__a(n)}function M(n){var e,r,u;function o(o){if(e||(e=n()).then(function(n){r=n.default||n},function(n){u=n}),u)throw u;if(!r)throw e;return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(r,o)}return o.displayName=\"Lazy\",o.__f=!0,o}function V(){this.u=null,this.o=null}preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount=function(n){var t=n.__c;t&&t.__R&&t.__R(),t&&!0===n.__h&&(n.type=null),I&&I(n)},(D.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component).__c=function(n,t){var e=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(e);var u=F(r.__v),o=!1,i=function(){o||(o=!0,e.__R=null,u?u(l):l())};e.__R=i;var l=function(){if(!--r.__u){if(r.state.__a){var n=r.state.__a;r.__v.__k[0]=U(n,n.__c.__P,n.__c.__O)}var t;for(r.setState({__a:r.__b=null});t=r.t.pop();)t.forceUpdate()}},c=!0===t.__h;r.__u++||c||r.setState({__a:r.__b=r.__v.__k[0]}),n.then(i,i)},D.prototype.componentWillUnmount=function(){this.t=[]},D.prototype.render=function(n,e){if(this.__b){if(this.__v.__k){var r=document.createElement(\"div\"),o=this.__v.__k[0].__c;this.__v.__k[0]=L(this.__b,r,o.__O=o.__P)}this.__b=null}var i=e.__a&&(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,n.fallback);return i&&(i.__h=null),[(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,e.__a?null:n.children),i]};var W=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&(\"t\"!==n.props.revealOrder[0]||!n.o.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2]}};function P(n){return this.getChildContext=function(){return n.context},n.children}function $(n){var e=this,r=n.i;e.componentWillUnmount=function(){(0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(null,e.l),e.l=null,e.i=null},e.i&&e.i!==r&&e.componentWillUnmount(),n.__v?(e.l||(e.i=r,e.l={nodeType:1,parentNode:r,childNodes:[],appendChild:function(n){this.childNodes.push(n),e.i.appendChild(n)},insertBefore:function(n,t){this.childNodes.push(n),e.i.appendChild(n)},removeChild:function(n){this.childNodes.splice(this.childNodes.indexOf(n)>>>1,1),e.i.removeChild(n)}}),(0,preact__WEBPACK_IMPORTED_MODULE_0__.render)((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(P,{context:e.context},n.__v),e.l)):e.l&&e.componentWillUnmount()}function j(n,e){var r=(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)($,{__v:n,i:e});return r.containerInfo=e,r}(V.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component).__a=function(n){var t=this,e=F(t.__v),r=t.o.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),W(t,n,r)):u()};e?e(o):o()}},V.prototype.render=function(n){this.u=null,this.o=new Map;var t=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n.children);n.revealOrder&&\"b\"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.o.set(t[e],this.u=[1,0,this.u]);return n.children},V.prototype.componentDidUpdate=V.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){W(n,e,t)})};var z=\"undefined\"!=typeof Symbol&&Symbol.for&&Symbol.for(\"react.element\")||60103,B=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,H=\"undefined\"!=typeof document,Z=function(n){return(\"undefined\"!=typeof Symbol&&\"symbol\"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(n)};function Y(n,t,e){return null==t.__k&&(t.textContent=\"\"),(0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(n,t),\"function\"==typeof e&&e(),n?n.__c:null}function q(n,t,e){return (0,preact__WEBPACK_IMPORTED_MODULE_0__.hydrate)(n,t),\"function\"==typeof e&&e(),n?n.__c:null}preact__WEBPACK_IMPORTED_MODULE_0__.Component.prototype.isReactComponent={},[\"componentWillMount\",\"componentWillReceiveProps\",\"componentWillUpdate\"].forEach(function(t){Object.defineProperty(preact__WEBPACK_IMPORTED_MODULE_0__.Component.prototype,t,{configurable:!0,get:function(){return this[\"UNSAFE_\"+t]},set:function(n){Object.defineProperty(this,t,{configurable:!0,writable:!0,value:n})}})});var G=preact__WEBPACK_IMPORTED_MODULE_0__.options.event;function J(){}function K(){return this.cancelBubble}function Q(){return this.defaultPrevented}preact__WEBPACK_IMPORTED_MODULE_0__.options.event=function(n){return G&&(n=G(n)),n.persist=J,n.isPropagationStopped=K,n.isDefaultPrevented=Q,n.nativeEvent=n};var X,nn={configurable:!0,get:function(){return this.class}},tn=preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode;preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode=function(n){var t=n.type,e=n.props,u=e;if(\"string\"==typeof t){var o=-1===t.indexOf(\"-\");for(var i in u={},e){var l=e[i];H&&\"children\"===i&&\"noscript\"===t||\"value\"===i&&\"defaultValue\"in e&&null==l||(\"defaultValue\"===i&&\"value\"in e&&null==e.value?i=\"value\":\"download\"===i&&!0===l?l=\"\":/ondoubleclick/i.test(i)?i=\"ondblclick\":/^onchange(textarea|input)/i.test(i+t)&&!Z(e.type)?i=\"oninput\":/^onfocus$/i.test(i)?i=\"onfocusin\":/^onblur$/i.test(i)?i=\"onfocusout\":/^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i)?i=i.toLowerCase():o&&B.test(i)?i=i.replace(/[A-Z0-9]/g,\"-$&\").toLowerCase():null===l&&(l=void 0),/^oninput$/i.test(i)&&(i=i.toLowerCase(),u[i]&&(i=\"oninputCapture\")),u[i]=l)}\"select\"==t&&u.multiple&&Array.isArray(u.value)&&(u.value=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(e.children).forEach(function(n){n.props.selected=-1!=u.value.indexOf(n.props.value)})),\"select\"==t&&null!=u.defaultValue&&(u.value=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(e.children).forEach(function(n){n.props.selected=u.multiple?-1!=u.defaultValue.indexOf(n.props.value):u.defaultValue==n.props.value})),n.props=u,e.class!=e.className&&(nn.enumerable=\"className\"in e,null!=e.className&&(u.class=e.className),Object.defineProperty(u,\"className\",nn))}n.$$typeof=z,tn&&tn(n)};var en=preact__WEBPACK_IMPORTED_MODULE_0__.options.__r;preact__WEBPACK_IMPORTED_MODULE_0__.options.__r=function(n){en&&en(n),X=n.__c};var rn={ReactCurrentDispatcher:{current:{readContext:function(n){return X.__n[n.__c].props.value}}}},un=\"17.0.2\";function on(n){return preact__WEBPACK_IMPORTED_MODULE_0__.createElement.bind(null,n)}function ln(n){return!!n&&n.$$typeof===z}function cn(n){return ln(n)?preact__WEBPACK_IMPORTED_MODULE_0__.cloneElement.apply(null,arguments):n}function fn(n){return!!n.__k&&((0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(null,n),!0)}function an(n){return n&&(n.base||1===n.nodeType&&n)||null}var sn=function(n,t){return n(t)},hn=function(n,t){return n(t)},vn=preact__WEBPACK_IMPORTED_MODULE_0__.Fragment;function dn(n){n()}function pn(n){return n}function mn(){return[!1,dn]}var yn=preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect;function _n(n,t){var e=t(),r=(0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useState)({h:{__:e,v:t}}),u=r[0].h,o=r[1];return (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(function(){u.__=e,u.v=t,E(u.__,t())||o({h:u})},[n,e,t]),(0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function(){return E(u.__,u.v())||o({h:u}),n(function(){E(u.__,u.v())||o({h:u})})},[n]),e}var bn={useState:preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useState,useId:preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useId,useReducer:preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useReducer,useEffect:preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useEffect,useLayoutEffect:preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect,useInsertionEffect:yn,useTransition:mn,useDeferredValue:pn,useSyncExternalStore:_n,startTransition:dn,useRef:preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useRef,useImperativeHandle:preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle,useMemo:preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useMemo,useCallback:preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useCallback,useContext:preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useContext,useDebugValue:preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useDebugValue,version:\"17.0.2\",Children:O,render:Y,hydrate:q,unmountComponentAtNode:fn,createPortal:j,createElement:preact__WEBPACK_IMPORTED_MODULE_0__.createElement,createContext:preact__WEBPACK_IMPORTED_MODULE_0__.createContext,createFactory:on,cloneElement:cn,createRef:preact__WEBPACK_IMPORTED_MODULE_0__.createRef,Fragment:preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,isValidElement:ln,findDOMNode:an,Component:preact__WEBPACK_IMPORTED_MODULE_0__.Component,PureComponent:w,memo:R,forwardRef:k,flushSync:hn,unstable_batchedUpdates:sn,StrictMode:vn,Suspense:D,SuspenseList:V,lazy:M,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:rn};\n//# sourceMappingURL=compat.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9kaXN0L2NvbXBhdC5tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9lLGdCQUFnQix5QkFBeUIsU0FBUyxnQkFBZ0IscURBQXFELHVEQUF1RCxTQUFTLGdCQUFnQiw0Q0FBNEMsY0FBYyxhQUFhLGdCQUFnQixjQUFjLGdDQUFnQyxvRkFBb0YsY0FBYyxvQ0FBb0MscURBQUMsTUFBTSxvR0FBb0csaUJBQWlCLDZDQUFDLDBFQUEwRSx5Q0FBeUMsTUFBTSwyQ0FBQyxLQUFLLDJDQUFDLGlCQUFpQixtRUFBbUUsb0ZBQW9GLGNBQWMsY0FBYyxVQUFVLElBQUkscUNBQXFDLCtIQUErSCxvQkFBb0Isb0JBQW9CLG9EQUFDLENBQUMsb0RBQUMsWUFBWSxJQUFJLGtDQUFrQyxTQUFTLG9EQUFDLGFBQWEsa0JBQWtCLE1BQU0sb0RBQUMsSUFBSSxxQ0FBcUMsWUFBWSxTQUFTLGdEQUFDLENBQUMsR0FBRywyQ0FBQyxLQUFLLDJDQUFDLHVCQUF1Qix3QkFBd0IsT0FBTyw4RUFBOEUsWUFBWSxNQUFNLDJDQUFDLFNBQVMsa0JBQWtCLCtEQUErRCxrQ0FBa0MsK0JBQStCLHVGQUF1RixnQkFBZ0IsS0FBSyxrQkFBa0IseURBQXlELGdCQUFnQix5RkFBeUYsYUFBYSxxQ0FBcUMsY0FBYyxlQUFlLDBCQUEwQixjQUFjLFVBQVUsY0FBYywrQkFBK0IsZUFBZSxhQUFhLElBQUksWUFBWSxjQUFjLE9BQU8scURBQUMsTUFBTSx1Q0FBdUMsYUFBYSx3QkFBd0IsMkNBQUMscUJBQXFCLFlBQVksdURBQXVELGtCQUFrQiw2Q0FBQyxvQkFBb0IsbUJBQW1CLGdDQUFnQyxpQ0FBaUMsaUNBQWlDLFFBQVEsaUJBQWlCLGFBQWEsZ0JBQWdCLGtCQUFrQixzQ0FBc0MsTUFBTSxnQkFBZ0IsZUFBZSxFQUFFLFlBQVksa0JBQWtCLGNBQWMsd0JBQXdCLHVCQUF1QixjQUFjLDZDQUE2QyxVQUFVLGtDQUFrQyxhQUFhLGlCQUFpQiwwREFBMEQsMENBQTBDLGNBQWMsYUFBYSxxREFBQyxDQUFDLDRDQUFDLGtCQUFrQix3QkFBd0IscURBQUMsQ0FBQyw0Q0FBQyxpQ0FBaUMsc0JBQXNCLHlHQUF5RyxFQUFFLEVBQUUsS0FBSyxXQUFXLFdBQVcsbUJBQW1CLGFBQWEsY0FBYyx1Q0FBdUMsaUJBQWlCLFlBQVksY0FBYyxpQkFBaUIsa0NBQWtDLDhDQUFDLDZCQUE2QixnRUFBZ0UsOERBQThELDJDQUEyQyw0QkFBNEIsMkNBQTJDLHlCQUF5Qiw2RUFBNkUsRUFBRSw4Q0FBQyxDQUFDLHFEQUFDLElBQUksa0JBQWtCLDRDQUE0QyxnQkFBZ0IsTUFBTSxxREFBQyxJQUFJLFVBQVUsRUFBRSwyQkFBMkIsaUJBQWlCLDZDQUFDLGtCQUFrQixtQ0FBbUMsMEJBQTBCLGlCQUFpQiw4Q0FBOEMsWUFBWSxnQ0FBZ0MsMkJBQTJCLE1BQU0sb0RBQUMsYUFBYSxtREFBbUQsbUJBQW1CLElBQUksc0NBQXNDLGtCQUFrQix5RUFBeUUsV0FBVyw2QkFBNkIsU0FBUyxHQUFHLDBaQUEwWixvR0FBb0csa0JBQWtCLHVDQUF1Qyw4Q0FBQyw2Q0FBNkMsa0JBQWtCLE9BQU8sK0NBQUMsNkNBQTZDLDZDQUFDLDhCQUE4Qiw4RkFBOEYsc0JBQXNCLDZDQUFDLGNBQWMsK0JBQStCLHlCQUF5QixpQkFBaUIsOEJBQThCLG9DQUFvQyxHQUFHLEVBQUUsRUFBRSxNQUFNLDJDQUFDLE9BQU8sY0FBYyxhQUFhLHlCQUF5QixhQUFhLDZCQUE2QiwyQ0FBQyxtQkFBbUIsZ0dBQWdHLFVBQVUsK0JBQStCLG1CQUFtQixJQUFJLDJDQUFDLE9BQU8sMkNBQUMsbUJBQW1CLDJCQUEyQix1QkFBdUIsMEJBQTBCLGlCQUFpQixJQUFJLFdBQVcseWlCQUF5aUIsMERBQTBELG9EQUFDLGlDQUFpQyxvREFBb0QsK0NBQStDLG9EQUFDLGlDQUFpQyxvR0FBb0csb0pBQW9KLHdCQUF3QixPQUFPLDJDQUFDLEtBQUssMkNBQUMsaUJBQWlCLG1CQUFtQixRQUFRLHdCQUF3QixTQUFTLHdCQUF3QixtQ0FBbUMsYUFBYSxlQUFlLE9BQU8saURBQUMsY0FBYyxlQUFlLDBCQUEwQixlQUFlLGFBQWEsZ0RBQUMseUJBQXlCLGVBQWUsZ0JBQWdCLDhDQUFDLGFBQWEsZUFBZSw0Q0FBNEMscUJBQXFCLFlBQVksa0JBQWtCLFlBQVksSUFBSSw0Q0FBQyxDQUFDLGVBQWUsSUFBSSxlQUFlLFNBQVMsY0FBYyxjQUFjLE9BQU8seURBQUMsQ0FBQyxpQkFBaUIsWUFBWSxzREFBQyxFQUFFLEdBQUcsVUFBVSxrQkFBa0IsT0FBTyw2REFBQyxZQUFZLDZCQUE2QixJQUFJLEVBQUUsVUFBVSx1REFBQyxZQUFZLHlCQUF5QixJQUFJLGVBQWUsa0JBQWtCLElBQUksRUFBRSxFQUFFLFFBQVEsUUFBUSxTQUFTLGtEQUFDLE9BQU8sK0NBQUMsWUFBWSxvREFBQyxXQUFXLG1EQUFDLGlCQUFpQix5REFBQyw4R0FBOEcsZ0RBQUMscUJBQXFCLDZEQUFDLFNBQVMsaURBQUMsYUFBYSxxREFBQyxZQUFZLG9EQUFDLGVBQWUsdURBQUMsdUdBQXVHLGlEQUFDLGVBQWUsaURBQUMsNENBQTRDLDZDQUFDLFVBQVUsNENBQUMsNENBQTRDLDZDQUFDLG1MQUErckI7QUFDbGxTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9kaXN0L2NvbXBhdC5tb2R1bGUuanM/NzFlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7Q29tcG9uZW50IGFzIG4sY3JlYXRlRWxlbWVudCBhcyB0LG9wdGlvbnMgYXMgZSx0b0NoaWxkQXJyYXkgYXMgcixGcmFnbWVudCBhcyB1LHJlbmRlciBhcyBvLGh5ZHJhdGUgYXMgaSxjcmVhdGVDb250ZXh0IGFzIGwsY3JlYXRlUmVmIGFzIGMsY2xvbmVFbGVtZW50IGFzIGZ9ZnJvbVwicHJlYWN0XCI7ZXhwb3J0e0NvbXBvbmVudCxGcmFnbWVudCxjcmVhdGVDb250ZXh0LGNyZWF0ZUVsZW1lbnQsY3JlYXRlUmVmfWZyb21cInByZWFjdFwiO2ltcG9ydHt1c2VTdGF0ZSBhcyBhLHVzZUlkIGFzIHMsdXNlUmVkdWNlciBhcyBoLHVzZUVmZmVjdCBhcyB2LHVzZUxheW91dEVmZmVjdCBhcyBkLHVzZVJlZiBhcyBwLHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgbSx1c2VNZW1vIGFzIHksdXNlQ2FsbGJhY2sgYXMgXyx1c2VDb250ZXh0IGFzIGIsdXNlRGVidWdWYWx1ZSBhcyBTfWZyb21cInByZWFjdC9ob29rc1wiO2V4cG9ydCpmcm9tXCJwcmVhY3QvaG9va3NcIjtmdW5jdGlvbiBnKG4sdCl7Zm9yKHZhciBlIGluIHQpbltlXT10W2VdO3JldHVybiBufWZ1bmN0aW9uIEMobix0KXtmb3IodmFyIGUgaW4gbilpZihcIl9fc291cmNlXCIhPT1lJiYhKGUgaW4gdCkpcmV0dXJuITA7Zm9yKHZhciByIGluIHQpaWYoXCJfX3NvdXJjZVwiIT09ciYmbltyXSE9PXRbcl0pcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gRShuLHQpe3JldHVybiBuPT09dCYmKDAhPT1ufHwxL249PTEvdCl8fG4hPW4mJnQhPXR9ZnVuY3Rpb24gdyhuKXt0aGlzLnByb3BzPW59ZnVuY3Rpb24gUihuLGUpe2Z1bmN0aW9uIHIobil7dmFyIHQ9dGhpcy5wcm9wcy5yZWYscj10PT1uLnJlZjtyZXR1cm4hciYmdCYmKHQuY2FsbD90KG51bGwpOnQuY3VycmVudD1udWxsKSxlPyFlKHRoaXMucHJvcHMsbil8fCFyOkModGhpcy5wcm9wcyxuKX1mdW5jdGlvbiB1KGUpe3JldHVybiB0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZT1yLHQobixlKX1yZXR1cm4gdS5kaXNwbGF5TmFtZT1cIk1lbW8oXCIrKG4uZGlzcGxheU5hbWV8fG4ubmFtZSkrXCIpXCIsdS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD0hMCx1Ll9fZj0hMCx1fSh3LnByb3RvdHlwZT1uZXcgbikuaXNQdXJlUmVhY3RDb21wb25lbnQ9ITAsdy5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIEModGhpcy5wcm9wcyxuKXx8Qyh0aGlzLnN0YXRlLHQpfTt2YXIgeD1lLl9fYjtlLl9fYj1mdW5jdGlvbihuKXtuLnR5cGUmJm4udHlwZS5fX2YmJm4ucmVmJiYobi5wcm9wcy5yZWY9bi5yZWYsbi5yZWY9bnVsbCkseCYmeChuKX07dmFyIE49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvciYmU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpfHwzOTExO2Z1bmN0aW9uIGsobil7ZnVuY3Rpb24gdCh0KXt2YXIgZT1nKHt9LHQpO3JldHVybiBkZWxldGUgZS5yZWYsbihlLHQucmVmfHxudWxsKX1yZXR1cm4gdC4kJHR5cGVvZj1OLHQucmVuZGVyPXQsdC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD10Ll9fZj0hMCx0LmRpc3BsYXlOYW1lPVwiRm9yd2FyZFJlZihcIisobi5kaXNwbGF5TmFtZXx8bi5uYW1lKStcIilcIix0fXZhciBBPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG51bGw9PW4/bnVsbDpyKHIobikubWFwKHQpKX0sTz17bWFwOkEsZm9yRWFjaDpBLGNvdW50OmZ1bmN0aW9uKG4pe3JldHVybiBuP3IobikubGVuZ3RoOjB9LG9ubHk6ZnVuY3Rpb24obil7dmFyIHQ9cihuKTtpZigxIT09dC5sZW5ndGgpdGhyb3dcIkNoaWxkcmVuLm9ubHlcIjtyZXR1cm4gdFswXX0sdG9BcnJheTpyfSxUPWUuX19lO2UuX19lPWZ1bmN0aW9uKG4sdCxlLHIpe2lmKG4udGhlbilmb3IodmFyIHUsbz10O289by5fXzspaWYoKHU9by5fX2MpJiZ1Ll9fYylyZXR1cm4gbnVsbD09dC5fX2UmJih0Ll9fZT1lLl9fZSx0Ll9faz1lLl9fayksdS5fX2Mobix0KTtUKG4sdCxlLHIpfTt2YXIgST1lLnVubW91bnQ7ZnVuY3Rpb24gTChuLHQsZSl7cmV0dXJuIG4mJihuLl9fYyYmbi5fX2MuX19IJiYobi5fX2MuX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7XCJmdW5jdGlvblwiPT10eXBlb2Ygbi5fX2MmJm4uX19jKCl9KSxuLl9fYy5fX0g9bnVsbCksbnVsbCE9KG49Zyh7fSxuKSkuX19jJiYobi5fX2MuX19QPT09ZSYmKG4uX19jLl9fUD10KSxuLl9fYz1udWxsKSxuLl9faz1uLl9fayYmbi5fX2subWFwKGZ1bmN0aW9uKG4pe3JldHVybiBMKG4sdCxlKX0pKSxufWZ1bmN0aW9uIFUobix0LGUpe3JldHVybiBuJiYobi5fX3Y9bnVsbCxuLl9faz1uLl9fayYmbi5fX2subWFwKGZ1bmN0aW9uKG4pe3JldHVybiBVKG4sdCxlKX0pLG4uX19jJiZuLl9fYy5fX1A9PT10JiYobi5fX2UmJmUuaW5zZXJ0QmVmb3JlKG4uX19lLG4uX19kKSxuLl9fYy5fX2U9ITAsbi5fX2MuX19QPWUpKSxufWZ1bmN0aW9uIEQoKXt0aGlzLl9fdT0wLHRoaXMudD1udWxsLHRoaXMuX19iPW51bGx9ZnVuY3Rpb24gRihuKXt2YXIgdD1uLl9fLl9fYztyZXR1cm4gdCYmdC5fX2EmJnQuX19hKG4pfWZ1bmN0aW9uIE0obil7dmFyIGUscix1O2Z1bmN0aW9uIG8obyl7aWYoZXx8KGU9bigpKS50aGVuKGZ1bmN0aW9uKG4pe3I9bi5kZWZhdWx0fHxufSxmdW5jdGlvbihuKXt1PW59KSx1KXRocm93IHU7aWYoIXIpdGhyb3cgZTtyZXR1cm4gdChyLG8pfXJldHVybiBvLmRpc3BsYXlOYW1lPVwiTGF6eVwiLG8uX19mPSEwLG99ZnVuY3Rpb24gVigpe3RoaXMudT1udWxsLHRoaXMubz1udWxsfWUudW5tb3VudD1mdW5jdGlvbihuKXt2YXIgdD1uLl9fYzt0JiZ0Ll9fUiYmdC5fX1IoKSx0JiYhMD09PW4uX19oJiYobi50eXBlPW51bGwpLEkmJkkobil9LChELnByb3RvdHlwZT1uZXcgbikuX19jPWZ1bmN0aW9uKG4sdCl7dmFyIGU9dC5fX2Mscj10aGlzO251bGw9PXIudCYmKHIudD1bXSksci50LnB1c2goZSk7dmFyIHU9RihyLl9fdiksbz0hMSxpPWZ1bmN0aW9uKCl7b3x8KG89ITAsZS5fX1I9bnVsbCx1P3UobCk6bCgpKX07ZS5fX1I9aTt2YXIgbD1mdW5jdGlvbigpe2lmKCEtLXIuX191KXtpZihyLnN0YXRlLl9fYSl7dmFyIG49ci5zdGF0ZS5fX2E7ci5fX3YuX19rWzBdPVUobixuLl9fYy5fX1Asbi5fX2MuX19PKX12YXIgdDtmb3Ioci5zZXRTdGF0ZSh7X19hOnIuX19iPW51bGx9KTt0PXIudC5wb3AoKTspdC5mb3JjZVVwZGF0ZSgpfX0sYz0hMD09PXQuX19oO3IuX191Kyt8fGN8fHIuc2V0U3RhdGUoe19fYTpyLl9fYj1yLl9fdi5fX2tbMF19KSxuLnRoZW4oaSxpKX0sRC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXt0aGlzLnQ9W119LEQucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihuLGUpe2lmKHRoaXMuX19iKXtpZih0aGlzLl9fdi5fX2spe3ZhciByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksbz10aGlzLl9fdi5fX2tbMF0uX19jO3RoaXMuX192Ll9fa1swXT1MKHRoaXMuX19iLHIsby5fX089by5fX1ApfXRoaXMuX19iPW51bGx9dmFyIGk9ZS5fX2EmJnQodSxudWxsLG4uZmFsbGJhY2spO3JldHVybiBpJiYoaS5fX2g9bnVsbCksW3QodSxudWxsLGUuX19hP251bGw6bi5jaGlsZHJlbiksaV19O3ZhciBXPWZ1bmN0aW9uKG4sdCxlKXtpZigrK2VbMV09PT1lWzBdJiZuLm8uZGVsZXRlKHQpLG4ucHJvcHMucmV2ZWFsT3JkZXImJihcInRcIiE9PW4ucHJvcHMucmV2ZWFsT3JkZXJbMF18fCFuLm8uc2l6ZSkpZm9yKGU9bi51O2U7KXtmb3IoO2UubGVuZ3RoPjM7KWUucG9wKCkoKTtpZihlWzFdPGVbMF0pYnJlYWs7bi51PWU9ZVsyXX19O2Z1bmN0aW9uIFAobil7cmV0dXJuIHRoaXMuZ2V0Q2hpbGRDb250ZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIG4uY29udGV4dH0sbi5jaGlsZHJlbn1mdW5jdGlvbiAkKG4pe3ZhciBlPXRoaXMscj1uLmk7ZS5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe28obnVsbCxlLmwpLGUubD1udWxsLGUuaT1udWxsfSxlLmkmJmUuaSE9PXImJmUuY29tcG9uZW50V2lsbFVubW91bnQoKSxuLl9fdj8oZS5sfHwoZS5pPXIsZS5sPXtub2RlVHlwZToxLHBhcmVudE5vZGU6cixjaGlsZE5vZGVzOltdLGFwcGVuZENoaWxkOmZ1bmN0aW9uKG4pe3RoaXMuY2hpbGROb2Rlcy5wdXNoKG4pLGUuaS5hcHBlbmRDaGlsZChuKX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKG4sdCl7dGhpcy5jaGlsZE5vZGVzLnB1c2gobiksZS5pLmFwcGVuZENoaWxkKG4pfSxyZW1vdmVDaGlsZDpmdW5jdGlvbihuKXt0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKG4pPj4+MSwxKSxlLmkucmVtb3ZlQ2hpbGQobil9fSksbyh0KFAse2NvbnRleHQ6ZS5jb250ZXh0fSxuLl9fdiksZS5sKSk6ZS5sJiZlLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9ZnVuY3Rpb24gaihuLGUpe3ZhciByPXQoJCx7X192Om4saTplfSk7cmV0dXJuIHIuY29udGFpbmVySW5mbz1lLHJ9KFYucHJvdG90eXBlPW5ldyBuKS5fX2E9ZnVuY3Rpb24obil7dmFyIHQ9dGhpcyxlPUYodC5fX3YpLHI9dC5vLmdldChuKTtyZXR1cm4gclswXSsrLGZ1bmN0aW9uKHUpe3ZhciBvPWZ1bmN0aW9uKCl7dC5wcm9wcy5yZXZlYWxPcmRlcj8oci5wdXNoKHUpLFcodCxuLHIpKTp1KCl9O2U/ZShvKTpvKCl9fSxWLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24obil7dGhpcy51PW51bGwsdGhpcy5vPW5ldyBNYXA7dmFyIHQ9cihuLmNoaWxkcmVuKTtuLnJldmVhbE9yZGVyJiZcImJcIj09PW4ucmV2ZWFsT3JkZXJbMF0mJnQucmV2ZXJzZSgpO2Zvcih2YXIgZT10Lmxlbmd0aDtlLS07KXRoaXMuby5zZXQodFtlXSx0aGlzLnU9WzEsMCx0aGlzLnVdKTtyZXR1cm4gbi5jaGlsZHJlbn0sVi5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlPVYucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50PWZ1bmN0aW9uKCl7dmFyIG49dGhpczt0aGlzLm8uZm9yRWFjaChmdW5jdGlvbih0LGUpe1cobixlLHQpfSl9O3ZhciB6PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3ImJlN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpfHw2MDEwMyxCPS9eKD86YWNjZW50fGFsaWdubWVudHxhcmFiaWN8YmFzZWxpbmV8Y2FwfGNsaXAoPyFQYXRoVSl8Y29sb3J8ZG9taW5hbnR8ZmlsbHxmbG9vZHxmb250fGdseXBoKD8hUil8aG9yaXp8aW1hZ2V8bGV0dGVyfGxpZ2h0aW5nfG1hcmtlcig/IUh8V3xVKXxvdmVybGluZXxwYWludHxwb2ludGVyfHNoYXBlfHN0b3B8c3RyaWtldGhyb3VnaHxzdHJva2V8dGV4dCg/IUwpfHRyYW5zZm9ybXx1bmRlcmxpbmV8dW5pY29kZXx1bml0c3x2fHZlY3Rvcnx2ZXJ0fHdvcmR8d3JpdGluZ3x4KD8hQykpW0EtWl0vLEg9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50LFo9ZnVuY3Rpb24obil7cmV0dXJuKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2woKT8vZmlsfGNoZXxyYWQvaTovZmlsfGNoZXxyYS9pKS50ZXN0KG4pfTtmdW5jdGlvbiBZKG4sdCxlKXtyZXR1cm4gbnVsbD09dC5fX2smJih0LnRleHRDb250ZW50PVwiXCIpLG8obix0KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlKCksbj9uLl9fYzpudWxsfWZ1bmN0aW9uIHEobix0LGUpe3JldHVybiBpKG4sdCksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZSgpLG4/bi5fX2M6bnVsbH1uLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9LFtcImNvbXBvbmVudFdpbGxNb3VudFwiLFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiLFwiY29tcG9uZW50V2lsbFVwZGF0ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLnByb3RvdHlwZSx0LHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbXCJVTlNBRkVfXCIrdF19LHNldDpmdW5jdGlvbihuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyx0LHtjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bn0pfX0pfSk7dmFyIEc9ZS5ldmVudDtmdW5jdGlvbiBKKCl7fWZ1bmN0aW9uIEsoKXtyZXR1cm4gdGhpcy5jYW5jZWxCdWJibGV9ZnVuY3Rpb24gUSgpe3JldHVybiB0aGlzLmRlZmF1bHRQcmV2ZW50ZWR9ZS5ldmVudD1mdW5jdGlvbihuKXtyZXR1cm4gRyYmKG49RyhuKSksbi5wZXJzaXN0PUosbi5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1LLG4uaXNEZWZhdWx0UHJldmVudGVkPVEsbi5uYXRpdmVFdmVudD1ufTt2YXIgWCxubj17Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsYXNzfX0sdG49ZS52bm9kZTtlLnZub2RlPWZ1bmN0aW9uKG4pe3ZhciB0PW4udHlwZSxlPW4ucHJvcHMsdT1lO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXt2YXIgbz0tMT09PXQuaW5kZXhPZihcIi1cIik7Zm9yKHZhciBpIGluIHU9e30sZSl7dmFyIGw9ZVtpXTtIJiZcImNoaWxkcmVuXCI9PT1pJiZcIm5vc2NyaXB0XCI9PT10fHxcInZhbHVlXCI9PT1pJiZcImRlZmF1bHRWYWx1ZVwiaW4gZSYmbnVsbD09bHx8KFwiZGVmYXVsdFZhbHVlXCI9PT1pJiZcInZhbHVlXCJpbiBlJiZudWxsPT1lLnZhbHVlP2k9XCJ2YWx1ZVwiOlwiZG93bmxvYWRcIj09PWkmJiEwPT09bD9sPVwiXCI6L29uZG91YmxlY2xpY2svaS50ZXN0KGkpP2k9XCJvbmRibGNsaWNrXCI6L15vbmNoYW5nZSh0ZXh0YXJlYXxpbnB1dCkvaS50ZXN0KGkrdCkmJiFaKGUudHlwZSk/aT1cIm9uaW5wdXRcIjovXm9uZm9jdXMkL2kudGVzdChpKT9pPVwib25mb2N1c2luXCI6L15vbmJsdXIkL2kudGVzdChpKT9pPVwib25mb2N1c291dFwiOi9eb24oQW5pfFRyYXxUb3V8QmVmb3JlSW5wfENvbXBvKS8udGVzdChpKT9pPWkudG9Mb3dlckNhc2UoKTpvJiZCLnRlc3QoaSk/aT1pLnJlcGxhY2UoL1tBLVowLTldL2csXCItJCZcIikudG9Mb3dlckNhc2UoKTpudWxsPT09bCYmKGw9dm9pZCAwKSwvXm9uaW5wdXQkL2kudGVzdChpKSYmKGk9aS50b0xvd2VyQ2FzZSgpLHVbaV0mJihpPVwib25pbnB1dENhcHR1cmVcIikpLHVbaV09bCl9XCJzZWxlY3RcIj09dCYmdS5tdWx0aXBsZSYmQXJyYXkuaXNBcnJheSh1LnZhbHVlKSYmKHUudmFsdWU9cihlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe24ucHJvcHMuc2VsZWN0ZWQ9LTEhPXUudmFsdWUuaW5kZXhPZihuLnByb3BzLnZhbHVlKX0pKSxcInNlbGVjdFwiPT10JiZudWxsIT11LmRlZmF1bHRWYWx1ZSYmKHUudmFsdWU9cihlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe24ucHJvcHMuc2VsZWN0ZWQ9dS5tdWx0aXBsZT8tMSE9dS5kZWZhdWx0VmFsdWUuaW5kZXhPZihuLnByb3BzLnZhbHVlKTp1LmRlZmF1bHRWYWx1ZT09bi5wcm9wcy52YWx1ZX0pKSxuLnByb3BzPXUsZS5jbGFzcyE9ZS5jbGFzc05hbWUmJihubi5lbnVtZXJhYmxlPVwiY2xhc3NOYW1lXCJpbiBlLG51bGwhPWUuY2xhc3NOYW1lJiYodS5jbGFzcz1lLmNsYXNzTmFtZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHUsXCJjbGFzc05hbWVcIixubikpfW4uJCR0eXBlb2Y9eix0biYmdG4obil9O3ZhciBlbj1lLl9fcjtlLl9fcj1mdW5jdGlvbihuKXtlbiYmZW4obiksWD1uLl9fY307dmFyIHJuPXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyOntjdXJyZW50OntyZWFkQ29udGV4dDpmdW5jdGlvbihuKXtyZXR1cm4gWC5fX25bbi5fX2NdLnByb3BzLnZhbHVlfX19fSx1bj1cIjE3LjAuMlwiO2Z1bmN0aW9uIG9uKG4pe3JldHVybiB0LmJpbmQobnVsbCxuKX1mdW5jdGlvbiBsbihuKXtyZXR1cm4hIW4mJm4uJCR0eXBlb2Y9PT16fWZ1bmN0aW9uIGNuKG4pe3JldHVybiBsbihuKT9mLmFwcGx5KG51bGwsYXJndW1lbnRzKTpufWZ1bmN0aW9uIGZuKG4pe3JldHVybiEhbi5fX2smJihvKG51bGwsbiksITApfWZ1bmN0aW9uIGFuKG4pe3JldHVybiBuJiYobi5iYXNlfHwxPT09bi5ub2RlVHlwZSYmbil8fG51bGx9dmFyIHNuPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4odCl9LGhuPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4odCl9LHZuPXU7ZnVuY3Rpb24gZG4obil7bigpfWZ1bmN0aW9uIHBuKG4pe3JldHVybiBufWZ1bmN0aW9uIG1uKCl7cmV0dXJuWyExLGRuXX12YXIgeW49ZDtmdW5jdGlvbiBfbihuLHQpe3ZhciBlPXQoKSxyPWEoe2g6e19fOmUsdjp0fX0pLHU9clswXS5oLG89clsxXTtyZXR1cm4gZChmdW5jdGlvbigpe3UuX189ZSx1LnY9dCxFKHUuX18sdCgpKXx8byh7aDp1fSl9LFtuLGUsdF0pLHYoZnVuY3Rpb24oKXtyZXR1cm4gRSh1Ll9fLHUudigpKXx8byh7aDp1fSksbihmdW5jdGlvbigpe0UodS5fXyx1LnYoKSl8fG8oe2g6dX0pfSl9LFtuXSksZX12YXIgYm49e3VzZVN0YXRlOmEsdXNlSWQ6cyx1c2VSZWR1Y2VyOmgsdXNlRWZmZWN0OnYsdXNlTGF5b3V0RWZmZWN0OmQsdXNlSW5zZXJ0aW9uRWZmZWN0OnluLHVzZVRyYW5zaXRpb246bW4sdXNlRGVmZXJyZWRWYWx1ZTpwbix1c2VTeW5jRXh0ZXJuYWxTdG9yZTpfbixzdGFydFRyYW5zaXRpb246ZG4sdXNlUmVmOnAsdXNlSW1wZXJhdGl2ZUhhbmRsZTptLHVzZU1lbW86eSx1c2VDYWxsYmFjazpfLHVzZUNvbnRleHQ6Yix1c2VEZWJ1Z1ZhbHVlOlMsdmVyc2lvbjpcIjE3LjAuMlwiLENoaWxkcmVuOk8scmVuZGVyOlksaHlkcmF0ZTpxLHVubW91bnRDb21wb25lbnRBdE5vZGU6Zm4sY3JlYXRlUG9ydGFsOmosY3JlYXRlRWxlbWVudDp0LGNyZWF0ZUNvbnRleHQ6bCxjcmVhdGVGYWN0b3J5Om9uLGNsb25lRWxlbWVudDpjbixjcmVhdGVSZWY6YyxGcmFnbWVudDp1LGlzVmFsaWRFbGVtZW50OmxuLGZpbmRET01Ob2RlOmFuLENvbXBvbmVudDpuLFB1cmVDb21wb25lbnQ6dyxtZW1vOlIsZm9yd2FyZFJlZjprLGZsdXNoU3luYzpobix1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczpzbixTdHJpY3RNb2RlOnZuLFN1c3BlbnNlOkQsU3VzcGVuc2VMaXN0OlYsbGF6eTpNLF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOnJufTtleHBvcnR7TyBhcyBDaGlsZHJlbix3IGFzIFB1cmVDb21wb25lbnQsdm4gYXMgU3RyaWN0TW9kZSxEIGFzIFN1c3BlbnNlLFYgYXMgU3VzcGVuc2VMaXN0LHJuIGFzIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELGNuIGFzIGNsb25lRWxlbWVudCxvbiBhcyBjcmVhdGVGYWN0b3J5LGogYXMgY3JlYXRlUG9ydGFsLGJuIGFzIGRlZmF1bHQsYW4gYXMgZmluZERPTU5vZGUsaG4gYXMgZmx1c2hTeW5jLGsgYXMgZm9yd2FyZFJlZixxIGFzIGh5ZHJhdGUsbG4gYXMgaXNWYWxpZEVsZW1lbnQsTSBhcyBsYXp5LFIgYXMgbWVtbyxZIGFzIHJlbmRlcixkbiBhcyBzdGFydFRyYW5zaXRpb24sZm4gYXMgdW5tb3VudENvbXBvbmVudEF0Tm9kZSxzbiBhcyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxwbiBhcyB1c2VEZWZlcnJlZFZhbHVlLHluIGFzIHVzZUluc2VydGlvbkVmZmVjdCxfbiBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSxtbiBhcyB1c2VUcmFuc2l0aW9uLHVuIGFzIHZlcnNpb259O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGF0Lm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/preact/compat/dist/compat.module.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/preact/dist/preact.module.js":
/*!****************************************************!*\
  !*** ../node_modules/preact/dist/preact.module.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: function() { return /* binding */ x; },\n/* harmony export */   Fragment: function() { return /* binding */ _; },\n/* harmony export */   cloneElement: function() { return /* binding */ F; },\n/* harmony export */   createContext: function() { return /* binding */ G; },\n/* harmony export */   createElement: function() { return /* binding */ y; },\n/* harmony export */   createRef: function() { return /* binding */ d; },\n/* harmony export */   h: function() { return /* binding */ y; },\n/* harmony export */   hydrate: function() { return /* binding */ E; },\n/* harmony export */   isValidElement: function() { return /* binding */ i; },\n/* harmony export */   options: function() { return /* binding */ l; },\n/* harmony export */   render: function() { return /* binding */ D; },\n/* harmony export */   toChildArray: function() { return /* binding */ j; }\n/* harmony export */ });\nvar n,l,u,i,t,r,o,f,e,c={},s=[],a=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function h(n,l){for(var u in l)n[u]=l[u];return n}function v(n){var l=n.parentNode;l&&l.removeChild(n)}function y(l,u,i){var t,r,o,f={};for(o in u)\"key\"==o?t=u[o]:\"ref\"==o?r=u[o]:f[o]=u[o];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),\"function\"==typeof l&&null!=l.defaultProps)for(o in l.defaultProps)void 0===f[o]&&(f[o]=l.defaultProps[o]);return p(l,f,t,r,null)}function p(n,i,t,r,o){var f={type:n,props:i,key:t,ref:r,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==o?++u:o};return null==o&&null!=l.vnode&&l.vnode(f),f}function d(){return{current:null}}function _(n){return n.children}function k(n,l,u,i,t){var r;for(r in u)\"children\"===r||\"key\"===r||r in l||g(n,r,null,u[r],i);for(r in l)t&&\"function\"!=typeof l[r]||\"children\"===r||\"key\"===r||\"value\"===r||\"checked\"===r||u[r]===l[r]||g(n,r,l[r],u[r],i)}function b(n,l,u){\"-\"===l[0]?n.setProperty(l,null==u?\"\":u):n[l]=null==u?\"\":\"number\"!=typeof u||a.test(l)?u:u+\"px\"}function g(n,l,u,i,t){var r;n:if(\"style\"===l)if(\"string\"==typeof u)n.style.cssText=u;else{if(\"string\"==typeof i&&(n.style.cssText=i=\"\"),i)for(l in i)u&&l in u||b(n.style,l,\"\");if(u)for(l in u)i&&u[l]===i[l]||b(n.style,l,u[l])}else if(\"o\"===l[0]&&\"n\"===l[1])r=l!==(l=l.replace(/Capture$/,\"\")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+r]=u,u?i||n.addEventListener(l,r?w:m,r):n.removeEventListener(l,r?w:m,r);else if(\"dangerouslySetInnerHTML\"!==l){if(t)l=l.replace(/xlink(H|:h)/,\"h\").replace(/sName$/,\"s\");else if(\"width\"!==l&&\"height\"!==l&&\"href\"!==l&&\"list\"!==l&&\"form\"!==l&&\"tabIndex\"!==l&&\"download\"!==l&&l in n)try{n[l]=null==u?\"\":u;break n}catch(n){}\"function\"==typeof u||(null==u||!1===u&&-1==l.indexOf(\"-\")?n.removeAttribute(l):n.setAttribute(l,u))}}function m(n){t=!0;try{return this.l[n.type+!1](l.event?l.event(n):n)}finally{t=!1}}function w(n){t=!0;try{return this.l[n.type+!0](l.event?l.event(n):n)}finally{t=!1}}function x(n,l){this.props=n,this.context=l}function A(n,l){if(null==l)return n.__?A(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return\"function\"==typeof n.type?A(n):null}function P(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return P(n)}}function C(n){t?setTimeout(n):f(n)}function T(n){(!n.__d&&(n.__d=!0)&&r.push(n)&&!$.__r++||o!==l.debounceRendering)&&((o=l.debounceRendering)||C)($)}function $(){var n,l,u,i,t,o,f,e;for(r.sort(function(n,l){return n.__v.__b-l.__v.__b});n=r.shift();)n.__d&&(l=r.length,i=void 0,t=void 0,f=(o=(u=n).__v).__e,(e=u.__P)&&(i=[],(t=h({},o)).__v=o.__v+1,M(e,o,t,u.__n,void 0!==e.ownerSVGElement,null!=o.__h?[f]:null,i,null==f?A(o):f,o.__h),N(i,o),o.__e!=f&&P(o)),r.length>l&&r.sort(function(n,l){return n.__v.__b-l.__v.__b}));$.__r=0}function H(n,l,u,i,t,r,o,f,e,a){var h,v,y,d,k,b,g,m=i&&i.__k||s,w=m.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(d=u.__k[h]=null==(d=l[h])||\"boolean\"==typeof d?null:\"string\"==typeof d||\"number\"==typeof d||\"bigint\"==typeof d?p(null,d,null,null,d):Array.isArray(d)?p(_,{children:d},null,null,null):d.__b>0?p(d.type,d.props,d.key,d.ref?d.ref:null,d.__v):d)){if(d.__=u,d.__b=u.__b+1,null===(y=m[h])||y&&d.key==y.key&&d.type===y.type)m[h]=void 0;else for(v=0;v<w;v++){if((y=m[v])&&d.key==y.key&&d.type===y.type){m[v]=void 0;break}y=null}M(n,d,y=y||c,t,r,o,f,e,a),k=d.__e,(v=d.ref)&&y.ref!=v&&(g||(g=[]),y.ref&&g.push(y.ref,null,d),g.push(v,d.__c||k,d)),null!=k?(null==b&&(b=k),\"function\"==typeof d.type&&d.__k===y.__k?d.__d=e=I(d,e,n):e=z(n,d,y,m,k,e),\"function\"==typeof u.type&&(u.__d=e)):e&&y.__e==e&&e.parentNode!=n&&(e=A(y))}for(u.__e=b,h=w;h--;)null!=m[h]&&(\"function\"==typeof u.type&&null!=m[h].__e&&m[h].__e==u.__d&&(u.__d=L(i).nextSibling),q(m[h],m[h]));if(g)for(h=0;h<g.length;h++)S(g[h],g[++h],g[++h])}function I(n,l,u){for(var i,t=n.__k,r=0;t&&r<t.length;r++)(i=t[r])&&(i.__=n,l=\"function\"==typeof i.type?I(i,l,u):z(u,i,i,t,i.__e,l));return l}function j(n,l){return l=l||[],null==n||\"boolean\"==typeof n||(Array.isArray(n)?n.some(function(n){j(n,l)}):l.push(n)),l}function z(n,l,u,i,t,r){var o,f,e;if(void 0!==l.__d)o=l.__d,l.__d=void 0;else if(null==u||t!=r||null==t.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(t),o=null;else{for(f=r,e=0;(f=f.nextSibling)&&e<i.length;e+=1)if(f==t)break n;n.insertBefore(t,r),o=r}return void 0!==o?o:t.nextSibling}function L(n){var l,u,i;if(null==n.type||\"string\"==typeof n.type)return n.__e;if(n.__k)for(l=n.__k.length-1;l>=0;l--)if((u=n.__k[l])&&(i=L(u)))return i;return null}function M(n,u,i,t,r,o,f,e,c){var s,a,v,y,p,d,k,b,g,m,w,A,P,C,T,$=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,o=[e]),(s=l.__b)&&s(u);try{n:if(\"function\"==typeof $){if(b=u.props,g=(s=$.contextType)&&t[s.__c],m=s?g?g.props.value:s.__:t,i.__c?k=(a=u.__c=i.__c).__=a.__E:(\"prototype\"in $&&$.prototype.render?u.__c=a=new $(b,m):(u.__c=a=new x(b,m),a.constructor=$,a.render=B),g&&g.sub(a),a.props=b,a.state||(a.state={}),a.context=m,a.__n=t,v=a.__d=!0,a.__h=[],a._sb=[]),null==a.__s&&(a.__s=a.state),null!=$.getDerivedStateFromProps&&(a.__s==a.state&&(a.__s=h({},a.__s)),h(a.__s,$.getDerivedStateFromProps(b,a.__s))),y=a.props,p=a.state,a.__v=u,v)null==$.getDerivedStateFromProps&&null!=a.componentWillMount&&a.componentWillMount(),null!=a.componentDidMount&&a.__h.push(a.componentDidMount);else{if(null==$.getDerivedStateFromProps&&b!==y&&null!=a.componentWillReceiveProps&&a.componentWillReceiveProps(b,m),!a.__e&&null!=a.shouldComponentUpdate&&!1===a.shouldComponentUpdate(b,a.__s,m)||u.__v===i.__v){for(u.__v!==i.__v&&(a.props=b,a.state=a.__s,a.__d=!1),u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u)}),w=0;w<a._sb.length;w++)a.__h.push(a._sb[w]);a._sb=[],a.__h.length&&f.push(a);break n}null!=a.componentWillUpdate&&a.componentWillUpdate(b,a.__s,m),null!=a.componentDidUpdate&&a.__h.push(function(){a.componentDidUpdate(y,p,d)})}if(a.context=m,a.props=b,a.__P=n,A=l.__r,P=0,\"prototype\"in $&&$.prototype.render){for(a.state=a.__s,a.__d=!1,A&&A(u),s=a.render(a.props,a.state,a.context),C=0;C<a._sb.length;C++)a.__h.push(a._sb[C]);a._sb=[]}else do{a.__d=!1,A&&A(u),s=a.render(a.props,a.state,a.context),a.state=a.__s}while(a.__d&&++P<25);a.state=a.__s,null!=a.getChildContext&&(t=h(h({},t),a.getChildContext())),v||null==a.getSnapshotBeforeUpdate||(d=a.getSnapshotBeforeUpdate(y,p)),T=null!=s&&s.type===_&&null==s.key?s.props.children:s,H(n,Array.isArray(T)?T:[T],u,i,t,r,o,f,e,c),a.base=u.__e,u.__h=null,a.__h.length&&f.push(a),k&&(a.__E=a.__=null),a.__e=!1}else null==o&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=O(i.__e,u,i,t,r,o,f,c);(s=l.diffed)&&s(u)}catch(n){u.__v=null,(c||null!=o)&&(u.__e=e,u.__h=!!c,o[o.indexOf(e)]=null),l.__e(n,u,i)}}function N(n,u){l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function O(l,u,i,t,r,o,f,e){var s,a,h,y=i.props,p=u.props,d=u.type,_=0;if(\"svg\"===d&&(r=!0),null!=o)for(;_<o.length;_++)if((s=o[_])&&\"setAttribute\"in s==!!d&&(d?s.localName===d:3===s.nodeType)){l=s,o[_]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=r?document.createElementNS(\"http://www.w3.org/2000/svg\",d):document.createElement(d,p.is&&p),o=null,e=!1}if(null===d)y===p||e&&l.data===p||(l.data=p);else{if(o=o&&n.call(l.childNodes),a=(y=i.props||c).dangerouslySetInnerHTML,h=p.dangerouslySetInnerHTML,!e){if(null!=o)for(y={},_=0;_<l.attributes.length;_++)y[l.attributes[_].name]=l.attributes[_].value;(h||a)&&(h&&(a&&h.__html==a.__html||h.__html===l.innerHTML)||(l.innerHTML=h&&h.__html||\"\"))}if(k(l,p,y,r,e),h)u.__k=[];else if(_=u.props.children,H(l,Array.isArray(_)?_:[_],u,i,t,r&&\"foreignObject\"!==d,o,f,o?o[0]:i.__k&&A(i,0),e),null!=o)for(_=o.length;_--;)null!=o[_]&&v(o[_]);e||(\"value\"in p&&void 0!==(_=p.value)&&(_!==l.value||\"progress\"===d&&!_||\"option\"===d&&_!==y.value)&&g(l,\"value\",_,y.value,!1),\"checked\"in p&&void 0!==(_=p.checked)&&_!==l.checked&&g(l,\"checked\",_,y.checked,!1))}return l}function S(n,u,i){try{\"function\"==typeof n?n(u):n.current=u}catch(n){l.__e(n,i)}}function q(n,u,i){var t,r;if(l.unmount&&l.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||S(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(n){l.__e(n,u)}t.base=t.__P=null,n.__c=void 0}if(t=n.__k)for(r=0;r<t.length;r++)t[r]&&q(t[r],u,i||\"function\"!=typeof n.type);i||null==n.__e||v(n.__e),n.__=n.__e=n.__d=void 0}function B(n,l,u){return this.constructor(n,u)}function D(u,i,t){var r,o,f;l.__&&l.__(u,i),o=(r=\"function\"==typeof t)?null:t&&t.__k||i.__k,f=[],M(i,u=(!r&&t||i).__k=y(_,null,[u]),o||c,c,void 0!==i.ownerSVGElement,!r&&t?[t]:o?null:i.firstChild?n.call(i.childNodes):null,f,!r&&t?t:o?o.__e:i.firstChild,r),N(f,u)}function E(n,l){D(n,l,E)}function F(l,u,i){var t,r,o,f=h({},l.props);for(o in u)\"key\"==o?t=u[o]:\"ref\"==o?r=u[o]:f[o]=u[o];return arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),p(l.type,f,t||l.key,r||l.ref,null)}function G(n,l){var u={__c:l=\"__cC\"+e++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(function(n){n.__e=!0,T(n)})},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=s.slice,l={__e:function(n,l,u,i){for(var t,r,o;l=l.__;)if((t=l.__c)&&!t.__)try{if((r=t.constructor)&&null!=r.getDerivedStateFromError&&(t.setState(r.getDerivedStateFromError(n)),o=t.__d),null!=t.componentDidCatch&&(t.componentDidCatch(n,i||{}),o=t.__d),o)return t.__E=t}catch(l){n=l}throw n}},u=0,i=function(n){return null!=n&&void 0===n.constructor},t=!1,x.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=h({},this.state),\"function\"==typeof n&&(n=n(h({},u),this.props)),n&&h(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),T(this))},x.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),T(this))},x.prototype.render=_,r=[],f=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,$.__r=0,e=0;\n//# sourceMappingURL=preact.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcHJlYWN0L2Rpc3QvcHJlYWN0Lm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSwwQkFBMEIsNEVBQTRFLGdCQUFnQix5QkFBeUIsU0FBUyxjQUFjLG1CQUFtQixvQkFBb0Isa0JBQWtCLGVBQWUscURBQXFELHdMQUF3TCx1QkFBdUIsc0JBQXNCLE9BQU8sOEhBQThILDRDQUE0QyxhQUFhLE9BQU8sY0FBYyxjQUFjLGtCQUFrQixzQkFBc0IsTUFBTSxpRUFBaUUsOEhBQThILGtCQUFrQixnR0FBZ0csc0JBQXNCLE1BQU0seURBQXlELEtBQUssc0ZBQXNGLGtEQUFrRCx3SUFBd0ksaUZBQWlGLHVDQUF1QywwREFBMEQsa0hBQWtILGtCQUFrQixRQUFRLFVBQVUsc0dBQXNHLGNBQWMsS0FBSyxJQUFJLCtDQUErQyxRQUFRLE1BQU0sY0FBYyxLQUFLLElBQUksK0NBQStDLFFBQVEsTUFBTSxnQkFBZ0IsNEJBQTRCLGdCQUFnQiwwREFBMEQsVUFBVSxlQUFlLG9EQUFvRCwwQ0FBMEMsY0FBYyxRQUFRLGdDQUFnQyw4QkFBOEIsZUFBZSx3Q0FBd0MsdUJBQXVCLE1BQU0sYUFBYSxjQUFjLHFCQUFxQixjQUFjLG9HQUFvRyxhQUFhLG9CQUFvQix5QkFBeUIsMkJBQTJCLEVBQUUsWUFBWSxrRkFBa0YsK0pBQStKLDJCQUEyQixHQUFHLFFBQVEsZ0NBQWdDLDJDQUEyQyxpQkFBaUIsV0FBVyx5S0FBeUssV0FBVyw0RUFBNEUsc0ZBQXNGLGFBQWEsSUFBSSxLQUFLLDRDQUE0QyxZQUFZLE1BQU0sT0FBTyxvU0FBb1MsZ0JBQWdCLElBQUksaUhBQWlILGFBQWEsV0FBVywwQkFBMEIsa0JBQWtCLHNCQUFzQixjQUFjLCtFQUErRSxTQUFTLGdCQUFnQixrRkFBa0YsT0FBTyxlQUFlLHdCQUF3QixVQUFVLHVDQUF1QyxpR0FBaUcsS0FBSyxZQUFZLDhCQUE4QixxQkFBcUIsd0JBQXdCLGtDQUFrQyxjQUFjLFVBQVUsc0RBQXNELDhCQUE4QixLQUFLLHVDQUF1QyxZQUFZLDhCQUE4QiwyQ0FBMkMsc0NBQXNDLHNFQUFzRSxJQUFJLDJCQUEyQix5UEFBeVAsK0lBQStJLHFPQUFxTyxLQUFLLCtNQUErTSx3R0FBd0csWUFBWSxNQUFNLGVBQWUseUJBQXlCLGlDQUFpQyxRQUFRLGdIQUFnSCw0QkFBNEIsRUFBRSxrRkFBa0YsNkVBQTZFLGVBQWUseUJBQXlCLFNBQVMsUUFBUSxxRUFBcUUscUJBQXFCLGdEQUFnRCxpUkFBaVIsbUZBQW1GLG1CQUFtQixTQUFTLGdGQUFnRixnQkFBZ0IscUNBQXFDLElBQUksb0NBQW9DLFVBQVUsRUFBRSxTQUFTLGdCQUFnQixFQUFFLDRCQUE0QiwyQ0FBMkMsa0NBQWtDLFdBQVcsOEVBQThFLGNBQWMsTUFBTSxZQUFZLDhDQUE4QywyR0FBMkcsNkNBQTZDLEtBQUssc0dBQXNHLG1CQUFtQixLQUFLLHNCQUFzQixrREFBa0QsNEZBQTRGLDJCQUEyQixzSUFBc0ksSUFBSSxxQkFBcUIsb05BQW9OLFNBQVMsa0JBQWtCLElBQUksc0NBQXNDLFNBQVMsWUFBWSxrQkFBa0IsUUFBUSxtR0FBbUcsOEJBQThCLHlCQUF5QixTQUFTLFdBQVcsK0JBQStCLG1CQUFtQixXQUFXLGlEQUFpRCxpREFBaUQsa0JBQWtCLDZCQUE2QixrQkFBa0IsVUFBVSwyT0FBMk8sZ0JBQWdCLFNBQVMsa0JBQWtCLGdCQUFnQixVQUFVLHFEQUFxRCxvSEFBb0gsZ0JBQWdCLE9BQU8sNkNBQTZDLHFCQUFxQixzQkFBc0IsUUFBUSx3Q0FBd0MsMENBQTBDLFNBQVMsd0NBQXdDLCtDQUErQyxjQUFjLEVBQUUsc0JBQXNCLFVBQVUsNkJBQTZCLGtDQUFrQyx1Q0FBdUMsZUFBZSw4Q0FBOEMsYUFBYSxzQkFBc0IsY0FBYyxPQUFPLHlCQUF5QixtS0FBbUssNEJBQTRCLFNBQVMsSUFBSSxTQUFTLG1CQUFtQix1Q0FBdUMseUNBQXlDLE1BQU0sOERBQThELDRDQUE0Qyw0RUFBNEUscUNBQXFDLG9EQUFvRCw4SEFBNlQ7QUFDMzdVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvcHJlYWN0L2Rpc3QvcHJlYWN0Lm1vZHVsZS5qcz83YmY4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBuLGwsdSxpLHQscixvLGYsZSxjPXt9LHM9W10sYT0vYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pO2Z1bmN0aW9uIGgobixsKXtmb3IodmFyIHUgaW4gbCluW3VdPWxbdV07cmV0dXJuIG59ZnVuY3Rpb24gdihuKXt2YXIgbD1uLnBhcmVudE5vZGU7bCYmbC5yZW1vdmVDaGlsZChuKX1mdW5jdGlvbiB5KGwsdSxpKXt2YXIgdCxyLG8sZj17fTtmb3IobyBpbiB1KVwia2V5XCI9PW8/dD11W29dOlwicmVmXCI9PW8/cj11W29dOmZbb109dVtvXTtpZihhcmd1bWVudHMubGVuZ3RoPjImJihmLmNoaWxkcmVuPWFyZ3VtZW50cy5sZW5ndGg+Mz9uLmNhbGwoYXJndW1lbnRzLDIpOmkpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGwmJm51bGwhPWwuZGVmYXVsdFByb3BzKWZvcihvIGluIGwuZGVmYXVsdFByb3BzKXZvaWQgMD09PWZbb10mJihmW29dPWwuZGVmYXVsdFByb3BzW29dKTtyZXR1cm4gcChsLGYsdCxyLG51bGwpfWZ1bmN0aW9uIHAobixpLHQscixvKXt2YXIgZj17dHlwZTpuLHByb3BzOmksa2V5OnQscmVmOnIsX19rOm51bGwsX186bnVsbCxfX2I6MCxfX2U6bnVsbCxfX2Q6dm9pZCAwLF9fYzpudWxsLF9faDpudWxsLGNvbnN0cnVjdG9yOnZvaWQgMCxfX3Y6bnVsbD09bz8rK3U6b307cmV0dXJuIG51bGw9PW8mJm51bGwhPWwudm5vZGUmJmwudm5vZGUoZiksZn1mdW5jdGlvbiBkKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19ZnVuY3Rpb24gXyhuKXtyZXR1cm4gbi5jaGlsZHJlbn1mdW5jdGlvbiBrKG4sbCx1LGksdCl7dmFyIHI7Zm9yKHIgaW4gdSlcImNoaWxkcmVuXCI9PT1yfHxcImtleVwiPT09cnx8ciBpbiBsfHxnKG4scixudWxsLHVbcl0saSk7Zm9yKHIgaW4gbCl0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBsW3JdfHxcImNoaWxkcmVuXCI9PT1yfHxcImtleVwiPT09cnx8XCJ2YWx1ZVwiPT09cnx8XCJjaGVja2VkXCI9PT1yfHx1W3JdPT09bFtyXXx8ZyhuLHIsbFtyXSx1W3JdLGkpfWZ1bmN0aW9uIGIobixsLHUpe1wiLVwiPT09bFswXT9uLnNldFByb3BlcnR5KGwsbnVsbD09dT9cIlwiOnUpOm5bbF09bnVsbD09dT9cIlwiOlwibnVtYmVyXCIhPXR5cGVvZiB1fHxhLnRlc3QobCk/dTp1K1wicHhcIn1mdW5jdGlvbiBnKG4sbCx1LGksdCl7dmFyIHI7bjppZihcInN0eWxlXCI9PT1sKWlmKFwic3RyaW5nXCI9PXR5cGVvZiB1KW4uc3R5bGUuY3NzVGV4dD11O2Vsc2V7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGkmJihuLnN0eWxlLmNzc1RleHQ9aT1cIlwiKSxpKWZvcihsIGluIGkpdSYmbCBpbiB1fHxiKG4uc3R5bGUsbCxcIlwiKTtpZih1KWZvcihsIGluIHUpaSYmdVtsXT09PWlbbF18fGIobi5zdHlsZSxsLHVbbF0pfWVsc2UgaWYoXCJvXCI9PT1sWzBdJiZcIm5cIj09PWxbMV0pcj1sIT09KGw9bC5yZXBsYWNlKC9DYXB0dXJlJC8sXCJcIikpLGw9bC50b0xvd2VyQ2FzZSgpaW4gbj9sLnRvTG93ZXJDYXNlKCkuc2xpY2UoMik6bC5zbGljZSgyKSxuLmx8fChuLmw9e30pLG4ubFtsK3JdPXUsdT9pfHxuLmFkZEV2ZW50TGlzdGVuZXIobCxyP3c6bSxyKTpuLnJlbW92ZUV2ZW50TGlzdGVuZXIobCxyP3c6bSxyKTtlbHNlIGlmKFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIiE9PWwpe2lmKHQpbD1sLnJlcGxhY2UoL3hsaW5rKEh8OmgpLyxcImhcIikucmVwbGFjZSgvc05hbWUkLyxcInNcIik7ZWxzZSBpZihcIndpZHRoXCIhPT1sJiZcImhlaWdodFwiIT09bCYmXCJocmVmXCIhPT1sJiZcImxpc3RcIiE9PWwmJlwiZm9ybVwiIT09bCYmXCJ0YWJJbmRleFwiIT09bCYmXCJkb3dubG9hZFwiIT09bCYmbCBpbiBuKXRyeXtuW2xdPW51bGw9PXU/XCJcIjp1O2JyZWFrIG59Y2F0Y2gobil7fVwiZnVuY3Rpb25cIj09dHlwZW9mIHV8fChudWxsPT11fHwhMT09PXUmJi0xPT1sLmluZGV4T2YoXCItXCIpP24ucmVtb3ZlQXR0cmlidXRlKGwpOm4uc2V0QXR0cmlidXRlKGwsdSkpfX1mdW5jdGlvbiBtKG4pe3Q9ITA7dHJ5e3JldHVybiB0aGlzLmxbbi50eXBlKyExXShsLmV2ZW50P2wuZXZlbnQobik6bil9ZmluYWxseXt0PSExfX1mdW5jdGlvbiB3KG4pe3Q9ITA7dHJ5e3JldHVybiB0aGlzLmxbbi50eXBlKyEwXShsLmV2ZW50P2wuZXZlbnQobik6bil9ZmluYWxseXt0PSExfX1mdW5jdGlvbiB4KG4sbCl7dGhpcy5wcm9wcz1uLHRoaXMuY29udGV4dD1sfWZ1bmN0aW9uIEEobixsKXtpZihudWxsPT1sKXJldHVybiBuLl9fP0Eobi5fXyxuLl9fLl9fay5pbmRleE9mKG4pKzEpOm51bGw7Zm9yKHZhciB1O2w8bi5fX2subGVuZ3RoO2wrKylpZihudWxsIT0odT1uLl9fa1tsXSkmJm51bGwhPXUuX19lKXJldHVybiB1Ll9fZTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBuLnR5cGU/QShuKTpudWxsfWZ1bmN0aW9uIFAobil7dmFyIGwsdTtpZihudWxsIT0obj1uLl9fKSYmbnVsbCE9bi5fX2Mpe2ZvcihuLl9fZT1uLl9fYy5iYXNlPW51bGwsbD0wO2w8bi5fX2subGVuZ3RoO2wrKylpZihudWxsIT0odT1uLl9fa1tsXSkmJm51bGwhPXUuX19lKXtuLl9fZT1uLl9fYy5iYXNlPXUuX19lO2JyZWFrfXJldHVybiBQKG4pfX1mdW5jdGlvbiBDKG4pe3Q/c2V0VGltZW91dChuKTpmKG4pfWZ1bmN0aW9uIFQobil7KCFuLl9fZCYmKG4uX19kPSEwKSYmci5wdXNoKG4pJiYhJC5fX3IrK3x8byE9PWwuZGVib3VuY2VSZW5kZXJpbmcpJiYoKG89bC5kZWJvdW5jZVJlbmRlcmluZyl8fEMpKCQpfWZ1bmN0aW9uICQoKXt2YXIgbixsLHUsaSx0LG8sZixlO2ZvcihyLnNvcnQoZnVuY3Rpb24obixsKXtyZXR1cm4gbi5fX3YuX19iLWwuX192Ll9fYn0pO249ci5zaGlmdCgpOyluLl9fZCYmKGw9ci5sZW5ndGgsaT12b2lkIDAsdD12b2lkIDAsZj0obz0odT1uKS5fX3YpLl9fZSwoZT11Ll9fUCkmJihpPVtdLCh0PWgoe30sbykpLl9fdj1vLl9fdisxLE0oZSxvLHQsdS5fX24sdm9pZCAwIT09ZS5vd25lclNWR0VsZW1lbnQsbnVsbCE9by5fX2g/W2ZdOm51bGwsaSxudWxsPT1mP0Eobyk6ZixvLl9faCksTihpLG8pLG8uX19lIT1mJiZQKG8pKSxyLmxlbmd0aD5sJiZyLnNvcnQoZnVuY3Rpb24obixsKXtyZXR1cm4gbi5fX3YuX19iLWwuX192Ll9fYn0pKTskLl9fcj0wfWZ1bmN0aW9uIEgobixsLHUsaSx0LHIsbyxmLGUsYSl7dmFyIGgsdix5LGQsayxiLGcsbT1pJiZpLl9fa3x8cyx3PW0ubGVuZ3RoO2Zvcih1Ll9faz1bXSxoPTA7aDxsLmxlbmd0aDtoKyspaWYobnVsbCE9KGQ9dS5fX2tbaF09bnVsbD09KGQ9bFtoXSl8fFwiYm9vbGVhblwiPT10eXBlb2YgZD9udWxsOlwic3RyaW5nXCI9PXR5cGVvZiBkfHxcIm51bWJlclwiPT10eXBlb2YgZHx8XCJiaWdpbnRcIj09dHlwZW9mIGQ/cChudWxsLGQsbnVsbCxudWxsLGQpOkFycmF5LmlzQXJyYXkoZCk/cChfLHtjaGlsZHJlbjpkfSxudWxsLG51bGwsbnVsbCk6ZC5fX2I+MD9wKGQudHlwZSxkLnByb3BzLGQua2V5LGQucmVmP2QucmVmOm51bGwsZC5fX3YpOmQpKXtpZihkLl9fPXUsZC5fX2I9dS5fX2IrMSxudWxsPT09KHk9bVtoXSl8fHkmJmQua2V5PT15LmtleSYmZC50eXBlPT09eS50eXBlKW1baF09dm9pZCAwO2Vsc2UgZm9yKHY9MDt2PHc7disrKXtpZigoeT1tW3ZdKSYmZC5rZXk9PXkua2V5JiZkLnR5cGU9PT15LnR5cGUpe21bdl09dm9pZCAwO2JyZWFrfXk9bnVsbH1NKG4sZCx5PXl8fGMsdCxyLG8sZixlLGEpLGs9ZC5fX2UsKHY9ZC5yZWYpJiZ5LnJlZiE9diYmKGd8fChnPVtdKSx5LnJlZiYmZy5wdXNoKHkucmVmLG51bGwsZCksZy5wdXNoKHYsZC5fX2N8fGssZCkpLG51bGwhPWs/KG51bGw9PWImJihiPWspLFwiZnVuY3Rpb25cIj09dHlwZW9mIGQudHlwZSYmZC5fX2s9PT15Ll9faz9kLl9fZD1lPUkoZCxlLG4pOmU9eihuLGQseSxtLGssZSksXCJmdW5jdGlvblwiPT10eXBlb2YgdS50eXBlJiYodS5fX2Q9ZSkpOmUmJnkuX19lPT1lJiZlLnBhcmVudE5vZGUhPW4mJihlPUEoeSkpfWZvcih1Ll9fZT1iLGg9dztoLS07KW51bGwhPW1baF0mJihcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LnR5cGUmJm51bGwhPW1baF0uX19lJiZtW2hdLl9fZT09dS5fX2QmJih1Ll9fZD1MKGkpLm5leHRTaWJsaW5nKSxxKG1baF0sbVtoXSkpO2lmKGcpZm9yKGg9MDtoPGcubGVuZ3RoO2grKylTKGdbaF0sZ1srK2hdLGdbKytoXSl9ZnVuY3Rpb24gSShuLGwsdSl7Zm9yKHZhciBpLHQ9bi5fX2sscj0wO3QmJnI8dC5sZW5ndGg7cisrKShpPXRbcl0pJiYoaS5fXz1uLGw9XCJmdW5jdGlvblwiPT10eXBlb2YgaS50eXBlP0koaSxsLHUpOnoodSxpLGksdCxpLl9fZSxsKSk7cmV0dXJuIGx9ZnVuY3Rpb24gaihuLGwpe3JldHVybiBsPWx8fFtdLG51bGw9PW58fFwiYm9vbGVhblwiPT10eXBlb2Ygbnx8KEFycmF5LmlzQXJyYXkobik/bi5zb21lKGZ1bmN0aW9uKG4pe2oobixsKX0pOmwucHVzaChuKSksbH1mdW5jdGlvbiB6KG4sbCx1LGksdCxyKXt2YXIgbyxmLGU7aWYodm9pZCAwIT09bC5fX2Qpbz1sLl9fZCxsLl9fZD12b2lkIDA7ZWxzZSBpZihudWxsPT11fHx0IT1yfHxudWxsPT10LnBhcmVudE5vZGUpbjppZihudWxsPT1yfHxyLnBhcmVudE5vZGUhPT1uKW4uYXBwZW5kQ2hpbGQodCksbz1udWxsO2Vsc2V7Zm9yKGY9cixlPTA7KGY9Zi5uZXh0U2libGluZykmJmU8aS5sZW5ndGg7ZSs9MSlpZihmPT10KWJyZWFrIG47bi5pbnNlcnRCZWZvcmUodCxyKSxvPXJ9cmV0dXJuIHZvaWQgMCE9PW8/bzp0Lm5leHRTaWJsaW5nfWZ1bmN0aW9uIEwobil7dmFyIGwsdSxpO2lmKG51bGw9PW4udHlwZXx8XCJzdHJpbmdcIj09dHlwZW9mIG4udHlwZSlyZXR1cm4gbi5fX2U7aWYobi5fX2spZm9yKGw9bi5fX2subGVuZ3RoLTE7bD49MDtsLS0paWYoKHU9bi5fX2tbbF0pJiYoaT1MKHUpKSlyZXR1cm4gaTtyZXR1cm4gbnVsbH1mdW5jdGlvbiBNKG4sdSxpLHQscixvLGYsZSxjKXt2YXIgcyxhLHYseSxwLGQsayxiLGcsbSx3LEEsUCxDLFQsJD11LnR5cGU7aWYodm9pZCAwIT09dS5jb25zdHJ1Y3RvcilyZXR1cm4gbnVsbDtudWxsIT1pLl9faCYmKGM9aS5fX2gsZT11Ll9fZT1pLl9fZSx1Ll9faD1udWxsLG89W2VdKSwocz1sLl9fYikmJnModSk7dHJ5e246aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgJCl7aWYoYj11LnByb3BzLGc9KHM9JC5jb250ZXh0VHlwZSkmJnRbcy5fX2NdLG09cz9nP2cucHJvcHMudmFsdWU6cy5fXzp0LGkuX19jP2s9KGE9dS5fX2M9aS5fX2MpLl9fPWEuX19FOihcInByb3RvdHlwZVwiaW4gJCYmJC5wcm90b3R5cGUucmVuZGVyP3UuX19jPWE9bmV3ICQoYixtKToodS5fX2M9YT1uZXcgeChiLG0pLGEuY29uc3RydWN0b3I9JCxhLnJlbmRlcj1CKSxnJiZnLnN1YihhKSxhLnByb3BzPWIsYS5zdGF0ZXx8KGEuc3RhdGU9e30pLGEuY29udGV4dD1tLGEuX19uPXQsdj1hLl9fZD0hMCxhLl9faD1bXSxhLl9zYj1bXSksbnVsbD09YS5fX3MmJihhLl9fcz1hLnN0YXRlKSxudWxsIT0kLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyYmKGEuX19zPT1hLnN0YXRlJiYoYS5fX3M9aCh7fSxhLl9fcykpLGgoYS5fX3MsJC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoYixhLl9fcykpKSx5PWEucHJvcHMscD1hLnN0YXRlLGEuX192PXUsdiludWxsPT0kLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyYmbnVsbCE9YS5jb21wb25lbnRXaWxsTW91bnQmJmEuY29tcG9uZW50V2lsbE1vdW50KCksbnVsbCE9YS5jb21wb25lbnREaWRNb3VudCYmYS5fX2gucHVzaChhLmNvbXBvbmVudERpZE1vdW50KTtlbHNle2lmKG51bGw9PSQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiZiIT09eSYmbnVsbCE9YS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZhLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoYixtKSwhYS5fX2UmJm51bGwhPWEuc2hvdWxkQ29tcG9uZW50VXBkYXRlJiYhMT09PWEuc2hvdWxkQ29tcG9uZW50VXBkYXRlKGIsYS5fX3MsbSl8fHUuX192PT09aS5fX3Ype2Zvcih1Ll9fdiE9PWkuX192JiYoYS5wcm9wcz1iLGEuc3RhdGU9YS5fX3MsYS5fX2Q9ITEpLHUuX19lPWkuX19lLHUuX19rPWkuX19rLHUuX19rLmZvckVhY2goZnVuY3Rpb24obil7biYmKG4uX189dSl9KSx3PTA7dzxhLl9zYi5sZW5ndGg7dysrKWEuX19oLnB1c2goYS5fc2Jbd10pO2EuX3NiPVtdLGEuX19oLmxlbmd0aCYmZi5wdXNoKGEpO2JyZWFrIG59bnVsbCE9YS5jb21wb25lbnRXaWxsVXBkYXRlJiZhLmNvbXBvbmVudFdpbGxVcGRhdGUoYixhLl9fcyxtKSxudWxsIT1hLmNvbXBvbmVudERpZFVwZGF0ZSYmYS5fX2gucHVzaChmdW5jdGlvbigpe2EuY29tcG9uZW50RGlkVXBkYXRlKHkscCxkKX0pfWlmKGEuY29udGV4dD1tLGEucHJvcHM9YixhLl9fUD1uLEE9bC5fX3IsUD0wLFwicHJvdG90eXBlXCJpbiAkJiYkLnByb3RvdHlwZS5yZW5kZXIpe2ZvcihhLnN0YXRlPWEuX19zLGEuX19kPSExLEEmJkEodSkscz1hLnJlbmRlcihhLnByb3BzLGEuc3RhdGUsYS5jb250ZXh0KSxDPTA7QzxhLl9zYi5sZW5ndGg7QysrKWEuX19oLnB1c2goYS5fc2JbQ10pO2EuX3NiPVtdfWVsc2UgZG97YS5fX2Q9ITEsQSYmQSh1KSxzPWEucmVuZGVyKGEucHJvcHMsYS5zdGF0ZSxhLmNvbnRleHQpLGEuc3RhdGU9YS5fX3N9d2hpbGUoYS5fX2QmJisrUDwyNSk7YS5zdGF0ZT1hLl9fcyxudWxsIT1hLmdldENoaWxkQ29udGV4dCYmKHQ9aChoKHt9LHQpLGEuZ2V0Q2hpbGRDb250ZXh0KCkpKSx2fHxudWxsPT1hLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHwoZD1hLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHkscCkpLFQ9bnVsbCE9cyYmcy50eXBlPT09XyYmbnVsbD09cy5rZXk/cy5wcm9wcy5jaGlsZHJlbjpzLEgobixBcnJheS5pc0FycmF5KFQpP1Q6W1RdLHUsaSx0LHIsbyxmLGUsYyksYS5iYXNlPXUuX19lLHUuX19oPW51bGwsYS5fX2gubGVuZ3RoJiZmLnB1c2goYSksayYmKGEuX19FPWEuX189bnVsbCksYS5fX2U9ITF9ZWxzZSBudWxsPT1vJiZ1Ll9fdj09PWkuX192Pyh1Ll9faz1pLl9fayx1Ll9fZT1pLl9fZSk6dS5fX2U9TyhpLl9fZSx1LGksdCxyLG8sZixjKTsocz1sLmRpZmZlZCkmJnModSl9Y2F0Y2gobil7dS5fX3Y9bnVsbCwoY3x8bnVsbCE9bykmJih1Ll9fZT1lLHUuX19oPSEhYyxvW28uaW5kZXhPZihlKV09bnVsbCksbC5fX2Uobix1LGkpfX1mdW5jdGlvbiBOKG4sdSl7bC5fX2MmJmwuX19jKHUsbiksbi5zb21lKGZ1bmN0aW9uKHUpe3RyeXtuPXUuX19oLHUuX19oPVtdLG4uc29tZShmdW5jdGlvbihuKXtuLmNhbGwodSl9KX1jYXRjaChuKXtsLl9fZShuLHUuX192KX19KX1mdW5jdGlvbiBPKGwsdSxpLHQscixvLGYsZSl7dmFyIHMsYSxoLHk9aS5wcm9wcyxwPXUucHJvcHMsZD11LnR5cGUsXz0wO2lmKFwic3ZnXCI9PT1kJiYocj0hMCksbnVsbCE9bylmb3IoO188by5sZW5ndGg7XysrKWlmKChzPW9bX10pJiZcInNldEF0dHJpYnV0ZVwiaW4gcz09ISFkJiYoZD9zLmxvY2FsTmFtZT09PWQ6Mz09PXMubm9kZVR5cGUpKXtsPXMsb1tfXT1udWxsO2JyZWFrfWlmKG51bGw9PWwpe2lmKG51bGw9PT1kKXJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwKTtsPXI/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixkKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KGQscC5pcyYmcCksbz1udWxsLGU9ITF9aWYobnVsbD09PWQpeT09PXB8fGUmJmwuZGF0YT09PXB8fChsLmRhdGE9cCk7ZWxzZXtpZihvPW8mJm4uY2FsbChsLmNoaWxkTm9kZXMpLGE9KHk9aS5wcm9wc3x8YykuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsaD1wLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLCFlKXtpZihudWxsIT1vKWZvcih5PXt9LF89MDtfPGwuYXR0cmlidXRlcy5sZW5ndGg7XysrKXlbbC5hdHRyaWJ1dGVzW19dLm5hbWVdPWwuYXR0cmlidXRlc1tfXS52YWx1ZTsoaHx8YSkmJihoJiYoYSYmaC5fX2h0bWw9PWEuX19odG1sfHxoLl9faHRtbD09PWwuaW5uZXJIVE1MKXx8KGwuaW5uZXJIVE1MPWgmJmguX19odG1sfHxcIlwiKSl9aWYoayhsLHAseSxyLGUpLGgpdS5fX2s9W107ZWxzZSBpZihfPXUucHJvcHMuY2hpbGRyZW4sSChsLEFycmF5LmlzQXJyYXkoXyk/XzpbX10sdSxpLHQsciYmXCJmb3JlaWduT2JqZWN0XCIhPT1kLG8sZixvP29bMF06aS5fX2smJkEoaSwwKSxlKSxudWxsIT1vKWZvcihfPW8ubGVuZ3RoO18tLTspbnVsbCE9b1tfXSYmdihvW19dKTtlfHwoXCJ2YWx1ZVwiaW4gcCYmdm9pZCAwIT09KF89cC52YWx1ZSkmJihfIT09bC52YWx1ZXx8XCJwcm9ncmVzc1wiPT09ZCYmIV98fFwib3B0aW9uXCI9PT1kJiZfIT09eS52YWx1ZSkmJmcobCxcInZhbHVlXCIsXyx5LnZhbHVlLCExKSxcImNoZWNrZWRcImluIHAmJnZvaWQgMCE9PShfPXAuY2hlY2tlZCkmJl8hPT1sLmNoZWNrZWQmJmcobCxcImNoZWNrZWRcIixfLHkuY2hlY2tlZCwhMSkpfXJldHVybiBsfWZ1bmN0aW9uIFMobix1LGkpe3RyeXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBuP24odSk6bi5jdXJyZW50PXV9Y2F0Y2gobil7bC5fX2UobixpKX19ZnVuY3Rpb24gcShuLHUsaSl7dmFyIHQscjtpZihsLnVubW91bnQmJmwudW5tb3VudChuKSwodD1uLnJlZikmJih0LmN1cnJlbnQmJnQuY3VycmVudCE9PW4uX19lfHxTKHQsbnVsbCx1KSksbnVsbCE9KHQ9bi5fX2MpKXtpZih0LmNvbXBvbmVudFdpbGxVbm1vdW50KXRyeXt0LmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2gobil7bC5fX2Uobix1KX10LmJhc2U9dC5fX1A9bnVsbCxuLl9fYz12b2lkIDB9aWYodD1uLl9faylmb3Iocj0wO3I8dC5sZW5ndGg7cisrKXRbcl0mJnEodFtyXSx1LGl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4udHlwZSk7aXx8bnVsbD09bi5fX2V8fHYobi5fX2UpLG4uX189bi5fX2U9bi5fX2Q9dm9pZCAwfWZ1bmN0aW9uIEIobixsLHUpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yKG4sdSl9ZnVuY3Rpb24gRCh1LGksdCl7dmFyIHIsbyxmO2wuX18mJmwuX18odSxpKSxvPShyPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQpP251bGw6dCYmdC5fX2t8fGkuX19rLGY9W10sTShpLHU9KCFyJiZ0fHxpKS5fX2s9eShfLG51bGwsW3VdKSxvfHxjLGMsdm9pZCAwIT09aS5vd25lclNWR0VsZW1lbnQsIXImJnQ/W3RdOm8/bnVsbDppLmZpcnN0Q2hpbGQ/bi5jYWxsKGkuY2hpbGROb2Rlcyk6bnVsbCxmLCFyJiZ0P3Q6bz9vLl9fZTppLmZpcnN0Q2hpbGQsciksTihmLHUpfWZ1bmN0aW9uIEUobixsKXtEKG4sbCxFKX1mdW5jdGlvbiBGKGwsdSxpKXt2YXIgdCxyLG8sZj1oKHt9LGwucHJvcHMpO2ZvcihvIGluIHUpXCJrZXlcIj09bz90PXVbb106XCJyZWZcIj09bz9yPXVbb106ZltvXT11W29dO3JldHVybiBhcmd1bWVudHMubGVuZ3RoPjImJihmLmNoaWxkcmVuPWFyZ3VtZW50cy5sZW5ndGg+Mz9uLmNhbGwoYXJndW1lbnRzLDIpOmkpLHAobC50eXBlLGYsdHx8bC5rZXkscnx8bC5yZWYsbnVsbCl9ZnVuY3Rpb24gRyhuLGwpe3ZhciB1PXtfX2M6bD1cIl9fY0NcIitlKyssX186bixDb25zdW1lcjpmdW5jdGlvbihuLGwpe3JldHVybiBuLmNoaWxkcmVuKGwpfSxQcm92aWRlcjpmdW5jdGlvbihuKXt2YXIgdSxpO3JldHVybiB0aGlzLmdldENoaWxkQ29udGV4dHx8KHU9W10sKGk9e30pW2xdPXRoaXMsdGhpcy5nZXRDaGlsZENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gaX0sdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGU9ZnVuY3Rpb24obil7dGhpcy5wcm9wcy52YWx1ZSE9PW4udmFsdWUmJnUuc29tZShmdW5jdGlvbihuKXtuLl9fZT0hMCxUKG4pfSl9LHRoaXMuc3ViPWZ1bmN0aW9uKG4pe3UucHVzaChuKTt2YXIgbD1uLmNvbXBvbmVudFdpbGxVbm1vdW50O24uY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXt1LnNwbGljZSh1LmluZGV4T2YobiksMSksbCYmbC5jYWxsKG4pfX0pLG4uY2hpbGRyZW59fTtyZXR1cm4gdS5Qcm92aWRlci5fXz11LkNvbnN1bWVyLmNvbnRleHRUeXBlPXV9bj1zLnNsaWNlLGw9e19fZTpmdW5jdGlvbihuLGwsdSxpKXtmb3IodmFyIHQscixvO2w9bC5fXzspaWYoKHQ9bC5fX2MpJiYhdC5fXyl0cnl7aWYoKHI9dC5jb25zdHJ1Y3RvcikmJm51bGwhPXIuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yJiYodC5zZXRTdGF0ZShyLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihuKSksbz10Ll9fZCksbnVsbCE9dC5jb21wb25lbnREaWRDYXRjaCYmKHQuY29tcG9uZW50RGlkQ2F0Y2gobixpfHx7fSksbz10Ll9fZCksbylyZXR1cm4gdC5fX0U9dH1jYXRjaChsKXtuPWx9dGhyb3cgbn19LHU9MCxpPWZ1bmN0aW9uKG4pe3JldHVybiBudWxsIT1uJiZ2b2lkIDA9PT1uLmNvbnN0cnVjdG9yfSx0PSExLHgucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKG4sbCl7dmFyIHU7dT1udWxsIT10aGlzLl9fcyYmdGhpcy5fX3MhPT10aGlzLnN0YXRlP3RoaXMuX19zOnRoaXMuX19zPWgoe30sdGhpcy5zdGF0ZSksXCJmdW5jdGlvblwiPT10eXBlb2YgbiYmKG49bihoKHt9LHUpLHRoaXMucHJvcHMpKSxuJiZoKHUsbiksbnVsbCE9biYmdGhpcy5fX3YmJihsJiZ0aGlzLl9zYi5wdXNoKGwpLFQodGhpcykpfSx4LnByb3RvdHlwZS5mb3JjZVVwZGF0ZT1mdW5jdGlvbihuKXt0aGlzLl9fdiYmKHRoaXMuX19lPSEwLG4mJnRoaXMuX19oLnB1c2gobiksVCh0aGlzKSl9LHgucHJvdG90eXBlLnJlbmRlcj1fLHI9W10sZj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm9taXNlP1Byb21pc2UucHJvdG90eXBlLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSk6c2V0VGltZW91dCwkLl9fcj0wLGU9MDtleHBvcnR7eCBhcyBDb21wb25lbnQsXyBhcyBGcmFnbWVudCxGIGFzIGNsb25lRWxlbWVudCxHIGFzIGNyZWF0ZUNvbnRleHQseSBhcyBjcmVhdGVFbGVtZW50LGQgYXMgY3JlYXRlUmVmLHkgYXMgaCxFIGFzIGh5ZHJhdGUsaSBhcyBpc1ZhbGlkRWxlbWVudCxsIGFzIG9wdGlvbnMsRCBhcyByZW5kZXIsaiBhcyB0b0NoaWxkQXJyYXl9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlYWN0Lm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/preact/dist/preact.module.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/preact/hooks/dist/hooks.module.js":
/*!*********************************************************!*\
  !*** ../node_modules/preact/hooks/dist/hooks.module.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCallback: function() { return /* binding */ T; },\n/* harmony export */   useContext: function() { return /* binding */ q; },\n/* harmony export */   useDebugValue: function() { return /* binding */ x; },\n/* harmony export */   useEffect: function() { return /* binding */ h; },\n/* harmony export */   useErrorBoundary: function() { return /* binding */ P; },\n/* harmony export */   useId: function() { return /* binding */ V; },\n/* harmony export */   useImperativeHandle: function() { return /* binding */ A; },\n/* harmony export */   useLayoutEffect: function() { return /* binding */ s; },\n/* harmony export */   useMemo: function() { return /* binding */ F; },\n/* harmony export */   useReducer: function() { return /* binding */ y; },\n/* harmony export */   useRef: function() { return /* binding */ _; },\n/* harmony export */   useState: function() { return /* binding */ p; }\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"(app-pages-browser)/../node_modules/preact/dist/preact.module.js\");\nvar t,r,u,i,o=0,f=[],c=[],e=preact__WEBPACK_IMPORTED_MODULE_0__.options.__b,a=preact__WEBPACK_IMPORTED_MODULE_0__.options.__r,v=preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed,l=preact__WEBPACK_IMPORTED_MODULE_0__.options.__c,m=preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount;function d(t,u){preact__WEBPACK_IMPORTED_MODULE_0__.options.__h&&preact__WEBPACK_IMPORTED_MODULE_0__.options.__h(r,t,o||u),o=0;var i=r.__H||(r.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({__V:c}),i.__[t]}function p(n){return o=1,y(B,n)}function y(n,u,i){var o=d(t++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):B(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}))}],o.__c=r,!r.u)){r.u=!0;var f=r.shouldComponentUpdate;r.shouldComponentUpdate=function(n,t,r){if(!o.__c.__H)return!0;var u=o.__c.__H.__.filter(function(n){return n.__c});if(u.every(function(n){return!n.__N}))return!f||f.call(this,n,t,r);var i=!1;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0)}}),!(!i&&o.__c.props===n)&&(!f||f.call(this,n,t,r))}}return o.__N||o.__}function h(u,i){var o=d(t++,3);!preact__WEBPACK_IMPORTED_MODULE_0__.options.__s&&z(o.__H,i)&&(o.__=u,o.i=i,r.__H.__h.push(o))}function s(u,i){var o=d(t++,4);!preact__WEBPACK_IMPORTED_MODULE_0__.options.__s&&z(o.__H,i)&&(o.__=u,o.i=i,r.__h.push(o))}function _(n){return o=5,F(function(){return{current:n}},[])}function A(n,t,r){o=6,s(function(){return\"function\"==typeof n?(n(t()),function(){return n(null)}):n?(n.current=t(),function(){return n.current=null}):void 0},null==r?r:r.concat(n))}function F(n,r){var u=d(t++,7);return z(u.__H,r)?(u.__V=n(),u.i=r,u.__h=n,u.__V):u.__}function T(n,t){return o=8,F(function(){return n},t)}function q(n){var u=r.context[n.__c],i=d(t++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r)),u.props.value):n.__}function x(t,r){preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue&&preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue(r?r(t):t)}function P(n){var u=d(t++,10),i=p();return u.__=n,r.componentDidCatch||(r.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n)}),[i[0],function(){i[1](void 0)}]}function V(){var n=d(t++,11);if(!n.__){for(var u=r.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__=\"P\"+i[0]+\"-\"+i[1]++}return n.__}function b(){for(var t;t=f.shift();)if(t.__P&&t.__H)try{t.__H.__h.forEach(k),t.__H.__h.forEach(w),t.__H.__h=[]}catch(r){t.__H.__h=[],preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(r,t.__v)}}preact__WEBPACK_IMPORTED_MODULE_0__.options.__b=function(n){r=null,e&&e(n)},preact__WEBPACK_IMPORTED_MODULE_0__.options.__r=function(n){a&&a(n),t=0;var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.__V=c,n.__N=n.i=void 0})):(i.__h.forEach(k),i.__h.forEach(w),i.__h=[])),u=r},preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed=function(t){v&&v(t);var o=t.__c;o&&o.__H&&(o.__H.__h.length&&(1!==f.push(o)&&i===preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame||((i=preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame)||j)(b)),o.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.__V!==c&&(n.__=n.__V),n.i=void 0,n.__V=c})),u=r=null},preact__WEBPACK_IMPORTED_MODULE_0__.options.__c=function(t,r){r.some(function(t){try{t.__h.forEach(k),t.__h=t.__h.filter(function(n){return!n.__||w(n)})}catch(u){r.some(function(n){n.__h&&(n.__h=[])}),r=[],preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(u,t.__v)}}),l&&l(t,r)},preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount=function(t){m&&m(t);var r,u=t.__c;u&&u.__H&&(u.__H.__.forEach(function(n){try{k(n)}catch(n){r=n}}),u.__H=void 0,r&&preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(r,u.__v))};var g=\"function\"==typeof requestAnimationFrame;function j(n){var t,r=function(){clearTimeout(u),g&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,100);g&&(t=requestAnimationFrame(r))}function k(n){var t=r,u=n.__c;\"function\"==typeof u&&(n.__c=void 0,u()),r=t}function w(n){var t=r;n.__c=n.__(),r=t}function z(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function B(n,t){return\"function\"==typeof t?t(n):t}\n//# sourceMappingURL=hooks.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL2Rpc3QvaG9va3MubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUMsNEJBQTRCLDJDQUFDLE9BQU8sMkNBQUMsT0FBTywyQ0FBQyxVQUFVLDJDQUFDLE9BQU8sMkNBQUMsU0FBUyxnQkFBZ0IsMkNBQUMsTUFBTSwyQ0FBQyxtQkFBbUIscUJBQXFCLGFBQWEsRUFBRSxrQ0FBa0MsTUFBTSxVQUFVLGNBQWMsa0JBQWtCLGtCQUFrQixlQUFlLHVEQUF1RCx3Q0FBd0MsMkNBQTJDLEdBQUcsaUJBQWlCLE9BQU8sOEJBQThCLHdDQUF3Qyx1QkFBdUIsc0NBQXNDLGFBQWEsRUFBRSx1QkFBdUIsYUFBYSwrQkFBK0IsU0FBUyw2QkFBNkIsVUFBVSxjQUFjLDZDQUE2QyxvREFBb0QsbUJBQW1CLGdCQUFnQixlQUFlLENBQUMsMkNBQUMsbURBQW1ELGdCQUFnQixlQUFlLENBQUMsMkNBQUMsK0NBQStDLGNBQWMsd0JBQXdCLE9BQU8sV0FBVyxLQUFLLGtCQUFrQixpQkFBaUIsOENBQThDLGVBQWUsOEJBQThCLHNCQUFzQixTQUFTLHdCQUF3QixnQkFBZ0IsZUFBZSx1REFBdUQsZ0JBQWdCLHdCQUF3QixTQUFTLElBQUksY0FBYyxrQ0FBa0MsbUVBQW1FLGdCQUFnQiwyQ0FBQyxnQkFBZ0IsMkNBQUMseUJBQXlCLGNBQWMsc0JBQXNCLHNFQUFzRSx3QkFBd0IsbUJBQW1CLGFBQWEsRUFBRSxhQUFhLGdCQUFnQixVQUFVLGdCQUFnQiw4QkFBOEIsUUFBUSwyQkFBMkIseUJBQXlCLFlBQVksYUFBYSxVQUFVLFlBQVkscUJBQXFCLHVEQUF1RCxTQUFTLGFBQWEsMkNBQUMsZUFBZSwyQ0FBQyxpQkFBaUIsZUFBZSxDQUFDLDJDQUFDLGlCQUFpQixZQUFZLG9CQUFvQixzREFBc0QsNkNBQTZDLHFEQUFxRCxDQUFDLDJDQUFDLG9CQUFvQixRQUFRLFlBQVksaURBQWlELDJDQUFDLDRCQUE0QiwyQ0FBQyw2REFBNkQsNERBQTRELFlBQVksQ0FBQywyQ0FBQyxtQkFBbUIsbUJBQW1CLElBQUksZ0RBQWdELGtCQUFrQixFQUFFLFNBQVMsbUJBQW1CLGtCQUFrQixPQUFPLDJDQUFDLGVBQWUsWUFBWSxDQUFDLDJDQUFDLHFCQUFxQixRQUFRLGNBQWMsd0NBQXdDLElBQUksS0FBSyxTQUFTLEtBQUssa0JBQWtCLDJDQUFDLGdCQUFnQiwrQ0FBK0MsY0FBYyxtQkFBbUIseURBQXlELHFCQUFxQixnQ0FBZ0MsY0FBYyxnQkFBZ0IsNkNBQTZDLGNBQWMsUUFBUSxpQkFBaUIsZ0JBQWdCLG9EQUFvRCxnQkFBZ0IsRUFBRSxnQkFBZ0Isa0NBQW1QO0FBQ2g4RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC9ob29rcy9kaXN0L2hvb2tzLm1vZHVsZS5qcz83YmIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydHtvcHRpb25zIGFzIG59ZnJvbVwicHJlYWN0XCI7dmFyIHQscix1LGksbz0wLGY9W10sYz1bXSxlPW4uX19iLGE9bi5fX3Isdj1uLmRpZmZlZCxsPW4uX19jLG09bi51bm1vdW50O2Z1bmN0aW9uIGQodCx1KXtuLl9faCYmbi5fX2gocix0LG98fHUpLG89MDt2YXIgaT1yLl9fSHx8KHIuX19IPXtfXzpbXSxfX2g6W119KTtyZXR1cm4gdD49aS5fXy5sZW5ndGgmJmkuX18ucHVzaCh7X19WOmN9KSxpLl9fW3RdfWZ1bmN0aW9uIHAobil7cmV0dXJuIG89MSx5KEIsbil9ZnVuY3Rpb24geShuLHUsaSl7dmFyIG89ZCh0KyssMik7aWYoby50PW4sIW8uX19jJiYoby5fXz1baT9pKHUpOkIodm9pZCAwLHUpLGZ1bmN0aW9uKG4pe3ZhciB0PW8uX19OP28uX19OWzBdOm8uX19bMF0scj1vLnQodCxuKTt0IT09ciYmKG8uX19OPVtyLG8uX19bMV1dLG8uX19jLnNldFN0YXRlKHt9KSl9XSxvLl9fYz1yLCFyLnUpKXtyLnU9ITA7dmFyIGY9ci5zaG91bGRDb21wb25lbnRVcGRhdGU7ci5zaG91bGRDb21wb25lbnRVcGRhdGU9ZnVuY3Rpb24obix0LHIpe2lmKCFvLl9fYy5fX0gpcmV0dXJuITA7dmFyIHU9by5fX2MuX19ILl9fLmZpbHRlcihmdW5jdGlvbihuKXtyZXR1cm4gbi5fX2N9KTtpZih1LmV2ZXJ5KGZ1bmN0aW9uKG4pe3JldHVybiFuLl9fTn0pKXJldHVybiFmfHxmLmNhbGwodGhpcyxuLHQscik7dmFyIGk9ITE7cmV0dXJuIHUuZm9yRWFjaChmdW5jdGlvbihuKXtpZihuLl9fTil7dmFyIHQ9bi5fX1swXTtuLl9fPW4uX19OLG4uX19OPXZvaWQgMCx0IT09bi5fX1swXSYmKGk9ITApfX0pLCEoIWkmJm8uX19jLnByb3BzPT09bikmJighZnx8Zi5jYWxsKHRoaXMsbix0LHIpKX19cmV0dXJuIG8uX19OfHxvLl9ffWZ1bmN0aW9uIGgodSxpKXt2YXIgbz1kKHQrKywzKTshbi5fX3MmJnooby5fX0gsaSkmJihvLl9fPXUsby5pPWksci5fX0guX19oLnB1c2gobykpfWZ1bmN0aW9uIHModSxpKXt2YXIgbz1kKHQrKyw0KTshbi5fX3MmJnooby5fX0gsaSkmJihvLl9fPXUsby5pPWksci5fX2gucHVzaChvKSl9ZnVuY3Rpb24gXyhuKXtyZXR1cm4gbz01LEYoZnVuY3Rpb24oKXtyZXR1cm57Y3VycmVudDpufX0sW10pfWZ1bmN0aW9uIEEobix0LHIpe289NixzKGZ1bmN0aW9uKCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2Ygbj8obih0KCkpLGZ1bmN0aW9uKCl7cmV0dXJuIG4obnVsbCl9KTpuPyhuLmN1cnJlbnQ9dCgpLGZ1bmN0aW9uKCl7cmV0dXJuIG4uY3VycmVudD1udWxsfSk6dm9pZCAwfSxudWxsPT1yP3I6ci5jb25jYXQobikpfWZ1bmN0aW9uIEYobixyKXt2YXIgdT1kKHQrKyw3KTtyZXR1cm4geih1Ll9fSCxyKT8odS5fX1Y9bigpLHUuaT1yLHUuX19oPW4sdS5fX1YpOnUuX199ZnVuY3Rpb24gVChuLHQpe3JldHVybiBvPTgsRihmdW5jdGlvbigpe3JldHVybiBufSx0KX1mdW5jdGlvbiBxKG4pe3ZhciB1PXIuY29udGV4dFtuLl9fY10saT1kKHQrKyw5KTtyZXR1cm4gaS5jPW4sdT8obnVsbD09aS5fXyYmKGkuX189ITAsdS5zdWIocikpLHUucHJvcHMudmFsdWUpOm4uX199ZnVuY3Rpb24geCh0LHIpe24udXNlRGVidWdWYWx1ZSYmbi51c2VEZWJ1Z1ZhbHVlKHI/cih0KTp0KX1mdW5jdGlvbiBQKG4pe3ZhciB1PWQodCsrLDEwKSxpPXAoKTtyZXR1cm4gdS5fXz1uLHIuY29tcG9uZW50RGlkQ2F0Y2h8fChyLmNvbXBvbmVudERpZENhdGNoPWZ1bmN0aW9uKG4sdCl7dS5fXyYmdS5fXyhuLHQpLGlbMV0obil9KSxbaVswXSxmdW5jdGlvbigpe2lbMV0odm9pZCAwKX1dfWZ1bmN0aW9uIFYoKXt2YXIgbj1kKHQrKywxMSk7aWYoIW4uX18pe2Zvcih2YXIgdT1yLl9fdjtudWxsIT09dSYmIXUuX19tJiZudWxsIT09dS5fXzspdT11Ll9fO3ZhciBpPXUuX19tfHwodS5fX209WzAsMF0pO24uX189XCJQXCIraVswXStcIi1cIitpWzFdKyt9cmV0dXJuIG4uX199ZnVuY3Rpb24gYigpe2Zvcih2YXIgdDt0PWYuc2hpZnQoKTspaWYodC5fX1AmJnQuX19IKXRyeXt0Ll9fSC5fX2guZm9yRWFjaChrKSx0Ll9fSC5fX2guZm9yRWFjaCh3KSx0Ll9fSC5fX2g9W119Y2F0Y2gocil7dC5fX0guX19oPVtdLG4uX19lKHIsdC5fX3YpfX1uLl9fYj1mdW5jdGlvbihuKXtyPW51bGwsZSYmZShuKX0sbi5fX3I9ZnVuY3Rpb24obil7YSYmYShuKSx0PTA7dmFyIGk9KHI9bi5fX2MpLl9fSDtpJiYodT09PXI/KGkuX19oPVtdLHIuX19oPVtdLGkuX18uZm9yRWFjaChmdW5jdGlvbihuKXtuLl9fTiYmKG4uX189bi5fX04pLG4uX19WPWMsbi5fX049bi5pPXZvaWQgMH0pKTooaS5fX2guZm9yRWFjaChrKSxpLl9faC5mb3JFYWNoKHcpLGkuX19oPVtdKSksdT1yfSxuLmRpZmZlZD1mdW5jdGlvbih0KXt2JiZ2KHQpO3ZhciBvPXQuX19jO28mJm8uX19IJiYoby5fX0guX19oLmxlbmd0aCYmKDEhPT1mLnB1c2gobykmJmk9PT1uLnJlcXVlc3RBbmltYXRpb25GcmFtZXx8KChpPW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKXx8aikoYikpLG8uX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7bi5pJiYobi5fX0g9bi5pKSxuLl9fViE9PWMmJihuLl9fPW4uX19WKSxuLmk9dm9pZCAwLG4uX19WPWN9KSksdT1yPW51bGx9LG4uX19jPWZ1bmN0aW9uKHQscil7ci5zb21lKGZ1bmN0aW9uKHQpe3RyeXt0Ll9faC5mb3JFYWNoKGspLHQuX19oPXQuX19oLmZpbHRlcihmdW5jdGlvbihuKXtyZXR1cm4hbi5fX3x8dyhuKX0pfWNhdGNoKHUpe3Iuc29tZShmdW5jdGlvbihuKXtuLl9faCYmKG4uX19oPVtdKX0pLHI9W10sbi5fX2UodSx0Ll9fdil9fSksbCYmbCh0LHIpfSxuLnVubW91bnQ9ZnVuY3Rpb24odCl7bSYmbSh0KTt2YXIgcix1PXQuX19jO3UmJnUuX19IJiYodS5fX0guX18uZm9yRWFjaChmdW5jdGlvbihuKXt0cnl7ayhuKX1jYXRjaChuKXtyPW59fSksdS5fX0g9dm9pZCAwLHImJm4uX19lKHIsdS5fX3YpKX07dmFyIGc9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO2Z1bmN0aW9uIGoobil7dmFyIHQscj1mdW5jdGlvbigpe2NsZWFyVGltZW91dCh1KSxnJiZjYW5jZWxBbmltYXRpb25GcmFtZSh0KSxzZXRUaW1lb3V0KG4pfSx1PXNldFRpbWVvdXQociwxMDApO2cmJih0PXJlcXVlc3RBbmltYXRpb25GcmFtZShyKSl9ZnVuY3Rpb24gayhuKXt2YXIgdD1yLHU9bi5fX2M7XCJmdW5jdGlvblwiPT10eXBlb2YgdSYmKG4uX19jPXZvaWQgMCx1KCkpLHI9dH1mdW5jdGlvbiB3KG4pe3ZhciB0PXI7bi5fX2M9bi5fXygpLHI9dH1mdW5jdGlvbiB6KG4sdCl7cmV0dXJuIW58fG4ubGVuZ3RoIT09dC5sZW5ndGh8fHQuc29tZShmdW5jdGlvbih0LHIpe3JldHVybiB0IT09bltyXX0pfWZ1bmN0aW9uIEIobix0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Qobik6dH1leHBvcnR7VCBhcyB1c2VDYWxsYmFjayxxIGFzIHVzZUNvbnRleHQseCBhcyB1c2VEZWJ1Z1ZhbHVlLGggYXMgdXNlRWZmZWN0LFAgYXMgdXNlRXJyb3JCb3VuZGFyeSxWIGFzIHVzZUlkLEEgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZSxzIGFzIHVzZUxheW91dEVmZmVjdCxGIGFzIHVzZU1lbW8seSBhcyB1c2VSZWR1Y2VyLF8gYXMgdXNlUmVmLHAgYXMgdXNlU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9va3MubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/preact/hooks/dist/hooks.module.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"174821446fde\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvZ2xvYmFscy5jc3M/MDYwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjE3NDgyMTQ0NmZkZVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/components/nav/nav.module.css":
/*!***********************************************!*\
  !*** ./src/app/components/nav/nav.module.css ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"navbar\":\"nav_navbar__FjzPZ\",\"navbar_section\":\"nav_navbar_section__saq35\",\"navbar_item\":\"nav_navbar_item__zcEP8\"};\n    if(true) {\n      // 1732417343835\n      var cssReload = __webpack_require__(/*! ../node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/../node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"4dce8f16863a\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50cy9uYXYvbmF2Lm1vZHVsZS5jc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsME1BQTRILGNBQWMsc0RBQXNEO0FBQzlOLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9jb21wb25lbnRzL25hdi9uYXYubW9kdWxlLmNzcz8zZDk3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJuYXZiYXJcIjpcIm5hdl9uYXZiYXJfX0ZqelBaXCIsXCJuYXZiYXJfc2VjdGlvblwiOlwibmF2X25hdmJhcl9zZWN0aW9uX19zYXEzNVwiLFwibmF2YmFyX2l0ZW1cIjpcIm5hdl9uYXZiYXJfaXRlbV9femNFUDhcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTczMjQxNzM0MzgzNVxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCIvVXNlcnMvYnJ5Y2UvRG9jdW1lbnRzL1JlcG9zL3RpbWVzcGFyay9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgXG5tb2R1bGUuZXhwb3J0cy5fX2NoZWNrc3VtID0gXCI0ZGNlOGYxNjg2M2FcIlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/components/nav/nav.module.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/global.module.css":
/*!***********************************!*\
  !*** ./src/app/global.module.css ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"page\":\"global_page__q720x\",\"content\":\"global_content__68SBT\"};\n    if(true) {\n      // 1732417343773\n      var cssReload = __webpack_require__(/*! ../node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/../node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"ef2cbe31e3a0\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFsLm1vZHVsZS5jc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsME1BQTRILGNBQWMsc0RBQXNEO0FBQzlOLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9nbG9iYWwubW9kdWxlLmNzcz9iNjA1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJwYWdlXCI6XCJnbG9iYWxfcGFnZV9fcTcyMHhcIixcImNvbnRlbnRcIjpcImdsb2JhbF9jb250ZW50X182OFNCVFwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzMyNDE3MzQzNzczXG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIi9Vc2Vycy9icnljZS9Eb2N1bWVudHMvUmVwb3MvdGltZXNwYXJrL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICBcbm1vZHVsZS5leHBvcnRzLl9fY2hlY2tzdW0gPSBcImVmMmNiZTMxZTNhMFwiXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/global.module.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/(pages)/calendar/page.js":
/*!******************************************!*\
  !*** ./src/app/(pages)/calendar/page.js ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Page; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _fullcalendar_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fullcalendar/react */ \"(app-pages-browser)/../node_modules/@fullcalendar/react/dist/index.js\");\n/* harmony import */ var _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fullcalendar/daygrid */ \"(app-pages-browser)/../node_modules/@fullcalendar/daygrid/index.js\");\n/* harmony import */ var _globals_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../globals.css */ \"(app-pages-browser)/./src/app/globals.css\");\n/* harmony import */ var _global_module_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../global.module.css */ \"(app-pages-browser)/./src/app/global.module.css\");\n/* harmony import */ var _global_module_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_global_module_css__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_nav_nav__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/nav/nav */ \"(app-pages-browser)/./src/app/components/nav/nav.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n // a plugin!\n\n\n\nfunction Page() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: (_global_module_css__WEBPACK_IMPORTED_MODULE_2___default().page),\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_nav_nav__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/(pages)/calendar/page.js\",\n                        lineNumber: 13,\n                        columnNumber: 14\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/(pages)/calendar/page.js\",\n                    lineNumber: 13,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_global_module_css__WEBPACK_IMPORTED_MODULE_2___default().content),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                            children: \"CALENDAR\"\n                        }, void 0, false, {\n                            fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/(pages)/calendar/page.js\",\n                            lineNumber: 15,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fullcalendar_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                            plugins: [\n                                _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_5__[\"default\"]\n                            ],\n                            initialView: \"dayGridMonth\"\n                        }, void 0, false, {\n                            fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/(pages)/calendar/page.js\",\n                            lineNumber: 16,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/(pages)/calendar/page.js\",\n                    lineNumber: 14,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/(pages)/calendar/page.js\",\n            lineNumber: 12,\n            columnNumber: 7\n        }, this)\n    }, void 0, false);\n}\n_c = Page;\nvar _c;\n$RefreshReg$(_c, \"Page\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvKHBhZ2VzKS9jYWxlbmRhci9wYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUU4QztBQUNHLENBQUMsWUFBWTtBQUNwQztBQUNrQjtBQUNDO0FBRTlCLFNBQVNJO0lBQ3RCLHFCQUNFO2tCQUNFLDRFQUFDQztZQUFJQyxXQUFXSixnRUFBVzs7OEJBQ3pCLDhEQUFDRzs4QkFBSSw0RUFBQ0YsMkRBQU1BOzs7Ozs7Ozs7OzhCQUNaLDhEQUFDRTtvQkFBSUMsV0FBV0osbUVBQWM7O3NDQUM1Qiw4REFBQ087c0NBQUc7Ozs7OztzQ0FDRiw4REFBQ1QsMkRBQVlBOzRCQUNYVSxTQUFTO2dDQUFFVCw2REFBYUE7NkJBQUU7NEJBQzFCVSxhQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTTFCO0tBZndCUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwLyhwYWdlcykvY2FsZW5kYXIvcGFnZS5qcz9kZjQ4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgRnVsbENhbGVuZGFyIGZyb20gJ0BmdWxsY2FsZW5kYXIvcmVhY3QnXG5pbXBvcnQgZGF5R3JpZFBsdWdpbiBmcm9tICdAZnVsbGNhbGVuZGFyL2RheWdyaWQnIC8vIGEgcGx1Z2luIVxuaW1wb3J0ICcuLi8uLi9nbG9iYWxzLmNzcydcbmltcG9ydCBnbG9iYWwgZnJvbSAnLi4vLi4vZ2xvYmFsLm1vZHVsZS5jc3MnXG5pbXBvcnQgTmF2YmFyIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbmF2L25hdidcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGFnZSgpIHtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e2dsb2JhbC5wYWdlfT5cbiAgICAgICAgPGRpdj48TmF2YmFyIC8+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtnbG9iYWwuY29udGVudH0+XG4gICAgICAgICAgPGgxPkNBTEVOREFSPC9oMT5cbiAgICAgICAgICAgIDxGdWxsQ2FsZW5kYXJcbiAgICAgICAgICAgICAgcGx1Z2lucz17WyBkYXlHcmlkUGx1Z2luIF19XG4gICAgICAgICAgICAgIGluaXRpYWxWaWV3PVwiZGF5R3JpZE1vbnRoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXYgPlxuICAgIDwvPiBcbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJGdWxsQ2FsZW5kYXIiLCJkYXlHcmlkUGx1Z2luIiwiZ2xvYmFsIiwiTmF2YmFyIiwiUGFnZSIsImRpdiIsImNsYXNzTmFtZSIsInBhZ2UiLCJjb250ZW50IiwiaDEiLCJwbHVnaW5zIiwiaW5pdGlhbFZpZXciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/(pages)/calendar/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/components/nav/nav.js":
/*!***************************************!*\
  !*** ./src/app/components/nav/nav.js ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Navbar; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _nav_module_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nav.module.css */ \"(app-pages-browser)/./src/app/components/nav/nav.module.css\");\n/* harmony import */ var _nav_module_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_nav_module_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/../node_modules/next/dist/api/link.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/../node_modules/next/dist/api/image.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\nfunction Navbar() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: (_nav_module_css__WEBPACK_IMPORTED_MODULE_1___default().navbar),\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_nav_module_css__WEBPACK_IMPORTED_MODULE_1___default().navbar_section),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                            className: (_nav_module_css__WEBPACK_IMPORTED_MODULE_1___default().navbar_item),\n                            href: \"/dashboard\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                src: \"/icons/dashboard-icon.png\",\n                                alt: \"Home\",\n                                width: \"30\",\n                                height: \"30\"\n                            }, void 0, false, {\n                                fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n                                lineNumber: 12,\n                                columnNumber: 76\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n                            lineNumber: 12,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                            className: (_nav_module_css__WEBPACK_IMPORTED_MODULE_1___default().navbar_item),\n                            href: \"/calendar\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                src: \"/icons/calendar-icon.png\",\n                                alt: \"Calednar\",\n                                width: \"30\",\n                                height: \"30\"\n                            }, void 0, false, {\n                                fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n                                lineNumber: 13,\n                                columnNumber: 75\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n                            lineNumber: 13,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                            className: (_nav_module_css__WEBPACK_IMPORTED_MODULE_1___default().navbar_item),\n                            href: \"/activity_analysis\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                src: \"/icons/analytics-icon.png\",\n                                alt: \"Analytics\",\n                                width: \"30\",\n                                height: \"30\"\n                            }, void 0, false, {\n                                fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n                                lineNumber: 14,\n                                columnNumber: 84\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n                            lineNumber: 14,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                            className: (_nav_module_css__WEBPACK_IMPORTED_MODULE_1___default().navbar_item),\n                            href: \"/time_matcher\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                src: \"/icons/matcher-icon.png\",\n                                alt: \"Matcher\",\n                                width: \"30\",\n                                height: \"30\"\n                            }, void 0, false, {\n                                fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n                                lineNumber: 15,\n                                columnNumber: 79\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n                            lineNumber: 15,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                            className: (_nav_module_css__WEBPACK_IMPORTED_MODULE_1___default().navbar_item),\n                            href: \"/time_finder\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                src: \"/icons/finder-icon.png\",\n                                alt: \"finder\",\n                                width: \"30\",\n                                height: \"30\"\n                            }, void 0, false, {\n                                fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n                                lineNumber: 16,\n                                columnNumber: 78\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n                            lineNumber: 16,\n                            columnNumber: 21\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n                    lineNumber: 11,\n                    columnNumber: 17\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_nav_module_css__WEBPACK_IMPORTED_MODULE_1___default().navbar_section),\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                        className: (_nav_module_css__WEBPACK_IMPORTED_MODULE_1___default().navbar_item),\n                        href: \"/\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                            src: \"/logo.png\",\n                            alt: \"HomeIcon\",\n                            width: \"42\",\n                            height: \"48\"\n                        }, void 0, false, {\n                            fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n                            lineNumber: 19,\n                            columnNumber: 67\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n                        lineNumber: 19,\n                        columnNumber: 21\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n                    lineNumber: 18,\n                    columnNumber: 17\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/bryce/Documents/Repos/timespark/frontend/src/app/components/nav/nav.js\",\n            lineNumber: 10,\n            columnNumber: 13\n        }, this)\n    }, void 0, false);\n} // <div className={styles.navbar}>\n //                 <div>\n //                     <div>\n //                         <Link href=\"/dashboard\"><Image src={`/icons/dashboard-icon.png`} alt={\"Home\"} width=\"32\" height=\"32\" /></Link>\n //                     </div>\n //                     <div>\n //                         <Link href=\"/calendar\"><Image src={`/icons/calendar-icon.png`} alt={\"Calednar\"} width=\"32\" height=\"32\" /></Link>\n //                     </div>\n //                     <div>\n //                         <Link href=\"/activity_analysis\"><Image src={`/icons/analytics-icon.png`} alt={\"Analytics\"} width=\"32\" height=\"32\" /></Link>\n //                     </div>\n //                     <div>\n //                         <Link href=\"/time_matcher\"><Image src={`/icons/matcher-icon.png`} alt={\"Matcher\"} width=\"32\" height=\"32\" /></Link>\n //                     </div>\n //                     <div>\n //                         <Link href=\"/time_finder\"><Image src={`/icons/finder-icon.png`} alt={\"finder\"} width=\"32\" height=\"32\" /></Link>\n //                     </div>\n //                 </div>\n //                 <div>\n //                     <div>\n //                         <Link href=\"/\">\n //                             <Image src={`/icons/logo.png`} alt={\"HomeIcon\"} style={{marginBottom: -30430, paddingLeft: 5}}width=\"32\" height=\"32\" />\n //                         </Link>\n //                     </div>\n //                 </div>\n //             </div>\n_c = Navbar;\nvar _c;\n$RefreshReg$(_c, \"Navbar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50cy9uYXYvbmF2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDcUM7QUFDVDtBQUNFO0FBR2YsU0FBU0c7SUFDcEIscUJBQ0k7a0JBQ0ksNEVBQUNDO1lBQUlDLFdBQVdMLCtEQUFhOzs4QkFDekIsOERBQUNJO29CQUFJQyxXQUFXTCx1RUFBcUI7O3NDQUNqQyw4REFBQ0MsaURBQUlBOzRCQUFDSSxXQUFXTCxvRUFBa0I7NEJBQUVTLE1BQUs7c0NBQWEsNEVBQUNQLGtEQUFLQTtnQ0FBQ1EsS0FBTTtnQ0FBNEJDLEtBQUs7Z0NBQVFDLE9BQU07Z0NBQUtDLFFBQU87Ozs7Ozs7Ozs7O3NDQUMvSCw4REFBQ1osaURBQUlBOzRCQUFDSSxXQUFXTCxvRUFBa0I7NEJBQUVTLE1BQUs7c0NBQVksNEVBQUNQLGtEQUFLQTtnQ0FBQ1EsS0FBTTtnQ0FBMkJDLEtBQUs7Z0NBQVlDLE9BQU07Z0NBQUtDLFFBQU87Ozs7Ozs7Ozs7O3NDQUNqSSw4REFBQ1osaURBQUlBOzRCQUFDSSxXQUFXTCxvRUFBa0I7NEJBQUVTLE1BQUs7c0NBQXFCLDRFQUFDUCxrREFBS0E7Z0NBQUNRLEtBQU07Z0NBQTRCQyxLQUFLO2dDQUFhQyxPQUFNO2dDQUFLQyxRQUFPOzs7Ozs7Ozs7OztzQ0FDNUksOERBQUNaLGlEQUFJQTs0QkFBQ0ksV0FBV0wsb0VBQWtCOzRCQUFFUyxNQUFLO3NDQUFnQiw0RUFBQ1Asa0RBQUtBO2dDQUFDUSxLQUFNO2dDQUEwQkMsS0FBSztnQ0FBV0MsT0FBTTtnQ0FBS0MsUUFBTzs7Ozs7Ozs7Ozs7c0NBQ25JLDhEQUFDWixpREFBSUE7NEJBQUNJLFdBQVdMLG9FQUFrQjs0QkFBRVMsTUFBSztzQ0FBZSw0RUFBQ1Asa0RBQUtBO2dDQUFDUSxLQUFNO2dDQUF5QkMsS0FBSztnQ0FBVUMsT0FBTTtnQ0FBS0MsUUFBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7OEJBRXBJLDhEQUFDVDtvQkFBSUMsV0FBV0wsdUVBQXFCOzhCQUNqQyw0RUFBQ0MsaURBQUlBO3dCQUFDSSxXQUFXTCxvRUFBa0I7d0JBQUVTLE1BQUs7a0NBQUksNEVBQUNQLGtEQUFLQTs0QkFBQ1EsS0FBTTs0QkFBWUMsS0FBSzs0QkFBWUMsT0FBTTs0QkFBS0MsUUFBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLOUgsRUFFQSxrQ0FBa0M7Q0FDbEMsd0JBQXdCO0NBQ3hCLDRCQUE0QjtDQUM1Qix5SUFBeUk7Q0FDekksNkJBQTZCO0NBQzdCLDRCQUE0QjtDQUM1QiwySUFBMkk7Q0FDM0ksNkJBQTZCO0NBQzdCLDRCQUE0QjtDQUM1QixzSkFBc0o7Q0FDdEosNkJBQTZCO0NBQzdCLDRCQUE0QjtDQUM1Qiw2SUFBNkk7Q0FDN0ksNkJBQTZCO0NBQzdCLDRCQUE0QjtDQUM1QiwwSUFBMEk7Q0FDMUksNkJBQTZCO0NBQzdCLHlCQUF5QjtDQUN6Qix3QkFBd0I7Q0FDeEIsNEJBQTRCO0NBQzVCLDBDQUEwQztDQUMxQyxzSkFBc0o7Q0FDdEosa0NBQWtDO0NBQ2xDLDZCQUE2QjtDQUM3Qix5QkFBeUI7Q0FDekIscUJBQXFCO0tBNUNHViIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL2NvbXBvbmVudHMvbmF2L25hdi5qcz83NDk2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0IHN0eWxlcyBmcm9tIFwiLi9uYXYubW9kdWxlLmNzc1wiXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnXG5pbXBvcnQgSW1hZ2UgZnJvbSAnbmV4dC9pbWFnZSdcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBOYXZiYXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubmF2YmFyfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLm5hdmJhcl9zZWN0aW9ufT5cbiAgICAgICAgICAgICAgICAgICAgPExpbmsgY2xhc3NOYW1lPXtzdHlsZXMubmF2YmFyX2l0ZW19IGhyZWY9XCIvZGFzaGJvYXJkXCI+PEltYWdlIHNyYz17YC9pY29ucy9kYXNoYm9hcmQtaWNvbi5wbmdgfSBhbHQ9e1wiSG9tZVwifSB3aWR0aD1cIjMwXCIgaGVpZ2h0PVwiMzBcIiAvPjwvTGluaz5cbiAgICAgICAgICAgICAgICAgICAgPExpbmsgY2xhc3NOYW1lPXtzdHlsZXMubmF2YmFyX2l0ZW19IGhyZWY9XCIvY2FsZW5kYXJcIj48SW1hZ2Ugc3JjPXtgL2ljb25zL2NhbGVuZGFyLWljb24ucG5nYH0gYWx0PXtcIkNhbGVkbmFyXCJ9IHdpZHRoPVwiMzBcIiBoZWlnaHQ9XCIzMFwiIC8+PC9MaW5rPlxuICAgICAgICAgICAgICAgICAgICA8TGluayBjbGFzc05hbWU9e3N0eWxlcy5uYXZiYXJfaXRlbX0gaHJlZj1cIi9hY3Rpdml0eV9hbmFseXNpc1wiPjxJbWFnZSBzcmM9e2AvaWNvbnMvYW5hbHl0aWNzLWljb24ucG5nYH0gYWx0PXtcIkFuYWx5dGljc1wifSB3aWR0aD1cIjMwXCIgaGVpZ2h0PVwiMzBcIiAvPjwvTGluaz5cbiAgICAgICAgICAgICAgICAgICAgPExpbmsgY2xhc3NOYW1lPXtzdHlsZXMubmF2YmFyX2l0ZW19IGhyZWY9XCIvdGltZV9tYXRjaGVyXCI+PEltYWdlIHNyYz17YC9pY29ucy9tYXRjaGVyLWljb24ucG5nYH0gYWx0PXtcIk1hdGNoZXJcIn0gd2lkdGg9XCIzMFwiIGhlaWdodD1cIjMwXCIgLz48L0xpbms+XG4gICAgICAgICAgICAgICAgICAgIDxMaW5rIGNsYXNzTmFtZT17c3R5bGVzLm5hdmJhcl9pdGVtfSBocmVmPVwiL3RpbWVfZmluZGVyXCI+PEltYWdlIHNyYz17YC9pY29ucy9maW5kZXItaWNvbi5wbmdgfSBhbHQ9e1wiZmluZGVyXCJ9IHdpZHRoPVwiMzBcIiBoZWlnaHQ9XCIzMFwiIC8+PC9MaW5rPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubmF2YmFyX3NlY3Rpb259PiAgIFxuICAgICAgICAgICAgICAgICAgICA8TGluayBjbGFzc05hbWU9e3N0eWxlcy5uYXZiYXJfaXRlbX0gaHJlZj1cIi9cIj48SW1hZ2Ugc3JjPXtgL2xvZ28ucG5nYH0gYWx0PXtcIkhvbWVJY29uXCJ9IHdpZHRoPVwiNDJcIiBoZWlnaHQ9XCI0OFwiIC8+PC9MaW5rPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvPlxuICAgICk7XG59XG5cbi8vIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubmF2YmFyfT5cbi8vICAgICAgICAgICAgICAgICA8ZGl2PlxuLy8gICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgPExpbmsgaHJlZj1cIi9kYXNoYm9hcmRcIj48SW1hZ2Ugc3JjPXtgL2ljb25zL2Rhc2hib2FyZC1pY29uLnBuZ2B9IGFsdD17XCJIb21lXCJ9IHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIC8+PC9MaW5rPlxuLy8gICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbi8vICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIDxMaW5rIGhyZWY9XCIvY2FsZW5kYXJcIj48SW1hZ2Ugc3JjPXtgL2ljb25zL2NhbGVuZGFyLWljb24ucG5nYH0gYWx0PXtcIkNhbGVkbmFyXCJ9IHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIC8+PC9MaW5rPlxuLy8gICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbi8vICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIDxMaW5rIGhyZWY9XCIvYWN0aXZpdHlfYW5hbHlzaXNcIj48SW1hZ2Ugc3JjPXtgL2ljb25zL2FuYWx5dGljcy1pY29uLnBuZ2B9IGFsdD17XCJBbmFseXRpY3NcIn0gd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgLz48L0xpbms+XG4vLyAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuLy8gICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgPExpbmsgaHJlZj1cIi90aW1lX21hdGNoZXJcIj48SW1hZ2Ugc3JjPXtgL2ljb25zL21hdGNoZXItaWNvbi5wbmdgfSBhbHQ9e1wiTWF0Y2hlclwifSB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiAvPjwvTGluaz5cbi8vICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4vLyAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICA8TGluayBocmVmPVwiL3RpbWVfZmluZGVyXCI+PEltYWdlIHNyYz17YC9pY29ucy9maW5kZXItaWNvbi5wbmdgfSBhbHQ9e1wiZmluZGVyXCJ9IHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIC8+PC9MaW5rPlxuLy8gICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbi8vICAgICAgICAgICAgICAgICA8L2Rpdj5cbi8vICAgICAgICAgICAgICAgICA8ZGl2PlxuLy8gICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgPExpbmsgaHJlZj1cIi9cIj5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SW1hZ2Ugc3JjPXtgL2ljb25zL2xvZ28ucG5nYH0gYWx0PXtcIkhvbWVJY29uXCJ9IHN0eWxlPXt7bWFyZ2luQm90dG9tOiAtMzA0MzAsIHBhZGRpbmdMZWZ0OiA1fX13aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiAvPlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgPC9MaW5rPlxuLy8gICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbi8vICAgICAgICAgICAgICAgICA8L2Rpdj5cbi8vICAgICAgICAgICAgIDwvZGl2PiJdLCJuYW1lcyI6WyJzdHlsZXMiLCJMaW5rIiwiSW1hZ2UiLCJOYXZiYXIiLCJkaXYiLCJjbGFzc05hbWUiLCJuYXZiYXIiLCJuYXZiYXJfc2VjdGlvbiIsIm5hdmJhcl9pdGVtIiwiaHJlZiIsInNyYyIsImFsdCIsIndpZHRoIiwiaGVpZ2h0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/components/nav/nav.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/add-locale.js":
/*!******************************************************!*\
  !*** ../node_modules/next/dist/client/add-locale.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addLocale\", ({\n    enumerable: true,\n    get: function() {\n        return addLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/../node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst addLocale = function(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) {}\n    return path;\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtbG9jYWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7NkNBR2FBOzs7ZUFBQUE7OztvREFGOEI7QUFFcEMsTUFBTUEsWUFBdUIsU0FBQ0MsSUFBQUE7cUNBQVNDLE9BQUFBLElBQUFBLE1BQUFBLE9BQUFBLElBQUFBLE9BQUFBLElBQUFBLElBQUFBLE9BQUFBLEdBQUFBLE9BQUFBLE1BQUFBLE9BQUFBO1FBQUFBLElBQUFBLENBQUFBLE9BQUFBLEVBQUFBLEdBQUFBLFNBQUFBLENBQUFBLEtBQUFBOztJQUM1QyxJQUFJQyxLQUErQixFQUFFLEVBSXJDO0lBQ0EsT0FBT0Y7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NsaWVudC9hZGQtbG9jYWxlLnRzP2ZhYWUiXSwibmFtZXMiOlsiYWRkTG9jYWxlIiwicGF0aCIsImFyZ3MiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/get-domain-locale.js":
/*!*************************************************************!*\
  !*** ../node_modules/next/dist/client/get-domain-locale.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/../node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQU9nQkE7OztlQUFBQTs7O29EQUoyQjtBQUUzQyxNQUFNQyxXQUFXQyxNQUFtQyxJQUFlO0FBRTVELFNBQVNGLGdCQUNkSyxJQUFZLEVBQ1pDLE1BQXVCLEVBQ3ZCQyxPQUFrQixFQUNsQkMsYUFBOEI7SUFFOUIsSUFBSU4sS0FBK0IsRUFBRSxFQWdCckMsTUFBTztRQUNMLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLnRzPzFkNGUiXSwibmFtZXMiOlsiZ2V0RG9tYWluTG9jYWxlIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicmVxdWlyZSIsImRldGVjdERvbWFpbkxvY2FsZSIsInRhcmdldCIsImRldGVjdGVkTG9jYWxlIiwiZG9tYWluIiwidW5kZWZpbmVkIiwicHJvdG8iLCJodHRwIiwiZmluYWxMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/image-component.js":
/*!***********************************************************!*\
  !*** ../node_modules/next/dist/client/image-component.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/head.js\"));\nconst _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/image-config.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/image-loader.js\"));\n// This is replaced by webpack define plugin\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]};\nif (typeof window === \"undefined\") {\n    globalThis.__NEXT_IMAGE_IMPORTED = true;\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {\n    const src = img == null ? void 0 : img.src;\n    if (!img || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    const p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== \"empty\") {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event(\"load\");\n            Object.defineProperty(event, \"target\", {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current({\n                ...event,\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            });\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            const origSrc = new URL(src, \"http://n\").searchParams.get(\"url\") || src;\n            if (img.getAttribute(\"data-nimg\") === \"fill\") {\n                if (!unoptimized && (!sizesInput || sizesInput === \"100vw\")) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        if (sizesInput === \"100vw\") {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        } else {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        }\n                    }\n                }\n                if (img.parentElement) {\n                    const { position } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        \"absolute\",\n                        \"fixed\",\n                        \"relative\"\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(\",\") + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute(\"height\");\n            const widthModified = img.width.toString() !== img.getAttribute(\"width\");\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    if (Boolean(_react.use)) {\n        // In React 19.0.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nconst ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{\n    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, sizesInput, onLoad, onError, ...rest } = param;\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", {\n        ...rest,\n        ...getDynamicProps(fetchPriority),\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? \"fill\" : \"1\",\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: (0, _react.useCallback)((img)=>{\n            if (forwardedRef) {\n                if (typeof forwardedRef === \"function\") forwardedRef(img);\n                else if (typeof forwardedRef === \"object\") {\n                    // @ts-ignore - .current is read only it's usually assigned by react internally\n                    forwardedRef.current = img;\n                }\n            }\n            if (!img) {\n                return;\n            }\n            if (onError) {\n                // If the image has an error before react hydrates, then the error is lost.\n                // The workaround is to wait until the image is mounted which is after hydration,\n                // then we set the src again to trigger the error handler (if there was an error).\n                // eslint-disable-next-line no-self-assign\n                img.src = img.src;\n            }\n            if (true) {\n                if (!src) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n                if (img.getAttribute(\"alt\") === null) {\n                    console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n                }\n            }\n            if (img.complete) {\n                handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n            }\n        }, [\n            src,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            onError,\n            unoptimized,\n            sizesInput,\n            forwardedRef\n        ]),\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        },\n        onError: (event)=>{\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== \"empty\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    });\n});\nfunction ImagePreload(param) {\n    let { isAppRouter, imgAttributes } = param;\n    const opts = {\n        as: \"image\",\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy,\n        ...getDynamicProps(imgAttributes.fetchPriority)\n    };\n    if (isAppRouter && _reactdom.default.preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom.default.preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n            ...opts\n        }, \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nconst Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{\n    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }, [\n        configContext\n    ]);\n    const { onLoad, onLoadingComplete } = props;\n    const onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [showAltText, setShowAltText] = (0, _react.useState)(false);\n    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader.default,\n        imgConf: config,\n        blurComplete,\n        showAltText\n    });\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {\n                ...imgAttributes,\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                sizesInput: props.sizes,\n                ref: forwardedRef\n            }),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbWFnZS1jb21wb25lbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7K0VBYWlCO3FEQUNXQSxDQUFBLENBQUFDLG1CQUFBQSxDQUFBO3lDQVlPOzt5Q0FFVkEsbUJBQUFBLENBQUE7OztBQU16QixNQUFBQyxlQUFBLGNBQUFDLHlCQUE0Q0gsQ0FBQSxDQUFBQyxtQkFBQUEsQ0FBQTtBQUM1Qyw0Q0FBOEJHO0FBRTlCLE1BQUlDLFlBQU9DLDBOQUF3QjtJQUMvQkUsT0FBQUEsV0FBbUJDLGFBQUFBO0lBQ3ZCRCxXQUFBQyxxQkFBQTtBQW1CQTtBQUNBLDBFQUFpRDtBQUNqRCxpREFHRUM7U0FNQUMsY0FBWUMsR0FBQUEsRUFBQUEsV0FBQUEsRUFBQUEsU0FBUSxFQUFBQyxvQkFBQSxFQUFBQyxlQUFBLEVBQUFDLFdBQUEsRUFBQUMsVUFBQTtJQUNwQixNQUFLSixNQUFPQSxPQUFJLGdCQUFrQkEsSUFBS0ssR0FBQUE7UUFDckMsQ0FBQUwsT0FBQUEsR0FBQSx3QkFBQUssS0FBQTtRQUNGO0lBQ0FMO0lBQ0FBLEdBQUEsbUJBQXNCQSxHQUFBQTtJQUN0Qk0sTUFBRUMsSUFBTSxZQUFlUCxNQUFBQSxJQUFBUSxNQUFBLEtBQUFDLFFBQUFDLE9BQUE7V0FDckIsQ0FBSSxLQUFLQyxHQUFBQSxJQUFBQSxDQUFBQTtZQUNQLENBQUFYLElBQUFXLGFBQUEsS0FBQVgsSUFBQVksV0FBQSxFQUF3QztZQUN4Qyx3Q0FBdUI7WUFDdkI7WUFDQSxzQ0FBc0I7WUFDdEI7WUFDQTtZQUNGO1FBQ0E7WUFDRVYsZ0JBQWdCO1lBQ2xCQSxnQkFBQTtRQUNBO1lBQ0VKLGFBQUEsZ0JBQUFBLFVBQUFlLE9BQUEsRUFBK0M7WUFDL0MsK0NBQTBDO1lBQzFDO1lBQ0EsMkNBQXdCO1lBQ3hCQyxNQUFBQSxRQUFPQyxJQUFBQSxNQUFlQzttQkFBbUJDLGNBQVUsQ0FBQUQsT0FBQTtnQkFB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QUErRCxjQUFBO2dCQUNqQjNILEdBQUFBLGFBQWFvSDtnQkFDYjlDLGFBQWE4QyxRQUFROUMsV0FBVztnQkFDaENzRCxhQUFNUixRQUFZOUMsV0FBQTtnQkFDbEIzRSxNQUFBQSxRQUFXQSxJQUFBQTtnQkFDWEcsV0FBQUE7Z0JBQ0FDLHNCQUFpQkE7Z0JBQ2pCeUUsaUJBQWdCQTtnQkFDaEJ2RSxnQkFBWXVIO2dCQUNaeEQsWUFBS0UsTUFBQUEsS0FBQUE7O1lBR1JrRDtvQkFFR2xDLFFBQUFBLEdBQWFBLFdBQUFBLEdBQUFBLENBQUFBLEdBQUFBLFlBQUFBLEdBQUFBLEVBQUFBLGNBQUFBO2dCQUNiUCxhQUFBQTsrQkFFQUE7OztJQUdWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L2ltYWdlLWNvbXBvbmVudC50c3g/NTFlMSJdLCJuYW1lcyI6WyJfIiwicmVxdWlyZSIsIl9pbWFnZWxvYWRlciIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl9fTkVYVF9JTUFHRV9PUFRTIiwiY29uZmlnRW52Iiwid2luZG93IiwiZW52IiwiZ2xvYmFsVGhpcyIsIl9fTkVYVF9JTUFHRV9JTVBPUlRFRCIsIm9uTG9hZFJlZiIsImhhbmRsZUxvYWRpbmciLCJpbWciLCJvbkxvYWRpbmdDb21wbGV0ZVJlZiIsInNldEJsdXJDb21wbGV0ZSIsInVub3B0aW1pemVkIiwic2l6ZXNJbnB1dCIsInNyYyIsInAiLCJjYXRjaCIsImRlY29kZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicGFyZW50RWxlbWVudCIsImlzQ29ubmVjdGVkIiwiY3VycmVudCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXZlbnQiLCJ3cml0YWJsZSIsInZhbHVlIiwic3RvcHBlZCIsIm5hdGl2ZUV2ZW50IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImlzRGVmYXVsdFByZXZlbnRlZCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwicHJldmVudGVkIiwicGVyc2lzdCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwicHJvY2VzcyIsImdldEF0dHJpYnV0ZSIsIlVSTCIsInNlYXJjaFBhcmFtcyIsImdldCIsIndpZHRoVmlld3BvcnRSYXRpbyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwiaW5uZXJXaWR0aCIsIndhcm5PbmNlIiwiX3dhcm5vbmNlIiwib3JpZ1NyYyIsInZhbGlkIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInBvc2l0aW9uIiwibWFwIiwiU3RyaW5nIiwiam9pbiIsIndpZHRoTW9kaWZpZWQiLCJ0b1N0cmluZyIsImhlaWdodE1vZGlmaWVkIiwiQm9vbGVhbiIsInVzZSIsIl9yZWFjdCIsImZldGNoUHJpb3JpdHkiLCJmZXRjaHByaW9yaXR5IiwiaGVpZ2h0IiwiZGVjb2RpbmciLCJjbGFzc05hbWUiLCJzdHlsZSIsInNyY1NldCIsInNpemVzIiwicmVzdCIsIl9qc3hydW50aW1lIiwianN4IiwiZ2V0RHluYW1pY1Byb3BzIiwibG9hZGluZyIsImRhdGEtbmltZyIsInJlZiIsInVzZUNhbGxiYWNrIiwiZm9yd2FyZGVkUmVmIiwib25FcnJvciIsImNvbnNvbGUiLCJlcnJvciIsInBsYWNlaG9sZGVyIiwib25Mb2FkIiwic2V0U2hvd0FsdFRleHQiLCJJbWFnZVByZWxvYWQiLCJwYXJhbSIsImltZ0F0dHJpYnV0ZXMiLCJvcHRzIiwiYXMiLCJpbWFnZVNyY1NldCIsImltYWdlU2l6ZXMiLCJjcm9zc09yaWdpbiIsInJlZmVycmVyUG9saWN5IiwiaXNBcHBSb3V0ZXIiLCJfcmVhY3Rkb20iLCJkZWZhdWx0IiwicHJlbG9hZCIsIlJlYWN0RE9NIiwiX2hlYWQiLCJsaW5rIiwicmVsIiwiaHJlZiIsInVuZGVmaW5lZCIsIkltYWdlIiwidXNlQ29udGV4dCIsInBhZ2VzUm91dGVyIiwiUm91dGVyQ29udGV4dCIsIl9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSIsImNvbmZpZ0NvbnRleHQiLCJjb25maWciLCJ1c2VNZW1vIiwiX2ltYWdlY29uZmlnY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJJbWFnZUNvbmZpZ0NvbnRleHQiLCJhbGxTaXplcyIsIl9pbWFnZWNvbmZpZyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImRldmljZVNpemVzIiwiYyIsImEiLCJiIiwic29ydCIsInVzZVJlZiIsInVzZUVmZmVjdCIsIm9uTG9hZGluZ0NvbXBsZXRlIiwic2hvd0FsdFRleHQiLCJ1c2VTdGF0ZSIsIm1ldGEiLCJpbWdNZXRhIiwiZ2V0SW1nUHJvcHMiLCJkZWZhdWx0TG9hZGVyIiwiX2dldGltZ3Byb3BzIiwicHJvcHMiLCJpbWdDb25mIiwiYmx1ckNvbXBsZXRlIiwiSW1hZ2VFbGVtZW50IiwiZmlsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/link.js":
/*!************************************************!*\
  !*** ../node_modules/next/dist/client/link.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\"));\nconst _resolvehref = __webpack_require__(/*! ./resolve-href */ \"(app-pages-browser)/../node_modules/next/dist/client/resolve-href.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/utils.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"(app-pages-browser)/../node_modules/next/dist/client/add-locale.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _useintersection = __webpack_require__(/*! ./use-intersection */ \"(app-pages-browser)/../node_modules/next/dist/client/use-intersection.js\");\nconst _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"(app-pages-browser)/../node_modules/next/dist/client/get-domain-locale.js\");\nconst _addbasepath = __webpack_require__(/*! ./add-base-path */ \"(app-pages-browser)/../node_modules/next/dist/client/add-base-path.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./components/router-reducer/router-reducer-types */ \"(app-pages-browser)/../node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, appOptions, isAppRouter) {\n    if (typeof window === \"undefined\") {\n        return;\n    }\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    const doPrefetch = async ()=>{\n        if (isAppRouter) {\n            // note that `appRouter.prefetch()` is currently sync,\n            // so we have to wrap this call in an async function to be able to catch() errors below.\n            return router.prefetch(href, appOptions);\n        } else {\n            return router.prefetch(href, as, options);\n        }\n    };\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    doPrefetch().catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browser’s default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        const routerScroll = scroll != null ? scroll : true;\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow,\n                locale,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                scroll: routerScroll\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * A React component that extends the HTML `<a>` element to provide [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation between routes.\n *\n * It is the primary way to navigate between routes in Next.js.\n *\n * Read more: [Next.js docs: `<Link>`](https://nextjs.org/docs/app/api-reference/components/link)\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    let children;\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, locale, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const pagesRouter = _react.default.useContext(_routercontextsharedruntime.RouterContext);\n    const appRouter = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + (typeof window !== \"undefined\" ? \"\\nOpen your browser's console to view the Component stack trace.\" : \"\"));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current && !isAppRouter) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    if (true) {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + (typeof window !== \"undefined\" ? \" \\nOpen your browser's console to view the Component stack trace.\" : \"\"));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, {\n            kind: appPrefetchKind\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter,\n        appPrefetchKind\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if ((!prefetchEnabled || \"development\" === \"development\") && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        },\n        onTouchStart:  false ? 0 : function onTouchStart(e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n        ...restProps,\n        ...childProps,\n        children: children\n    });\n}, \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\")), \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\");\n_c1 = Link;\nconst _default = Link;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OzZCQVM0QkEseUJBQUFDLENBQUEsQ0FBQUMsbUJBQUFBLENBQUE7eUNBQ0Q7d0NBQ0Q7dUNBQ0k7Ozs7dUNBUUVBLG1CQUFBQSxDQUFBOzZDQUNBOzZDQUNKOztBQW1HNUIsTUFBTUMsc0JBQWlCQyxtQkFBQUEsQ0FBQUEsZ0tBQUFBO0FBVXZCLE1BQUFELGFBQ0VFLElBQUFBO1NBT0lDLFNBQU9DLE1BQUFBLEVBQVdDLElBQUEsRUFBQUMsRUFBQSxFQUFBQyxPQUFhLEVBQUFDLFVBQUEsRUFBQUMsV0FBQTtRQUNqQyxPQUFBTCxXQUFBO1FBQ0Y7SUFFQTtJQUNBLGdKQUF1QztRQUNyQyxDQUFBSyxlQUFBLEtBQUFDLFlBQUFDLFVBQUEsRUFBQU4sT0FBQTtRQUNGO0lBRUE7SUFDQSw0RUFBWTtJQUNaLFlBQUtFO1FBQ0gsQ0FBQUEsUUFBTUsscUJBQ0o7UUFDQSxNQUFBQSxTQU9GLE9BQU1DLFFBQUFBLE1BQUFBLEtBQWdCUixjQUFrQkUsUUFBTUssTUFBQUEsR0FBQUEsWUFBQUEsU0FBQUEsT0FBQUEsTUFBQUEsR0FBQUE7UUFFOUMsTUFBQUMsZ0JBQUFSLE9BQUEsTUFBQUMsS0FBQSxNQUFBTTtRQUNBLGtFQUFtQztZQUNqQ1osV0FBQWMsR0FBQSxDQUFBRCxnQkFBQTtZQUNGO1FBRUE7UUFDQWIsK0JBQWVhO1FBQ2pCYixXQUFBZSxHQUFBLENBQUFGO0lBRUE7VUFDRUcsYUFBSVA7WUFDRkEsYUFBQTtZQUNBO1lBQ0Esd0ZBQW9ERDtZQUN0RCxPQUFPTixPQUFBQyxRQUFBLENBQUFFLE1BQUFHO2VBQ0w7WUFDRixPQUFBTixPQUFBQyxRQUFBLENBQUFFLE1BQUFDLElBQUFDO1FBQ0Y7SUFFQTtJQUNBO0lBQ0EsMERBQXNEO0lBQ3REO0lBQ0FTLHlEQUFvQkM7aUJBQ2RDLEtBQVFDLENBQUcsQ0FBQ0M7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LGNBQUE1RixPQUFBQyxPQUFBLENBQUE0RixZQUFBLENBQUFyQyxPQUFBd0IsY0FBQSxrQkFBQWMsWUFBQUMsR0FBQTtRQUFHLEdBQUdmLFNBQUFBO3FCQUNuQnpFOztJQUdQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L2xpbmsudHN4P2FjZjAiXSwibmFtZXMiOlsiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiXyIsInJlcXVpcmUiLCJwcmVmZXRjaGVkIiwiU2V0Iiwicm91dGVyIiwicHJlZmV0Y2giLCJ3aW5kb3ciLCJocmVmIiwiYXMiLCJvcHRpb25zIiwiYXBwT3B0aW9ucyIsImlzQXBwUm91dGVyIiwiX2lzbG9jYWx1cmwiLCJpc0xvY2FsVVJMIiwibG9jYWxlIiwicHJlZmV0Y2hlZEtleSIsImhhcyIsImFkZCIsImRvUHJlZmV0Y2giLCJlcnIiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXQiLCJldmVudFRhcmdldCIsIm5hdGl2ZUV2ZW50Iiwid2hpY2giLCJtZXRhS2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJub2RlTmFtZSIsImlzQW5jaG9yTm9kZU5hbWUiLCJwcmV2ZW50RGVmYXVsdCIsIm5hdmlnYXRlIiwicm91dGVyU2Nyb2xsIiwiUmVhY3QiLCJfcmVhY3QiLCJkZWZhdWx0Iiwic3RhcnRUcmFuc2l0aW9uIiwiZm9ybWF0U3RyaW5nT3JVcmwiLCJ1cmxPYmpPclN0cmluZyIsIl9mb3JtYXR1cmwiLCJmb3JtYXRVcmwiLCJjaGlsZHJlbiIsImNoaWxkcmVuUHJvcCIsImxlZ2FjeUJlaGF2aW9yIiwiYSIsImFwcFJvdXRlciIsInVzZUNvbnRleHQiLCJBcHBSb3V0ZXJDb250ZXh0IiwicGFnZXNSb3V0ZXIiLCJwcmVmZXRjaEVuYWJsZWQiLCJwcmVmZXRjaFByb3AiLCJfcm91dGVycmVkdWNlcnR5cGVzIiwiUHJlZmV0Y2hLaW5kIiwiQVVUTyIsIkZVTEwiLCJhcmdzIiwiY3JlYXRlUHJvcEVycm9yIiwiRXJyb3IiLCJrZXkiLCJleHBlY3RlZCIsImFjdHVhbCIsInJlcXVpcmVkUHJvcHMiLCJPYmplY3QiLCJwcm9wcyIsInBhc3NIcmVmIiwib25DbGljayIsIm9uTW91c2VFbnRlciIsIm9uVG91Y2hTdGFydCIsIm9wdGlvbmFsUHJvcHMiLCJ2YWxUeXBlIiwiaGFzV2FybmVkIiwiY3VycmVudCIsImNvbnNvbGUiLCJ3YXJuIiwiYXNQcm9wIiwiaHJlZlByb3AiLCJwYXRobmFtZSIsImhhc0R5bmFtaWNTZWdtZW50Iiwic3BsaXQiLCJzb21lIiwic2VnbWVudCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInVzZU1lbW8iLCJyZXNvbHZlZEhyZWYiLCJyZXNvbHZlZEFzIiwiX3Jlc29sdmVocmVmIiwicmVzb2x2ZUhyZWYiLCJwcmV2aW91c0FzIiwidXNlUmVmIiwiY2hpbGQiLCJDaGlsZHJlbiIsIm9ubHkiLCJ0eXBlIiwiY2hpbGRSZWYiLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJpc1Zpc2libGUiLCJyZXNldFZpc2libGUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJyb290TWFyZ2luIiwiX3VzZWludGVyc2VjdGlvbiIsInNldFJlZiIsInVzZUNhbGxiYWNrIiwiZWwiLCJwcmV2aW91c0hyZWYiLCJ1c2VFZmZlY3QiLCJhcHBQcmVmZXRjaEtpbmQiLCJyZWYiLCJkZWZhdWx0UHJldmVudGVkIiwib25Nb3VzZUVudGVyUHJvcCIsInByaW9yaXR5IiwiYnlwYXNzUHJlZmV0Y2hlZENoZWNrIiwib25Ub3VjaFN0YXJ0UHJvcCIsInVuZGVmaW5lZCIsImNoaWxkUHJvcHMiLCJjdXJMb2NhbGUiLCJpc0xvY2FsZURvbWFpbiIsImxvY2FsZURvbWFpbiIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwiX2dldGRvbWFpbmxvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIl9hZGRiYXNlcGF0aCIsIl9hZGRsb2NhbGUiLCJyZXN0UHJvcHMiLCJjbG9uZUVsZW1lbnQiLCJfanN4cnVudGltZSIsImpzeCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/request-idle-callback.js":
/*!*****************************************************************!*\
  !*** ../node_modules/next/dist/client/request-idle-callback.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    },\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZXF1ZXN0LWlkbGUtY2FsbGJhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBZ0JhQSxvQkFBa0I7ZUFBbEJBOztJQWhCQUMscUJBQW1CO2VBQW5CQTs7O0FBQU4sTUFBTUEsc0JBQ1gsT0FBUUMsU0FBUyxlQUNmQSxLQUFLRCxtQkFBbUIsSUFDeEJDLEtBQUtELG1CQUFtQixDQUFDRSxJQUFJLENBQUNDLFdBQ2hDLFNBQVVDLEVBQXVCO0lBQy9CLElBQUlDLFFBQVFDLEtBQUtDLEdBQUc7SUFDcEIsT0FBT04sS0FBS08sVUFBVSxDQUFDO1FBQ3JCSixHQUFHO1lBQ0RLLFlBQVk7WUFDWkMsZUFBZTtnQkFDYixPQUFPQyxLQUFLQyxHQUFHLENBQUMsR0FBRyxLQUFNTixDQUFBQSxLQUFLQyxHQUFHLEtBQUtGLEtBQUFBO1lBQ3hDO1FBQ0Y7SUFDRixHQUFHO0FBQ0w7QUFFSyxNQUFNTixxQkFDWCxPQUFRRSxTQUFTLGVBQ2ZBLEtBQUtGLGtCQUFrQixJQUN2QkUsS0FBS0Ysa0JBQWtCLENBQUNHLElBQUksQ0FBQ0MsV0FDL0IsU0FBVVUsRUFBVTtJQUNsQixPQUFPQyxhQUFhRDtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NsaWVudC9yZXF1ZXN0LWlkbGUtY2FsbGJhY2sudHM/MDVmNCJdLCJuYW1lcyI6WyJjYW5jZWxJZGxlQ2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwic2VsZiIsImJpbmQiLCJ3aW5kb3ciLCJjYiIsInN0YXJ0IiwiRGF0ZSIsIm5vdyIsInNldFRpbWVvdXQiLCJkaWRUaW1lb3V0IiwidGltZVJlbWFpbmluZyIsIk1hdGgiLCJtYXgiLCJpZCIsImNsZWFyVGltZW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/resolve-href.js":
/*!********************************************************!*\
  !*** ../node_modules/next/dist/client/resolve-href.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"resolveHref\", ({\n    enumerable: true,\n    get: function() {\n        return resolveHref;\n    }\n}));\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _omit = __webpack_require__(/*! ../shared/lib/router/utils/omit */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/utils.js\");\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/../node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _utils1 = __webpack_require__(/*! ../shared/lib/router/utils */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/index.js\");\nconst _interpolateas = __webpack_require__(/*! ../shared/lib/router/utils/interpolate-as */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split(\"?\", 1);\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n        let interpolatedAs = \"\";\n        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n            const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formaturl.formatWithValidation)({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit.omit)(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=resolve-href.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZXNvbHZlLWhyZWYuanMiLCJtYXBwaW5ncyI6Ijs7OzsrQ0F5QmdCQTs7O2VBQUFBOzs7eUNBdkJ1Qjt1Q0FDRjtrQ0FDaEI7bUNBQ29CO29EQUNFO3dDQUNoQjtvQ0FDSTsyQ0FDRDtBQWdCdkIsU0FBU0EsWUFDZEMsTUFBa0IsRUFDbEJDLElBQVMsRUFDVEMsU0FBbUI7SUFFbkIsNENBQTRDO0lBQzVDLElBQUlDO0lBQ0osSUFBSUMsY0FBYyxPQUFPSCxTQUFTLFdBQVdBLE9BQU9JLENBQUFBLEdBQUFBLFdBQUFBLG9CQUFvQixFQUFDSjtJQUV6RSw2REFBNkQ7SUFDN0QsbURBQW1EO0lBQ25ELE1BQU1LLGdCQUFnQkYsWUFBWUcsS0FBSyxDQUFDO0lBQ3hDLE1BQU1DLHFCQUFxQkYsZ0JBQ3ZCRixZQUFZSyxLQUFLLENBQUNILGFBQWEsQ0FBQyxFQUFFLENBQUNJLE1BQU0sSUFDekNOO0lBRUosTUFBTU8sV0FBV0gsbUJBQW1CSSxLQUFLLENBQUMsS0FBSztJQUUvQyxJQUFJLENBQUNELFFBQVEsQ0FBQyxFQUFFLElBQUksSUFBSUosS0FBSyxDQUFDLGNBQWM7UUFDMUNNLFFBQVFDLEtBQUssQ0FDWCxtQkFBaUJWLGNBQVksdUNBQW9DSixPQUFPZSxRQUFRLEdBQUM7UUFFbkYsTUFBTUMsZ0JBQWdCQyxDQUFBQSxHQUFBQSxPQUFBQSx3QkFBd0IsRUFBQ1Q7UUFDL0NKLGNBQWMsQ0FBQ0UsZ0JBQWdCQSxhQUFhLENBQUMsRUFBRSxHQUFHLE1BQU1VO0lBQzFEO0lBRUEsMkRBQTJEO0lBQzNELElBQUksQ0FBQ0UsQ0FBQUEsR0FBQUEsWUFBQUEsVUFBVSxFQUFDZCxjQUFjO1FBQzVCLE9BQVFGLFlBQVk7WUFBQ0U7U0FBWSxHQUFHQTtJQUN0QztJQUVBLElBQUk7UUFDRkQsT0FBTyxJQUFJZ0IsSUFDVGYsWUFBWWdCLFVBQVUsQ0FBQyxPQUFPcEIsT0FBT3FCLE1BQU0sR0FBR3JCLE9BQU9lLFFBQVEsRUFDN0Q7SUFFSixFQUFFLE9BQU9PLEdBQUc7UUFDVixrREFBa0Q7UUFDbERuQixPQUFPLElBQUlnQixJQUFJLEtBQUs7SUFDdEI7SUFFQSxJQUFJO1FBQ0YsTUFBTUksV0FBVyxJQUFJSixJQUFJZixhQUFhRDtRQUN0Q29CLFNBQVNSLFFBQVEsR0FBR1MsQ0FBQUEsR0FBQUEsd0JBQUFBLDBCQUEwQixFQUFDRCxTQUFTUixRQUFRO1FBQ2hFLElBQUlVLGlCQUFpQjtRQUVyQixJQUNFQyxDQUFBQSxHQUFBQSxRQUFBQSxjQUFjLEVBQUNILFNBQVNSLFFBQVEsS0FDaENRLFNBQVNJLFlBQVksSUFDckJ6QixXQUNBO1lBQ0EsTUFBTTBCLFFBQVFDLENBQUFBLEdBQUFBLGFBQUFBLHNCQUFzQixFQUFDTixTQUFTSSxZQUFZO1lBRTFELE1BQU0sRUFBRUcsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0MsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBYSxFQUN0Q1QsU0FBU1IsUUFBUSxFQUNqQlEsU0FBU1IsUUFBUSxFQUNqQmE7WUFHRixJQUFJRSxRQUFRO2dCQUNWTCxpQkFBaUJwQixDQUFBQSxHQUFBQSxXQUFBQSxvQkFBb0IsRUFBQztvQkFDcENVLFVBQVVlO29CQUNWRyxNQUFNVixTQUFTVSxJQUFJO29CQUNuQkwsT0FBT00sQ0FBQUEsR0FBQUEsTUFBQUEsSUFBSSxFQUFDTixPQUFPRztnQkFDckI7WUFDRjtRQUNGO1FBRUEsb0VBQW9FO1FBQ3BFLE1BQU1JLGVBQ0paLFNBQVNhLE1BQU0sS0FBS2pDLEtBQUtpQyxNQUFNLEdBQzNCYixTQUFTdEIsSUFBSSxDQUFDUSxLQUFLLENBQUNjLFNBQVNhLE1BQU0sQ0FBQzFCLE1BQU0sSUFDMUNhLFNBQVN0QixJQUFJO1FBRW5CLE9BQU9DLFlBQ0g7WUFBQ2lDO1lBQWNWLGtCQUFrQlU7U0FBYSxHQUM5Q0E7SUFDTixFQUFFLE9BQU9iLEdBQUc7UUFDVixPQUFPcEIsWUFBWTtZQUFDRTtTQUFZLEdBQUdBO0lBQ3JDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jbGllbnQvcmVzb2x2ZS1ocmVmLnRzP2U2ZDIiXSwibmFtZXMiOlsicmVzb2x2ZUhyZWYiLCJyb3V0ZXIiLCJocmVmIiwicmVzb2x2ZUFzIiwiYmFzZSIsInVybEFzU3RyaW5nIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJ1cmxQcm90b01hdGNoIiwibWF0Y2giLCJ1cmxBc1N0cmluZ05vUHJvdG8iLCJzbGljZSIsImxlbmd0aCIsInVybFBhcnRzIiwic3BsaXQiLCJjb25zb2xlIiwiZXJyb3IiLCJwYXRobmFtZSIsIm5vcm1hbGl6ZWRVcmwiLCJub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMiLCJpc0xvY2FsVVJMIiwiVVJMIiwic3RhcnRzV2l0aCIsImFzUGF0aCIsIl8iLCJmaW5hbFVybCIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwiaW50ZXJwb2xhdGVkQXMiLCJpc0R5bmFtaWNSb3V0ZSIsInNlYXJjaFBhcmFtcyIsInF1ZXJ5Iiwic2VhcmNoUGFyYW1zVG9VcmxRdWVyeSIsInJlc3VsdCIsInBhcmFtcyIsImludGVycG9sYXRlQXMiLCJoYXNoIiwib21pdCIsInJlc29sdmVkSHJlZiIsIm9yaWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/resolve-href.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/client/use-intersection.js":
/*!************************************************************!*\
  !*** ../node_modules/next/dist/client/use-intersection.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/../node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id, observer, elements } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef, rootMargin, disabled } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7bURBK0ZnQkE7OztlQUFBQTs7O21DQS9GeUM7aURBSWxEO0FBcUJQLE1BQU1DLDBCQUEwQixPQUFPQyx5QkFBeUI7QUFFaEUsTUFBTUMsWUFBWSxJQUFJQztBQUN0QixNQUFNQyxTQUF1QixFQUFFO0FBRS9CLFNBQVNDLGVBQWVDLE9BQW9DO0lBQzFELE1BQU1DLEtBQUs7UUFDVEMsTUFBTUYsUUFBUUUsSUFBSSxJQUFJO1FBQ3RCQyxRQUFRSCxRQUFRSSxVQUFVLElBQUk7SUFDaEM7SUFDQSxNQUFNQyxXQUFXUCxPQUFPUSxJQUFJLENBQzFCLENBQUNDLE1BQVFBLElBQUlMLElBQUksS0FBS0QsR0FBR0MsSUFBSSxJQUFJSyxJQUFJSixNQUFNLEtBQUtGLEdBQUdFLE1BQU07SUFFM0QsSUFBSUs7SUFFSixJQUFJSCxVQUFVO1FBQ1pHLFdBQVdaLFVBQVVhLEdBQUcsQ0FBQ0o7UUFDekIsSUFBSUcsVUFBVTtZQUNaLE9BQU9BO1FBQ1Q7SUFDRjtJQUVBLE1BQU1FLFdBQVcsSUFBSWI7SUFDckIsTUFBTWMsV0FBVyxJQUFJaEIscUJBQXFCLENBQUNpQjtRQUN6Q0EsUUFBUUMsT0FBTyxDQUFDLENBQUNDO1lBQ2YsTUFBTUMsV0FBV0wsU0FBU0QsR0FBRyxDQUFDSyxNQUFNRSxNQUFNO1lBQzFDLE1BQU1DLFlBQVlILE1BQU1JLGNBQWMsSUFBSUosTUFBTUssaUJBQWlCLEdBQUc7WUFDcEUsSUFBSUosWUFBWUUsV0FBVztnQkFDekJGLFNBQVNFO1lBQ1g7UUFDRjtJQUNGLEdBQUdqQjtJQUNIUSxXQUFXO1FBQ1RQO1FBQ0FVO1FBQ0FEO0lBQ0Y7SUFFQVosT0FBT3NCLElBQUksQ0FBQ25CO0lBQ1pMLFVBQVV5QixHQUFHLENBQUNwQixJQUFJTztJQUNsQixPQUFPQTtBQUNUO0FBRUEsU0FBU2MsUUFDUEMsT0FBZ0IsRUFDaEJSLFFBQXlCLEVBQ3pCZixPQUFvQztJQUVwQyxNQUFNLEVBQUVDLEVBQUUsRUFBRVUsUUFBUSxFQUFFRCxRQUFRLEVBQUUsR0FBR1gsZUFBZUM7SUFDbERVLFNBQVNXLEdBQUcsQ0FBQ0UsU0FBU1I7SUFFdEJKLFNBQVNXLE9BQU8sQ0FBQ0M7SUFDakIsT0FBTyxTQUFTQztRQUNkZCxTQUFTZSxNQUFNLENBQUNGO1FBQ2hCWixTQUFTYSxTQUFTLENBQUNEO1FBRW5CLHVEQUF1RDtRQUN2RCxJQUFJYixTQUFTZ0IsSUFBSSxLQUFLLEdBQUc7WUFDdkJmLFNBQVNnQixVQUFVO1lBQ25CL0IsVUFBVTZCLE1BQU0sQ0FBQ3hCO1lBQ2pCLE1BQU0yQixRQUFROUIsT0FBTytCLFNBQVMsQ0FDNUIsQ0FBQ3RCLE1BQVFBLElBQUlMLElBQUksS0FBS0QsR0FBR0MsSUFBSSxJQUFJSyxJQUFJSixNQUFNLEtBQUtGLEdBQUdFLE1BQU07WUFFM0QsSUFBSXlCLFFBQVEsQ0FBQyxHQUFHO2dCQUNkOUIsT0FBT2dDLE1BQU0sQ0FBQ0YsT0FBTztZQUN2QjtRQUNGO0lBQ0Y7QUFDRjtBQUVPLFNBQVNuQyxnQkFBbUNzQyxLQUlqQztJQUppQyxNQUNqREMsT0FBTyxFQUNQNUIsVUFBVSxFQUNWNkIsUUFBUSxFQUNRLEdBSmlDRjtJQUtqRCxNQUFNRyxhQUFzQkQsWUFBWSxDQUFDdkM7SUFFekMsTUFBTSxDQUFDeUMsU0FBU0MsV0FBVyxHQUFHQyxDQUFBQSxHQUFBQSxPQUFBQSxRQUFRLEVBQUM7SUFDdkMsTUFBTUMsYUFBYUMsQ0FBQUEsR0FBQUEsT0FBQUEsTUFBTSxFQUFXO0lBQ3BDLE1BQU1DLGFBQWFDLENBQUFBLEdBQUFBLE9BQUFBLFdBQVcsRUFBQyxDQUFDbEI7UUFDOUJlLFdBQVdJLE9BQU8sR0FBR25CO0lBQ3ZCLEdBQUcsRUFBRTtJQUVMb0IsQ0FBQUEsR0FBQUEsT0FBQUEsU0FBUyxFQUFDO1FBQ1IsSUFBSWpELHlCQUF5QjtZQUMzQixJQUFJd0MsY0FBY0MsU0FBUztZQUUzQixNQUFNWixVQUFVZSxXQUFXSSxPQUFPO1lBQ2xDLElBQUluQixXQUFXQSxRQUFRcUIsT0FBTyxFQUFFO2dCQUM5QixNQUFNcEIsWUFBWUYsUUFDaEJDLFNBQ0EsQ0FBQ04sWUFBY0EsYUFBYW1CLFdBQVduQixZQUN2QztvQkFBRWYsTUFBTThCLFdBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFFBQVNVLE9BQU87b0JBQUV0QztnQkFBVztnQkFHdkMsT0FBT29CO1lBQ1Q7UUFDRixPQUFPO1lBQ0wsSUFBSSxDQUFDVyxTQUFTO2dCQUNaLE1BQU1VLGVBQWVDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBbUIsRUFBQyxJQUFNVixXQUFXO2dCQUMxRCxPQUFPLElBQU1XLENBQUFBLEdBQUFBLHFCQUFBQSxrQkFBa0IsRUFBQ0Y7WUFDbEM7UUFDRjtJQUNBLHVEQUF1RDtJQUN6RCxHQUFHO1FBQUNYO1FBQVk5QjtRQUFZNEI7UUFBU0c7UUFBU0csV0FBV0ksT0FBTztLQUFDO0lBRWpFLE1BQU1NLGVBQWVQLENBQUFBLEdBQUFBLE9BQUFBLFdBQVcsRUFBQztRQUMvQkwsV0FBVztJQUNiLEdBQUcsRUFBRTtJQUVMLE9BQU87UUFBQ0k7UUFBWUw7UUFBU2E7S0FBYTtBQUM1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLnRzeD81N2VlIl0sIm5hbWVzIjpbInVzZUludGVyc2VjdGlvbiIsImhhc0ludGVyc2VjdGlvbk9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlcnMiLCJNYXAiLCJpZExpc3QiLCJjcmVhdGVPYnNlcnZlciIsIm9wdGlvbnMiLCJpZCIsInJvb3QiLCJtYXJnaW4iLCJyb290TWFyZ2luIiwiZXhpc3RpbmciLCJmaW5kIiwib2JqIiwiaW5zdGFuY2UiLCJnZXQiLCJlbGVtZW50cyIsIm9ic2VydmVyIiwiZW50cmllcyIsImZvckVhY2giLCJlbnRyeSIsImNhbGxiYWNrIiwidGFyZ2V0IiwiaXNWaXNpYmxlIiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3Rpb25SYXRpbyIsInB1c2giLCJzZXQiLCJvYnNlcnZlIiwiZWxlbWVudCIsInVub2JzZXJ2ZSIsImRlbGV0ZSIsInNpemUiLCJkaXNjb25uZWN0IiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJwYXJhbSIsInJvb3RSZWYiLCJkaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsInVzZVN0YXRlIiwiZWxlbWVudFJlZiIsInVzZVJlZiIsInNldEVsZW1lbnQiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJ1c2VFZmZlY3QiLCJ0YWdOYW1lIiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsInJlc2V0VmlzaWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!**************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function() {\n        return AmpStateContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\"));\nconst AmpStateContext = _react.default.createContext({});\nif (true) {\n    AmpStateContext.displayName = \"AmpStateContext\";\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7OzttREFFYUE7OztlQUFBQTs7Ozs0RUFGSztBQUVYLE1BQU1BLGtCQUFzQ0MsT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBQUMsQ0FBQztBQUV4RSxJQUFJQyxJQUF5QixFQUFjO0lBQ3pDSCxnQkFBZ0JJLFdBQVcsR0FBRztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvYW1wLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUudHM/OTY0MSJdLCJuYW1lcyI6WyJBbXBTdGF0ZUNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/amp-mode.js":
/*!********************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/amp-mode.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLW1vZGUuanMiLCJtYXBwaW5ncyI6Ijs7OzsrQ0FBZ0JBOzs7ZUFBQUE7OztBQUFULFNBQVNBLFlBQVlDLEtBQUE7SUFBQSxNQUMxQkMsV0FBVyxLQUFLLEVBQ2hCQyxTQUFTLEtBQUssRUFDZEMsV0FBVyxLQUFLLEVBQ2pCLEdBSjJCSCxVQUFBLFNBSXhCLENBQUMsSUFKdUJBO0lBSzFCLE9BQU9DLFlBQWFDLFVBQVVDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9hbXAtbW9kZS50cz9jZTA0Il0sIm5hbWVzIjpbImlzSW5BbXBNb2RlIiwicGFyYW0iLCJhbXBGaXJzdCIsImh5YnJpZCIsImhhc1F1ZXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/escape-regexp.js":
/*!*************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// regexp is based on https://github.com/sindresorhus/escape-string-regexp\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"escapeStringRegexp\", ({\n    enumerable: true,\n    get: function() {\n        return escapeStringRegexp;\n    }\n}));\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, \"\\\\$&\");\n    }\n    return str;\n} //# sourceMappingURL=escape-regexp.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvZXNjYXBlLXJlZ2V4cC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwwRUFBMEU7Ozs7O3NEQUkxREE7OztlQUFBQTs7O0FBSGhCLE1BQU1DLGNBQWM7QUFDcEIsTUFBTUMsa0JBQWtCO0FBRWpCLFNBQVNGLG1CQUFtQkcsR0FBVztJQUM1QywrR0FBK0c7SUFDL0csSUFBSUYsWUFBWUcsSUFBSSxDQUFDRCxNQUFNO1FBQ3pCLE9BQU9BLElBQUlFLE9BQU8sQ0FBQ0gsaUJBQWlCO0lBQ3RDO0lBQ0EsT0FBT0M7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvZXNjYXBlLXJlZ2V4cC50cz9kY2IxIl0sIm5hbWVzIjpbImVzY2FwZVN0cmluZ1JlZ2V4cCIsInJlSGFzUmVnRXhwIiwicmVSZXBsYWNlUmVnRXhwIiwic3RyIiwidGVzdCIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/escape-regexp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/get-img-props.js":
/*!*************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/get-img-props.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function() {\n        return getImgProps;\n    }\n}));\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/image-blur-svg.js\");\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/image-config.js\");\nconst VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nconst allImgs = new Map();\nlet perfObserver;\nfunction getInt(x) {\n    if (typeof x === \"undefined\") {\n        return x;\n    }\n    if (typeof x === \"number\") {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === \"string\" && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    let { deviceSizes, allSizes } = param;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config, src, unoptimized, width, quality, sizes, loader } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths, kind } = getWidths(config, width, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map((w, i)=>loader({\n                config,\n                src,\n                quality,\n                width: w\n            }) + \" \" + (kind === \"w\" ? w : i + 1) + kind).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, overrideSrc, onLoad, onLoadingComplete, placeholder = \"empty\", blurDataURL, fetchPriority, decoding = \"async\", layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;\n    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;\n    let config;\n    let c = imgConf || _imageconfig.imageConfigDefault;\n    if (\"allSizes\" in c) {\n        config = c;\n    } else {\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        config = {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }\n    if (typeof defaultLoader === \"undefined\") {\n        throw new Error(\"images.loaderFile detected but the file is missing default export.\\nRead more: https://nextjs.org/docs/messages/invalid-images-config\");\n    }\n    let loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    const isDefaultLoader = \"__next_img_default\" in loader;\n    if (isDefaultLoader) {\n        if (config.loader === \"custom\") {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        const customImageLoader = loader;\n        loader = (obj)=>{\n            const { config: _, ...opts } = obj;\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === \"fill\") {\n            fill = true;\n        }\n        const layoutToStyle = {\n            intrinsic: {\n                maxWidth: \"100%\",\n                height: \"auto\"\n            },\n            responsive: {\n                width: \"100%\",\n                height: \"auto\"\n            }\n        };\n        const layoutToSizes = {\n            responsive: \"100vw\",\n            fill: \"100vw\"\n        };\n        const layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = {\n                ...style,\n                ...layoutStyle\n            };\n        }\n        const layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    let staticSrc = \"\";\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    let blurWidth;\n    let blurHeight;\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                const ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                const ratio = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio);\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    let isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (!src || src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    if (priority) {\n        fetchPriority = \"high\";\n    }\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === \"export\" && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== \"absolute\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(\",\") + \".\");\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder !== \"empty\" && placeholder !== \"blur\" && !placeholder.startsWith(\"data:image/\")) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".');\n        }\n        if (placeholder !== \"empty\") {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === \"blur\" && !blurDataURL) {\n            const VALID_BLUR_EXT = [\n                \"jpeg\",\n                \"png\",\n                \"webp\",\n                \"avif\"\n            ] // should match next-image-loader\n            ;\n            throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(\",\") + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n        }\n        if (\"ref\" in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            const urlStr = loader({\n                config,\n                src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            let url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        for (const [legacyKey, legacyValue] of Object.entries({\n            layout,\n            objectFit,\n            objectPosition,\n            lazyBoundary,\n            lazyRoot\n        })){\n            if (legacyValue) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n            }\n        }\n        if (typeof window !== \"undefined\" && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver((entryList)=>{\n                for (const entry of entryList.getEntries()){\n                    var _entry_element;\n                    // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                    const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || \"\";\n                    const lcpImage = allImgs.get(imgSrc);\n                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder === \"empty\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                        // https://web.dev/lcp/#measure-lcp-in-javascript\n                        (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: \"largest-contentful-paint\",\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    const imgStyle = Object.assign(fill ? {\n        position: \"absolute\",\n        height: \"100%\",\n        width: \"100%\",\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit,\n        objectPosition\n    } : {}, showAltText ? {} : {\n        color: \"transparent\"\n    }, style);\n    const backgroundImage = !blurComplete && placeholder !== \"empty\" ? placeholder === \"blur\" ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt,\n        heightInt,\n        blurWidth,\n        blurHeight,\n        blurDataURL: blurDataURL || \"\",\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    let placeholderStyle = backgroundImage ? {\n        backgroundSize: imgStyle.objectFit || \"cover\",\n        backgroundPosition: imgStyle.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === \"blur\" && (blurDataURL == null ? void 0 : blurDataURL.startsWith(\"/\"))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    const imgAttributes = generateImgAttrs({\n        config,\n        src,\n        unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    });\n    if (true) {\n        if (typeof window !== \"undefined\") {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const props = {\n        ...rest,\n        loading: isLazy ? \"lazy\" : loading,\n        fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding,\n        className,\n        style: {\n            ...imgStyle,\n            ...placeholderStyle\n        },\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: overrideSrc || imgAttributes.src\n    };\n    const meta = {\n        unoptimized,\n        priority,\n        placeholder,\n        fill\n    };\n    return {\n        props,\n        meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvZ2V0LWltZy1wcm9wcy5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQTJPZ0JBOzs7ZUFBQUE7OztzQ0EzT1M7MENBQ087eUNBQ0c7QUE2RW5DLE1BQU1DLHVCQUF1QjtJQUFDO0lBQVE7SUFBU0M7Q0FBVTtBQWtCekQsU0FBU0MsZ0JBQ1BDLEdBQW9DO0lBRXBDLE9BQU9BLElBQXVCQyxPQUFPLEtBQUtIO0FBQzVDO0FBRUEsU0FBU0ksa0JBQ1BGLEdBQW9DO0lBRXBDLE9BQU9BLElBQXlCQSxHQUFHLEtBQUtGO0FBQzFDO0FBRUEsU0FBU0ssZUFBZUgsR0FBMEI7SUFDaEQsT0FDRSxPQUFPQSxRQUFRLFlBQ2RELENBQUFBLGdCQUFnQkMsUUFDZkUsa0JBQWtCRixJQUFBQTtBQUV4QjtBQUVBLE1BQU1JLFVBQVUsSUFBSUM7QUFJcEIsSUFBSUM7QUFFSixTQUFTQyxPQUFPQyxDQUFVO0lBQ3hCLElBQUksT0FBT0EsTUFBTSxhQUFhO1FBQzVCLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJLE9BQU9BLE1BQU0sVUFBVTtRQUN6QixPQUFPQyxPQUFPQyxRQUFRLENBQUNGLEtBQUtBLElBQUlHO0lBQ2xDO0lBQ0EsSUFBSSxPQUFPSCxNQUFNLFlBQVksV0FBV0ksSUFBSSxDQUFDSixJQUFJO1FBQy9DLE9BQU9LLFNBQVNMLEdBQUc7SUFDckI7SUFDQSxPQUFPRztBQUNUO0FBRUEsU0FBU0csVUFDUEMsS0FBc0MsRUFDdENDLEtBQXlCLEVBQ3pCQyxLQUF5QjtJQUZ6QixNQUFFQyxXQUFXLEVBQUVDLFFBQVEsRUFBZSxHQUF0Q0o7SUFJQSxJQUFJRSxPQUFPO1FBQ1QseURBQXlEO1FBQ3pELE1BQU1HLGtCQUFrQjtRQUN4QixNQUFNQyxlQUFlLEVBQUU7UUFDdkIsSUFBSyxJQUFJQyxPQUFRQSxRQUFRRixnQkFBZ0JHLElBQUksQ0FBQ04sUUFBU0ssTUFBTztZQUM1REQsYUFBYUcs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dkM7UUFDQXdDO1FBQ0F4QixPQUFPMkU7UUFDUGxELFNBQVMrRDtRQUNUdkY7UUFDQXlCO0lBQ0Y7SUFFQSxJQUFJK0QsSUFBeUIsRUFBYztRQUN6QyxJQUFJLE9BQU9rQixXQUFXLGFBQWE7WUFDakMsSUFBSTRCO1lBQ0osSUFBSTtnQkFDRkEsVUFBVSxJQUFJcEMsSUFBSW1DLGNBQWN0SixHQUFHO1lBQ3JDLEVBQUUsT0FBT3dKLEdBQUc7Z0JBQ1ZELFVBQVUsSUFBSXBDLElBQUltQyxjQUFjdEosR0FBRyxFQUFFMkgsT0FBTzhCLFFBQVEsQ0FBQ0MsSUFBSTtZQUMzRDtZQUNBdEosUUFBUXVKLEdBQUcsQ0FBQ0osUUFBUUcsSUFBSSxFQUFFO2dCQUFFMUo7Z0JBQUtnRDtnQkFBVVM7WUFBWTtRQUN6RDtJQUNGO0lBRUEsTUFBTW1HLFFBQWtCO1FBQ3RCLEdBQUcxRixJQUFJO1FBQ1BqQixTQUFTbUQsU0FBUyxTQUFTbkQ7UUFDM0JVO1FBQ0EzQyxPQUFPMkU7UUFDUHhDLFFBQVF5QztRQUNSaEM7UUFDQVY7UUFDQUcsT0FBTztZQUFFLEdBQUdvRixRQUFRO1lBQUUsR0FBR1MsZ0JBQWdCO1FBQUM7UUFDMUNqSSxPQUFPcUksY0FBY3JJLEtBQUs7UUFDMUIwQixRQUFRMkcsY0FBYzNHLE1BQU07UUFDNUIzQyxLQUFLc0QsZUFBZWdHLGNBQWN0SixHQUFHO0lBQ3ZDO0lBQ0EsTUFBTTZKLE9BQU87UUFBRXJIO1FBQWFRO1FBQVVTO1FBQWFMO0lBQUs7SUFDeEQsT0FBTztRQUFFd0c7UUFBT0M7SUFBSztBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvZ2V0LWltZy1wcm9wcy50cz9lYzkxIl0sIm5hbWVzIjpbImdldEltZ1Byb3BzIiwiVkFMSURfTE9BRElOR19WQUxVRVMiLCJ1bmRlZmluZWQiLCJpc1N0YXRpY1JlcXVpcmUiLCJzcmMiLCJkZWZhdWx0IiwiaXNTdGF0aWNJbWFnZURhdGEiLCJpc1N0YXRpY0ltcG9ydCIsImFsbEltZ3MiLCJNYXAiLCJwZXJmT2JzZXJ2ZXIiLCJnZXRJbnQiLCJ4IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJOYU4iLCJ0ZXN0IiwicGFyc2VJbnQiLCJnZXRXaWR0aHMiLCJwYXJhbSIsIndpZHRoIiwic2l6ZXMiLCJkZXZpY2VTaXplcyIsImFsbFNpemVzIiwidmlld3BvcnRXaWR0aFJlIiwicGVyY2VudFNpemVzIiwibWF0Y2giLCJleGVjIiwicHVzaCIsImxlbmd0aCIsInNtYWxsZXN0UmF0aW8iLCJNYXRoIiwibWluIiwid2lkdGhzIiwiZmlsdGVyIiwicyIsImtpbmQiLCJTZXQiLCJtYXAiLCJ3IiwiZmluZCIsInAiLCJnZW5lcmF0ZUltZ0F0dHJzIiwiY29uZmlnIiwidW5vcHRpbWl6ZWQiLCJxdWFsaXR5IiwibG9hZGVyIiwic3JjU2V0IiwibGFzdCIsImkiLCJqb2luIiwiX3N0YXRlIiwicHJpb3JpdHkiLCJsb2FkaW5nIiwiY2xhc3NOYW1lIiwiaGVpZ2h0IiwiZmlsbCIsInN0eWxlIiwib3ZlcnJpZGVTcmMiLCJvbkxvYWQiLCJvbkxvYWRpbmdDb21wbGV0ZSIsInBsYWNlaG9sZGVyIiwiYmx1ckRhdGFVUkwiLCJmZXRjaFByaW9yaXR5IiwiZGVjb2RpbmciLCJsYXlvdXQiLCJvYmplY3RGaXQiLCJvYmplY3RQb3NpdGlvbiIsImxhenlCb3VuZGFyeSIsImxhenlSb290IiwicmVzdCIsImltZ0NvbmYiLCJzaG93QWx0VGV4dCIsImJsdXJDb21wbGV0ZSIsImRlZmF1bHRMb2FkZXIiLCJjIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiaW1hZ2VTaXplcyIsInNvcnQiLCJhIiwiYiIsIkVycm9yIiwiaXNEZWZhdWx0TG9hZGVyIiwiY3VzdG9tSW1hZ2VMb2FkZXIiLCJvYmoiLCJfIiwib3B0cyIsImxheW91dFRvU3R5bGUiLCJpbnRyaW5zaWMiLCJtYXhXaWR0aCIsInJlc3BvbnNpdmUiLCJsYXlvdXRUb1NpemVzIiwibGF5b3V0U3R5bGUiLCJsYXlvdXRTaXplcyIsInN0YXRpY1NyYyIsIndpZHRoSW50IiwiaGVpZ2h0SW50IiwiYmx1cldpZHRoIiwiYmx1ckhlaWdodCIsInN0YXRpY0ltYWdlRGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyYXRpbyIsInJvdW5kIiwiaXNMYXp5Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwiZGFuZ2Vyb3VzbHlBbGxvd1NWRyIsInF1YWxpdHlJbnQiLCJwcm9jZXNzIiwib3V0cHV0IiwicG9zaXRpb24iLCJpc05hTiIsImluY2x1ZGVzIiwiU3RyaW5nIiwid2Fybk9uY2UiLCJWQUxJRF9CTFVSX0VYVCIsInVybFN0ciIsInVybCIsIlVSTCIsImVyciIsInBhdGhuYW1lIiwic2VhcmNoIiwibGVnYWN5S2V5IiwibGVnYWN5VmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwid2luZG93IiwiUGVyZm9ybWFuY2VPYnNlcnZlciIsImVudHJ5TGlzdCIsImVudHJ5IiwiZ2V0RW50cmllcyIsImltZ1NyYyIsImVsZW1lbnQiLCJsY3BJbWFnZSIsImdldCIsIm9ic2VydmUiLCJ0eXBlIiwiYnVmZmVyZWQiLCJjb25zb2xlIiwiZXJyb3IiLCJpbWdTdHlsZSIsImFzc2lnbiIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImNvbG9yIiwiYmFja2dyb3VuZEltYWdlIiwiZ2V0SW1hZ2VCbHVyU3ZnIiwicGxhY2Vob2xkZXJTdHlsZSIsImJhY2tncm91bmRTaXplIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFJlcGVhdCIsImltZ0F0dHJpYnV0ZXMiLCJmdWxsVXJsIiwiZSIsImxvY2F0aW9uIiwiaHJlZiIsInNldCIsInByb3BzIiwibWV0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/head.js":
/*!****************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/head.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    defaultHead: function() {\n        return defaultHead;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\"));\nconst _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/side-effect.js\"));\nconst _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/amp-mode.js\");\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    const head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        })\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === \"string\" || typeof child === \"number\") {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === \"string\" || typeof fragmentChild === \"number\") {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    \"name\",\n    \"httpEquiv\",\n    \"charSet\",\n    \"itemProp\"\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== \"number\" && h.key.indexOf(\"$\") > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf(\"$\") + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case \"title\":\n            case \"base\":\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case \"meta\":\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === \"charSet\") {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== \"name\" || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (false) {}\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === \"script\" && c.props[\"type\"] !== \"application/ld+json\") {\n                const srcMessage = c.props[\"src\"] ? '<script> tag with src=\"' + c.props[\"src\"] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === \"link\" && c.props[\"rel\"] === \"stylesheet\") {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props[\"href\"] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    let { children } = param;\n    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nconst _default = Head;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaGVhZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztRQXFNQUEsU0FBbUI7OztJQXhMSEM7aUJBQUFBOzs7Ozs7OzsyREFUZ0JDLENBQUEsQ0FBQUMsbUJBQUFBLENBQUE7O3lDQUVKQSxtQkFBQUEsQ0FBQTs7QUFPckIsTUFBQUMsWUFBU0gsbUJBQUFBLENBQVlJLHNHQUFBQTtTQUFBQSxZQUFBQSxTQUFBQTtJQUMxQixJQUFBQSxjQUFhLFFBQUFBLFlBQUE7O21CQUFPQyxHQUFRLElBQUFDLFlBQUFDLEdBQUE7O1FBQVc7S0FDdkM7UUFDRUMsQ0FBQUEsV0FBUzthQUFPQyxJQUFBQSxDQUFLLGtCQUFBSCxZQUFBQyxHQUFBO1lBQVdHLE1BQUFBOztRQUNsQztJQUNBO0lBQ0YsT0FBQUY7QUFFQTtTQUlFRyxpQkFBQUMsSUFBQSxFQUFBQyxLQUFBO0lBQ0EsOEZBQTREO1FBQzFELE9BQU9ELFVBQUFBLFlBQUFBLE9BQUFBLFVBQUFBLFVBQUFBO1FBQ1QsT0FBQUE7SUFDQTtJQUNBLGtDQUF5QkU7UUFDdkJELE1BQUFFLElBQU9ILEtBQUtJLE9BQ1ZDLE9BQUEsQ0FBQUgsUUFBQTtRQUNBSSxPQUFBQSxLQUFBQSxNQUFNQyxDQUVKQyxPQUNFQyxPQUFBQSxDQUNBQyxRQUFBQSxDQUFBQSxPQUFBQSxDQUFBQSxNQUFBQSxLQUFBQSxDQUFBQSxRQUFBQSxFQUFBQSxNQUFBQSxnQkFHU0E7Z0JBR1AsT0FBT0Qsa0JBQUFBLFlBQUFBLE9BQUFBLGtCQUFBQSxVQUFBQTtnQkFDVCxPQUFBQTtZQUNBO1lBRUYsT0FBRUEsYUFBQUwsTUFBQSxDQUFBTTtRQUdSO0lBQ0E7SUFDRixPQUFBVixLQUFBSSxNQUFBLENBQUFIO0FBRUE7TUFBbUJVLFlBQUE7SUFBUTtJQUFhO0lBQVc7SUFBVztDQUU5RDs7Ozs7WUFNUUM7SUFDTixNQUFNQyxPQUFPLElBQUlDO0lBQ2pCLE1BQU1DLE9BQUFBLElBQUFBO0lBQ04sTUFBTUMsWUFBQUEsSUFBQUE7SUFFTixNQUFBQSxpQkFBUUMsQ0FBQUE7V0FDTixDQUFJQztRQUNKLElBQUlDLFdBQVM7UUFFYixJQUFJRixTQUFTO1lBQ1hFLEVBQUFBLEdBQUFBLElBQVMsT0FBQUYsRUFBQUcsR0FBQSxpQkFBQUgsRUFBQUcsR0FBQSxDQUFBQyxPQUFBO1lBQ1RGLFNBQU1DO1lBQ04sTUFBSVIsTUFBUUssRUFBQ0csR0FBQUEsQ0FBQUEsS0FBTSxDQUFBSCxFQUFBRyxHQUFBLENBQUFDLE9BQUE7Z0JBQ2pCSCxLQUFBQSxHQUFBQSxDQUFBQSxNQUFXO2dCQUNiQSxXQUFPO21CQUNMTjtnQkFDRkEsS0FBQVUsR0FBQSxDQUFBRjtZQUNGO1FBRUE7UUFDQSx3Q0FBYztlQUNaSCxFQUFLZCxJQUFBO1lBQ0wsS0FBSztpQkFDSDtvQkFDRWUsS0FBQUEsR0FBQUEsQ0FBQUEsRUFBV2YsSUFBQTtvQkFDYmUsV0FBTzt1QkFDTEw7b0JBQ0ZBLEtBQUFTLEdBQUEsQ0FBQUwsRUFBQWQsSUFBQTtnQkFDQTtnQkFDRjtpQkFDRTtvQkFDRSxJQUFBb0IsSUFBTUMsR0FBQUEsTUFBV2IsVUFBVVksTUFBRSxFQUFBQSxJQUFBRSxLQUFBRixJQUFBO29CQUM3QixNQUFLTixXQUFRUyxTQUFBQSxDQUFjSCxFQUFDQztvQkFFNUIsSUFBSUEsQ0FBQUEsRUFBQUEsS0FBQUEsQ0FBQUEsY0FBYSxDQUFXQSxXQUFBO3dCQUMxQkEsYUFBSVQsV0FBY1M7NEJBQ2hCTixVQUFBQSxHQUFXLENBQUFNLFdBQUE7NEJBQ2JOLFdBQU87K0JBQ0xIOzRCQUNGQSxVQUFBTyxHQUFBLENBQUFFO3dCQUNGOzJCQUNFO3dCQUNBLE1BQU1HLFdBQUFBLEVBQWFYLEtBQUFBLENBQUFBLFNBQWVRO3dCQUNsQyxNQUFLQSxhQUFhUixjQUFXRyxDQUFBQSxTQUFXUSxJQUFBQSxJQUFXQzs0QkFDakRWLENBQUFBLGFBQVcsV0FBQUMsTUFBQSxLQUFBUSxXQUFBQyxHQUFBLENBQUFDLFdBQUE7NEJBQ2JYLFdBQU87K0JBQ0xTOzRCQUNBWCxXQUFBQSxHQUFjLENBQUNROzRCQUNqQlIsY0FBQSxDQUFBUSxTQUFBLEdBQUFHO3dCQUNGO29CQUNGO2dCQUNBO2dCQUNKO1FBRUE7UUFDRixPQUFBVDtJQUNGO0FBRUE7Ozs7SUFRRSxTQUFRMUIsaUJBQWNzQyxvQkFBQUEsRUFBQUEsS0FBQUE7SUFDdEIsUUFBT0MsU0FBQUEsRUFBQUEsR0FBQUE7V0FPSEEscUJBQXFCUixNQUFBQSxDQUFBQSxrQkFBQUEsRUFBQUEsRUFBQUEsT0FBQUEsR0FBQUEsTUFBQUEsQ0FBQUEsWUFBQUEsV0FBQUEsT0FBQUEsSUFBQUEsTUFBQUEsQ0FBQUEsVUFBQUEsT0FBQUEsR0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUE7UUFDckIsTUFDRVMsTUFBUUMsRUFBQUEsR0FBSUMsSUFBQUE7WUFJWkYsS0FHRXhDLEVBQUEsRUFlSjtZQUNFd0MsSUFBQTtZQUNBLHlEQUErQztnQkFDN0NHLEVBQUFoQyxJQUFNd0MsS0FBQUEsWUFBZWIsRUFBQUEsS0FBTSxRQUN0Qiw0QkFBMkJBO2dCQUVoQ2MsTUFBQUEsYUFBQUEsRUFBQUEsS0FDRyxzQ0FBQVQsRUFBQUwsS0FBQSxPQUFnRGEsR0FBQUEsTUFBQUE7Z0JBRXJELElBQU9wRCxVQUFVcUQsUUFBSyxxREFBMkNELGFBQUE7bUJBQy9EQyxJQUFBQSxFQUFBQSxJQUFBQSxLQUFBQSxVQUNHVCxFQUFBTCxLQUFBO2dCQUVMLElBQUF2QyxVQUFBcUQsUUFBQSwwRkFBQVQsRUFBQUwsS0FBQTtZQUNGO1FBQ0E7ZUFBK0JWLFdBQUFBLEdBQUFBLE9BQUFBLE9BQUFBLENBQUFBLFlBQUFBLENBQUFBLEdBQUFBO1lBQUlBO1FBQ3JDO0lBQ0o7QUFFQTs7OztJQUljLFNBQUV5QixLQUFRQyxLQUFWO0lBQ1osTUFBTUMsUUFBQUEsRUFBQUEsR0FBV0M7SUFDakIsTUFBTUMsV0FBQUEsQ0FBQUEsR0FBY0QsT0FBQUEsVUFBQUEsRUFBQUEseUJBQVdFLGVBQUFBO0lBQy9CLE1BQUFELGNBQUEsQ0FDRSxHQUFBekMsT0FBQXdDLFVBQUEsRUFBQ0csaUNBQU1ELGtCQUFBO1dBQ0xFLFdBQUFBLEdBQUFBLENBQUFBLEdBQUFBLFlBQXlCQyxHQUFBQSxFQUFBQSxZQUFBQSxPQUFBQSxFQUFBQTtRQUN6QkoseUJBQWFBO1FBQ2J6RCxhQUFXOEQ7bUJBRVZULENBQUFBLEdBQUFBLFNBQUFBLFdBQUFBLEVBQUFBOztJQUdQOztLQVpnQkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2hlYWQudHN4PzM2NzAiXSwibmFtZXMiOlsiZXhwb3J0cyIsImRlZmF1bHRIZWFkIiwiXyIsInJlcXVpcmUiLCJfd2Fybm9uY2UiLCJpbkFtcE1vZGUiLCJjaGFyU2V0IiwiX2pzeHJ1bnRpbWUiLCJqc3giLCJoZWFkIiwibmFtZSIsImNvbnRlbnQiLCJvbmx5UmVhY3RFbGVtZW50IiwibGlzdCIsImNoaWxkIiwiRnJhZ21lbnQiLCJ0eXBlIiwiY29uY2F0IiwiZGVmYXVsdCIsIlJlYWN0IiwiQ2hpbGRyZW4iLCJfcmVhY3QiLCJmcmFnbWVudExpc3QiLCJmcmFnbWVudENoaWxkIiwiTUVUQVRZUEVTIiwia2V5cyIsInRhZ3MiLCJTZXQiLCJtZXRhVHlwZXMiLCJtZXRhQ2F0ZWdvcmllcyIsImgiLCJpc1VuaXF1ZSIsImhhc0tleSIsImtleSIsImluZGV4T2YiLCJhZGQiLCJpIiwibWV0YXR5cGUiLCJsZW4iLCJoYXNPd25Qcm9wZXJ0eSIsImNhdGVnb3JpZXMiLCJoYXMiLCJjYXRlZ29yeSIsInByb3BzIiwiaGVhZENoaWxkcmVuRWxlbWVudHMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjIiwiX19ORVhUX09QVElNSVpFX0ZPTlRTIiwic29tZSIsInVybCIsIm5ld1Byb3BzIiwic3RhcnRzV2l0aCIsInVuZGVmaW5lZCIsImNsb25lRWxlbWVudCIsInNyY01lc3NhZ2UiLCJ3YXJuT25jZSIsImNoaWxkcmVuIiwicGFyYW0iLCJhbXBTdGF0ZSIsInVzZUNvbnRleHQiLCJoZWFkTWFuYWdlciIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsIkVmZmVjdCIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwicmVkdWNlQ29tcG9uZW50cyIsImlzSW5BbXBNb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!**************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;\n    const std = 20;\n    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    const viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : \"\";\n    const preserveAspectRatio = viewBox ? \"none\" : objectFit === \"contain\" ? \"xMidYMid\" : objectFit === \"cover\" ? \"xMidYMid slice\" : \"none\";\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtYmx1ci1zdmcuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUM7Ozs7bURBQ2VBOzs7ZUFBQUE7OztBQUFULFNBQVNBLGdCQUFnQkMsS0FjL0I7SUFkK0IsTUFDOUJDLFFBQVEsRUFDUkMsU0FBUyxFQUNUQyxTQUFTLEVBQ1RDLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyxTQUFTLEVBUVYsR0FkK0JOO0lBZTlCLE1BQU1PLE1BQU07SUFDWixNQUFNQyxXQUFXTCxZQUFZQSxZQUFZLEtBQUtGO0lBQzlDLE1BQU1RLFlBQVlMLGFBQWFBLGFBQWEsS0FBS0Y7SUFFakQsTUFBTVEsVUFDSkYsWUFBWUMsWUFBWSxrQkFBZ0JELFdBQVMsTUFBR0MsWUFBVSxNQUFLO0lBQ3JFLE1BQU1FLHNCQUFzQkQsVUFDeEIsU0FDQUosY0FBYyxZQUNkLGFBQ0FBLGNBQWMsVUFDZCxtQkFDQTtJQUVKLE9BQU8sK0NBQTZDSSxVQUFRLDhGQUEyRkgsTUFBSSxvUUFBaVFBLE1BQUksZ0dBQTZGSSxzQkFBb0Isd0NBQXFDTixjQUFZO0FBQ3BrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvaW1hZ2UtYmx1ci1zdmcudHM/Yzc5YyJdLCJuYW1lcyI6WyJnZXRJbWFnZUJsdXJTdmciLCJwYXJhbSIsIndpZHRoSW50IiwiaGVpZ2h0SW50IiwiYmx1cldpZHRoIiwiYmx1ckhlaWdodCIsImJsdXJEYXRhVVJMIiwib2JqZWN0Rml0Iiwic3RkIiwic3ZnV2lkdGgiLCJzdmdIZWlnaHQiLCJ2aWV3Qm94IiwicHJlc2VydmVBc3BlY3RSYXRpbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \***********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function() {\n        return ImageConfigContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\"));\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/image-config.js\");\nconst ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = \"ImageConfigContext\";\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7OztzREFJYUE7OztlQUFBQTs7Ozs0RUFKSzt5Q0FFaUI7QUFFNUIsTUFBTUEscUJBQ1hDLE9BQUFBLE9BQUssQ0FBQ0MsYUFBYSxDQUFzQkMsYUFBQUEsa0JBQWtCO0FBRTdELElBQUlDLElBQXlCLEVBQWM7SUFDekNKLG1CQUFtQkssV0FBVyxHQUFHO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS50cz8zZDc1Il0sIm5hbWVzIjpbIkltYWdlQ29uZmlnQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsImltYWdlQ29uZmlnRGVmYXVsdCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/image-config.js":
/*!************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/image-config.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function() {\n        return imageConfigDefault;\n    }\n});\nconst VALID_LOADERS = [\n    \"default\",\n    \"imgix\",\n    \"cloudinary\",\n    \"akamai\",\n    \"custom\"\n];\nconst imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: \"/_next/image\",\n    loader: \"default\",\n    loaderFile: \"\",\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        \"image/webp\"\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: \"inline\",\n    localPatterns: undefined,\n    remotePatterns: [],\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQUFhQSxlQUFhO2VBQWJBOztJQThIQUMsb0JBQWtCO2VBQWxCQTs7O0FBOUhOLE1BQU1ELGdCQUFnQjtJQUMzQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUF3SE0sTUFBTUMscUJBQTBDO0lBQ3JEQyxhQUFhO1FBQUM7UUFBSztRQUFLO1FBQUs7UUFBTTtRQUFNO1FBQU07UUFBTTtLQUFLO0lBQzFEQyxZQUFZO1FBQUM7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUs7UUFBSztLQUFJO0lBQy9DQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsWUFBWTtJQUNaQyxTQUFTLEVBQUU7SUFDWEMscUJBQXFCO0lBQ3JCQyxpQkFBaUI7SUFDakJDLFNBQVM7UUFBQztLQUFhO0lBQ3ZCQyxxQkFBcUI7SUFDckJDLHVCQUF3QjtJQUN4QkMsd0JBQXdCO0lBQ3hCQyxlQUFlQztJQUNmQyxnQkFBZ0IsRUFBRTtJQUNsQkMsYUFBYTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcudHM/MTM0YSJdLCJuYW1lcyI6WyJWQUxJRF9MT0FERVJTIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiZGV2aWNlU2l6ZXMiLCJpbWFnZVNpemVzIiwicGF0aCIsImxvYWRlciIsImxvYWRlckZpbGUiLCJkb21haW5zIiwiZGlzYWJsZVN0YXRpY0ltYWdlcyIsIm1pbmltdW1DYWNoZVRUTCIsImZvcm1hdHMiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwiY29udGVudFNlY3VyaXR5UG9saWN5IiwiY29udGVudERpc3Bvc2l0aW9uVHlwZSIsImxvY2FsUGF0dGVybnMiLCJ1bmRlZmluZWQiLCJyZW1vdGVQYXR0ZXJucyIsInVub3B0aW1pemVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/image-external.js":
/*!**************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/image-external.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    getImageProps: function() {\n        return getImageProps;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _getimgprops = __webpack_require__(/*! ./get-img-props */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imagecomponent = __webpack_require__(/*! ../../client/image-component */ \"(app-pages-browser)/../node_modules/next/dist/client/image-component.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/image-loader.js\"));\nfunction getImageProps(imgProps) {\n    const { props } = (0, _getimgprops.getImgProps)(imgProps, {\n        defaultLoader: _imageloader.default,\n        // This is replaced by webpack define plugin\n        imgConf: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]}\n    });\n    // Normally we don't care about undefined props because we pass to JSX,\n    // but this exported function could be used by the end user for anything\n    // so we delete undefined props to clean it up a little.\n    for (const [key, value] of Object.entries(props)){\n        if (value === undefined) {\n            delete props[key];\n        }\n    }\n    return {\n        props\n    };\n}\nconst _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBaUNBQSxTQUFvQjtlQUFwQkM7O0lBakJnQkMsZUFBYTtlQUFiQTs7Ozt5Q0FiWTs0Q0FDTjtrRkFHSTtBQVNuQixTQUFTQSxjQUFjQyxRQUFvQjtJQUNoRCxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxhQUFBQSxXQUFXLEVBQUNGLFVBQVU7UUFDdENHLGVBQUFBLGFBQUFBLE9BQWE7UUFDYiw0Q0FBNEM7UUFDNUNDLFNBQVNDLDBOQUE2QjtJQUN4QztJQUNBLHVFQUF1RTtJQUN2RSx3RUFBd0U7SUFDeEUsd0RBQXdEO0lBQ3hELEtBQUssTUFBTSxDQUFDRyxLQUFLQyxNQUFNLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ1YsT0FBUTtRQUNoRCxJQUFJUSxVQUFVRyxXQUFXO1lBQ3ZCLE9BQU9YLEtBQUssQ0FBQ08sSUFBMEI7UUFDekM7SUFDRjtJQUNBLE9BQU87UUFBRVA7SUFBTTtBQUNqQjtNQUVBSCxXQUFlZSxnQkFBQUEsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWwudHN4PzM4MjYiXSwibmFtZXMiOlsiZGVmYXVsdCIsIl9kZWZhdWx0IiwiZ2V0SW1hZ2VQcm9wcyIsImltZ1Byb3BzIiwicHJvcHMiLCJnZXRJbWdQcm9wcyIsImRlZmF1bHRMb2FkZXIiLCJpbWdDb25mIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwidW5kZWZpbmVkIiwiSW1hZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/image-external.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/image-loader.js":
/*!************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/image-loader.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nfunction defaultLoader(param) {\n    let { config, src, width, quality } = param;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(\", \") + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src,\n                width,\n                quality\n            }));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (src.startsWith(\"/\") && config.localPatterns) {\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasLocalMatch } = __webpack_require__(/*! ./match-local-pattern */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/match-local-pattern.js\");\n                if (!hasLocalMatch(config.localPatterns, src)) {\n                    throw new Error(\"Invalid src prop (\" + src + \") on `next/image` does not match `images.localPatterns` configured in your `next.config.js`\\n\" + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns\");\n                }\n            }\n        }\n        if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasRemoteMatch } = __webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasRemoteMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75) + ( false ? 0 : \"\");\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nconst _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7MkNBeUZBOzs7ZUFBQUE7OztBQXZGQSxTQUFTQyxjQUFjQyxLQUtNO0lBTE4sTUFDckJDLE1BQU0sRUFDTkMsR0FBRyxFQUNIQyxLQUFLLEVBQ0xDLE9BQU8sRUFDb0IsR0FMTko7SUFNckIsSUFBSUssSUFBeUIsRUFBYztRQUN6QyxNQUFNQyxnQkFBZ0IsRUFBRTtRQUV4Qix5REFBeUQ7UUFDekQsSUFBSSxDQUFDSixLQUFLSSxjQUFjQyxJQUFJLENBQUM7UUFDN0IsSUFBSSxDQUFDSixPQUFPRyxjQUFjQyxJQUFJLENBQUM7UUFFL0IsSUFBSUQsY0FBY0UsTUFBTSxHQUFHLEdBQUc7WUFDNUIsTUFBTSxJQUFJQyxNQUNSLHNDQUFvQ0gsY0FBY0ksSUFBSSxDQUNwRCxRQUNBLGdHQUErRkMsS0FBS0MsU0FBUyxDQUM3RztnQkFBRVY7Z0JBQUtDO2dCQUFPQztZQUFRO1FBRzVCO1FBRUEsSUFBSUYsSUFBSVcsVUFBVSxDQUFDLE9BQU87WUFDeEIsTUFBTSxJQUFJSixNQUNSLDBCQUF3QlAsTUFBSTtRQUVoQztRQUVBLElBQUlBLElBQUlXLFVBQVUsQ0FBQyxRQUFRWixPQUFPYSxhQUFhLEVBQUU7WUFDL0MsSUFDRVQsSUFFNkIsRUFDN0I7Z0JBQ0EsdUVBQXVFO2dCQUN2RSxNQUFNLEVBQUVZLGFBQWEsRUFBRSxHQUFHQyxtQkFBQUEsQ0FBUTtnQkFDbEMsSUFBSSxDQUFDRCxjQUFjaEIsT0FBT2EsYUFBYSxFQUFFWixNQUFNO29CQUM3QyxNQUFNLElBQUlPLE1BQ1IsdUJBQXFCUCxNQUFJLGtHQUN0QjtnQkFFUDtZQUNGO1FBQ0Y7UUFFQSxJQUFJLENBQUNBLElBQUlXLFVBQVUsQ0FBQyxRQUFTWixDQUFBQSxPQUFPa0IsT0FBTyxJQUFJbEIsT0FBT21CLGNBQWMsR0FBRztZQUNyRSxJQUFJQztZQUNKLElBQUk7Z0JBQ0ZBLFlBQVksSUFBSUMsSUFBSXBCO1lBQ3RCLEVBQUUsT0FBT3FCLEtBQUs7Z0JBQ1pDLFFBQVFDLEtBQUssQ0FBQ0Y7Z0JBQ2QsTUFBTSxJQUFJZCxNQUNSLDBCQUF3QlAsTUFBSTtZQUVoQztZQUVBLElBQ0VHLElBRTZCLEVBQzdCO2dCQUNBLHVFQUF1RTtnQkFDdkUsTUFBTSxFQUFFcUIsY0FBYyxFQUFFLEdBQUdSLG1CQUFBQSxDQUFRO2dCQUNuQyxJQUFJLENBQUNRLGVBQWV6QixPQUFPa0IsT0FBTyxFQUFFbEIsT0FBT21CLGNBQWMsRUFBRUMsWUFBWTtvQkFDckUsTUFBTSxJQUFJWixNQUNSLHVCQUFxQlAsTUFBSSxrQ0FBaUNtQixVQUFVTSxRQUFRLEdBQUMsZ0VBQzFFO2dCQUVQO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBTzFCLE9BQVUyQixJQUFJLEdBQUMsVUFBT0MsbUJBQW1CM0IsT0FBSyxRQUFLQyxRQUFNLFFBQzlEQyxDQUFBQSxXQUFXLE1BRVhDLENBQUFBLE1BQThCLEdBQzFCLENBQXNDLEdBQ3RDO0FBRVI7QUFFQSwrREFBK0Q7QUFDL0QsMkRBQTJEO0FBQzNETixjQUFjZ0Msa0JBQWtCLEdBQUc7TUFFbkNqQyxXQUFlQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyLnRzP2QyODAiXSwibmFtZXMiOlsiX2RlZmF1bHQiLCJkZWZhdWx0TG9hZGVyIiwicGFyYW0iLCJjb25maWciLCJzcmMiLCJ3aWR0aCIsInF1YWxpdHkiLCJwcm9jZXNzIiwibWlzc2luZ1ZhbHVlcyIsInB1c2giLCJsZW5ndGgiLCJFcnJvciIsImpvaW4iLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhcnRzV2l0aCIsImxvY2FsUGF0dGVybnMiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJoYXNMb2NhbE1hdGNoIiwicmVxdWlyZSIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInBhcnNlZFNyYyIsIlVSTCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImhhc1JlbW90ZU1hdGNoIiwiaG9zdG5hbWUiLCJwYXRoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiTkVYVF9ERVBMT1lNRU5UX0lEIiwiX19uZXh0X2ltZ19kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/match-local-pattern.js":
/*!*******************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/match-local-pattern.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasLocalMatch: function() {\n        return hasLocalMatch;\n    },\n    matchLocalPattern: function() {\n        return matchLocalPattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/../node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchLocalPattern(pattern, url) {\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : \"**\", {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasLocalMatch(localPatterns, urlPathAndQuery) {\n    if (!localPatterns) {\n        // if the user didn't define \"localPatterns\", we allow all local images\n        return true;\n    }\n    const url = new URL(urlPathAndQuery, \"http://n\");\n    return localPatterns.some((p)=>matchLocalPattern(p, url));\n} //# sourceMappingURL=match-local-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbWF0Y2gtbG9jYWwtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFrQmdCQSxlQUFhO2VBQWJBOztJQWRBQyxtQkFBaUI7ZUFBakJBOzs7dUNBSE87QUFHaEIsU0FBU0Esa0JBQWtCQyxPQUFxQixFQUFFQyxHQUFRO0lBQy9ELElBQUlELFFBQVFFLE1BQU0sS0FBS0MsV0FBVztRQUNoQyxJQUFJSCxRQUFRRSxNQUFNLEtBQUtELElBQUlDLE1BQU0sRUFBRTtZQUNqQyxPQUFPO1FBQ1Q7SUFDRjtRQUVZRjtJQUFaLElBQUksQ0FBQ0ksQ0FBQUEsR0FBQUEsV0FBQUEsTUFBTSxFQUFDSixDQUFBQSxvQkFBQUEsUUFBUUssUUFBUSxZQUFoQkwsb0JBQW9CLE1BQU07UUFBRU0sS0FBSztJQUFLLEdBQUdDLElBQUksQ0FBQ04sSUFBSUksUUFBUSxHQUFHO1FBQ3ZFLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVPLFNBQVNQLGNBQ2RVLGFBQXlDLEVBQ3pDQyxlQUF1QjtJQUV2QixJQUFJLENBQUNELGVBQWU7UUFDbEIsdUVBQXVFO1FBQ3ZFLE9BQU87SUFDVDtJQUNBLE1BQU1QLE1BQU0sSUFBSVMsSUFBSUQsaUJBQWlCO0lBQ3JDLE9BQU9ELGNBQWNHLElBQUksQ0FBQyxDQUFDQyxJQUFNYixrQkFBa0JhLEdBQUdYO0FBQ3hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9tYXRjaC1sb2NhbC1wYXR0ZXJuLnRzPzYzNWQiXSwibmFtZXMiOlsiaGFzTG9jYWxNYXRjaCIsIm1hdGNoTG9jYWxQYXR0ZXJuIiwicGF0dGVybiIsInVybCIsInNlYXJjaCIsInVuZGVmaW5lZCIsIm1ha2VSZSIsInBhdGhuYW1lIiwiZG90IiwidGVzdCIsImxvY2FsUGF0dGVybnMiLCJ1cmxQYXRoQW5kUXVlcnkiLCJVUkwiLCJzb21lIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/match-local-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!********************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasRemoteMatch: function() {\n        return hasRemoteMatch;\n    },\n    matchRemotePattern: function() {\n        return matchRemotePattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/../node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        const actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    // Should be the same as writeImagesManifest()\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : \"**\", {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasRemoteMatch(domains, remotePatterns, url) {\n    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBeUNnQkEsZ0JBQWM7ZUFBZEE7O0lBckNBQyxvQkFBa0I7ZUFBbEJBOzs7dUNBSE87QUFHaEIsU0FBU0EsbUJBQW1CQyxPQUFzQixFQUFFQyxHQUFRO0lBQ2pFLElBQUlELFFBQVFFLFFBQVEsS0FBS0MsV0FBVztRQUNsQyxNQUFNQyxjQUFjSCxJQUFJQyxRQUFRLENBQUNHLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDM0MsSUFBSUwsUUFBUUUsUUFBUSxLQUFLRSxhQUFhO1lBQ3BDLE9BQU87UUFDVDtJQUNGO0lBQ0EsSUFBSUosUUFBUU0sSUFBSSxLQUFLSCxXQUFXO1FBQzlCLElBQUlILFFBQVFNLElBQUksS0FBS0wsSUFBSUssSUFBSSxFQUFFO1lBQzdCLE9BQU87UUFDVDtJQUNGO0lBRUEsSUFBSU4sUUFBUU8sUUFBUSxLQUFLSixXQUFXO1FBQ2xDLE1BQU0sSUFBSUssTUFDUiwrQ0FBNkNDLEtBQUtDLFNBQVMsQ0FBQ1Y7SUFFaEUsT0FBTztRQUNMLElBQUksQ0FBQ1csQ0FBQUEsR0FBQUEsV0FBQUEsTUFBTSxFQUFDWCxRQUFRTyxRQUFRLEVBQUVLLElBQUksQ0FBQ1gsSUFBSU0sUUFBUSxHQUFHO1lBQ2hELE9BQU87UUFDVDtJQUNGO0lBRUEsSUFBSVAsUUFBUWEsTUFBTSxLQUFLVixXQUFXO1FBQ2hDLElBQUlILFFBQVFhLE1BQU0sS0FBS1osSUFBSVksTUFBTSxFQUFFO1lBQ2pDLE9BQU87UUFDVDtJQUNGO1FBR1liO0lBRFosOENBQThDO0lBQzlDLElBQUksQ0FBQ1csQ0FBQUEsR0FBQUEsV0FBQUEsTUFBTSxFQUFDWCxDQUFBQSxvQkFBQUEsUUFBUWMsUUFBUSxZQUFoQmQsb0JBQW9CLE1BQU07UUFBRWUsS0FBSztJQUFLLEdBQUdILElBQUksQ0FBQ1gsSUFBSWEsUUFBUSxHQUFHO1FBQ3ZFLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVPLFNBQVNoQixlQUNka0IsT0FBaUIsRUFDakJDLGNBQStCLEVBQy9CaEIsR0FBUTtJQUVSLE9BQ0VlLFFBQVFFLElBQUksQ0FBQyxDQUFDQyxTQUFXbEIsSUFBSU0sUUFBUSxLQUFLWSxXQUMxQ0YsZUFBZUMsSUFBSSxDQUFDLENBQUNFLElBQU1yQixtQkFBbUJxQixHQUFHbkI7QUFFckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL21hdGNoLXJlbW90ZS1wYXR0ZXJuLnRzP2Q2MWQiXSwibmFtZXMiOlsiaGFzUmVtb3RlTWF0Y2giLCJtYXRjaFJlbW90ZVBhdHRlcm4iLCJwYXR0ZXJuIiwidXJsIiwicHJvdG9jb2wiLCJ1bmRlZmluZWQiLCJhY3R1YWxQcm90byIsInNsaWNlIiwicG9ydCIsImhvc3RuYW1lIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwibWFrZVJlIiwidGVzdCIsInNlYXJjaCIsInBhdGhuYW1lIiwiZG90IiwiZG9tYWlucyIsInJlbW90ZVBhdHRlcm5zIiwic29tZSIsImRvbWFpbiIsInAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \*****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7OztpREFHYUE7OztlQUFBQTs7Ozs0RUFISztBQUdYLE1BQU1BLGdCQUFnQkMsT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBQW9CO0FBRXBFLElBQUlDLElBQXlCLEVBQWM7SUFDekNILGNBQWNJLFdBQVcsR0FBRztBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUudHM/NjM2YyJdLCJuYW1lcyI6WyJSb3V0ZXJDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!***********************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/../node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || \"\";\n    let pathname = urlObj.pathname || \"\";\n    let hash = urlObj.hash || \"\";\n    let query = urlObj.query || \"\";\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, \":\") + \"@\" : \"\";\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(\":\") ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += \":\" + urlObj.port;\n        }\n    }\n    if (query && typeof query === \"object\") {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || \"\";\n    if (protocol && !protocol.endsWith(\":\")) protocol += \":\";\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = \"//\" + (host || \"\");\n        if (pathname && pathname[0] !== \"/\") pathname = \"/\" + pathname;\n    } else if (!host) {\n        host = \"\";\n    }\n    if (hash && hash[0] !== \"#\") hash = \"#\" + hash;\n    if (search && search[0] !== \"?\") search = \"?\" + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace(\"#\", \"%23\");\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    \"auth\",\n    \"hash\",\n    \"host\",\n    \"hostname\",\n    \"href\",\n    \"path\",\n    \"pathname\",\n    \"port\",\n    \"protocol\",\n    \"query\",\n    \"search\",\n    \"slashes\"\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === \"object\") {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwuanMiLCJtYXBwaW5ncyI6IkFBQUEsdUNBQXVDO0FBQ3ZDLHNEQUFzRDtBQUN0RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLGdFQUFnRTtBQUNoRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseURBQXlEO0FBQ3pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsNkRBQTZEO0FBQzdELDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usd0VBQXdFO0FBQ3hFLDRFQUE0RTtBQUM1RSx5Q0FBeUM7Ozs7Ozs7Ozs7Ozs7SUFRekJBLFdBQVM7ZUFBVEE7O0lBNkRBQyxzQkFBb0I7ZUFBcEJBOztJQWZIQyxlQUFhO2VBQWJBOzs7O21GQWxEZ0I7QUFFN0IsTUFBTUMsbUJBQW1CO0FBRWxCLFNBQVNILFVBQVVJLE1BQWlCO0lBQ3pDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxRQUFRLEVBQUUsR0FBR0Y7SUFDekIsSUFBSUcsV0FBV0gsT0FBT0csUUFBUSxJQUFJO0lBQ2xDLElBQUlDLFdBQVdKLE9BQU9JLFFBQVEsSUFBSTtJQUNsQyxJQUFJQyxPQUFPTCxPQUFPSyxJQUFJLElBQUk7SUFDMUIsSUFBSUMsUUFBUU4sT0FBT00sS0FBSyxJQUFJO0lBQzVCLElBQUlDLE9BQXVCO0lBRTNCTixPQUFPQSxPQUFPTyxtQkFBbUJQLE1BQU1RLE9BQU8sQ0FBQyxRQUFRLE9BQU8sTUFBTTtJQUVwRSxJQUFJVCxPQUFPTyxJQUFJLEVBQUU7UUFDZkEsT0FBT04sT0FBT0QsT0FBT08sSUFBSTtJQUMzQixPQUFPLElBQUlMLFVBQVU7UUFDbkJLLE9BQU9OLE9BQVEsRUFBQ0MsU0FBU1EsT0FBTyxDQUFDLE9BQU8sTUFBSVIsV0FBUyxNQUFLQSxRQUFBQTtRQUMxRCxJQUFJRixPQUFPVyxJQUFJLEVBQUU7WUFDZkosUUFBUSxNQUFNUCxPQUFPVyxJQUFJO1FBQzNCO0lBQ0Y7SUFFQSxJQUFJTCxTQUFTLE9BQU9BLFVBQVUsVUFBVTtRQUN0Q0EsUUFBUU0sT0FBT0MsYUFBWUMsc0JBQXNCLENBQUNSO0lBQ3BEO0lBRUEsSUFBSVMsU0FBU2YsT0FBT2UsTUFBTSxJQUFLVCxTQUFTLE1BQUlBLFNBQVk7SUFFeEQsSUFBSUgsWUFBWSxDQUFDQSxTQUFTYSxRQUFRLENBQUMsTUFBTWIsWUFBWTtJQUVyRCxJQUNFSCxPQUFPaUIsT0FBTyxJQUNiLENBQUMsQ0FBQ2QsWUFBWUosaUJBQWlCbUIsSUFBSSxDQUFDZixTQUFBQSxLQUFjSSxTQUFTLE9BQzVEO1FBQ0FBLE9BQU8sT0FBUUEsQ0FBQUEsUUFBUTtRQUN2QixJQUFJSCxZQUFZQSxRQUFRLENBQUMsRUFBRSxLQUFLLEtBQUtBLFdBQVcsTUFBTUE7SUFDeEQsT0FBTyxJQUFJLENBQUNHLE1BQU07UUFDaEJBLE9BQU87SUFDVDtJQUVBLElBQUlGLFFBQVFBLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBS0EsT0FBTyxNQUFNQTtJQUMxQyxJQUFJVSxVQUFVQSxNQUFNLENBQUMsRUFBRSxLQUFLLEtBQUtBLFNBQVMsTUFBTUE7SUFFaERYLFdBQVdBLFNBQVNLLE9BQU8sQ0FBQyxTQUFTRDtJQUNyQ08sU0FBU0EsT0FBT04sT0FBTyxDQUFDLEtBQUs7SUFFN0IsT0FBTyxLQUFHTixXQUFXSSxPQUFPSCxXQUFXVyxTQUFTVjtBQUNsRDtBQUVPLE1BQU1QLGdCQUFnQjtJQUMzQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVNLFNBQVNELHFCQUFxQnNCLEdBQWM7SUFDakQsSUFBSUMsSUFBeUIsRUFBZTtRQUMxQyxJQUFJRCxRQUFRLFFBQVEsT0FBT0EsUUFBUSxVQUFVO1lBQzNDRSxPQUFPQyxJQUFJLENBQUNILEtBQUtJLE9BQU8sQ0FBQyxDQUFDQztnQkFDeEIsSUFBSSxDQUFDMUIsY0FBYzJCLFFBQVEsQ0FBQ0QsTUFBTTtvQkFDaENFLFFBQVFDLElBQUksQ0FDVix1REFBcURIO2dCQUV6RDtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE9BQU81QixVQUFVdUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLnRzPzFiODciXSwibmFtZXMiOlsiZm9ybWF0VXJsIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJ1cmxPYmplY3RLZXlzIiwic2xhc2hlZFByb3RvY29scyIsInVybE9iaiIsImF1dGgiLCJob3N0bmFtZSIsInByb3RvY29sIiwicGF0aG5hbWUiLCJoYXNoIiwicXVlcnkiLCJob3N0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImluZGV4T2YiLCJwb3J0IiwiU3RyaW5nIiwicXVlcnlzdHJpbmciLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwiZW5kc1dpdGgiLCJzbGFzaGVzIiwidGVzdCIsInVybCIsInByb2Nlc3MiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/index.js":
/*!******************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/index.js ***!
  \******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getSortedRoutes: function() {\n        return _sortedroutes.getSortedRoutes;\n    },\n    isDynamicRoute: function() {\n        return _isdynamic.isDynamicRoute;\n    }\n});\nconst _sortedroutes = __webpack_require__(/*! ./sorted-routes */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\");\nconst _isdynamic = __webpack_require__(/*! ./is-dynamic */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\"); //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQUFTQSxpQkFBZTtlQUFmQSxjQUFBQSxlQUFlOztJQUNmQyxnQkFBYztlQUFkQSxXQUFBQSxjQUFjOzs7MENBRFM7dUNBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pbmRleC50cz83MmQ1Il0sIm5hbWVzIjpbImdldFNvcnRlZFJvdXRlcyIsImlzRHluYW1pY1JvdXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js":
/*!***************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"interpolateAs\", ({\n    enumerable: true,\n    get: function() {\n        return interpolateAs;\n    }\n}));\nconst _routematcher = __webpack_require__(/*! ./route-matcher */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./route-regex */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = \"\";\n    const dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || \"\";\n        const { repeat, optional } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n        if (optional) {\n            replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n} //# sourceMappingURL=interpolate-as.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2ludGVycG9sYXRlLWFzLmpzIiwibWFwcGluZ3MiOiI7Ozs7aURBS2dCQTs7O2VBQUFBOzs7MENBSGdCO3dDQUNGO0FBRXZCLFNBQVNBLGNBQ2RDLEtBQWEsRUFDYkMsVUFBa0IsRUFDbEJDLEtBQXFCO0lBRXJCLElBQUlDLG9CQUFvQjtJQUV4QixNQUFNQyxlQUFlQyxDQUFBQSxHQUFBQSxZQUFBQSxhQUFhLEVBQUNMO0lBQ25DLE1BQU1NLGdCQUFnQkYsYUFBYUcsTUFBTTtJQUN6QyxNQUFNQyxpQkFFSFAsQ0FBQUEsZUFBZUQsUUFBUVMsQ0FBQUEsR0FBQUEsY0FBQUEsZUFBZSxFQUFDTCxjQUFjSCxjQUFjLE9BQ3BFLGdEQUFnRDtJQUNoRCxzRUFBc0U7SUFDdEVDO0lBRUZDLG9CQUFvQkg7SUFDcEIsTUFBTVUsU0FBU0MsT0FBT0MsSUFBSSxDQUFDTjtJQUUzQixJQUNFLENBQUNJLE9BQU9HLEtBQUssQ0FBQyxDQUFDQztRQUNiLElBQUlDLFFBQVFQLGNBQWMsQ0FBQ00sTUFBTSxJQUFJO1FBQ3JDLE1BQU0sRUFBRUUsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR1gsYUFBYSxDQUFDUSxNQUFNO1FBRWpELGlDQUFpQztRQUNqQywwREFBMEQ7UUFDMUQsSUFBSUksV0FBVyxNQUFJRixDQUFBQSxTQUFTLFFBQVEsTUFBS0YsUUFBTTtRQUMvQyxJQUFJRyxVQUFVO1lBQ1pDLFdBQVcsQ0FBRyxDQUFDSCxRQUFRLE1BQU0sTUFBRyxNQUFHRyxXQUFTO1FBQzlDO1FBQ0EsSUFBSUYsVUFBVSxDQUFDRyxNQUFNQyxPQUFPLENBQUNMLFFBQVFBLFFBQVE7WUFBQ0E7U0FBTTtRQUVwRCxPQUNFLENBQUNFLFlBQVlILFNBQVNOLGNBQUFBLEtBQ3RCLDZDQUE2QztRQUM1Q0wsQ0FBQUEsb0JBQ0NBLGtCQUFtQmtCLE9BQU8sQ0FDeEJILFVBQ0FGLFNBQ0lELE1BQ0dPLEdBQUcsQ0FFRix1REFBdUQ7UUFDdkQsa0RBQWtEO1FBQ2xELG9DQUFvQztRQUNwQyxDQUFDQyxVQUFZQyxtQkFBbUJELFVBRWpDRSxJQUFJLENBQUMsT0FDUkQsbUJBQW1CVCxXQUNwQjtJQUVYLElBQ0E7UUFDQVosb0JBQW9CLEdBQUcsbUNBQW1DOztJQUUxRCx1RUFBdUU7SUFDdkUsa0RBQWtEO0lBQ3BEO0lBQ0EsT0FBTztRQUNMTztRQUNBZ0IsUUFBUXZCO0lBQ1Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2ludGVycG9sYXRlLWFzLnRzPzllMzEiXSwibmFtZXMiOlsiaW50ZXJwb2xhdGVBcyIsInJvdXRlIiwiYXNQYXRobmFtZSIsInF1ZXJ5IiwiaW50ZXJwb2xhdGVkUm91dGUiLCJkeW5hbWljUmVnZXgiLCJnZXRSb3V0ZVJlZ2V4IiwiZHluYW1pY0dyb3VwcyIsImdyb3VwcyIsImR5bmFtaWNNYXRjaGVzIiwiZ2V0Um91dGVNYXRjaGVyIiwicGFyYW1zIiwiT2JqZWN0Iiwia2V5cyIsImV2ZXJ5IiwicGFyYW0iLCJ2YWx1ZSIsInJlcGVhdCIsIm9wdGlvbmFsIiwicmVwbGFjZWQiLCJBcnJheSIsImlzQXJyYXkiLCJyZXBsYWNlIiwibWFwIiwic2VnbWVudCIsImVuY29kZVVSSUNvbXBvbmVudCIsImpvaW4iLCJyZXN1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/*!***********************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isDynamicRoute\", ({\n    enumerable: true,\n    get: function() {\n        return isDynamicRoute;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/../node_modules/next/dist/server/future/helpers/interception-routes.js\");\n// Identify /[param]/ in route string\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {\n        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;\n    }\n    return TEST_ROUTE.test(route);\n} //# sourceMappingURL=is-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMuanMiLCJtYXBwaW5ncyI6Ijs7OztrREFRZ0JBOzs7ZUFBQUE7OztnREFMVDtBQUVQLHFDQUFxQztBQUNyQyxNQUFNQyxhQUFhO0FBRVosU0FBU0QsZUFBZUUsS0FBYTtJQUMxQyxJQUFJQyxDQUFBQSxHQUFBQSxvQkFBQUEsMEJBQTBCLEVBQUNELFFBQVE7UUFDckNBLFFBQVFFLENBQUFBLEdBQUFBLG9CQUFBQSxtQ0FBbUMsRUFBQ0YsT0FBT0csZ0JBQWdCO0lBQ3JFO0lBRUEsT0FBT0osV0FBV0ssSUFBSSxDQUFDSjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMudHM/ODJkYyJdLCJuYW1lcyI6WyJpc0R5bmFtaWNSb3V0ZSIsIlRFU1RfUk9VVEUiLCJyb3V0ZSIsImlzSW50ZXJjZXB0aW9uUm91dGVBcHBQYXRoIiwiZXh0cmFjdEludGVyY2VwdGlvblJvdXRlSW5mb3JtYXRpb24iLCJpbnRlcmNlcHRlZFJvdXRlIiwidGVzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!*************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/utils.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/../node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWxvY2FsLXVybC5qcyIsIm1hcHBpbmdzIjoiOzs7OzhDQU1nQkE7OztlQUFBQTs7O21DQU5pQzt5Q0FDckI7QUFLckIsU0FBU0EsV0FBV0MsR0FBVztJQUNwQyxnRUFBZ0U7SUFDaEUsSUFBSSxDQUFDQyxDQUFBQSxHQUFBQSxPQUFBQSxhQUFhLEVBQUNELE1BQU0sT0FBTztJQUNoQyxJQUFJO1FBQ0YsNERBQTREO1FBQzVELE1BQU1FLGlCQUFpQkMsQ0FBQUEsR0FBQUEsT0FBQUEsaUJBQWlCO1FBQ3hDLE1BQU1DLFdBQVcsSUFBSUMsSUFBSUwsS0FBS0U7UUFDOUIsT0FBT0UsU0FBU0UsTUFBTSxLQUFLSixrQkFBa0JLLENBQUFBLEdBQUFBLGFBQUFBLFdBQVcsRUFBQ0gsU0FBU0ksUUFBUTtJQUM1RSxFQUFFLE9BQU9DLEdBQUc7UUFDVixPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWxvY2FsLXVybC50cz8wNGU1Il0sIm5hbWVzIjpbImlzTG9jYWxVUkwiLCJ1cmwiLCJpc0Fic29sdXRlVXJsIiwibG9jYXRpb25PcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiVVJMIiwib3JpZ2luIiwiaGFzQmFzZVBhdGgiLCJwYXRobmFtZSIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/omit.js":
/*!*****************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/omit.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"omit\", ({\n    enumerable: true,\n    get: function() {\n        return omit;\n    }\n}));\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n} //# sourceMappingURL=omit.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL29taXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozt3Q0FBZ0JBOzs7ZUFBQUE7OztBQUFULFNBQVNBLEtBQ2RDLE1BQVMsRUFDVEMsSUFBUztJQUVULE1BQU1DLFVBQXNDLENBQUM7SUFDN0NDLE9BQU9GLElBQUksQ0FBQ0QsUUFBUUksT0FBTyxDQUFDLENBQUNDO1FBQzNCLElBQUksQ0FBQ0osS0FBS0ssUUFBUSxDQUFDRCxNQUFXO1lBQzVCSCxPQUFPLENBQUNHLElBQUksR0FBR0wsTUFBTSxDQUFDSyxJQUFJO1FBQzVCO0lBQ0Y7SUFDQSxPQUFPSDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdC50cz9iN2E4Il0sIm5hbWVzIjpbIm9taXQiLCJvYmplY3QiLCJrZXlzIiwib21pdHRlZCIsIk9iamVjdCIsImZvckVhY2giLCJrZXkiLCJpbmNsdWRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/omit.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    assign: function() {\n        return assign;\n    },\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    searchParams.forEach((value, key)=>{\n        if (typeof query[key] === \"undefined\") {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n        return String(param);\n    } else {\n        return \"\";\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    const result = new URLSearchParams();\n    Object.entries(urlQuery).forEach((param)=>{\n        let [key, value] = param;\n        if (Array.isArray(value)) {\n            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach((searchParams)=>{\n        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n        searchParams.forEach((value, key)=>target.append(key, value));\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQTRDZ0JBLFFBQU07ZUFBTkE7O0lBMUNBQyx3QkFBc0I7ZUFBdEJBOztJQTRCQUMsd0JBQXNCO2VBQXRCQTs7O0FBNUJULFNBQVNELHVCQUNkRSxZQUE2QjtJQUU3QixNQUFNQyxRQUF3QixDQUFDO0lBQy9CRCxhQUFhRSxPQUFPLENBQUMsQ0FBQ0MsT0FBT0M7UUFDM0IsSUFBSSxPQUFPSCxLQUFLLENBQUNHLElBQUksS0FBSyxhQUFhO1lBQ3JDSCxLQUFLLENBQUNHLElBQUksR0FBR0Q7UUFDZixPQUFPLElBQUlFLE1BQU1DLE9BQU8sQ0FBQ0wsS0FBSyxDQUFDRyxJQUFJLEdBQUc7WUFDbENILEtBQUssQ0FBQ0csSUFBSSxDQUFjRyxJQUFJLENBQUNKO1FBQ2pDLE9BQU87WUFDTEYsS0FBSyxDQUFDRyxJQUFJLEdBQUc7Z0JBQUNILEtBQUssQ0FBQ0csSUFBSTtnQkFBWUQ7YUFBTTtRQUM1QztJQUNGO0lBQ0EsT0FBT0Y7QUFDVDtBQUVBLFNBQVNPLHVCQUF1QkMsS0FBYztJQUM1QyxJQUNFLE9BQU9BLFVBQVUsWUFDaEIsT0FBT0EsVUFBVSxZQUFZLENBQUNDLE1BQU1ELFVBQ3JDLE9BQU9BLFVBQVUsV0FDakI7UUFDQSxPQUFPRSxPQUFPRjtJQUNoQixPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0Y7QUFFTyxTQUFTVix1QkFDZGEsUUFBd0I7SUFFeEIsTUFBTUMsU0FBUyxJQUFJQztJQUNuQkMsT0FBT0MsT0FBTyxDQUFDSixVQUFVVixPQUFPLENBQUMsQ0FBQU87WUFBQyxDQUFDTCxLQUFLRCxNQUFNLEdBQUFNO1FBQzVDLElBQUlKLE1BQU1DLE9BQU8sQ0FBQ0gsUUFBUTtZQUN4QkEsTUFBTUQsT0FBTyxDQUFDLENBQUNlLE9BQVNKLE9BQU9LLE1BQU0sQ0FBQ2QsS0FBS0ksdUJBQXVCUztRQUNwRSxPQUFPO1lBQ0xKLE9BQU9NLEdBQUcsQ0FBQ2YsS0FBS0ksdUJBQXVCTDtRQUN6QztJQUNGO0lBQ0EsT0FBT1U7QUFDVDtBQUVPLFNBQVNoQixPQUNkdUIsTUFBdUI7SUFDdkIsUUFBQUMsT0FBQUMsVUFBQUMsTUFBQSxFQUFBQyxtQkFBQSxJQUFBbkIsTUFBQWdCLE9BQUEsSUFBQUEsT0FBQSxRQUFBSSxPQUFBLEdBQUFBLE9BQUFKLE1BQUFJLE9BQUE7UUFBR0QsZ0JBQUFBLENBQUhDLE9BQUEsS0FBQUgsU0FBQSxDQUFBRyxLQUFzQzs7SUFFdENELGlCQUFpQnRCLE9BQU8sQ0FBQyxDQUFDRjtRQUN4QkssTUFBTXFCLElBQUksQ0FBQzFCLGFBQWEyQixJQUFJLElBQUl6QixPQUFPLENBQUMsQ0FBQ0UsTUFBUWdCLE9BQU9RLE1BQU0sQ0FBQ3hCO1FBQy9ESixhQUFhRSxPQUFPLENBQUMsQ0FBQ0MsT0FBT0MsTUFBUWdCLE9BQU9GLE1BQU0sQ0FBQ2QsS0FBS0Q7SUFDMUQ7SUFDQSxPQUFPaUI7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLnRzPzgyZmEiXSwibmFtZXMiOlsiYXNzaWduIiwic2VhcmNoUGFyYW1zVG9VcmxRdWVyeSIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsImZvckVhY2giLCJ2YWx1ZSIsImtleSIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJzdHJpbmdpZnlVcmxRdWVyeVBhcmFtIiwicGFyYW0iLCJpc05hTiIsIlN0cmluZyIsInVybFF1ZXJ5IiwicmVzdWx0IiwiVVJMU2VhcmNoUGFyYW1zIiwiT2JqZWN0IiwiZW50cmllcyIsIml0ZW0iLCJhcHBlbmQiLCJzZXQiLCJ0YXJnZXQiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic2VhcmNoUGFyYW1zTGlzdCIsIl9rZXkiLCJmcm9tIiwia2V5cyIsImRlbGV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!**************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getRouteMatcher\", ({\n    enumerable: true,\n    get: function() {\n        return getRouteMatcher;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/utils.js\");\nfunction getRouteMatcher(param) {\n    let { re, groups } = param;\n    return (pathname)=>{\n        const routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        const decode = (param)=>{\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError(\"failed to decode param\");\n            }\n        };\n        const params = {};\n        Object.keys(groups).forEach((slugName)=>{\n            const g = groups[slugName];\n            const m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf(\"/\") ? m.split(\"/\").map((entry)=>decode(entry)) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n} //# sourceMappingURL=route-matcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLW1hdGNoZXIuanMiLCJtYXBwaW5ncyI6Ijs7OzttREFXZ0JBOzs7ZUFBQUE7OzttQ0FWWTtBQVVyQixTQUFTQSxnQkFBZ0JDLEtBQTBCO0lBQTFCLE1BQUVDLEVBQUUsRUFBRUMsTUFBTSxFQUFjLEdBQTFCRjtJQUM5QixPQUFPLENBQUNHO1FBQ04sTUFBTUMsYUFBYUgsR0FBR0ksSUFBSSxDQUFDRjtRQUMzQixJQUFJLENBQUNDLFlBQVk7WUFDZixPQUFPO1FBQ1Q7UUFFQSxNQUFNRSxTQUFTLENBQUNOO1lBQ2QsSUFBSTtnQkFDRixPQUFPTyxtQkFBbUJQO1lBQzVCLEVBQUUsT0FBT1EsR0FBRztnQkFDVixNQUFNLElBQUlDLE9BQUFBLFdBQVcsQ0FBQztZQUN4QjtRQUNGO1FBQ0EsTUFBTUMsU0FBcUQsQ0FBQztRQUU1REMsT0FBT0MsSUFBSSxDQUFDVixRQUFRVyxPQUFPLENBQUMsQ0FBQ0M7WUFDM0IsTUFBTUMsSUFBSWIsTUFBTSxDQUFDWSxTQUFTO1lBQzFCLE1BQU1FLElBQUlaLFVBQVUsQ0FBQ1csRUFBRUUsR0FBRyxDQUFDO1lBQzNCLElBQUlELE1BQU1FLFdBQVc7Z0JBQ25CUixNQUFNLENBQUNJLFNBQVMsR0FBRyxDQUFDRSxFQUFFRyxPQUFPLENBQUMsT0FDMUJILEVBQUVJLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUMsQ0FBQ0MsUUFBVWhCLE9BQU9nQixVQUNuQ1AsRUFBRVEsTUFBTSxHQUNSO29CQUFDakIsT0FBT1U7aUJBQUcsR0FDWFYsT0FBT1U7WUFDYjtRQUNGO1FBQ0EsT0FBT047SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci50cz8zMTc5Il0sIm5hbWVzIjpbImdldFJvdXRlTWF0Y2hlciIsInBhcmFtIiwicmUiLCJncm91cHMiLCJwYXRobmFtZSIsInJvdXRlTWF0Y2giLCJleGVjIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiXyIsIkRlY29kZUVycm9yIiwicGFyYW1zIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJzbHVnTmFtZSIsImciLCJtIiwicG9zIiwidW5kZWZpbmVkIiwiaW5kZXhPZiIsInNwbGl0IiwibWFwIiwiZW50cnkiLCJyZXBlYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/route-matcher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getNamedMiddlewareRegex: function() {\n        return getNamedMiddlewareRegex;\n    },\n    getNamedRouteRegex: function() {\n        return getNamedRouteRegex;\n    },\n    getRouteRegex: function() {\n        return getRouteRegex;\n    },\n    parseParameter: function() {\n        return parseParameter;\n    }\n});\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/../node_modules/next/dist/server/future/helpers/interception-routes.js\");\nconst _escaperegexp = __webpack_require__(/*! ../../escape-regexp */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/escape-regexp.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\nfunction parseParameter(param) {\n    const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (markerMatch && paramMatches) {\n                const { key, optional, repeat } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n            } else if (paramMatches) {\n                const { key, repeat, optional } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let i = 0;\n    return ()=>{\n        let routeKey = \"\";\n        let j = ++i;\n        while(j > 0){\n            routeKey += String.fromCharCode(97 + (j - 1) % 26);\n            j = Math.floor((j - 1) / 26);\n        }\n        return routeKey;\n    };\n}\nfunction getSafeKeyFromSegment(param) {\n    let { interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix } = param;\n    const { key, optional, repeat } = parseParameter(segment);\n    // replace any non-word characters since they can break\n    // the named regex\n    let cleanedKey = key.replace(/\\W/g, \"\");\n    if (keyPrefix) {\n        cleanedKey = \"\" + keyPrefix + cleanedKey;\n    }\n    let invalidKey = false;\n    // check if the key is still invalid and fallback to using a known\n    // safe key\n    if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n        invalidKey = true;\n    }\n    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n        invalidKey = true;\n    }\n    if (invalidKey) {\n        cleanedKey = getSafeRouteKey();\n    }\n    if (keyPrefix) {\n        routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n    } else {\n        routeKeys[cleanedKey] = key;\n    }\n    // if the segment has an interception marker, make sure that's part of the regex pattern\n    // this is to ensure that the route with the interception marker doesn't incorrectly match\n    // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n    const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : \"\";\n    return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (hasInterceptionMarker && paramMatches) {\n                const [usedMarker] = segment.split(paramMatches[0]);\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    interceptionMarker: usedMarker,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                });\n            } else if (paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n                });\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n    const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n    return {\n        ...getRouteRegex(normalizedRoute),\n        namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n        routeKeys: result.routeKeys\n    };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);\n    const { catchAll = true } = options;\n    if (parameterizedRoute === \"/\") {\n        let catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\" + catchAllRegex + \"$\"\n        };\n    }\n    const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);\n    let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQTJOZ0JBLHlCQUF1QjtlQUF2QkE7O0lBaEJBQyxvQkFBa0I7ZUFBbEJBOztJQW5JQUMsZUFBYTtlQUFiQTs7SUE5Q0FDLGdCQUFjO2VBQWRBOzs7Z0RBMUIyQjswQ0FDUjtpREFDQztBQUVwQyxNQUFNQywwQkFBMEI7QUFDaEMsTUFBTUMsa0NBQWtDO0FBcUJqQyxTQUFTRixlQUFlRyxLQUFhO0lBQzFDLE1BQU1DLFdBQVdELE1BQU1FLFVBQVUsQ0FBQyxRQUFRRixNQUFNRyxRQUFRLENBQUM7SUFDekQsSUFBSUYsVUFBVTtRQUNaRCxRQUFRQSxNQUFNSSxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQzFCO0lBQ0EsTUFBTUMsU0FBU0wsTUFBTUUsVUFBVSxDQUFDO0lBQ2hDLElBQUlHLFFBQVE7UUFDVkwsUUFBUUEsTUFBTUksS0FBSyxDQUFDO0lBQ3RCO0lBQ0EsT0FBTztRQUFFRSxLQUFLTjtRQUFPSztRQUFRSjtJQUFTO0FBQ3hDO0FBRUEsU0FBU00scUJBQXFCQyxLQUFhO0lBQ3pDLE1BQU1DLFdBQVdDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBbUIsRUFBQ0YsT0FBT0osS0FBSyxDQUFDLEdBQUdPLEtBQUssQ0FBQztJQUMzRCxNQUFNQyxTQUF5QyxDQUFDO0lBQ2hELElBQUlDLGFBQWE7SUFDakIsT0FBTztRQUNMQyxvQkFBb0JMLFNBQ2pCTSxHQUFHLENBQUMsQ0FBQ0M7WUFDSixNQUFNQyxjQUFjQyxvQkFBQUEsMEJBQTBCLENBQUNDLElBQUksQ0FBQyxDQUFDQyxJQUNuREosUUFBUWQsVUFBVSxDQUFDa0I7WUFFckIsTUFBTUMsZUFBZUwsUUFBUU0sS0FBSyxDQUFDLHVCQUF1Qix1QkFBdUI7O1lBRWpGLElBQUlMLGVBQWVJLGNBQWM7Z0JBQy9CLE1BQU0s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RUQsTUFBTSxFQUFFN0Msa0JBQWtCLEVBQUUsR0FBR1AscUJBQXFCbUI7SUFDcEQsTUFBTSxFQUFFa0MsV0FBVyxJQUFJLEVBQUUsR0FBR0Q7SUFDNUIsSUFBSTdDLHVCQUF1QixLQUFLO1FBQzlCLElBQUkrQyxnQkFBZ0JELFdBQVcsT0FBTztRQUN0QyxPQUFPO1lBQ0xGLFlBQVksT0FBS0csZ0JBQWM7UUFDakM7SUFDRjtJQUVBLE1BQU0sRUFBRVYsdUJBQXVCLEVBQUUsR0FBR0YsMEJBQ2xDdkIsaUJBQ0E7SUFFRixJQUFJb0MsdUJBQXVCRixXQUFXLGVBQWU7SUFDckQsT0FBTztRQUNMRixZQUFZLE1BQUlQLDBCQUEwQlcsdUJBQXFCO0lBQ2pFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1yZWdleC50cz8xNmExIl0sIm5hbWVzIjpbImdldE5hbWVkTWlkZGxld2FyZVJlZ2V4IiwiZ2V0TmFtZWRSb3V0ZVJlZ2V4IiwiZ2V0Um91dGVSZWdleCIsInBhcnNlUGFyYW1ldGVyIiwiTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVgiLCJORVhUX0lOVEVSQ0VQVElPTl9NQVJLRVJfUFJFRklYIiwicGFyYW0iLCJvcHRpb25hbCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNsaWNlIiwicmVwZWF0Iiwia2V5IiwiZ2V0UGFyYW1ldHJpemVkUm91dGUiLCJyb3V0ZSIsInNlZ21lbnRzIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsInNwbGl0IiwiZ3JvdXBzIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsIm1hcCIsInNlZ21lbnQiLCJtYXJrZXJNYXRjaCIsIklOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTIiwiZmluZCIsIm0iLCJwYXJhbU1hdGNoZXMiLCJtYXRjaCIsInBvcyIsImVzY2FwZVN0cmluZ1JlZ2V4cCIsImpvaW4iLCJub3JtYWxpemVkUm91dGUiLCJyZSIsIlJlZ0V4cCIsImJ1aWxkR2V0U2FmZVJvdXRlS2V5IiwiaSIsInJvdXRlS2V5IiwiaiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIk1hdGgiLCJmbG9vciIsImdldFNhZmVLZXlGcm9tU2VnbWVudCIsImludGVyY2VwdGlvbk1hcmtlciIsImdldFNhZmVSb3V0ZUtleSIsInJvdXRlS2V5cyIsImtleVByZWZpeCIsImNsZWFuZWRLZXkiLCJyZXBsYWNlIiwiaW52YWxpZEtleSIsImxlbmd0aCIsImlzTmFOIiwicGFyc2VJbnQiLCJpbnRlcmNlcHRpb25QcmVmaXgiLCJnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlIiwicHJlZml4Um91dGVLZXlzIiwibmFtZWRQYXJhbWV0ZXJpemVkUm91dGUiLCJoYXNJbnRlcmNlcHRpb25NYXJrZXIiLCJzb21lIiwidXNlZE1hcmtlciIsInVuZGVmaW5lZCIsInByZWZpeFJvdXRlS2V5IiwicmVzdWx0IiwibmFtZWRSZWdleCIsIm9wdGlvbnMiLCJjYXRjaEFsbCIsImNhdGNoQWxsUmVnZXgiLCJjYXRjaEFsbEdyb3VwZWRSZWdleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/route-regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/*!**************************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/utils/sorted-routes.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSortedRoutes\", ({\n    enumerable: true,\n    get: function() {\n        return getSortedRoutes;\n    }\n}));\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split(\"/\").filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix) {\n        if (prefix === void 0) prefix = \"/\";\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[]\"), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[...]\"), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[[...]]\"), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(\"\" + prefix + c + \"/\")).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ], []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get(\"[]\")._smoosh(prefix + \"[\" + this.slugName + \"]/\"));\n        }\n        if (!this.placeholder) {\n            const r = prefix === \"/\" ? \"/\" : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error('You cannot define a route with the same specificity as a optional catch-all route (\"' + r + '\" and \"' + r + \"[[...\" + this.optionalRestSlugName + ']]\").');\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get(\"[...]\")._smoosh(prefix + \"[...\" + this.restSlugName + \"]/\"));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get(\"[[...]]\")._smoosh(prefix + \"[[...\" + this.optionalRestSlugName + \"]]/\"));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(\"Catch-all must be the last part of the URL.\");\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith(\"[\") && nextSegment.endsWith(\"]\")) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith(\"[\") && segmentName.endsWith(\"]\")) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith(\"...\")) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith(\"[\") || segmentName.endsWith(\"]\")) {\n                throw new Error(\"Segment names may not start or end with extra brackets ('\" + segmentName + \"').\");\n            }\n            if (segmentName.startsWith(\".\")) {\n                throw new Error(\"Segment names may not start with erroneous periods ('\" + segmentName + \"').\");\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(\"You cannot use different slug names for the same dynamic path ('\" + previousSlug + \"' !== '\" + nextSlug + \"').\");\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error('You cannot have the same slug name \"' + nextSlug + '\" repeat within a single dynamic path');\n                    }\n                    if (slug.replace(/\\W/g, \"\") === nextSegment.replace(/\\W/g, \"\")) {\n                        throw new Error('You cannot have the slug names \"' + slug + '\" and \"' + nextSlug + '\" differ only by non-word symbols within a single dynamic path');\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error('You cannot use both an required and optional catch-all route at the same level (\"[...' + this.restSlugName + ']\" and \"' + urlPaths[0] + '\" ).');\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = \"[[...]]\";\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error('You cannot use both an optional and required catch-all route at the same level (\"[[...' + this.optionalRestSlugName + ']]\" and \"' + urlPaths[0] + '\").');\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = \"[...]\";\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error('Optional route parameters are not yet supported (\"' + urlPaths[0] + '\").');\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = \"[]\";\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath));\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n} //# sourceMappingURL=sorted-routes.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3NvcnRlZC1yb3V0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7OzttREFxTWdCQTs7O2VBQUFBOzs7QUFyTWhCLE1BQU1DO0lBT0pDLE9BQU9DLE9BQWUsRUFBUTtRQUM1QixJQUFJLENBQUNDLE9BQU8sQ0FBQ0QsUUFBUUUsS0FBSyxDQUFDLEtBQUtDLE1BQU0sQ0FBQ0MsVUFBVSxFQUFFLEVBQUU7SUFDdkQ7SUFFQUMsU0FBbUI7UUFDakIsT0FBTyxJQUFJLENBQUNDLE9BQU87SUFDckI7SUFFUUEsUUFBUUMsTUFBb0IsRUFBWTtRQUFoQ0EsSUFBQUEsV0FBQUEsS0FBQUEsR0FBQUEsU0FBaUI7UUFDL0IsTUFBTUMsZ0JBQWdCO2VBQUksSUFBSSxDQUFDQyxRQUFRLENBQUNDLElBQUk7U0FBRyxDQUFDQyxJQUFJO1FBQ3BELElBQUksSUFBSSxDQUFDQyxRQUFRLEtBQUssTUFBTTtZQUMxQkosY0FBY0ssTUFBTSxDQUFDTCxjQUFjTSxPQUFPLENBQUMsT0FBTztRQUNwRDtRQUNBLElBQUksSUFBSSxDQUFDQyxZQUFZLEtBQUssTUFBTTtZQUM5QlAsY0FBY0ssTUFBTSxDQUFDTCxjQUFjTSxPQUFPLENBQUMsVUFBVTtRQUN2RDtRQUNBLElBQUksSUFBSSxDQUFDRSxvQkFBb0IsS0FBSyxNQUFNO1lBQ3RDUixjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxZQUFZO1FBQ3pEO1FBRUEsTUFBTUcsU0FBU1QsY0FDWlUsR0FBRyxDQUFDLENBQUNDLElBQU0sSUFBSSxDQUFDVixRQUFRLENBQUNXLEdBQUcsQ0FBQ0QsR0FBSWIsT0FBTyxDQUFDLEtBQUdDLFNBQVNZLElBQUUsTUFDdkRFLE1BQU0sQ0FBQyxDQUFDQyxNQUFNQyxPQUFTO21CQUFJRDttQkFBU0M7YUFBSyxFQUFFLEVBQUU7UUFFaEQsSUFBSSxJQUFJLENBQUNYLFFBQVEsS0FB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LENBQUN6QixRQUFRLENBQUNzQyxHQUFHLENBQUNiLGFBQWEsSUFBSXBDO1FBQ3JDO1FBRUEsSUFBSSxDQUFDVyxRQUFRLENBQ1ZXLEdBQUcsQ0FBQ2MsYUFDSmpDLE9BQU8sQ0FBQzZCLFNBQVNILEtBQUssQ0FBQyxJQUFJSSxXQUFXQztJQUMzQzs7YUFqTUFQLFdBQUFBLEdBQXVCO2FBQ3ZCaEIsUUFBQUEsR0FBaUMsSUFBSXVDO2FBQ3JDcEMsUUFBQUEsR0FBMEI7YUFDMUJHLFlBQUFBLEdBQThCO2FBQzlCQyxvQkFBQUEsR0FBc0M7O0FBOEx4QztBQUVPLFNBQVNuQixnQkFDZG9ELGVBQXNDO0lBRXRDLGtGQUFrRjtJQUNsRiw0RUFBNEU7SUFDNUUsMkNBQTJDO0lBRTNDLHlFQUF5RTtJQUN6RSwyQkFBMkI7SUFDM0Isb0NBQW9DO0lBQ3BDLDhFQUE4RTtJQUM5RSx3RUFBd0U7SUFDeEUsZ0hBQWdIO0lBQ2hILDRFQUE0RTtJQUM1RSxNQUFNQyxPQUFPLElBQUlwRDtJQUVqQiw2RkFBNkY7SUFDN0ZtRCxnQkFBZ0JOLE9BQU8sQ0FBQyxDQUFDUSxXQUFhRCxLQUFLbkQsTUFBTSxDQUFDb0Q7SUFDbEQsNEdBQTRHO0lBQzVHLE9BQU9ELEtBQUs3QyxNQUFNO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvc29ydGVkLXJvdXRlcy50cz9kNTNiIl0sIm5hbWVzIjpbImdldFNvcnRlZFJvdXRlcyIsIlVybE5vZGUiLCJpbnNlcnQiLCJ1cmxQYXRoIiwiX2luc2VydCIsInNwbGl0IiwiZmlsdGVyIiwiQm9vbGVhbiIsInNtb29zaCIsIl9zbW9vc2giLCJwcmVmaXgiLCJjaGlsZHJlblBhdGhzIiwiY2hpbGRyZW4iLCJrZXlzIiwic29ydCIsInNsdWdOYW1lIiwic3BsaWNlIiwiaW5kZXhPZiIsInJlc3RTbHVnTmFtZSIsIm9wdGlvbmFsUmVzdFNsdWdOYW1lIiwicm91dGVzIiwibWFwIiwiYyIsImdldCIsInJlZHVjZSIsInByZXYiLCJjdXJyIiwicHVzaCIsInBsYWNlaG9sZGVyIiwiciIsInNsaWNlIiwiRXJyb3IiLCJ1bnNoaWZ0IiwidXJsUGF0aHMiLCJzbHVnTmFtZXMiLCJpc0NhdGNoQWxsIiwibGVuZ3RoIiwibmV4dFNlZ21lbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzZWdtZW50TmFtZSIsImlzT3B0aW9uYWwiLCJzdWJzdHJpbmciLCJoYW5kbGVTbHVnIiwicHJldmlvdXNTbHVnIiwibmV4dFNsdWciLCJmb3JFYWNoIiwic2x1ZyIsInJlcGxhY2UiLCJoYXMiLCJzZXQiLCJNYXAiLCJub3JtYWxpemVkUGFnZXMiLCJyb290IiwicGFnZVBhdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/side-effect.js":
/*!***********************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/side-effect.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return SideEffect;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\nconst isServer = typeof window === \"undefined\";\nconst useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    const { headManager, reduceComponentsToState } = props;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect(()=>{\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        return ()=>{\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n        };\n    });\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect(()=>{\n        if (headManager) {\n            headManager._pendingUpdate = emitChange;\n        }\n        return ()=>{\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n        };\n    });\n    useClientOnlyEffect(()=>{\n        if (headManager && headManager._pendingUpdate) {\n            headManager._pendingUpdate();\n            headManager._pendingUpdate = null;\n        }\n        return ()=>{\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n        };\n    });\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvc2lkZS1lZmZlY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OzJDQW9CQTs7O2VBQXdCQTs7O21DQW5CNkI7QUFlckQsTUFBTUMsV0FBVyxPQUFPQyxXQUFXO0FBQ25DLE1BQU1DLDRCQUE0QkYsV0FBVyxLQUFPLElBQUlHLE9BQUFBLGVBQWU7QUFDdkUsTUFBTUMsc0JBQXNCSixXQUFXLEtBQU8sSUFBSUssT0FBQUEsU0FBUztBQUU1QyxTQUFTTixXQUFXTyxLQUFzQjs7SUFDdkQsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLHVCQUF1QixFQUFFLEdBQUdGO0lBRWpELFNBQVNHO1FBQ1AsSUFBSUYsZUFBZUEsWUFBWUcsZ0JBQWdCLEVBQUU7WUFDL0MsTUFBTUMsZUFBZUMsT0FBQUEsUUFBUSxDQUFDQyxPQUFPLENBQ25DQyxNQUFNQyxJQUFJLENBQUNSLFlBQVlHLGdCQUFnQixFQUEwQk0sTUFBTSxDQUNyRUM7WUFHSlYsWUFBWVcsVUFBVSxDQUFDVix3QkFBd0JHLGNBQWNMO1FBQy9EO0lBQ0Y7SUFFQSxJQUFJTixVQUFVO1lBQ1pPO1FBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBZ0IscUJBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtRQUNqRFg7SUFDRjtJQUVBUCwwQkFBMEI7WUFDeEJLO1FBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBZ0IscUJBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtRQUNqRCxPQUFPO2dCQUNMYjtZQUFBQSxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxnQ0FBQUEsWUFBYUcsZ0JBQWdCLHFCQUE3QkgsOEJBQStCYyxNQUFNLENBQUNmLE1BQU1jLFFBQVE7UUFDdEQ7SUFDRjtJQUVBLGtGQUFrRjtJQUNsRixvRkFBb0Y7SUFDcEYsZ0VBQWdFO0lBQ2hFLHFGQUFxRjtJQUNyRixtRkFBbUY7SUFDbkZsQiwwQkFBMEI7UUFDeEIsSUFBSUssYUFBYTtZQUNmQSxZQUFZZSxjQUFjLEdBQUdiO1FBQy9CO1FBQ0EsT0FBTztZQUNMLElBQUlGLGFBQWE7Z0JBQ2ZBLFlBQVllLGNBQWMsR0FBR2I7WUFDL0I7UUFDRjtJQUNGO0lBRUFMLG9CQUFvQjtRQUNsQixJQUFJRyxlQUFlQSxZQUFZZSxjQUFjLEVBQUU7WUFDN0NmLFlBQVllLGNBQWM7WUFDMUJmLFlBQVllLGNBQWMsR0FBRztRQUMvQjtRQUNBLE9BQU87WUFDTCxJQUFJZixlQUFlQSxZQUFZZSxjQUFjLEVBQUU7Z0JBQzdDZixZQUFZZSxjQUFjO2dCQUMxQmYsWUFBWWUsY0FBYyxHQUFHO1lBQy9CO1FBQ0Y7SUFDRjtJQUVBLE9BQU87QUFDVDtHQXhEd0J2Qjs7UUFtQnRCRztRQVlBQTtRQVdBRTs7O0tBMUNzQkwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3NpZGUtZWZmZWN0LnRzeD9lOGRkIl0sIm5hbWVzIjpbIlNpZGVFZmZlY3QiLCJpc1NlcnZlciIsIndpbmRvdyIsInVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDbGllbnRPbmx5RWZmZWN0IiwidXNlRWZmZWN0IiwicHJvcHMiLCJoZWFkTWFuYWdlciIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiZW1pdENoYW5nZSIsIm1vdW50ZWRJbnN0YW5jZXMiLCJoZWFkRWxlbWVudHMiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJBcnJheSIsImZyb20iLCJmaWx0ZXIiLCJCb29sZWFuIiwidXBkYXRlSGVhZCIsImFkZCIsImNoaWxkcmVuIiwiZGVsZXRlIiwiX3BlbmRpbmdVcGRhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/shared/lib/utils.js":
/*!*****************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/utils.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DecodeError: function() {\n        return DecodeError;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? \":\" + port : \"\");\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split(\"?\");\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\" + urlParts.slice(1).join(\"?\") : \"\");\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw new Error(message);\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw new Error(message);\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== \"undefined\";\nconst ST = SP && [\n    \"mark\",\n    \"measure\",\n    \"getEntriesByName\"\n].every((method)=>typeof performance[method] === \"function\");\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = \"ENOENT\";\n        this.name = \"PageNotFoundError\";\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = \"ENOENT\";\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBb2FhQSxhQUFXO2VBQVhBOztJQW9CQUMseUJBQXVCO2VBQXZCQTs7SUFQQUMsbUJBQWlCO2VBQWpCQTs7SUFaQUMsZ0JBQWM7ZUFBZEE7O0lBQ0FDLG1CQUFpQjtlQUFqQkE7O0lBVEFDLElBQUU7ZUFBRkE7O0lBQ0FDLElBQUU7ZUFBRkE7O0lBbFhBQyxZQUFVO2VBQVZBOztJQXNRR0MsVUFBUTtlQUFSQTs7SUErQkFDLGdCQUFjO2VBQWRBOztJQVhBQyxtQkFBaUI7ZUFBakJBOztJQUtBQyxRQUFNO2VBQU5BOztJQVBIQyxlQUFhO2VBQWJBOztJQW1CR0MsV0FBUztlQUFUQTs7SUFrQk1DLHFCQUFtQjtlQUFuQkE7O0lBZE5DLDBCQUF3QjtlQUF4QkE7O0lBK0dBQyxnQkFBYztlQUFkQTs7O0FBOVpULE1BQU1ULGFBQWE7SUFBQztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87Q0FBTztBQXNROUQsU0FBU0MsU0FDZFMsRUFBSztJQUVMLElBQUlDLE9BQU87SUFDWCxJQUFJQztJQUVKLE9BQVE7eUNBQUlDLE9BQUFBLElBQUFBLE1BQUFBLE9BQUFBLE9BQUFBLEdBQUFBLE9BQUFBLE1BQUFBLE9BQUFBO1lBQUFBLElBQUFBLENBQUFBLEtBQUFBLEdBQUFBLFNBQUFBLENBQUFBLEtBQUFBOztRQUNWLElBQUksQ0FBQ0YsTUFBTTtZQUNUQSxPQUFPO1lBQ1BDLFNBQVNGLE1BQU1HO1FBQ2pCO1FBQ0EsT0FBT0Q7SUFDVDtBQUNGO0FBRUEsMERBQTBEO0FBQzFELGdFQUFnRTtBQUNoRSxNQUFNRSxxQkFBcUI7QUFDcEIsTUFBTVQsZ0JBQWdCLENBQUNVLE1BQWdCRCxtQkFBbUJFLElBQUksQ0FBQ0Q7QUFFL0QsU0FBU1o7SUFDZCxNQUFNLEVBQUVjLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxJQUFJLEVB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RDtJQUNyQ1UsWUFBWUMsSUFBWSxFQUFFWixPQUFlLENBQUU7UUFDekMsS0FBSztRQUNMLElBQUksQ0FBQ0EsT0FBTyxHQUFHLDBDQUF3Q1ksT0FBSyxNQUFHWjtJQUNqRTtBQUNGO0FBRU8sTUFBTWpELGdDQUFnQ2tEO0lBRTNDVSxhQUFjO1FBQ1osS0FBSztRQUNMLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDYixPQUFPLEdBQUk7SUFDbEI7QUFDRjtBQVdPLFNBQVNsQyxlQUFlZ0QsS0FBWTtJQUN6QyxPQUFPQyxLQUFLQyxTQUFTLENBQUM7UUFBRWhCLFNBQVNjLE1BQU1kLE9BQU87UUFBRWlCLE9BQU9ILE1BQU1HLEtBQUs7SUFBQztBQUNyRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvdXRpbHMudHM/MWJkNSJdLCJuYW1lcyI6WyJEZWNvZGVFcnJvciIsIk1pZGRsZXdhcmVOb3RGb3VuZEVycm9yIiwiTWlzc2luZ1N0YXRpY1BhZ2UiLCJOb3JtYWxpemVFcnJvciIsIlBhZ2VOb3RGb3VuZEVycm9yIiwiU1AiLCJTVCIsIldFQl9WSVRBTFMiLCJleGVjT25jZSIsImdldERpc3BsYXlOYW1lIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJnZXRVUkwiLCJpc0Fic29sdXRlVXJsIiwiaXNSZXNTZW50IiwibG9hZEdldEluaXRpYWxQcm9wcyIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsInN0cmluZ2lmeUVycm9yIiwiZm4iLCJ1c2VkIiwicmVzdWx0IiwiYXJncyIsIkFCU09MVVRFX1VSTF9SRUdFWCIsInVybCIsInRlc3QiLCJwcm90b2NvbCIsImhvc3RuYW1lIiwicG9ydCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsIm9yaWdpbiIsInN1YnN0cmluZyIsImxlbmd0aCIsIkNvbXBvbmVudCIsImRpc3BsYXlOYW1lIiwibmFtZSIsInJlcyIsImZpbmlzaGVkIiwiaGVhZGVyc1NlbnQiLCJ1cmxQYXJ0cyIsInNwbGl0IiwidXJsTm9RdWVyeSIsInJlcGxhY2UiLCJzbGljZSIsImpvaW4iLCJBcHAiLCJjdHgiLCJwcm9jZXNzIiwicHJvdG90eXBlIiwiZ2V0SW5pdGlhbFByb3BzIiwibWVzc2FnZSIsIkVycm9yIiwicGFnZVByb3BzIiwicHJvcHMiLCJPYmplY3QiLCJrZXlzIiwiY29uc29sZSIsIndhcm4iLCJwZXJmb3JtYW5jZSIsImV2ZXJ5IiwibWV0aG9kIiwiY29uc3RydWN0b3IiLCJwYWdlIiwiY29kZSIsImVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0YWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!*****************************************************************************************!*\
  !*** ../node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsdUdBQTBCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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V0FBVyxjQUFjO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzPzkwYTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpOyAvLyBUT0RPOiBEZWxldGUgd2l0aCBlbmFibGVSZW5kZXJhYmxlQ29udGV4dFxuXG52YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnN1bWVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbnZhciBlbmFibGVSZW5kZXJhYmxlQ29udGV4dCA9IGZhbHNlO1xuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMiA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTsgLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyKSB7XG4gICAgICAvLyBUT0RPOiBDcmVhdGUgYSBjb252ZW50aW9uIGZvciBuYW1pbmcgY2xpZW50IHJlZmVyZW5jZXMgd2l0aCBkZWJ1ZyBpbmZvLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBSRUFDVF9DQUNIRV9UWVBFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJ0NhY2hlJztcbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCBlbmFibGVSZW5kZXJhYmxlQ29udGV4dCAgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuLyoqXG4gKiBMZXZlcmFnZXMgbmF0aXZlIGJyb3dzZXIvVk0gc3RhY2sgZnJhbWVzIHRvIGdldCBwcm9wZXIgZGV0YWlscyAoZS5nLlxuICogZmlsZW5hbWUsIGxpbmUgKyBjb2wgbnVtYmVyKSBmb3IgYSBzaW5nbGUgY29tcG9uZW50IGluIGEgY29tcG9uZW50IHN0YWNrLiBXZVxuICogZG8gdGhpcyBieTpcbiAqICAgKDEpIHRocm93aW5nIGFuZCBjYXRjaGluZyBhbiBlcnJvciBpbiB0aGUgZnVuY3Rpb24gLSB0aGlzIHdpbGwgYmUgb3VyXG4gKiAgICAgICBjb250cm9sIGVycm9yLlxuICogICAoMikgY2FsbGluZyB0aGUgY29tcG9uZW50IHdoaWNoIHdpbGwgZXZlbnR1YWxseSB0aHJvdyBhbiBlcnJvciB0aGF0IHdlJ2xsXG4gKiAgICAgICBjYXRjaCAtIHRoaXMgd2lsbCBiZSBvdXIgc2FtcGxlIGVycm9yLlxuICogICAoMykgZGlmZmluZyB0aGUgY29udHJvbCBhbmQgc2FtcGxlIGVycm9yIHN0YWNrcyB0byBmaW5kIHRoZSBzdGFjayBmcmFtZVxuICogICAgICAgd2hpY2ggcmVwcmVzZW50cyBvdXIgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuICAvKipcbiAgICogRmluZGluZyBhIGNvbW1vbiBzdGFjayBmcmFtZSBiZXR3ZWVuIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgY2FuIGJlXG4gICAqIHRyaWNreSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzIGFuZCBsZXZlbHMgb2Ygc3RhY2sgdHJhY2UgdHJ1bmNhdGlvbiBmcm9tXG4gICAqIGRpZmZlcmVudCBKUyBWTXMuIFNvIGluc3RlYWQgd2UnbGwgYXR0ZW1wdCB0byBjb250cm9sIHdoYXQgdGhhdCBjb21tb25cbiAgICogZnJhbWUgc2hvdWxkIGJlIHRocm91Z2ggdGhpcyBvYmplY3QgbWV0aG9kOlxuICAgKiBIYXZpbmcgYm90aCB0aGUgc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBiZSBpbiB0aGUgZnVuY3Rpb24gdW5kZXIgdGhlXG4gICAqIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgcHJvcGVydHksICsgc2V0dGluZyB0aGUgYG5hbWVgIGFuZFxuICAgKiBgZGlzcGxheU5hbWVgIHByb3BlcnRpZXMgb2YgdGhlIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBhIHN0YWNrXG4gICAqIGZyYW1lIGV4aXN0cyB0aGF0IGhhcyB0aGUgbWV0aG9kIG5hbWUgYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBpblxuICAgKiBpdCBmb3IgYm90aCBjb250cm9sIGFuZCBzYW1wbGUgc3RhY2tzLlxuICAgKi9cblxuXG4gIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb250cm9sO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICB9IC8vIFRPRE8obHVuYSk6IFRoaXMgd2lsbCBjdXJyZW50bHkgb25seSB0aHJvdyBpZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAgICAgLy8gaW4gc2ltcGxlIGNvbXBvbmVudHMgdG9vXG5cblxuICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSBmbigpOyAvLyBJZiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHJldHVybnMgYSBwcm9taXNlLCBpdCdzIGxpa2VseSBhbiBhc3luY1xuICAgICAgICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggd2UgZG9uJ3QgeWV0IHN1cHBvcnQuIEF0dGFjaCBhIG5vb3AgY2F0Y2ggaGFuZGxlciB0b1xuICAgICAgICAgIC8vIHNpbGVuY2UgdGhlIGVycm9yLlxuICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBjb21wb25lbnQgc3RhY2tzIGZvciBhc3luYyBjbGllbnQgY29tcG9uZW50cz9cblxuICAgICAgICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICB9XG4gIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnO1xuICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsICduYW1lJyk7IC8vIEJlZm9yZSBFUzYsIHRoZSBgbmFtZWAgcHJvcGVydHkgd2FzIG5vdCBjb25maWd1cmFibGUuXG5cbiAgaWYgKG5hbWVQcm9wRGVzY3JpcHRvciAmJiBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgLy8gVjggdXRpbGl6ZXMgYSBmdW5jdGlvbidzIGBuYW1lYCBwcm9wZXJ0eSB3aGVuIGdlbmVyYXRpbmcgYSBzdGFjayB0cmFjZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAvLyBDb25maWd1cmFibGUgcHJvcGVydGllcyBjYW4gYmUgdXBkYXRlZCBldmVuIGlmIGl0cyB3cml0YWJsZSBkZXNjcmlwdG9yXG4gICAgLy8gaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG4gICAgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCdcbiAgICB9KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuXG4gICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IDA7XG4gICAgICB2YXIgYyA9IDA7XG5cbiAgICAgIHdoaWxlIChzIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmICFzYW1wbGVMaW5lc1tzXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgcysrO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoYyA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiYgIWNvbnRyb2xMaW5lc1tjXS5pbmNsdWRlcygnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JykpIHtcbiAgICAgICAgYysrO1xuICAgICAgfSAvLyBXZSBjb3VsZG4ndCBmaW5kIG91ciBpbnRlbnRpb25hbGx5IGluamVjdGVkIGNvbW1vbiByb290IGZyYW1lLCBhdHRlbXB0XG4gICAgICAvLyB0byBmaW5kIGFub3RoZXIgY29tbW9uIHJvb3QgZnJhbWUgYnkgc2VhcmNoIGZyb20gdGhlIGJvdHRvbSBvZiB0aGVcbiAgICAgIC8vIGNvbnRyb2wgc3RhY2suLi5cblxuXG4gICAgICBpZiAocyA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8IGMgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICAgIGMtLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHtcbiAgICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG5mdW5jdGlvbiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCBfcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgcmVmO1xuXG4gIHtcbiAgICByZWYgPSBfcmVmO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQ7XG5cbiAge1xuICAgIC8vIEluIHByb2QsIGByZWZgIGlzIGEgcmVndWxhciBwcm9wZXJ0eS4gSXQgd2lsbCBiZSByZW1vdmVkIGluIGFcbiAgICAvLyBmdXR1cmUgcmVsZWFzZS5cbiAgICBlbGVtZW50ID0ge1xuICAgICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGtleToga2V5LFxuICAgICAgcmVmOiByZWYsXG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgX293bmVyOiBvd25lclxuICAgIH07XG4gIH1cblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIGRlYnVnSW5mbyBjb250YWlucyBTZXJ2ZXIgQ29tcG9uZW50IGRlYnVnIGluZm9ybWF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfZGVidWdJbmZvJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFViQxKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gaW52YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvL1xuICAgICAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhIHZhbGlkIGVsZW1lbnQgdHlwZS5cbiAgICAgIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZ1xuICAgICAgLy8gZXJyb3JzLiBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kXG4gICAgICAvLyBwcm9kLiAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGVcbiAgICAgIC8vIHR5cGUgaXMgZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBXYXJuIGFib3V0IGtleSBzcHJlYWQgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSB0eXBlIGlzIHZhbGlkLlxuXG5cbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB9XG5cbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgLy8gU2tpcCBvdmVyIHJlc2VydmVkIHByb3AgbmFtZXNcbiAgICAgIHByb3BOYW1lICE9PSAna2V5JyAmJiAocHJvcE5hbWUgIT09ICdyZWYnKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgIW5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSkgOyBlbHNlIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0byByZW5kZXIgcGhhc2UgaW5zdGVhZCBvZiBhdCBlbGVtZW50IGNyZWF0aW9uLlxuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBqc3hERVYgPSBqc3hERVYkMSA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3hERVYgPSBqc3hERVY7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!*******************************************************************!*\
  !*** ../node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsK0xBQXNFO0FBQ3hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9kM2YxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@fullcalendar/core/index.js":
/*!***************************************************!*\
  !*** ../node_modules/@fullcalendar/core/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Calendar: function() { return /* binding */ Calendar; },\n/* harmony export */   JsonRequestError: function() { return /* reexport safe */ _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ag; },\n/* harmony export */   createPlugin: function() { return /* binding */ createPlugin; },\n/* harmony export */   formatDate: function() { return /* binding */ formatDate; },\n/* harmony export */   formatRange: function() { return /* binding */ formatRange; },\n/* harmony export */   globalLocales: function() { return /* binding */ globalLocales; },\n/* harmony export */   globalPlugins: function() { return /* binding */ globalPlugins; },\n/* harmony export */   sliceEvents: function() { return /* binding */ sliceEvents; },\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\n/* harmony import */ var _internal_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal-common.js */ \"(app-pages-browser)/../node_modules/@fullcalendar/core/internal-common.js\");\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ \"(app-pages-browser)/../node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var preact_compat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! preact/compat */ \"(app-pages-browser)/../node_modules/preact/compat/dist/compat.module.js\");\n\n\n\n\n\nconst globalLocales = [];\n\nconst MINIMAL_RAW_EN_LOCALE = {\n    code: 'en',\n    week: {\n        dow: 0,\n        doy: 4, // 4 days need to be within the year to be considered the first week\n    },\n    direction: 'ltr',\n    buttonText: {\n        prev: 'prev',\n        next: 'next',\n        prevYear: 'prev year',\n        nextYear: 'next year',\n        year: 'year',\n        today: 'today',\n        month: 'month',\n        week: 'week',\n        day: 'day',\n        list: 'list',\n    },\n    weekText: 'W',\n    weekTextLong: 'Week',\n    closeHint: 'Close',\n    timeHint: 'Time',\n    eventHint: 'Event',\n    allDayText: 'all-day',\n    moreLinkText: 'more',\n    noEventsText: 'No events to display',\n};\nconst RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), { \n    // Includes things we don't want other locales to inherit,\n    // things that derive from other translatable strings.\n    buttonHints: {\n        prev: 'Previous $0',\n        next: 'Next $0',\n        today(buttonText, unit) {\n            return (unit === 'day')\n                ? 'Today'\n                : `This ${buttonText}`;\n        },\n    }, viewHint: '$0 view', navLinkHint: 'Go to $0', moreLinkHint(eventCnt) {\n        return `Show ${eventCnt} more event${eventCnt === 1 ? '' : 's'}`;\n    } });\nfunction organizeRawLocales(explicitRawLocales) {\n    let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';\n    let allRawLocales = globalLocales.concat(explicitRawLocales);\n    let rawLocaleMap = {\n        en: RAW_EN_LOCALE,\n    };\n    for (let rawLocale of allRawLocales) {\n        rawLocaleMap[rawLocale.code] = rawLocale;\n    }\n    return {\n        map: rawLocaleMap,\n        defaultCode,\n    };\n}\nfunction buildLocale(inputSingular, available) {\n    if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) {\n        return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);\n    }\n    return queryLocale(inputSingular, available);\n}\nfunction queryLocale(codeArg, available) {\n    let codes = [].concat(codeArg || []); // will convert to array\n    let raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n    return parseLocale(codeArg, codes, raw);\n}\nfunction queryRawLocale(codes, available) {\n    for (let i = 0; i < codes.length; i += 1) {\n        let parts = codes[i].toLocaleLowerCase().split('-');\n        for (let j = parts.length; j > 0; j -= 1) {\n            let simpleId = parts.slice(0, j).join('-');\n            if (available[simpleId]) {\n                return available[simpleId];\n            }\n        }\n    }\n    return null;\n}\nfunction parseLocale(codeArg, codes, raw) {\n    let merged = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.m)([MINIMAL_RAW_EN_LOCALE, raw], ['buttonText']);\n    delete merged.code; // don't want this part of the options\n    let { week } = merged;\n    delete merged.week;\n    return {\n        codeArg,\n        codes,\n        week,\n        simpleNumberFormat: new Intl.NumberFormat(codeArg),\n        options: merged,\n    };\n}\n\n// TODO: easier way to add new hooks? need to update a million things\nfunction createPlugin(input) {\n    return {\n        id: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.g)(),\n        name: input.name,\n        premiumReleaseDate: input.premiumReleaseDate ? new Date(input.premiumReleaseDate) : undefined,\n        deps: input.deps || [],\n        reducers: input.reducers || [],\n        isLoadingFuncs: input.isLoadingFuncs || [],\n        contextInit: [].concat(input.contextInit || []),\n        eventRefiners: input.eventRefiners || {},\n        eventDefMemberAdders: input.eventDefMemberAdders || [],\n        eventSourceRefiners: input.eventSourceRefiners || {},\n        isDraggableTransformers: input.isDraggableTransformers || [],\n        eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n        eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n        dateSelectionTransformers: input.dateSelectionTransformers || [],\n        datePointTransforms: input.datePointTransforms || [],\n        dateSpanTransforms: input.dateSpanTransforms || [],\n        views: input.views || {},\n        viewPropsTransformers: input.viewPropsTransformers || [],\n        isPropsValid: input.isPropsValid || null,\n        externalDefTransforms: input.externalDefTransforms || [],\n        viewContainerAppends: input.viewContainerAppends || [],\n        eventDropTransformers: input.eventDropTransformers || [],\n        componentInteractions: input.componentInteractions || [],\n        calendarInteractions: input.calendarInteractions || [],\n        themeClasses: input.themeClasses || {},\n        eventSourceDefs: input.eventSourceDefs || [],\n        cmdFormatter: input.cmdFormatter,\n        recurringTypes: input.recurringTypes || [],\n        namedTimeZonedImpl: input.namedTimeZonedImpl,\n        initialView: input.initialView || '',\n        elementDraggingImpl: input.elementDraggingImpl,\n        optionChangeHandlers: input.optionChangeHandlers || {},\n        scrollGridImpl: input.scrollGridImpl || null,\n        listenerRefiners: input.listenerRefiners || {},\n        optionRefiners: input.optionRefiners || {},\n        propSetHandlers: input.propSetHandlers || {},\n    };\n}\nfunction buildPluginHooks(pluginDefs, globalDefs) {\n    let currentPluginIds = {};\n    let hooks = {\n        premiumReleaseDate: undefined,\n        reducers: [],\n        isLoadingFuncs: [],\n        contextInit: [],\n        eventRefiners: {},\n        eventDefMemberAdders: [],\n        eventSourceRefiners: {},\n        isDraggableTransformers: [],\n        eventDragMutationMassagers: [],\n        eventDefMutationAppliers: [],\n        dateSelectionTransformers: [],\n        datePointTransforms: [],\n        dateSpanTransforms: [],\n        views: {},\n        viewPropsTransformers: [],\n        isPropsValid: null,\n        externalDefTransforms: [],\n        viewContainerAppends: [],\n        eventDropTransformers: [],\n        componentInteractions: [],\n        calendarInteractions: [],\n        themeClasses: {},\n        eventSourceDefs: [],\n        cmdFormatter: null,\n        recurringTypes: [],\n        namedTimeZonedImpl: null,\n        initialView: '',\n        elementDraggingImpl: null,\n        optionChangeHandlers: {},\n        scrollGridImpl: null,\n        listenerRefiners: {},\n        optionRefiners: {},\n        propSetHandlers: {},\n    };\n    function addDefs(defs) {\n        for (let def of defs) {\n            const pluginName = def.name;\n            const currentId = currentPluginIds[pluginName];\n            if (currentId === undefined) {\n                currentPluginIds[pluginName] = def.id;\n                addDefs(def.deps);\n                hooks = combineHooks(hooks, def);\n            }\n            else if (currentId !== def.id) {\n                // different ID than the one already added\n                console.warn(`Duplicate plugin '${pluginName}'`);\n            }\n        }\n    }\n    if (pluginDefs) {\n        addDefs(pluginDefs);\n    }\n    addDefs(globalDefs);\n    return hooks;\n}\nfunction buildBuildPluginHooks() {\n    let currentOverrideDefs = [];\n    let currentGlobalDefs = [];\n    let currentHooks;\n    return (overrideDefs, globalDefs) => {\n        if (!currentHooks || !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.i)(overrideDefs, currentOverrideDefs) || !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.i)(globalDefs, currentGlobalDefs)) {\n            currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n        }\n        currentOverrideDefs = overrideDefs;\n        currentGlobalDefs = globalDefs;\n        return currentHooks;\n    };\n}\nfunction combineHooks(hooks0, hooks1) {\n    return {\n        premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),\n        reducers: hooks0.reducers.concat(hooks1.reducers),\n        isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),\n        contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n        eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),\n        eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n        eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n        isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n        eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n        eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n        dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n        datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n        dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n        views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),\n        viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n        isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n        externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n        viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n        eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n        calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n        componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n        themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),\n        eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n        cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n        recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n        namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n        initialView: hooks0.initialView || hooks1.initialView,\n        elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n        optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n        scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n        listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n        optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),\n        propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers),\n    };\n}\nfunction compareOptionalDates(date0, date1) {\n    if (date0 === undefined) {\n        return date1;\n    }\n    if (date1 === undefined) {\n        return date0;\n    }\n    return new Date(Math.max(date0.valueOf(), date1.valueOf()));\n}\n\nclass StandardTheme extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.T {\n}\nStandardTheme.prototype.classes = {\n    root: 'fc-theme-standard',\n    tableCellShaded: 'fc-cell-shaded',\n    buttonGroup: 'fc-button-group',\n    button: 'fc-button fc-button-primary',\n    buttonActive: 'fc-button-active',\n};\nStandardTheme.prototype.baseIconClass = 'fc-icon';\nStandardTheme.prototype.iconClasses = {\n    close: 'fc-icon-x',\n    prev: 'fc-icon-chevron-left',\n    next: 'fc-icon-chevron-right',\n    prevYear: 'fc-icon-chevrons-left',\n    nextYear: 'fc-icon-chevrons-right',\n};\nStandardTheme.prototype.rtlIconClasses = {\n    prev: 'fc-icon-chevron-right',\n    next: 'fc-icon-chevron-left',\n    prevYear: 'fc-icon-chevrons-right',\n    nextYear: 'fc-icon-chevrons-left',\n};\nStandardTheme.prototype.iconOverrideOption = 'buttonIcons'; // TODO: make TS-friendly\nStandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';\nStandardTheme.prototype.iconOverridePrefix = 'fc-icon-';\n\nfunction compileViewDefs(defaultConfigs, overrideConfigs) {\n    let hash = {};\n    let viewType;\n    for (viewType in defaultConfigs) {\n        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    }\n    for (viewType in overrideConfigs) {\n        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    }\n    return hash;\n}\nfunction ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n    if (hash[viewType]) {\n        return hash[viewType];\n    }\n    let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    if (viewDef) {\n        hash[viewType] = viewDef;\n    }\n    return viewDef;\n}\nfunction buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n    let defaultConfig = defaultConfigs[viewType];\n    let overrideConfig = overrideConfigs[viewType];\n    let queryProp = (name) => ((defaultConfig && defaultConfig[name] !== null) ? defaultConfig[name] :\n        ((overrideConfig && overrideConfig[name] !== null) ? overrideConfig[name] : null));\n    let theComponent = queryProp('component');\n    let superType = queryProp('superType');\n    let superDef = null;\n    if (superType) {\n        if (superType === viewType) {\n            throw new Error('Can\\'t have a custom view type that references itself');\n        }\n        superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n    }\n    if (!theComponent && superDef) {\n        theComponent = superDef.component;\n    }\n    if (!theComponent) {\n        return null; // don't throw a warning, might be settings for a single-unit view\n    }\n    return {\n        type: viewType,\n        component: theComponent,\n        defaults: Object.assign(Object.assign({}, (superDef ? superDef.defaults : {})), (defaultConfig ? defaultConfig.rawOptions : {})),\n        overrides: Object.assign(Object.assign({}, (superDef ? superDef.overrides : {})), (overrideConfig ? overrideConfig.rawOptions : {})),\n    };\n}\n\nfunction parseViewConfigs(inputs) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a)(inputs, parseViewConfig);\n}\nfunction parseViewConfig(input) {\n    let rawOptions = typeof input === 'function' ?\n        { component: input } :\n        input;\n    let { component } = rawOptions;\n    if (rawOptions.content) {\n        // TODO: remove content/classNames/didMount/etc from options?\n        component = createViewHookComponent(rawOptions);\n    }\n    else if (component && !(component.prototype instanceof _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B)) {\n        // WHY?: people were using `component` property for `content`\n        // TODO: converge on one setting name\n        component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), { content: component }));\n    }\n    return {\n        superType: rawOptions.type,\n        component: component,\n        rawOptions, // includes type and component too :(\n    };\n}\nfunction createViewHookComponent(options) {\n    return (viewProps) => ((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.V.Consumer, null, (context) => ((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.C, { elTag: \"div\", elClasses: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.b)(context.viewSpec), renderProps: Object.assign(Object.assign({}, viewProps), { nextDayThreshold: context.options.nextDayThreshold }), generatorName: undefined, customGenerator: options.content, classNameGenerator: options.classNames, didMount: options.didMount, willUnmount: options.willUnmount }))));\n}\n\nfunction buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n    let defaultConfigs = parseViewConfigs(defaultInputs);\n    let overrideConfigs = parseViewConfigs(optionOverrides.views);\n    let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a)(viewDefs, (viewDef) => buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));\n}\nfunction buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n    let durationInput = viewDef.overrides.duration ||\n        viewDef.defaults.duration ||\n        dynamicOptionOverrides.duration ||\n        optionOverrides.duration;\n    let duration = null;\n    let durationUnit = '';\n    let singleUnit = '';\n    let singleUnitOverrides = {};\n    if (durationInput) {\n        duration = createDurationCached(durationInput);\n        if (duration) { // valid?\n            let denom = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.c)(duration);\n            durationUnit = denom.unit;\n            if (denom.value === 1) {\n                singleUnit = durationUnit;\n                singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n            }\n        }\n    }\n    let queryButtonText = (optionsSubset) => {\n        let buttonTextMap = optionsSubset.buttonText || {};\n        let buttonTextKey = viewDef.defaults.buttonTextKey;\n        if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n            return buttonTextMap[buttonTextKey];\n        }\n        if (buttonTextMap[viewDef.type] != null) {\n            return buttonTextMap[viewDef.type];\n        }\n        if (buttonTextMap[singleUnit] != null) {\n            return buttonTextMap[singleUnit];\n        }\n        return null;\n    };\n    let queryButtonTitle = (optionsSubset) => {\n        let buttonHints = optionsSubset.buttonHints || {};\n        let buttonKey = viewDef.defaults.buttonTextKey; // use same key as text\n        if (buttonKey != null && buttonHints[buttonKey] != null) {\n            return buttonHints[buttonKey];\n        }\n        if (buttonHints[viewDef.type] != null) {\n            return buttonHints[viewDef.type];\n        }\n        if (buttonHints[singleUnit] != null) {\n            return buttonHints[singleUnit];\n        }\n        return null;\n    };\n    return {\n        type: viewDef.type,\n        component: viewDef.component,\n        duration,\n        durationUnit,\n        singleUnit,\n        optionDefaults: viewDef.defaults,\n        optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),\n        buttonTextOverride: queryButtonText(dynamicOptionOverrides) ||\n            queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n            viewDef.overrides.buttonText,\n        buttonTextDefault: queryButtonText(localeDefaults) ||\n            viewDef.defaults.buttonText ||\n            queryButtonText(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e) ||\n            viewDef.type,\n        // not DRY\n        buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) ||\n            queryButtonTitle(optionOverrides) ||\n            viewDef.overrides.buttonHint,\n        buttonTitleDefault: queryButtonTitle(localeDefaults) ||\n            viewDef.defaults.buttonHint ||\n            queryButtonTitle(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e),\n        // will eventually fall back to buttonText\n    };\n}\n// hack to get memoization working\nlet durationInputMap = {};\nfunction createDurationCached(durationInput) {\n    let json = JSON.stringify(durationInput);\n    let res = durationInputMap[json];\n    if (res === undefined) {\n        res = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d)(durationInput);\n        durationInputMap[json] = res;\n    }\n    return res;\n}\n\nfunction reduceViewType(viewType, action) {\n    switch (action.type) {\n        case 'CHANGE_VIEW_TYPE':\n            viewType = action.viewType;\n    }\n    return viewType;\n}\n\nfunction reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n    switch (action.type) {\n        case 'SET_OPTION':\n            return Object.assign(Object.assign({}, dynamicOptionOverrides), { [action.optionName]: action.rawOptionValue });\n        default:\n            return dynamicOptionOverrides;\n    }\n}\n\nfunction reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n    let dp;\n    switch (action.type) {\n        case 'CHANGE_VIEW_TYPE':\n            return dateProfileGenerator.build(action.dateMarker || currentDate);\n        case 'CHANGE_DATE':\n            return dateProfileGenerator.build(action.dateMarker);\n        case 'PREV':\n            dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n            if (dp.isValid) {\n                return dp;\n            }\n            break;\n        case 'NEXT':\n            dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n            if (dp.isValid) {\n                return dp;\n            }\n            break;\n    }\n    return currentDateProfile;\n}\n\nfunction initEventSources(calendarOptions, dateProfile, context) {\n    let activeRange = dateProfile ? dateProfile.activeRange : null;\n    return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n}\nfunction reduceEventSources(eventSources, action, dateProfile, context) {\n    let activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n    switch (action.type) {\n        case 'ADD_EVENT_SOURCES': // already parsed\n            return addSources(eventSources, action.sources, activeRange, context);\n        case 'REMOVE_EVENT_SOURCE':\n            return removeSource(eventSources, action.sourceId);\n        case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n        case 'NEXT':\n        case 'CHANGE_DATE':\n        case 'CHANGE_VIEW_TYPE':\n            if (dateProfile) {\n                return fetchDirtySources(eventSources, activeRange, context);\n            }\n            return eventSources;\n        case 'FETCH_EVENT_SOURCES':\n            return fetchSourcesByIds(eventSources, action.sourceIds ? // why no type?\n                (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.f)(action.sourceIds) :\n                excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);\n        case 'RECEIVE_EVENTS':\n        case 'RECEIVE_EVENT_ERROR':\n            return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n        case 'REMOVE_ALL_EVENT_SOURCES':\n            return {};\n        default:\n            return eventSources;\n    }\n}\nfunction reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n    let activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n    return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);\n}\nfunction computeEventSourcesLoading(eventSources) {\n    for (let sourceId in eventSources) {\n        if (eventSources[sourceId].isFetching) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction addSources(eventSourceHash, sources, fetchRange, context) {\n    let hash = {};\n    for (let source of sources) {\n        hash[source.sourceId] = source;\n    }\n    if (fetchRange) {\n        hash = fetchDirtySources(hash, fetchRange, context);\n    }\n    return Object.assign(Object.assign({}, eventSourceHash), hash);\n}\nfunction removeSource(eventSourceHash, sourceId) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.h)(eventSourceHash, (eventSource) => eventSource.sourceId !== sourceId);\n}\nfunction fetchDirtySources(sourceHash, fetchRange, context) {\n    return fetchSourcesByIds(sourceHash, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.h)(sourceHash, (eventSource) => isSourceDirty(eventSource, fetchRange, context)), fetchRange, false, context);\n}\nfunction isSourceDirty(eventSource, fetchRange, context) {\n    if (!doesSourceNeedRange(eventSource, context)) {\n        return !eventSource.latestFetchId;\n    }\n    return !context.options.lazyFetching ||\n        !eventSource.fetchRange ||\n        eventSource.isFetching || // always cancel outdated in-progress fetches\n        fetchRange.start < eventSource.fetchRange.start ||\n        fetchRange.end > eventSource.fetchRange.end;\n}\nfunction fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {\n    let nextSources = {};\n    for (let sourceId in prevSources) {\n        let source = prevSources[sourceId];\n        if (sourceIdHash[sourceId]) {\n            nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);\n        }\n        else {\n            nextSources[sourceId] = source;\n        }\n    }\n    return nextSources;\n}\nfunction fetchSource(eventSource, fetchRange, isRefetch, context) {\n    let { options, calendarApi } = context;\n    let sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n    let fetchId = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.g)();\n    sourceDef.fetch({\n        eventSource,\n        range: fetchRange,\n        isRefetch,\n        context,\n    }, (res) => {\n        let { rawEvents } = res;\n        if (options.eventSourceSuccess) {\n            rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;\n        }\n        if (eventSource.success) {\n            rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;\n        }\n        context.dispatch({\n            type: 'RECEIVE_EVENTS',\n            sourceId: eventSource.sourceId,\n            fetchId,\n            fetchRange,\n            rawEvents,\n        });\n    }, (error) => {\n        let errorHandled = false;\n        if (options.eventSourceFailure) {\n            options.eventSourceFailure.call(calendarApi, error);\n            errorHandled = true;\n        }\n        if (eventSource.failure) {\n            eventSource.failure(error);\n            errorHandled = true;\n        }\n        if (!errorHandled) {\n            console.warn(error.message, error);\n        }\n        context.dispatch({\n            type: 'RECEIVE_EVENT_ERROR',\n            sourceId: eventSource.sourceId,\n            fetchId,\n            fetchRange,\n            error,\n        });\n    });\n    return Object.assign(Object.assign({}, eventSource), { isFetching: true, latestFetchId: fetchId });\n}\nfunction receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n    let eventSource = sourceHash[sourceId];\n    if (eventSource && // not already removed\n        fetchId === eventSource.latestFetchId) {\n        return Object.assign(Object.assign({}, sourceHash), { [sourceId]: Object.assign(Object.assign({}, eventSource), { isFetching: false, fetchRange }) });\n    }\n    return sourceHash;\n}\nfunction excludeStaticSources(eventSources, context) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.h)(eventSources, (eventSource) => doesSourceNeedRange(eventSource, context));\n}\nfunction parseInitialSources(rawOptions, context) {\n    let refiners = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.j)(context);\n    let rawSources = [].concat(rawOptions.eventSources || []);\n    let sources = []; // parsed\n    if (rawOptions.initialEvents) {\n        rawSources.unshift(rawOptions.initialEvents);\n    }\n    if (rawOptions.events) {\n        rawSources.unshift(rawOptions.events);\n    }\n    for (let rawSource of rawSources) {\n        let source = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.p)(rawSource, context, refiners);\n        if (source) {\n            sources.push(source);\n        }\n    }\n    return sources;\n}\nfunction doesSourceNeedRange(eventSource, context) {\n    let defs = context.pluginHooks.eventSourceDefs;\n    return !defs[eventSource.sourceDefId].ignoreRange;\n}\n\nfunction reduceDateSelection(currentSelection, action) {\n    switch (action.type) {\n        case 'UNSELECT_DATES':\n            return null;\n        case 'SELECT_DATES':\n            return action.selection;\n        default:\n            return currentSelection;\n    }\n}\n\nfunction reduceSelectedEvent(currentInstanceId, action) {\n    switch (action.type) {\n        case 'UNSELECT_EVENT':\n            return '';\n        case 'SELECT_EVENT':\n            return action.eventInstanceId;\n        default:\n            return currentInstanceId;\n    }\n}\n\nfunction reduceEventDrag(currentDrag, action) {\n    let newDrag;\n    switch (action.type) {\n        case 'UNSET_EVENT_DRAG':\n            return null;\n        case 'SET_EVENT_DRAG':\n            newDrag = action.state;\n            return {\n                affectedEvents: newDrag.affectedEvents,\n                mutatedEvents: newDrag.mutatedEvents,\n                isEvent: newDrag.isEvent,\n            };\n        default:\n            return currentDrag;\n    }\n}\n\nfunction reduceEventResize(currentResize, action) {\n    let newResize;\n    switch (action.type) {\n        case 'UNSET_EVENT_RESIZE':\n            return null;\n        case 'SET_EVENT_RESIZE':\n            newResize = action.state;\n            return {\n                affectedEvents: newResize.affectedEvents,\n                mutatedEvents: newResize.mutatedEvents,\n                isEvent: newResize.isEvent,\n            };\n        default:\n            return currentResize;\n    }\n}\n\nfunction parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n    let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n    return { header, footer };\n}\nfunction parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    let sectionWidgets = {};\n    let viewsWithButtons = [];\n    let hasTitle = false;\n    for (let sectionName in sectionStrHash) {\n        let sectionStr = sectionStrHash[sectionName];\n        let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);\n        sectionWidgets[sectionName] = sectionRes.widgets;\n        viewsWithButtons.push(...sectionRes.viewsWithButtons);\n        hasTitle = hasTitle || sectionRes.hasTitle;\n    }\n    return { sectionWidgets, viewsWithButtons, hasTitle };\n}\n/*\nBAD: querying icons and text here. should be done at render time\n*/\nfunction parseSection(sectionStr, calendarOptions, // defaults+overrides, then refined\ncalendarOptionOverrides, // overrides only!, unrefined :(\ntheme, viewSpecs, calendarApi) {\n    let isRtl = calendarOptions.direction === 'rtl';\n    let calendarCustomButtons = calendarOptions.customButtons || {};\n    let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n    let calendarButtonText = calendarOptions.buttonText || {};\n    let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};\n    let calendarButtonHints = calendarOptions.buttonHints || {};\n    let sectionSubstrs = sectionStr ? sectionStr.split(' ') : [];\n    let viewsWithButtons = [];\n    let hasTitle = false;\n    let widgets = sectionSubstrs.map((buttonGroupStr) => (buttonGroupStr.split(',').map((buttonName) => {\n        if (buttonName === 'title') {\n            hasTitle = true;\n            return { buttonName };\n        }\n        let customButtonProps;\n        let viewSpec;\n        let buttonClick;\n        let buttonIcon; // only one of these will be set\n        let buttonText; // \"\n        let buttonHint;\n        // ^ for the title=\"\" attribute, for accessibility\n        if ((customButtonProps = calendarCustomButtons[buttonName])) {\n            buttonClick = (ev) => {\n                if (customButtonProps.click) {\n                    customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?\n                }\n            };\n            (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||\n                (buttonIcon = theme.getIconClass(buttonName, isRtl)) ||\n                (buttonText = customButtonProps.text);\n            buttonHint = customButtonProps.hint || customButtonProps.text;\n        }\n        else if ((viewSpec = viewSpecs[buttonName])) {\n            viewsWithButtons.push(buttonName);\n            buttonClick = () => {\n                calendarApi.changeView(buttonName);\n            };\n            (buttonText = viewSpec.buttonTextOverride) ||\n                (buttonIcon = theme.getIconClass(buttonName, isRtl)) ||\n                (buttonText = viewSpec.buttonTextDefault);\n            let textFallback = viewSpec.buttonTextOverride ||\n                viewSpec.buttonTextDefault;\n            buttonHint = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.k)(viewSpec.buttonTitleOverride ||\n                viewSpec.buttonTitleDefault ||\n                calendarOptions.viewHint, [textFallback, buttonName], // view-name = buttonName\n            textFallback);\n        }\n        else if (calendarApi[buttonName]) { // a calendarApi method\n            buttonClick = () => {\n                calendarApi[buttonName]();\n            };\n            (buttonText = calendarButtonTextOverrides[buttonName]) ||\n                (buttonIcon = theme.getIconClass(buttonName, isRtl)) ||\n                (buttonText = calendarButtonText[buttonName]); // everything else is considered default\n            if (buttonName === 'prevYear' || buttonName === 'nextYear') {\n                let prevOrNext = buttonName === 'prevYear' ? 'prev' : 'next';\n                buttonHint = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.k)(calendarButtonHintOverrides[prevOrNext] ||\n                    calendarButtonHints[prevOrNext], [\n                    calendarButtonText.year || 'year',\n                    'year',\n                ], calendarButtonText[buttonName]);\n            }\n            else {\n                buttonHint = (navUnit) => (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.k)(calendarButtonHintOverrides[buttonName] ||\n                    calendarButtonHints[buttonName], [\n                    calendarButtonText[navUnit] || navUnit,\n                    navUnit,\n                ], calendarButtonText[buttonName]);\n            }\n        }\n        return { buttonName, buttonClick, buttonIcon, buttonText, buttonHint };\n    })));\n    return { widgets, viewsWithButtons, hasTitle };\n}\n\n// always represents the current view. otherwise, it'd need to change value every time date changes\nclass ViewImpl {\n    constructor(type, getCurrentData, dateEnv) {\n        this.type = type;\n        this.getCurrentData = getCurrentData;\n        this.dateEnv = dateEnv;\n    }\n    get calendar() {\n        return this.getCurrentData().calendarApi;\n    }\n    get title() {\n        return this.getCurrentData().viewTitle;\n    }\n    get activeStart() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n    }\n    get activeEnd() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n    }\n    get currentStart() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n    }\n    get currentEnd() {\n        return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n    }\n    getOption(name) {\n        return this.getCurrentData().options[name]; // are the view-specific options\n    }\n}\n\nlet eventSourceDef$2 = {\n    ignoreRange: true,\n    parseMeta(refined) {\n        if (Array.isArray(refined.events)) {\n            return refined.events;\n        }\n        return null;\n    },\n    fetch(arg, successCallback) {\n        successCallback({\n            rawEvents: arg.eventSource.meta,\n        });\n    },\n};\nconst arrayEventSourcePlugin = createPlugin({\n    name: 'array-event-source',\n    eventSourceDefs: [eventSourceDef$2],\n});\n\nlet eventSourceDef$1 = {\n    parseMeta(refined) {\n        if (typeof refined.events === 'function') {\n            return refined.events;\n        }\n        return null;\n    },\n    fetch(arg, successCallback, errorCallback) {\n        const { dateEnv } = arg.context;\n        const func = arg.eventSource.meta;\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.u)(func.bind(null, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.l)(arg.range, dateEnv)), (rawEvents) => successCallback({ rawEvents }), errorCallback);\n    },\n};\nconst funcEventSourcePlugin = createPlugin({\n    name: 'func-event-source',\n    eventSourceDefs: [eventSourceDef$1],\n});\n\nconst JSON_FEED_EVENT_SOURCE_REFINERS = {\n    method: String,\n    extraParams: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    startParam: String,\n    endParam: String,\n    timeZoneParam: String,\n};\n\nlet eventSourceDef = {\n    parseMeta(refined) {\n        if (refined.url && (refined.format === 'json' || !refined.format)) {\n            return {\n                url: refined.url,\n                format: 'json',\n                method: (refined.method || 'GET').toUpperCase(),\n                extraParams: refined.extraParams,\n                startParam: refined.startParam,\n                endParam: refined.endParam,\n                timeZoneParam: refined.timeZoneParam,\n            };\n        }\n        return null;\n    },\n    fetch(arg, successCallback, errorCallback) {\n        const { meta } = arg.eventSource;\n        const requestParams = buildRequestParams(meta, arg.range, arg.context);\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.r)(meta.method, meta.url, requestParams).then(([rawEvents, response]) => {\n            successCallback({ rawEvents, response });\n        }, errorCallback);\n    },\n};\nconst jsonFeedEventSourcePlugin = createPlugin({\n    name: 'json-event-source',\n    eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n    eventSourceDefs: [eventSourceDef],\n});\nfunction buildRequestParams(meta, range, context) {\n    let { dateEnv, options } = context;\n    let startParam;\n    let endParam;\n    let timeZoneParam;\n    let customRequestParams;\n    let params = {};\n    startParam = meta.startParam;\n    if (startParam == null) {\n        startParam = options.startParam;\n    }\n    endParam = meta.endParam;\n    if (endParam == null) {\n        endParam = options.endParam;\n    }\n    timeZoneParam = meta.timeZoneParam;\n    if (timeZoneParam == null) {\n        timeZoneParam = options.timeZoneParam;\n    }\n    // retrieve any outbound GET/POST data from the options\n    if (typeof meta.extraParams === 'function') {\n        // supplied as a function that returns a key/value object\n        customRequestParams = meta.extraParams();\n    }\n    else {\n        // probably supplied as a straight key/value object\n        customRequestParams = meta.extraParams || {};\n    }\n    Object.assign(params, customRequestParams);\n    params[startParam] = dateEnv.formatIso(range.start);\n    params[endParam] = dateEnv.formatIso(range.end);\n    if (dateEnv.timeZone !== 'local') {\n        params[timeZoneParam] = dateEnv.timeZone;\n    }\n    return params;\n}\n\nconst SIMPLE_RECURRING_REFINERS = {\n    daysOfWeek: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    startTime: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d,\n    endTime: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d,\n    duration: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.d,\n    startRecur: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n,\n    endRecur: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.n,\n};\n\nlet recurring = {\n    parse(refined, dateEnv) {\n        if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n            let recurringData = {\n                daysOfWeek: refined.daysOfWeek || null,\n                startTime: refined.startTime || null,\n                endTime: refined.endTime || null,\n                startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n                endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null,\n            };\n            let duration;\n            if (refined.duration) {\n                duration = refined.duration;\n            }\n            if (!duration && refined.startTime && refined.endTime) {\n                duration = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.s)(refined.endTime, refined.startTime);\n            }\n            return {\n                allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n                duration,\n                typeData: recurringData, // doesn't need endTime anymore but oh well\n            };\n        }\n        return null;\n    },\n    expand(typeData, framingRange, dateEnv) {\n        let clippedFramingRange = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.o)(framingRange, { start: typeData.startRecur, end: typeData.endRecur });\n        if (clippedFramingRange) {\n            return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n        }\n        return [];\n    },\n};\nconst simpleRecurringEventsPlugin = createPlugin({\n    name: 'simple-recurring-event',\n    recurringTypes: [recurring],\n    eventRefiners: SIMPLE_RECURRING_REFINERS,\n});\nfunction expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n    let dowHash = daysOfWeek ? (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.f)(daysOfWeek) : null;\n    let dayMarker = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.q)(framingRange.start);\n    let endMarker = framingRange.end;\n    let instanceStarts = [];\n    while (dayMarker < endMarker) {\n        let instanceStart;\n        // if everyday, or this particular day-of-week\n        if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n            if (startTime) {\n                instanceStart = dateEnv.add(dayMarker, startTime);\n            }\n            else {\n                instanceStart = dayMarker;\n            }\n            instanceStarts.push(instanceStart);\n        }\n        dayMarker = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.t)(dayMarker, 1);\n    }\n    return instanceStarts;\n}\n\nconst changeHandlerPlugin = createPlugin({\n    name: 'change-handler',\n    optionChangeHandlers: {\n        events(events, context) {\n            handleEventSources([events], context);\n        },\n        eventSources: handleEventSources,\n    },\n});\n/*\nBUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\n*/\nfunction handleEventSources(inputs, context) {\n    let unfoundSources = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.v)(context.getCurrentData().eventSources);\n    if (unfoundSources.length === 1 &&\n        inputs.length === 1 &&\n        Array.isArray(unfoundSources[0]._raw) &&\n        Array.isArray(inputs[0])) {\n        context.dispatch({\n            type: 'RESET_RAW_EVENTS',\n            sourceId: unfoundSources[0].sourceId,\n            rawEvents: inputs[0],\n        });\n        return;\n    }\n    let newInputs = [];\n    for (let input of inputs) {\n        let inputFound = false;\n        for (let i = 0; i < unfoundSources.length; i += 1) {\n            if (unfoundSources[i]._raw === input) {\n                unfoundSources.splice(i, 1); // delete\n                inputFound = true;\n                break;\n            }\n        }\n        if (!inputFound) {\n            newInputs.push(input);\n        }\n    }\n    for (let unfoundSource of unfoundSources) {\n        context.dispatch({\n            type: 'REMOVE_EVENT_SOURCE',\n            sourceId: unfoundSource.sourceId,\n        });\n    }\n    for (let newInput of newInputs) {\n        context.calendarApi.addEventSource(newInput);\n    }\n}\n\nfunction handleDateProfile(dateProfile, context) {\n    context.emitter.trigger('datesSet', Object.assign(Object.assign({}, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.l)(dateProfile.activeRange, context.dateEnv)), { view: context.viewApi }));\n}\n\nfunction handleEventStore(eventStore, context) {\n    let { emitter } = context;\n    if (emitter.hasHandlers('eventsSet')) {\n        emitter.trigger('eventsSet', (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.w)(eventStore, context));\n    }\n}\n\n/*\nthis array is exposed on the root namespace so that UMD plugins can add to it.\nsee the rollup-bundles script.\n*/\nconst globalPlugins = [\n    arrayEventSourcePlugin,\n    funcEventSourcePlugin,\n    jsonFeedEventSourcePlugin,\n    simpleRecurringEventsPlugin,\n    changeHandlerPlugin,\n    createPlugin({\n        name: 'misc',\n        isLoadingFuncs: [\n            (state) => computeEventSourcesLoading(state.eventSources),\n        ],\n        propSetHandlers: {\n            dateProfile: handleDateProfile,\n            eventStore: handleEventStore,\n        },\n    }),\n];\n\nclass TaskRunner {\n    constructor(runTaskOption, drainedOption) {\n        this.runTaskOption = runTaskOption;\n        this.drainedOption = drainedOption;\n        this.queue = [];\n        this.delayedRunner = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.D(this.drain.bind(this));\n    }\n    request(task, delay) {\n        this.queue.push(task);\n        this.delayedRunner.request(delay);\n    }\n    pause(scope) {\n        this.delayedRunner.pause(scope);\n    }\n    resume(scope, force) {\n        this.delayedRunner.resume(scope, force);\n    }\n    drain() {\n        let { queue } = this;\n        while (queue.length) {\n            let completedTasks = [];\n            let task;\n            while ((task = queue.shift())) {\n                this.runTask(task);\n                completedTasks.push(task);\n            }\n            this.drained(completedTasks);\n        } // keep going, in case new tasks were added in the drained handler\n    }\n    runTask(task) {\n        if (this.runTaskOption) {\n            this.runTaskOption(task);\n        }\n    }\n    drained(completedTasks) {\n        if (this.drainedOption) {\n            this.drainedOption(completedTasks);\n        }\n    }\n}\n\n// Computes what the title at the top of the calendarApi should be for this view\nfunction buildTitle(dateProfile, viewOptions, dateEnv) {\n    let range;\n    // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n    if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n        range = dateProfile.currentRange;\n    }\n    else { // for day units or smaller, use the actual day range\n        range = dateProfile.activeRange;\n    }\n    return dateEnv.formatRange(range.start, range.end, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.x)(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {\n        isEndExclusive: dateProfile.isRangeAllDay,\n        defaultSeparator: viewOptions.titleRangeSeparator,\n    });\n}\n// Generates the format string that should be used to generate the title for the current date range.\n// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\nfunction buildTitleFormat(dateProfile) {\n    let { currentRangeUnit } = dateProfile;\n    if (currentRangeUnit === 'year') {\n        return { year: 'numeric' };\n    }\n    if (currentRangeUnit === 'month') {\n        return { year: 'numeric', month: 'long' }; // like \"September 2014\"\n    }\n    let days = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.y)(dateProfile.currentRange.start, dateProfile.currentRange.end);\n    if (days !== null && days > 1) {\n        // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n        return { year: 'numeric', month: 'short', day: 'numeric' };\n    }\n    // one day. longer, like \"September 9 2014\"\n    return { year: 'numeric', month: 'long', day: 'numeric' };\n}\n\n// in future refactor, do the redux-style function(state=initial) for initial-state\n// also, whatever is happening in constructor, have it happen in action queue too\nclass CalendarDataManager {\n    constructor(props) {\n        this.computeCurrentViewData = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(this._computeCurrentViewData);\n        this.organizeRawLocales = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(organizeRawLocales);\n        this.buildLocale = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildLocale);\n        this.buildPluginHooks = buildBuildPluginHooks();\n        this.buildDateEnv = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildDateEnv$1);\n        this.buildTheme = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildTheme);\n        this.parseToolbars = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(parseToolbars);\n        this.buildViewSpecs = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildViewSpecs);\n        this.buildDateProfileGenerator = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.A)(buildDateProfileGenerator);\n        this.buildViewApi = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildViewApi);\n        this.buildViewUiProps = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.A)(buildViewUiProps);\n        this.buildEventUiBySource = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildEventUiBySource, _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.E);\n        this.buildEventUiBases = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildEventUiBases);\n        this.parseContextBusinessHours = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.A)(parseContextBusinessHours);\n        this.buildTitle = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildTitle);\n        this.emitter = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.F();\n        this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n        this.currentCalendarOptionsInput = {};\n        this.currentCalendarOptionsRefined = {};\n        this.currentViewOptionsInput = {};\n        this.currentViewOptionsRefined = {};\n        this.currentCalendarOptionsRefiners = {};\n        this.optionsForRefining = [];\n        this.optionsForHandling = [];\n        this.getCurrentData = () => this.data;\n        this.dispatch = (action) => {\n            this.actionRunner.request(action); // protects against recursive calls to _handleAction\n        };\n        this.props = props;\n        this.actionRunner.pause();\n        let dynamicOptionOverrides = {};\n        let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n        let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n        let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n        // wire things up\n        // TODO: not DRY\n        props.calendarApi.currentDataManager = this;\n        this.emitter.setThisContext(props.calendarApi);\n        this.emitter.setOptions(currentViewData.options);\n        let currentDate = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.G)(optionsData.calendarOptions, optionsData.dateEnv);\n        let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n        if (!(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.H)(dateProfile.activeRange, currentDate)) {\n            currentDate = dateProfile.currentRange.start;\n        }\n        let calendarContext = {\n            dateEnv: optionsData.dateEnv,\n            options: optionsData.calendarOptions,\n            pluginHooks: optionsData.pluginHooks,\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: this.emitter,\n            getCurrentData: this.getCurrentData,\n        };\n        // needs to be after setThisContext\n        for (let callback of optionsData.pluginHooks.contextInit) {\n            callback(calendarContext);\n        }\n        // NOT DRY\n        let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n        let initialState = {\n            dynamicOptionOverrides,\n            currentViewType,\n            currentDate,\n            dateProfile,\n            businessHours: this.parseContextBusinessHours(calendarContext),\n            eventSources,\n            eventUiBases: {},\n            eventStore: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.I)(),\n            renderableEventStore: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.I)(),\n            dateSelection: null,\n            eventSelection: '',\n            eventDrag: null,\n            eventResize: null,\n            selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig,\n        };\n        let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);\n        for (let reducer of optionsData.pluginHooks.reducers) {\n            Object.assign(initialState, reducer(null, null, contextAndState));\n        }\n        if (computeIsLoading(initialState, calendarContext)) {\n            this.emitter.trigger('loading', true); // NOT DRY\n        }\n        this.state = initialState;\n        this.updateData();\n        this.actionRunner.resume();\n    }\n    resetOptions(optionOverrides, changedOptionNames) {\n        let { props } = this;\n        if (changedOptionNames === undefined) {\n            props.optionOverrides = optionOverrides;\n        }\n        else {\n            props.optionOverrides = Object.assign(Object.assign({}, (props.optionOverrides || {})), optionOverrides);\n            this.optionsForRefining.push(...changedOptionNames);\n        }\n        if (changedOptionNames === undefined || changedOptionNames.length) {\n            this.actionRunner.request({\n                type: 'NOTHING',\n            });\n        }\n    }\n    _handleAction(action) {\n        let { props, state, emitter } = this;\n        let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n        let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n        let currentViewType = reduceViewType(state.currentViewType, action);\n        let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n        // wire things up\n        // TODO: not DRY\n        props.calendarApi.currentDataManager = this;\n        emitter.setThisContext(props.calendarApi);\n        emitter.setOptions(currentViewData.options);\n        let calendarContext = {\n            dateEnv: optionsData.dateEnv,\n            options: optionsData.calendarOptions,\n            pluginHooks: optionsData.pluginHooks,\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter,\n            getCurrentData: this.getCurrentData,\n        };\n        let { currentDate, dateProfile } = state;\n        if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) { // hack\n            dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n        }\n        currentDate = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.J)(currentDate, action);\n        dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n        if (action.type === 'PREV' || // TODO: move this logic into DateProfileGenerator\n            action.type === 'NEXT' || // \"\n            !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.H)(dateProfile.currentRange, currentDate)) {\n            currentDate = dateProfile.currentRange.start;\n        }\n        let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n        let eventStore = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.K)(state.eventStore, action, eventSources, dateProfile, calendarContext);\n        let isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading\n        let renderableEventStore = (isEventsLoading && !currentViewData.options.progressiveEventRendering) ?\n            (state.renderableEventStore || eventStore) : // try from previous state\n            eventStore;\n        let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext); // will memoize obj\n        let eventUiBySource = this.buildEventUiBySource(eventSources);\n        let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n        let newState = {\n            dynamicOptionOverrides,\n            currentViewType,\n            currentDate,\n            dateProfile,\n            eventSources,\n            eventStore,\n            renderableEventStore,\n            selectionConfig,\n            eventUiBases,\n            businessHours: this.parseContextBusinessHours(calendarContext),\n            dateSelection: reduceDateSelection(state.dateSelection, action),\n            eventSelection: reduceSelectedEvent(state.eventSelection, action),\n            eventDrag: reduceEventDrag(state.eventDrag, action),\n            eventResize: reduceEventResize(state.eventResize, action),\n        };\n        let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);\n        for (let reducer of optionsData.pluginHooks.reducers) {\n            Object.assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n        }\n        let wasLoading = computeIsLoading(state, calendarContext);\n        let isLoading = computeIsLoading(newState, calendarContext);\n        // TODO: use propSetHandlers in plugin system\n        if (!wasLoading && isLoading) {\n            emitter.trigger('loading', true);\n        }\n        else if (wasLoading && !isLoading) {\n            emitter.trigger('loading', false);\n        }\n        this.state = newState;\n        if (props.onAction) {\n            props.onAction(action);\n        }\n    }\n    updateData() {\n        let { props, state } = this;\n        let oldData = this.data;\n        let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n        let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n        let data = this.data = Object.assign(Object.assign(Object.assign({ viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv), calendarApi: props.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, optionsData), currentViewData), state);\n        let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n        let oldCalendarOptions = oldData && oldData.calendarOptions;\n        let newCalendarOptions = optionsData.calendarOptions;\n        if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n            if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n                // hack\n                state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n                state.eventStore = data.eventStore = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.L)(data.eventStore, oldData.dateEnv, data.dateEnv);\n                state.renderableEventStore = data.renderableEventStore = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.L)(data.renderableEventStore, oldData.dateEnv, data.dateEnv);\n            }\n            for (let optionName in changeHandlers) {\n                if (this.optionsForHandling.indexOf(optionName) !== -1 ||\n                    oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n                    changeHandlers[optionName](newCalendarOptions[optionName], data);\n                }\n            }\n        }\n        this.optionsForHandling = [];\n        if (props.onData) {\n            props.onData(data);\n        }\n    }\n    computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {\n        // TODO: blacklist options that are handled by optionChangeHandlers\n        if (!this.optionsForRefining.length &&\n            optionOverrides === this.stableOptionOverrides &&\n            dynamicOptionOverrides === this.stableDynamicOptionOverrides) {\n            return this.stableCalendarOptionsData;\n        }\n        let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra, } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);\n        warnUnknownOptions(extra);\n        let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n        let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);\n        let theme = this.buildTheme(refinedOptions, pluginHooks);\n        let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);\n        return this.stableCalendarOptionsData = {\n            calendarOptions: refinedOptions,\n            pluginHooks,\n            dateEnv,\n            viewSpecs,\n            theme,\n            toolbarConfig,\n            localeDefaults,\n            availableRawLocales: availableLocaleData.map,\n        };\n    }\n    // always called from behind a memoizer\n    processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {\n        let { locales, locale } = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.M)([\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e,\n            optionOverrides,\n            dynamicOptionOverrides,\n        ]);\n        let availableLocaleData = this.organizeRawLocales(locales);\n        let availableRawLocales = availableLocaleData.map;\n        let localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n        let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n        let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.N), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.O), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.P), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n        let extra = {};\n        let raw = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.M)([\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e,\n            localeDefaults,\n            optionOverrides,\n            dynamicOptionOverrides,\n        ]);\n        let refined = {};\n        let currentRaw = this.currentCalendarOptionsInput;\n        let currentRefined = this.currentCalendarOptionsRefined;\n        let anyChanges = false;\n        for (let optionName in raw) {\n            if (this.optionsForRefining.indexOf(optionName) === -1 && (raw[optionName] === currentRaw[optionName] || (_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName] &&\n                (optionName in currentRaw) &&\n                _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName](currentRaw[optionName], raw[optionName])))) {\n                refined[optionName] = currentRefined[optionName];\n            }\n            else if (refiners[optionName]) {\n                refined[optionName] = refiners[optionName](raw[optionName]);\n                anyChanges = true;\n            }\n            else {\n                extra[optionName] = currentRaw[optionName];\n            }\n        }\n        if (anyChanges) {\n            this.currentCalendarOptionsInput = raw;\n            this.currentCalendarOptionsRefined = refined;\n            this.stableOptionOverrides = optionOverrides;\n            this.stableDynamicOptionOverrides = dynamicOptionOverrides;\n        }\n        this.optionsForHandling.push(...this.optionsForRefining);\n        this.optionsForRefining = [];\n        return {\n            rawOptions: this.currentCalendarOptionsInput,\n            refinedOptions: this.currentCalendarOptionsRefined,\n            pluginHooks,\n            availableLocaleData,\n            localeDefaults,\n            extra,\n        };\n    }\n    _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n        let viewSpec = optionsData.viewSpecs[viewType];\n        if (!viewSpec) {\n            throw new Error(`viewType \"${viewType}\" is not available. Please make sure you've loaded all neccessary plugins`);\n        }\n        let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);\n        warnUnknownOptions(extra);\n        let dateProfileGenerator = this.buildDateProfileGenerator({\n            dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n            duration: viewSpec.duration,\n            durationUnit: viewSpec.durationUnit,\n            usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n            dateEnv: optionsData.dateEnv,\n            calendarApi: this.props.calendarApi,\n            slotMinTime: refinedOptions.slotMinTime,\n            slotMaxTime: refinedOptions.slotMaxTime,\n            showNonCurrentDates: refinedOptions.showNonCurrentDates,\n            dayCount: refinedOptions.dayCount,\n            dateAlignment: refinedOptions.dateAlignment,\n            dateIncrement: refinedOptions.dateIncrement,\n            hiddenDays: refinedOptions.hiddenDays,\n            weekends: refinedOptions.weekends,\n            nowInput: refinedOptions.now,\n            validRangeInput: refinedOptions.validRange,\n            visibleRangeInput: refinedOptions.visibleRange,\n            fixedWeekCount: refinedOptions.fixedWeekCount,\n        });\n        let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n        return { viewSpec, options: refinedOptions, dateProfileGenerator, viewApi };\n    }\n    processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n        let raw = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.M)([\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e,\n            viewSpec.optionDefaults,\n            localeDefaults,\n            optionOverrides,\n            viewSpec.optionOverrides,\n            dynamicOptionOverrides,\n        ]);\n        let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.N), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.O), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.P), _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.R), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n        let refined = {};\n        let currentRaw = this.currentViewOptionsInput;\n        let currentRefined = this.currentViewOptionsRefined;\n        let anyChanges = false;\n        let extra = {};\n        for (let optionName in raw) {\n            if (raw[optionName] === currentRaw[optionName] ||\n                (_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName] &&\n                    _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName](raw[optionName], currentRaw[optionName]))) {\n                refined[optionName] = currentRefined[optionName];\n            }\n            else {\n                if (raw[optionName] === this.currentCalendarOptionsInput[optionName] ||\n                    (_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName] &&\n                        _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Q[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName]))) {\n                    if (optionName in this.currentCalendarOptionsRefined) { // might be an \"extra\" prop\n                        refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n                    }\n                }\n                else if (refiners[optionName]) {\n                    refined[optionName] = refiners[optionName](raw[optionName]);\n                }\n                else {\n                    extra[optionName] = raw[optionName];\n                }\n                anyChanges = true;\n            }\n        }\n        if (anyChanges) {\n            this.currentViewOptionsInput = raw;\n            this.currentViewOptionsRefined = refined;\n        }\n        return {\n            rawOptions: this.currentViewOptionsInput,\n            refinedOptions: this.currentViewOptionsRefined,\n            extra,\n        };\n    }\n}\nfunction buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n    let locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n    return new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.S({\n        calendarSystem: 'gregory',\n        timeZone,\n        namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n        locale,\n        weekNumberCalculation,\n        firstDay,\n        weekText,\n        cmdFormatter: pluginHooks.cmdFormatter,\n        defaultSeparator,\n    });\n}\nfunction buildTheme(options, pluginHooks) {\n    let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n    return new ThemeClass(options);\n}\nfunction buildDateProfileGenerator(props) {\n    let DateProfileGeneratorClass = props.dateProfileGeneratorClass || _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.U;\n    return new DateProfileGeneratorClass(props);\n}\nfunction buildViewApi(type, getCurrentData, dateEnv) {\n    return new ViewImpl(type, getCurrentData, dateEnv);\n}\nfunction buildEventUiBySource(eventSources) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a)(eventSources, (eventSource) => eventSource.ui);\n}\nfunction buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n    let eventUiBases = { '': eventUiSingleBase };\n    for (let defId in eventDefs) {\n        let def = eventDefs[defId];\n        if (def.sourceId && eventUiBySource[def.sourceId]) {\n            eventUiBases[defId] = eventUiBySource[def.sourceId];\n        }\n    }\n    return eventUiBases;\n}\nfunction buildViewUiProps(calendarContext) {\n    let { options } = calendarContext;\n    return {\n        eventUiSingleBase: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.W)({\n            display: options.eventDisplay,\n            editable: options.editable,\n            startEditable: options.eventStartEditable,\n            durationEditable: options.eventDurationEditable,\n            constraint: options.eventConstraint,\n            overlap: typeof options.eventOverlap === 'boolean' ? options.eventOverlap : undefined,\n            allow: options.eventAllow,\n            backgroundColor: options.eventBackgroundColor,\n            borderColor: options.eventBorderColor,\n            textColor: options.eventTextColor,\n            color: options.eventColor,\n            // classNames: options.eventClassNames // render hook will handle this\n        }, calendarContext),\n        selectionConfig: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.W)({\n            constraint: options.selectConstraint,\n            overlap: typeof options.selectOverlap === 'boolean' ? options.selectOverlap : undefined,\n            allow: options.selectAllow,\n        }, calendarContext),\n    };\n}\nfunction computeIsLoading(state, context) {\n    for (let isLoadingFunc of context.pluginHooks.isLoadingFuncs) {\n        if (isLoadingFunc(state)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction parseContextBusinessHours(calendarContext) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.X)(calendarContext.options.businessHours, calendarContext);\n}\nfunction warnUnknownOptions(options, viewName) {\n    for (let optionName in options) {\n        console.warn(`Unknown option '${optionName}'` +\n            (viewName ? ` for view '${viewName}'` : ''));\n    }\n}\n\nclass ToolbarSection extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let children = this.props.widgetGroups.map((widgetGroup) => this.renderWidgetGroup(widgetGroup));\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { className: 'fc-toolbar-chunk' }, ...children);\n    }\n    renderWidgetGroup(widgetGroup) {\n        let { props } = this;\n        let { theme } = this.context;\n        let children = [];\n        let isOnlyButtons = true;\n        for (let widget of widgetGroup) {\n            let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;\n            if (buttonName === 'title') {\n                isOnlyButtons = false;\n                children.push((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"h2\", { className: \"fc-toolbar-title\", id: props.titleId }, props.title));\n            }\n            else {\n                let isPressed = buttonName === props.activeButton;\n                let isDisabled = (!props.isTodayEnabled && buttonName === 'today') ||\n                    (!props.isPrevEnabled && buttonName === 'prev') ||\n                    (!props.isNextEnabled && buttonName === 'next');\n                let buttonClasses = [`fc-${buttonName}-button`, theme.getClass('button')];\n                if (isPressed) {\n                    buttonClasses.push(theme.getClass('buttonActive'));\n                }\n                children.push((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"button\", { type: \"button\", title: typeof buttonHint === 'function' ? buttonHint(props.navUnit) : buttonHint, disabled: isDisabled, \"aria-pressed\": isPressed, className: buttonClasses.join(' '), onClick: buttonClick }, buttonText || (buttonIcon ? (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", { className: buttonIcon, role: \"img\" }) : '')));\n            }\n        }\n        if (children.length > 1) {\n            let groupClassName = (isOnlyButtons && theme.getClass('buttonGroup')) || '';\n            return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { className: groupClassName }, ...children);\n        }\n        return children[0];\n    }\n}\n\nclass Toolbar extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { model, extraClassName } = this.props;\n        let forceLtr = false;\n        let startContent;\n        let endContent;\n        let sectionWidgets = model.sectionWidgets;\n        let centerContent = sectionWidgets.center;\n        if (sectionWidgets.left) {\n            forceLtr = true;\n            startContent = sectionWidgets.left;\n        }\n        else {\n            startContent = sectionWidgets.start;\n        }\n        if (sectionWidgets.right) {\n            forceLtr = true;\n            endContent = sectionWidgets.right;\n        }\n        else {\n            endContent = sectionWidgets.end;\n        }\n        let classNames = [\n            extraClassName || '',\n            'fc-toolbar',\n            forceLtr ? 'fc-toolbar-ltr' : '',\n        ];\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: classNames.join(' ') },\n            this.renderSection('start', startContent || []),\n            this.renderSection('center', centerContent || []),\n            this.renderSection('end', endContent || [])));\n    }\n    renderSection(key, widgetGroups) {\n        let { props } = this;\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(ToolbarSection, { key: key, widgetGroups: widgetGroups, title: props.title, navUnit: props.navUnit, activeButton: props.activeButton, isTodayEnabled: props.isTodayEnabled, isPrevEnabled: props.isPrevEnabled, isNextEnabled: props.isNextEnabled, titleId: props.titleId }));\n    }\n}\n\nclass ViewHarness extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            availableWidth: null,\n        };\n        this.handleEl = (el) => {\n            this.el = el;\n            (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Y)(this.props.elRef, el);\n            this.updateAvailableWidth();\n        };\n        this.handleResize = () => {\n            this.updateAvailableWidth();\n        };\n    }\n    render() {\n        let { props, state } = this;\n        let { aspectRatio } = props;\n        let classNames = [\n            'fc-view-harness',\n            (aspectRatio || props.liquid || props.height)\n                ? 'fc-view-harness-active' // harness controls the height\n                : 'fc-view-harness-passive', // let the view do the height\n        ];\n        let height = '';\n        let paddingBottom = '';\n        if (aspectRatio) {\n            if (state.availableWidth !== null) {\n                height = state.availableWidth / aspectRatio;\n            }\n            else {\n                // while waiting to know availableWidth, we can't set height to *zero*\n                // because will cause lots of unnecessary scrollbars within scrollgrid.\n                // BETTER: don't start rendering ANYTHING yet until we know container width\n                // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)\n                paddingBottom = `${(1 / aspectRatio) * 100}%`;\n            }\n        }\n        else {\n            height = props.height || '';\n        }\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { \"aria-labelledby\": props.labeledById, ref: this.handleEl, className: classNames.join(' '), style: { height, paddingBottom } }, props.children));\n    }\n    componentDidMount() {\n        this.context.addResizeHandler(this.handleResize);\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleResize);\n    }\n    updateAvailableWidth() {\n        if (this.el && // needed. but why?\n            this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth\n        ) {\n            this.setState({ availableWidth: this.el.offsetWidth });\n        }\n    }\n}\n\n/*\nDetects when the user clicks on an event within a DateComponent\n*/\nclass EventClicking extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Z {\n    constructor(settings) {\n        super(settings);\n        this.handleSegClick = (ev, segEl) => {\n            let { component } = this;\n            let { context } = component;\n            let seg = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__._)(segEl);\n            if (seg && // might be the <div> surrounding the more link\n                component.isValidSegDownEl(ev.target)) {\n                // our way to simulate a link click for elements that can't be <a> tags\n                // grab before trigger fired in case trigger trashes DOM thru rerendering\n                let hasUrlContainer = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.$)(ev.target, '.fc-event-forced-url');\n                let url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';\n                context.emitter.trigger('eventClick', {\n                    el: segEl,\n                    event: new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a0(component.context, seg.eventRange.def, seg.eventRange.instance),\n                    jsEvent: ev,\n                    view: context.viewApi,\n                });\n                if (url && !ev.defaultPrevented) {\n                    window.location.href = url;\n                }\n            }\n        };\n        this.destroy = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a1)(settings.el, 'click', '.fc-event', // on both fg and bg events\n        this.handleSegClick);\n    }\n}\n\n/*\nTriggers events and adds/removes core classNames when the user's pointer\nenters/leaves event-elements of a component.\n*/\nclass EventHovering extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.Z {\n    constructor(settings) {\n        super(settings);\n        // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n        this.handleEventElRemove = (el) => {\n            if (el === this.currentSegEl) {\n                this.handleSegLeave(null, this.currentSegEl);\n            }\n        };\n        this.handleSegEnter = (ev, segEl) => {\n            if ((0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__._)(segEl)) { // TODO: better way to make sure not hovering over more+ link or its wrapper\n                this.currentSegEl = segEl;\n                this.triggerEvent('eventMouseEnter', ev, segEl);\n            }\n        };\n        this.handleSegLeave = (ev, segEl) => {\n            if (this.currentSegEl) {\n                this.currentSegEl = null;\n                this.triggerEvent('eventMouseLeave', ev, segEl);\n            }\n        };\n        this.removeHoverListeners = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a2)(settings.el, '.fc-event', // on both fg and bg events\n        this.handleSegEnter, this.handleSegLeave);\n    }\n    destroy() {\n        this.removeHoverListeners();\n    }\n    triggerEvent(publicEvName, ev, segEl) {\n        let { component } = this;\n        let { context } = component;\n        let seg = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__._)(segEl);\n        if (!ev || component.isValidSegDownEl(ev.target)) {\n            context.emitter.trigger(publicEvName, {\n                el: segEl,\n                event: new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a0(context, seg.eventRange.def, seg.eventRange.instance),\n                jsEvent: ev,\n                view: context.viewApi,\n            });\n        }\n    }\n}\n\nclass CalendarContent extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a3 {\n    constructor() {\n        super(...arguments);\n        this.buildViewContext = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a4);\n        this.buildViewPropTransformers = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildViewPropTransformers);\n        this.buildToolbarProps = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildToolbarProps);\n        this.headerRef = (0,preact__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.footerRef = (0,preact__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.interactionsStore = {};\n        // eslint-disable-next-line\n        this.state = {\n            viewLabelId: (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a5)(),\n        };\n        // Component Registration\n        // -----------------------------------------------------------------------------------------------------------------\n        this.registerInteractiveComponent = (component, settingsInput) => {\n            let settings = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a6)(component, settingsInput);\n            let DEFAULT_INTERACTIONS = [\n                EventClicking,\n                EventHovering,\n            ];\n            let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);\n            let interactions = interactionClasses.map((TheInteractionClass) => new TheInteractionClass(settings));\n            this.interactionsStore[component.uid] = interactions;\n            _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a7[component.uid] = settings;\n        };\n        this.unregisterInteractiveComponent = (component) => {\n            let listeners = this.interactionsStore[component.uid];\n            if (listeners) {\n                for (let listener of listeners) {\n                    listener.destroy();\n                }\n                delete this.interactionsStore[component.uid];\n            }\n            delete _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a7[component.uid];\n        };\n        // Resizing\n        // -----------------------------------------------------------------------------------------------------------------\n        this.resizeRunner = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.D(() => {\n            this.props.emitter.trigger('_resize', true); // should window resizes be considered \"forced\" ?\n            this.props.emitter.trigger('windowResize', { view: this.props.viewApi });\n        });\n        this.handleWindowResize = (ev) => {\n            let { options } = this.props;\n            if (options.handleWindowResize &&\n                ev.target === window // avoid jqui events\n            ) {\n                this.resizeRunner.request(options.windowResizeDelay);\n            }\n        };\n    }\n    /*\n    renders INSIDE of an outer div\n    */\n    render() {\n        let { props } = this;\n        let { toolbarConfig, options } = props;\n        let toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a8)(props.options.now, props.dateEnv), // TODO: use NowTimer????\n        props.viewTitle);\n        let viewVGrow = false;\n        let viewHeight = '';\n        let viewAspectRatio;\n        if (props.isHeightAuto || props.forPrint) {\n            viewHeight = '';\n        }\n        else if (options.height != null) {\n            viewVGrow = true;\n        }\n        else if (options.contentHeight != null) {\n            viewHeight = options.contentHeight;\n        }\n        else {\n            viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n        }\n        let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n        let viewLabelId = (toolbarConfig.header && toolbarConfig.header.hasTitle)\n            ? this.state.viewLabelId\n            : undefined;\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.V.Provider, { value: viewContext },\n            toolbarConfig.header && ((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(Toolbar, Object.assign({ ref: this.headerRef, extraClassName: \"fc-header-toolbar\", model: toolbarConfig.header, titleId: viewLabelId }, toolbarProps))),\n            (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewHarness, { liquid: viewVGrow, height: viewHeight, aspectRatio: viewAspectRatio, labeledById: viewLabelId },\n                this.renderView(props),\n                this.buildAppendContent()),\n            toolbarConfig.footer && ((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(Toolbar, Object.assign({ ref: this.footerRef, extraClassName: \"fc-footer-toolbar\", model: toolbarConfig.footer, titleId: \"\" }, toolbarProps)))));\n    }\n    componentDidMount() {\n        let { props } = this;\n        this.calendarInteractions = props.pluginHooks.calendarInteractions\n            .map((CalendarInteractionClass) => new CalendarInteractionClass(props));\n        window.addEventListener('resize', this.handleWindowResize);\n        let { propSetHandlers } = props.pluginHooks;\n        for (let propName in propSetHandlers) {\n            propSetHandlers[propName](props[propName], props);\n        }\n    }\n    componentDidUpdate(prevProps) {\n        let { props } = this;\n        let { propSetHandlers } = props.pluginHooks;\n        for (let propName in propSetHandlers) {\n            if (props[propName] !== prevProps[propName]) {\n                propSetHandlers[propName](props[propName], props);\n            }\n        }\n    }\n    componentWillUnmount() {\n        window.removeEventListener('resize', this.handleWindowResize);\n        this.resizeRunner.clear();\n        for (let interaction of this.calendarInteractions) {\n            interaction.destroy();\n        }\n        this.props.emitter.trigger('_unmount');\n    }\n    buildAppendContent() {\n        let { props } = this;\n        let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent) => buildAppendContent(props));\n        return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(preact__WEBPACK_IMPORTED_MODULE_1__.Fragment, {}, ...children);\n    }\n    renderView(props) {\n        let { pluginHooks } = props;\n        let { viewSpec } = props;\n        let viewProps = {\n            dateProfile: props.dateProfile,\n            businessHours: props.businessHours,\n            eventStore: props.renderableEventStore,\n            eventUiBases: props.eventUiBases,\n            dateSelection: props.dateSelection,\n            eventSelection: props.eventSelection,\n            eventDrag: props.eventDrag,\n            eventResize: props.eventResize,\n            isHeightAuto: props.isHeightAuto,\n            forPrint: props.forPrint,\n        };\n        let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n        for (let transformer of transformers) {\n            Object.assign(viewProps, transformer.transform(viewProps, props));\n        }\n        let ViewComponent = viewSpec.component;\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewComponent, Object.assign({}, viewProps)));\n    }\n}\nfunction buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n    // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n    let todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n    let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n    let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n    return {\n        title,\n        activeButton: viewSpec.type,\n        navUnit: viewSpec.singleUnit,\n        isTodayEnabled: todayInfo.isValid && !(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.H)(dateProfile.currentRange, now),\n        isPrevEnabled: prevInfo.isValid,\n        isNextEnabled: nextInfo.isValid,\n    };\n}\n// Plugin\n// -----------------------------------------------------------------------------------------------------------------\nfunction buildViewPropTransformers(theClasses) {\n    return theClasses.map((TheClass) => new TheClass());\n}\n\nclass Calendar extends _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.a9 {\n    constructor(el, optionOverrides = {}) {\n        super();\n        this.isRendering = false;\n        this.isRendered = false;\n        this.currentClassNames = [];\n        this.customContentRenderId = 0;\n        this.handleAction = (action) => {\n            // actions we know we want to render immediately\n            switch (action.type) {\n                case 'SET_EVENT_DRAG':\n                case 'SET_EVENT_RESIZE':\n                    this.renderRunner.tryDrain();\n            }\n        };\n        this.handleData = (data) => {\n            this.currentData = data;\n            this.renderRunner.request(data.calendarOptions.rerenderDelay);\n        };\n        this.handleRenderRequest = () => {\n            if (this.isRendering) {\n                this.isRendered = true;\n                let { currentData } = this;\n                (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.aa)(() => {\n                    (0,preact__WEBPACK_IMPORTED_MODULE_1__.render)((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ab, { options: currentData.calendarOptions, theme: currentData.theme, emitter: currentData.emitter }, (classNames, height, isHeightAuto, forPrint) => {\n                        this.setClassNames(classNames);\n                        this.setHeight(height);\n                        return ((0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ac.Provider, { value: this.customContentRenderId },\n                            (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(CalendarContent, Object.assign({ isHeightAuto: isHeightAuto, forPrint: forPrint }, currentData))));\n                    }), this.el);\n                });\n            }\n            else if (this.isRendered) {\n                this.isRendered = false;\n                (0,preact__WEBPACK_IMPORTED_MODULE_1__.render)(null, this.el);\n                this.setClassNames([]);\n                this.setHeight('');\n            }\n        };\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ad)(el);\n        this.el = el;\n        this.renderRunner = new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.D(this.handleRenderRequest);\n        new CalendarDataManager({\n            optionOverrides,\n            calendarApi: this,\n            onAction: this.handleAction,\n            onData: this.handleData,\n        });\n    }\n    render() {\n        let wasRendering = this.isRendering;\n        if (!wasRendering) {\n            this.isRendering = true;\n        }\n        else {\n            this.customContentRenderId += 1;\n        }\n        this.renderRunner.request();\n        if (wasRendering) {\n            this.updateSize();\n        }\n    }\n    destroy() {\n        if (this.isRendering) {\n            this.isRendering = false;\n            this.renderRunner.request();\n        }\n    }\n    updateSize() {\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.aa)(() => {\n            super.updateSize();\n        });\n    }\n    batchRendering(func) {\n        this.renderRunner.pause('batchRendering');\n        func();\n        this.renderRunner.resume('batchRendering');\n    }\n    pauseRendering() {\n        this.renderRunner.pause('pauseRendering');\n    }\n    resumeRendering() {\n        this.renderRunner.resume('pauseRendering', true);\n    }\n    resetOptions(optionOverrides, changedOptionNames) {\n        this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);\n    }\n    setClassNames(classNames) {\n        if (!(0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.i)(classNames, this.currentClassNames)) {\n            let { classList } = this.el;\n            for (let className of this.currentClassNames) {\n                classList.remove(className);\n            }\n            for (let className of classNames) {\n                classList.add(className);\n            }\n            this.currentClassNames = classNames;\n        }\n    }\n    setHeight(height) {\n        (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.ae)(this.el, 'height', height);\n    }\n}\n\nfunction formatDate(dateInput, options = {}) {\n    let dateEnv = buildDateEnv(options);\n    let formatter = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.x)(options);\n    let dateMeta = dateEnv.createMarkerMeta(dateInput);\n    if (!dateMeta) { // TODO: warning?\n        return '';\n    }\n    return dateEnv.format(dateMeta.marker, formatter, {\n        forcedTzo: dateMeta.forcedTzo,\n    });\n}\nfunction formatRange(startInput, endInput, options) {\n    let dateEnv = buildDateEnv(typeof options === 'object' && options ? options : {}); // pass in if non-null object\n    let formatter = (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.x)(options);\n    let startMeta = dateEnv.createMarkerMeta(startInput);\n    let endMeta = dateEnv.createMarkerMeta(endInput);\n    if (!startMeta || !endMeta) { // TODO: warning?\n        return '';\n    }\n    return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n        forcedStartTzo: startMeta.forcedTzo,\n        forcedEndTzo: endMeta.forcedTzo,\n        isEndExclusive: options.isEndExclusive,\n        defaultSeparator: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e.defaultRangeSeparator,\n    });\n}\n// TODO: more DRY and optimized\nfunction buildDateEnv(settings) {\n    let locale = buildLocale(settings.locale || 'en', organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n    return new _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.S(Object.assign(Object.assign({ timeZone: _internal_common_js__WEBPACK_IMPORTED_MODULE_0__.e.timeZone, calendarSystem: 'gregory' }, settings), { locale }));\n}\n\n// HELPERS\n/*\nif nextDayThreshold is specified, slicing is done in an all-day fashion.\nyou can get nextDayThreshold from context.nextDayThreshold\n*/\nfunction sliceEvents(props, allDay) {\n    return (0,_internal_common_js__WEBPACK_IMPORTED_MODULE_0__.af)(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n}\n\nconst version = '6.1.15';\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFpaUQ7QUFDbitDO0FBQ007QUFDN0M7O0FBRXZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckMsU0FBUztBQUNULEtBQUs7QUFDTCx1QkFBdUIsVUFBVSxZQUFZLDBCQUEwQjtBQUN2RSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzREFBVTtBQUMzQix3QkFBd0I7QUFDeEIsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBYTtBQUMxQixrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWM7QUFDdEI7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQSxvQkFBb0Isc0RBQWU7QUFDbkM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9GQUFvRixHQUFHO0FBQ3ZGLG9CQUFvQixzREFBZTtBQUNuQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrREFBb0I7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRixlQUFlLGtEQUFPLCtCQUErQixVQUFVLGtEQUFvQixzQ0FBc0MsZUFBZSxRQUFRO0FBQ2hKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQWU7QUFDMUI7O0FBRUE7O0FBRStHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2luZGV4LmpzPzdhNGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbSBhcyBtZXJnZVByb3BzLCBnIGFzIGd1aWQsIGkgYXMgaXNBcnJheXNFcXVhbCwgVCBhcyBUaGVtZSwgYSBhcyBtYXBIYXNoLCBCIGFzIEJhc2VDb21wb25lbnQsIFYgYXMgVmlld0NvbnRleHRUeXBlLCBDIGFzIENvbnRlbnRDb250YWluZXIsIGIgYXMgYnVpbGRWaWV3Q2xhc3NOYW1lcywgYyBhcyBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IsIGQgYXMgY3JlYXRlRHVyYXRpb24sIGUgYXMgQkFTRV9PUFRJT05fREVGQVVMVFMsIGYgYXMgYXJyYXlUb0hhc2gsIGggYXMgZmlsdGVySGFzaCwgaiBhcyBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMsIHAgYXMgcGFyc2VFdmVudFNvdXJjZSwgayBhcyBmb3JtYXRXaXRoT3JkaW5hbHMsIHUgYXMgdW5wcm9taXNpZnksIGwgYXMgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZSwgbiBhcyBpZGVudGl0eSwgciBhcyByZXF1ZXN0SnNvbiwgcyBhcyBzdWJ0cmFjdER1cmF0aW9ucywgbyBhcyBpbnRlcnNlY3RSYW5nZXMsIHEgYXMgc3RhcnRPZkRheSwgdCBhcyBhZGREYXlzLCB2IGFzIGhhc2hWYWx1ZXNUb0FycmF5LCB3IGFzIGJ1aWxkRXZlbnRBcGlzLCBEIGFzIERlbGF5ZWRSdW5uZXIsIHggYXMgY3JlYXRlRm9ybWF0dGVyLCB5IGFzIGRpZmZXaG9sZURheXMsIHogYXMgbWVtb2l6ZSwgQSBhcyBtZW1vaXplT2JqQXJnLCBFIGFzIGlzUHJvcHNFcXVhbCwgRiBhcyBFbWl0dGVyLCBHIGFzIGdldEluaXRpYWxEYXRlLCBIIGFzIHJhbmdlQ29udGFpbnNNYXJrZXIsIEkgYXMgY3JlYXRlRW1wdHlFdmVudFN0b3JlLCBKIGFzIHJlZHVjZUN1cnJlbnREYXRlLCBLIGFzIHJlZHVjZUV2ZW50U3RvcmUsIEwgYXMgcmV6b25lRXZlbnRTdG9yZURhdGVzLCBNIGFzIG1lcmdlUmF3T3B0aW9ucywgTiBhcyBCQVNFX09QVElPTl9SRUZJTkVSUywgTyBhcyBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUywgUCBhcyBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMsIFEgYXMgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMsIFIgYXMgVklFV19PUFRJT05fUkVGSU5FUlMsIFMgYXMgRGF0ZUVudiwgVSBhcyBEYXRlUHJvZmlsZUdlbmVyYXRvciwgVyBhcyBjcmVhdGVFdmVudFVpLCBYIGFzIHBhcnNlQnVzaW5lc3NIb3VycywgWSBhcyBzZXRSZWYsIFogYXMgSW50ZXJhY3Rpb24sIF8gYXMgZ2V0RWxTZWcsICQgYXMgZWxlbWVudENsb3Nlc3QsIGEwIGFzIEV2ZW50SW1wbCwgYTEgYXMgbGlzdGVuQnlTZWxlY3RvciwgYTIgYXMgbGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IsIGEzIGFzIFB1cmVDb21wb25lbnQsIGE0IGFzIGJ1aWxkVmlld0NvbnRleHQsIGE1IGFzIGdldFVuaXF1ZURvbUlkLCBhNiBhcyBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MsIGE3IGFzIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSwgYTggYXMgZ2V0Tm93LCBhOSBhcyBDYWxlbmRhckltcGwsIGFhIGFzIGZsdXNoU3luYywgYWIgYXMgQ2FsZW5kYXJSb290LCBhYyBhcyBSZW5kZXJJZCwgYWQgYXMgZW5zdXJlRWxIYXNTdHlsZXMsIGFlIGFzIGFwcGx5U3R5bGVQcm9wLCBhZiBhcyBzbGljZUV2ZW50U3RvcmUgfSBmcm9tICcuL2ludGVybmFsLWNvbW1vbi5qcyc7XG5leHBvcnQgeyBhZyBhcyBKc29uUmVxdWVzdEVycm9yIH0gZnJvbSAnLi9pbnRlcm5hbC1jb21tb24uanMnO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgY3JlYXRlUmVmLCBGcmFnbWVudCwgcmVuZGVyIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCAncHJlYWN0L2NvbXBhdCc7XG5cbmNvbnN0IGdsb2JhbExvY2FsZXMgPSBbXTtcblxuY29uc3QgTUlOSU1BTF9SQVdfRU5fTE9DQUxFID0ge1xuICAgIGNvZGU6ICdlbicsXG4gICAgd2Vlazoge1xuICAgICAgICBkb3c6IDAsXG4gICAgICAgIGRveTogNCwgLy8gNCBkYXlzIG5lZWQgdG8gYmUgd2l0aGluIHRoZSB5ZWFyIHRvIGJlIGNvbnNpZGVyZWQgdGhlIGZpcnN0IHdlZWtcbiAgICB9LFxuICAgIGRpcmVjdGlvbjogJ2x0cicsXG4gICAgYnV0dG9uVGV4dDoge1xuICAgICAgICBwcmV2OiAncHJldicsXG4gICAgICAgIG5leHQ6ICduZXh0JyxcbiAgICAgICAgcHJldlllYXI6ICdwcmV2IHllYXInLFxuICAgICAgICBuZXh0WWVhcjogJ25leHQgeWVhcicsXG4gICAgICAgIHllYXI6ICd5ZWFyJyxcbiAgICAgICAgdG9kYXk6ICd0b2RheScsXG4gICAgICAgIG1vbnRoOiAnbW9udGgnLFxuICAgICAgICB3ZWVrOiAnd2VlaycsXG4gICAgICAgIGRheTogJ2RheScsXG4gICAgICAgIGxpc3Q6ICdsaXN0JyxcbiAgICB9LFxuICAgIHdlZWtUZXh0OiAnVycsXG4gICAgd2Vla1RleHRMb25nOiAnV2VlaycsXG4gICAgY2xvc2VIaW50OiAnQ2xvc2UnLFxuICAgIHRpbWVIaW50OiAnVGltZScsXG4gICAgZXZlbnRIaW50OiAnRXZlbnQnLFxuICAgIGFsbERheVRleHQ6ICdhbGwtZGF5JyxcbiAgICBtb3JlTGlua1RleHQ6ICdtb3JlJyxcbiAgICBub0V2ZW50c1RleHQ6ICdObyBldmVudHMgdG8gZGlzcGxheScsXG59O1xuY29uc3QgUkFXX0VOX0xPQ0FMRSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgTUlOSU1BTF9SQVdfRU5fTE9DQUxFKSwgeyBcbiAgICAvLyBJbmNsdWRlcyB0aGluZ3Mgd2UgZG9uJ3Qgd2FudCBvdGhlciBsb2NhbGVzIHRvIGluaGVyaXQsXG4gICAgLy8gdGhpbmdzIHRoYXQgZGVyaXZlIGZyb20gb3RoZXIgdHJhbnNsYXRhYmxlIHN0cmluZ3MuXG4gICAgYnV0dG9uSGludHM6IHtcbiAgICAgICAgcHJldjogJ1ByZXZpb3VzICQwJyxcbiAgICAgICAgbmV4dDogJ05leHQgJDAnLFxuICAgICAgICB0b2RheShidXR0b25UZXh0LCB1bml0KSB7XG4gICAgICAgICAgICByZXR1cm4gKHVuaXQgPT09ICdkYXknKVxuICAgICAgICAgICAgICAgID8gJ1RvZGF5J1xuICAgICAgICAgICAgICAgIDogYFRoaXMgJHtidXR0b25UZXh0fWA7XG4gICAgICAgIH0sXG4gICAgfSwgdmlld0hpbnQ6ICckMCB2aWV3JywgbmF2TGlua0hpbnQ6ICdHbyB0byAkMCcsIG1vcmVMaW5rSGludChldmVudENudCkge1xuICAgICAgICByZXR1cm4gYFNob3cgJHtldmVudENudH0gbW9yZSBldmVudCR7ZXZlbnRDbnQgPT09IDEgPyAnJyA6ICdzJ31gO1xuICAgIH0gfSk7XG5mdW5jdGlvbiBvcmdhbml6ZVJhd0xvY2FsZXMoZXhwbGljaXRSYXdMb2NhbGVzKSB7XG4gICAgbGV0IGRlZmF1bHRDb2RlID0gZXhwbGljaXRSYXdMb2NhbGVzLmxlbmd0aCA+IDAgPyBleHBsaWNpdFJhd0xvY2FsZXNbMF0uY29kZSA6ICdlbic7XG4gICAgbGV0IGFsbFJhd0xvY2FsZXMgPSBnbG9iYWxMb2NhbGVzLmNvbmNhdChleHBsaWNpdFJhd0xvY2FsZXMpO1xuICAgIGxldCByYXdMb2NhbGVNYXAgPSB7XG4gICAgICAgIGVuOiBSQVdfRU5fTE9DQUxFLFxuICAgIH07XG4gICAgZm9yIChsZXQgcmF3TG9jYWxlIG9mIGFsbFJhd0xvY2FsZXMpIHtcbiAgICAgICAgcmF3TG9jYWxlTWFwW3Jhd0xvY2FsZS5jb2RlXSA9IHJhd0xvY2FsZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFwOiByYXdMb2NhbGVNYXAsXG4gICAgICAgIGRlZmF1bHRDb2RlLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZExvY2FsZShpbnB1dFNpbmd1bGFyLCBhdmFpbGFibGUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0U2luZ3VsYXIgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGlucHV0U2luZ3VsYXIpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUxvY2FsZShpbnB1dFNpbmd1bGFyLmNvZGUsIFtpbnB1dFNpbmd1bGFyLmNvZGVdLCBpbnB1dFNpbmd1bGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5TG9jYWxlKGlucHV0U2luZ3VsYXIsIGF2YWlsYWJsZSk7XG59XG5mdW5jdGlvbiBxdWVyeUxvY2FsZShjb2RlQXJnLCBhdmFpbGFibGUpIHtcbiAgICBsZXQgY29kZXMgPSBbXS5jb25jYXQoY29kZUFyZyB8fCBbXSk7IC8vIHdpbGwgY29udmVydCB0byBhcnJheVxuICAgIGxldCByYXcgPSBxdWVyeVJhd0xvY2FsZShjb2RlcywgYXZhaWxhYmxlKSB8fCBSQVdfRU5fTE9DQUxFO1xuICAgIHJldHVybiBwYXJzZUxvY2FsZShjb2RlQXJnLCBjb2RlcywgcmF3KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5UmF3TG9jYWxlKGNvZGVzLCBhdmFpbGFibGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IGNvZGVzW2ldLnRvTG9jYWxlTG93ZXJDYXNlKCkuc3BsaXQoJy0nKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IHBhcnRzLmxlbmd0aDsgaiA+IDA7IGogLT0gMSkge1xuICAgICAgICAgICAgbGV0IHNpbXBsZUlkID0gcGFydHMuc2xpY2UoMCwgaikuam9pbignLScpO1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZVtzaW1wbGVJZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlW3NpbXBsZUlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlTG9jYWxlKGNvZGVBcmcsIGNvZGVzLCByYXcpIHtcbiAgICBsZXQgbWVyZ2VkID0gbWVyZ2VQcm9wcyhbTUlOSU1BTF9SQVdfRU5fTE9DQUxFLCByYXddLCBbJ2J1dHRvblRleHQnXSk7XG4gICAgZGVsZXRlIG1lcmdlZC5jb2RlOyAvLyBkb24ndCB3YW50IHRoaXMgcGFydCBvZiB0aGUgb3B0aW9uc1xuICAgIGxldCB7IHdlZWsgfSA9IG1lcmdlZDtcbiAgICBkZWxldGUgbWVyZ2VkLndlZWs7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZUFyZyxcbiAgICAgICAgY29kZXMsXG4gICAgICAgIHdlZWssXG4gICAgICAgIHNpbXBsZU51bWJlckZvcm1hdDogbmV3IEludGwuTnVtYmVyRm9ybWF0KGNvZGVBcmcpLFxuICAgICAgICBvcHRpb25zOiBtZXJnZWQsXG4gICAgfTtcbn1cblxuLy8gVE9ETzogZWFzaWVyIHdheSB0byBhZGQgbmV3IGhvb2tzPyBuZWVkIHRvIHVwZGF0ZSBhIG1pbGxpb24gdGhpbmdzXG5mdW5jdGlvbiBjcmVhdGVQbHVnaW4oaW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogZ3VpZCgpLFxuICAgICAgICBuYW1lOiBpbnB1dC5uYW1lLFxuICAgICAgICBwcmVtaXVtUmVsZWFzZURhdGU6IGlucHV0LnByZW1pdW1SZWxlYXNlRGF0ZSA/IG5ldyBEYXRlKGlucHV0LnByZW1pdW1SZWxlYXNlRGF0ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgIGRlcHM6IGlucHV0LmRlcHMgfHwgW10sXG4gICAgICAgIHJlZHVjZXJzOiBpbnB1dC5yZWR1Y2VycyB8fCBbXSxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IGlucHV0LmlzTG9hZGluZ0Z1bmNzIHx8IFtdLFxuICAgICAgICBjb250ZXh0SW5pdDogW10uY29uY2F0KGlucHV0LmNvbnRleHRJbml0IHx8IFtdKSxcbiAgICAgICAgZXZlbnRSZWZpbmVyczogaW5wdXQuZXZlbnRSZWZpbmVycyB8fCB7fSxcbiAgICAgICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IGlucHV0LmV2ZW50RGVmTWVtYmVyQWRkZXJzIHx8IFtdLFxuICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiBpbnB1dC5ldmVudFNvdXJjZVJlZmluZXJzIHx8IHt9LFxuICAgICAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogaW5wdXQuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBpbnB1dC5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyB8fCBbXSxcbiAgICAgICAgZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzOiBpbnB1dC5ldmVudERlZk11dGF0aW9uQXBwbGllcnMgfHwgW10sXG4gICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IGlucHV0LmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IGlucHV0LmRhdGVQb2ludFRyYW5zZm9ybXMgfHwgW10sXG4gICAgICAgIGRhdGVTcGFuVHJhbnNmb3JtczogaW5wdXQuZGF0ZVNwYW5UcmFuc2Zvcm1zIHx8IFtdLFxuICAgICAgICB2aWV3czogaW5wdXQudmlld3MgfHwge30sXG4gICAgICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogaW5wdXQudmlld1Byb3BzVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBpc1Byb3BzVmFsaWQ6IGlucHV0LmlzUHJvcHNWYWxpZCB8fCBudWxsLFxuICAgICAgICBleHRlcm5hbERlZlRyYW5zZm9ybXM6IGlucHV0LmV4dGVybmFsRGVmVHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgdmlld0NvbnRhaW5lckFwcGVuZHM6IGlucHV0LnZpZXdDb250YWluZXJBcHBlbmRzIHx8IFtdLFxuICAgICAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IGlucHV0LmV2ZW50RHJvcFRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBpbnB1dC5jb21wb25lbnRJbnRlcmFjdGlvbnMgfHwgW10sXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBpbnB1dC5jYWxlbmRhckludGVyYWN0aW9ucyB8fCBbXSxcbiAgICAgICAgdGhlbWVDbGFzc2VzOiBpbnB1dC50aGVtZUNsYXNzZXMgfHwge30sXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogaW5wdXQuZXZlbnRTb3VyY2VEZWZzIHx8IFtdLFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IGlucHV0LmNtZEZvcm1hdHRlcixcbiAgICAgICAgcmVjdXJyaW5nVHlwZXM6IGlucHV0LnJlY3VycmluZ1R5cGVzIHx8IFtdLFxuICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IGlucHV0Lm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICAgICAgaW5pdGlhbFZpZXc6IGlucHV0LmluaXRpYWxWaWV3IHx8ICcnLFxuICAgICAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBpbnB1dC5lbGVtZW50RHJhZ2dpbmdJbXBsLFxuICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczogaW5wdXQub3B0aW9uQ2hhbmdlSGFuZGxlcnMgfHwge30sXG4gICAgICAgIHNjcm9sbEdyaWRJbXBsOiBpbnB1dC5zY3JvbGxHcmlkSW1wbCB8fCBudWxsLFxuICAgICAgICBsaXN0ZW5lclJlZmluZXJzOiBpbnB1dC5saXN0ZW5lclJlZmluZXJzIHx8IHt9LFxuICAgICAgICBvcHRpb25SZWZpbmVyczogaW5wdXQub3B0aW9uUmVmaW5lcnMgfHwge30sXG4gICAgICAgIHByb3BTZXRIYW5kbGVyczogaW5wdXQucHJvcFNldEhhbmRsZXJzIHx8IHt9LFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZFBsdWdpbkhvb2tzKHBsdWdpbkRlZnMsIGdsb2JhbERlZnMpIHtcbiAgICBsZXQgY3VycmVudFBsdWdpbklkcyA9IHt9O1xuICAgIGxldCBob29rcyA9IHtcbiAgICAgICAgcHJlbWl1bVJlbGVhc2VEYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIHJlZHVjZXJzOiBbXSxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IFtdLFxuICAgICAgICBjb250ZXh0SW5pdDogW10sXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IHt9LFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogW10sXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IHt9LFxuICAgICAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBbXSxcbiAgICAgICAgZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzOiBbXSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IFtdLFxuICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IFtdLFxuICAgICAgICB2aWV3czoge30sXG4gICAgICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGlzUHJvcHNWYWxpZDogbnVsbCxcbiAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgdmlld0NvbnRhaW5lckFwcGVuZHM6IFtdLFxuICAgICAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IFtdLFxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogW10sXG4gICAgICAgIHRoZW1lQ2xhc3Nlczoge30sXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogW10sXG4gICAgICAgIGNtZEZvcm1hdHRlcjogbnVsbCxcbiAgICAgICAgcmVjdXJyaW5nVHlwZXM6IFtdLFxuICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IG51bGwsXG4gICAgICAgIGluaXRpYWxWaWV3OiAnJyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogbnVsbCxcbiAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IHt9LFxuICAgICAgICBzY3JvbGxHcmlkSW1wbDogbnVsbCxcbiAgICAgICAgbGlzdGVuZXJSZWZpbmVyczoge30sXG4gICAgICAgIG9wdGlvblJlZmluZXJzOiB7fSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiB7fSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGFkZERlZnMoZGVmcykge1xuICAgICAgICBmb3IgKGxldCBkZWYgb2YgZGVmcykge1xuICAgICAgICAgICAgY29uc3QgcGx1Z2luTmFtZSA9IGRlZi5uYW1lO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudElkID0gY3VycmVudFBsdWdpbklkc1twbHVnaW5OYW1lXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQbHVnaW5JZHNbcGx1Z2luTmFtZV0gPSBkZWYuaWQ7XG4gICAgICAgICAgICAgICAgYWRkRGVmcyhkZWYuZGVwcyk7XG4gICAgICAgICAgICAgICAgaG9va3MgPSBjb21iaW5lSG9va3MoaG9va3MsIGRlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50SWQgIT09IGRlZi5pZCkge1xuICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudCBJRCB0aGFuIHRoZSBvbmUgYWxyZWFkeSBhZGRlZFxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRHVwbGljYXRlIHBsdWdpbiAnJHtwbHVnaW5OYW1lfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGx1Z2luRGVmcykge1xuICAgICAgICBhZGREZWZzKHBsdWdpbkRlZnMpO1xuICAgIH1cbiAgICBhZGREZWZzKGdsb2JhbERlZnMpO1xuICAgIHJldHVybiBob29rcztcbn1cbmZ1bmN0aW9uIGJ1aWxkQnVpbGRQbHVnaW5Ib29rcygpIHtcbiAgICBsZXQgY3VycmVudE92ZXJyaWRlRGVmcyA9IFtdO1xuICAgIGxldCBjdXJyZW50R2xvYmFsRGVmcyA9IFtdO1xuICAgIGxldCBjdXJyZW50SG9va3M7XG4gICAgcmV0dXJuIChvdmVycmlkZURlZnMsIGdsb2JhbERlZnMpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50SG9va3MgfHwgIWlzQXJyYXlzRXF1YWwob3ZlcnJpZGVEZWZzLCBjdXJyZW50T3ZlcnJpZGVEZWZzKSB8fCAhaXNBcnJheXNFcXVhbChnbG9iYWxEZWZzLCBjdXJyZW50R2xvYmFsRGVmcykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRIb29rcyA9IGJ1aWxkUGx1Z2luSG9va3Mob3ZlcnJpZGVEZWZzLCBnbG9iYWxEZWZzKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50T3ZlcnJpZGVEZWZzID0gb3ZlcnJpZGVEZWZzO1xuICAgICAgICBjdXJyZW50R2xvYmFsRGVmcyA9IGdsb2JhbERlZnM7XG4gICAgICAgIHJldHVybiBjdXJyZW50SG9va3M7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbWJpbmVIb29rcyhob29rczAsIGhvb2tzMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZW1pdW1SZWxlYXNlRGF0ZTogY29tcGFyZU9wdGlvbmFsRGF0ZXMoaG9va3MwLnByZW1pdW1SZWxlYXNlRGF0ZSwgaG9va3MxLnByZW1pdW1SZWxlYXNlRGF0ZSksXG4gICAgICAgIHJlZHVjZXJzOiBob29rczAucmVkdWNlcnMuY29uY2F0KGhvb2tzMS5yZWR1Y2VycyksXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBob29rczAuaXNMb2FkaW5nRnVuY3MuY29uY2F0KGhvb2tzMS5pc0xvYWRpbmdGdW5jcyksXG4gICAgICAgIGNvbnRleHRJbml0OiBob29rczAuY29udGV4dEluaXQuY29uY2F0KGhvb2tzMS5jb250ZXh0SW5pdCksXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLmV2ZW50UmVmaW5lcnMpLCBob29rczEuZXZlbnRSZWZpbmVycyksXG4gICAgICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBob29rczAuZXZlbnREZWZNZW1iZXJBZGRlcnMuY29uY2F0KGhvb2tzMS5ldmVudERlZk1lbWJlckFkZGVycyksXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLmV2ZW50U291cmNlUmVmaW5lcnMpLCBob29rczEuZXZlbnRTb3VyY2VSZWZpbmVycyksXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBob29rczAuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycyksXG4gICAgICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBob29rczAuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMuY29uY2F0KGhvb2tzMS5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyksXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaG9va3MwLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyksXG4gICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IGhvb2tzMC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyksXG4gICAgICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IGhvb2tzMC5kYXRlUG9pbnRUcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZGF0ZVBvaW50VHJhbnNmb3JtcyksXG4gICAgICAgIGRhdGVTcGFuVHJhbnNmb3JtczogaG9va3MwLmRhdGVTcGFuVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVTcGFuVHJhbnNmb3JtcyksXG4gICAgICAgIHZpZXdzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC52aWV3cyksIGhvb2tzMS52aWV3cyksXG4gICAgICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogaG9va3MwLnZpZXdQcm9wc1RyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLnZpZXdQcm9wc1RyYW5zZm9ybWVycyksXG4gICAgICAgIGlzUHJvcHNWYWxpZDogaG9va3MxLmlzUHJvcHNWYWxpZCB8fCBob29rczAuaXNQcm9wc1ZhbGlkLFxuICAgICAgICBleHRlcm5hbERlZlRyYW5zZm9ybXM6IGhvb2tzMC5leHRlcm5hbERlZlRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5leHRlcm5hbERlZlRyYW5zZm9ybXMpLFxuICAgICAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogaG9va3MwLnZpZXdDb250YWluZXJBcHBlbmRzLmNvbmNhdChob29rczEudmlld0NvbnRhaW5lckFwcGVuZHMpLFxuICAgICAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IGhvb2tzMC5ldmVudERyb3BUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5ldmVudERyb3BUcmFuc2Zvcm1lcnMpLFxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogaG9va3MwLmNhbGVuZGFySW50ZXJhY3Rpb25zLmNvbmNhdChob29rczEuY2FsZW5kYXJJbnRlcmFjdGlvbnMpLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IGhvb2tzMC5jb21wb25lbnRJbnRlcmFjdGlvbnMuY29uY2F0KGhvb2tzMS5jb21wb25lbnRJbnRlcmFjdGlvbnMpLFxuICAgICAgICB0aGVtZUNsYXNzZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLnRoZW1lQ2xhc3NlcyksIGhvb2tzMS50aGVtZUNsYXNzZXMpLFxuICAgICAgICBldmVudFNvdXJjZURlZnM6IGhvb2tzMC5ldmVudFNvdXJjZURlZnMuY29uY2F0KGhvb2tzMS5ldmVudFNvdXJjZURlZnMpLFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IGhvb2tzMS5jbWRGb3JtYXR0ZXIgfHwgaG9va3MwLmNtZEZvcm1hdHRlcixcbiAgICAgICAgcmVjdXJyaW5nVHlwZXM6IGhvb2tzMC5yZWN1cnJpbmdUeXBlcy5jb25jYXQoaG9va3MxLnJlY3VycmluZ1R5cGVzKSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBob29rczEubmFtZWRUaW1lWm9uZWRJbXBsIHx8IGhvb2tzMC5uYW1lZFRpbWVab25lZEltcGwsXG4gICAgICAgIGluaXRpYWxWaWV3OiBob29rczAuaW5pdGlhbFZpZXcgfHwgaG9va3MxLmluaXRpYWxWaWV3LFxuICAgICAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBob29rczAuZWxlbWVudERyYWdnaW5nSW1wbCB8fCBob29rczEuZWxlbWVudERyYWdnaW5nSW1wbCxcbiAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLm9wdGlvbkNoYW5nZUhhbmRsZXJzKSwgaG9va3MxLm9wdGlvbkNoYW5nZUhhbmRsZXJzKSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IGhvb2tzMS5zY3JvbGxHcmlkSW1wbCB8fCBob29rczAuc2Nyb2xsR3JpZEltcGwsXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLmxpc3RlbmVyUmVmaW5lcnMpLCBob29rczEubGlzdGVuZXJSZWZpbmVycyksXG4gICAgICAgIG9wdGlvblJlZmluZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5vcHRpb25SZWZpbmVycyksIGhvb2tzMS5vcHRpb25SZWZpbmVycyksXG4gICAgICAgIHByb3BTZXRIYW5kbGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAucHJvcFNldEhhbmRsZXJzKSwgaG9va3MxLnByb3BTZXRIYW5kbGVycyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVPcHRpb25hbERhdGVzKGRhdGUwLCBkYXRlMSkge1xuICAgIGlmIChkYXRlMCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBkYXRlMTtcbiAgICB9XG4gICAgaWYgKGRhdGUxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUwO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoTWF0aC5tYXgoZGF0ZTAudmFsdWVPZigpLCBkYXRlMS52YWx1ZU9mKCkpKTtcbn1cblxuY2xhc3MgU3RhbmRhcmRUaGVtZSBleHRlbmRzIFRoZW1lIHtcbn1cblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XG4gICAgcm9vdDogJ2ZjLXRoZW1lLXN0YW5kYXJkJyxcbiAgICB0YWJsZUNlbGxTaGFkZWQ6ICdmYy1jZWxsLXNoYWRlZCcsXG4gICAgYnV0dG9uR3JvdXA6ICdmYy1idXR0b24tZ3JvdXAnLFxuICAgIGJ1dHRvbjogJ2ZjLWJ1dHRvbiBmYy1idXR0b24tcHJpbWFyeScsXG4gICAgYnV0dG9uQWN0aXZlOiAnZmMtYnV0dG9uLWFjdGl2ZScsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYy1pY29uJztcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xuICAgIGNsb3NlOiAnZmMtaWNvbi14JyxcbiAgICBwcmV2OiAnZmMtaWNvbi1jaGV2cm9uLWxlZnQnLFxuICAgIG5leHQ6ICdmYy1pY29uLWNoZXZyb24tcmlnaHQnLFxuICAgIHByZXZZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0JyxcbiAgICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxufTtcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLnJ0bEljb25DbGFzc2VzID0ge1xuICAgIHByZXY6ICdmYy1pY29uLWNoZXZyb24tcmlnaHQnLFxuICAgIG5leHQ6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLXJpZ2h0JyxcbiAgICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtbGVmdCcsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlT3B0aW9uID0gJ2J1dHRvbkljb25zJzsgLy8gVE9ETzogbWFrZSBUUy1mcmllbmRseVxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ2ljb24nO1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZjLWljb24tJztcblxuZnVuY3Rpb24gY29tcGlsZVZpZXdEZWZzKGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICBsZXQgaGFzaCA9IHt9O1xuICAgIGxldCB2aWV3VHlwZTtcbiAgICBmb3IgKHZpZXdUeXBlIGluIGRlZmF1bHRDb25maWdzKSB7XG4gICAgICAgIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICBmb3IgKHZpZXdUeXBlIGluIG92ZXJyaWRlQ29uZmlncykge1xuICAgICAgICBlbnN1cmVWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2g7XG59XG5mdW5jdGlvbiBlbnN1cmVWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgaWYgKGhhc2hbdmlld1R5cGVdKSB7XG4gICAgICAgIHJldHVybiBoYXNoW3ZpZXdUeXBlXTtcbiAgICB9XG4gICAgbGV0IHZpZXdEZWYgPSBidWlsZFZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIGlmICh2aWV3RGVmKSB7XG4gICAgICAgIGhhc2hbdmlld1R5cGVdID0gdmlld0RlZjtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdEZWY7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICBsZXQgZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWdzW3ZpZXdUeXBlXTtcbiAgICBsZXQgb3ZlcnJpZGVDb25maWcgPSBvdmVycmlkZUNvbmZpZ3Nbdmlld1R5cGVdO1xuICAgIGxldCBxdWVyeVByb3AgPSAobmFtZSkgPT4gKChkZWZhdWx0Q29uZmlnICYmIGRlZmF1bHRDb25maWdbbmFtZV0gIT09IG51bGwpID8gZGVmYXVsdENvbmZpZ1tuYW1lXSA6XG4gICAgICAgICgob3ZlcnJpZGVDb25maWcgJiYgb3ZlcnJpZGVDb25maWdbbmFtZV0gIT09IG51bGwpID8gb3ZlcnJpZGVDb25maWdbbmFtZV0gOiBudWxsKSk7XG4gICAgbGV0IHRoZUNvbXBvbmVudCA9IHF1ZXJ5UHJvcCgnY29tcG9uZW50Jyk7XG4gICAgbGV0IHN1cGVyVHlwZSA9IHF1ZXJ5UHJvcCgnc3VwZXJUeXBlJyk7XG4gICAgbGV0IHN1cGVyRGVmID0gbnVsbDtcbiAgICBpZiAoc3VwZXJUeXBlKSB7XG4gICAgICAgIGlmIChzdXBlclR5cGUgPT09IHZpZXdUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgaGF2ZSBhIGN1c3RvbSB2aWV3IHR5cGUgdGhhdCByZWZlcmVuY2VzIGl0c2VsZicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyRGVmID0gZW5zdXJlVmlld0RlZihzdXBlclR5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICBpZiAoIXRoZUNvbXBvbmVudCAmJiBzdXBlckRlZikge1xuICAgICAgICB0aGVDb21wb25lbnQgPSBzdXBlckRlZi5jb21wb25lbnQ7XG4gICAgfVxuICAgIGlmICghdGhlQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBkb24ndCB0aHJvdyBhIHdhcm5pbmcsIG1pZ2h0IGJlIHNldHRpbmdzIGZvciBhIHNpbmdsZS11bml0IHZpZXdcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdmlld1R5cGUsXG4gICAgICAgIGNvbXBvbmVudDogdGhlQ29tcG9uZW50LFxuICAgICAgICBkZWZhdWx0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoc3VwZXJEZWYgPyBzdXBlckRlZi5kZWZhdWx0cyA6IHt9KSksIChkZWZhdWx0Q29uZmlnID8gZGVmYXVsdENvbmZpZy5yYXdPcHRpb25zIDoge30pKSxcbiAgICAgICAgb3ZlcnJpZGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChzdXBlckRlZiA/IHN1cGVyRGVmLm92ZXJyaWRlcyA6IHt9KSksIChvdmVycmlkZUNvbmZpZyA/IG92ZXJyaWRlQ29uZmlnLnJhd09wdGlvbnMgOiB7fSkpLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVmlld0NvbmZpZ3MoaW5wdXRzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goaW5wdXRzLCBwYXJzZVZpZXdDb25maWcpO1xufVxuZnVuY3Rpb24gcGFyc2VWaWV3Q29uZmlnKGlucHV0KSB7XG4gICAgbGV0IHJhd09wdGlvbnMgPSB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICB7IGNvbXBvbmVudDogaW5wdXQgfSA6XG4gICAgICAgIGlucHV0O1xuICAgIGxldCB7IGNvbXBvbmVudCB9ID0gcmF3T3B0aW9ucztcbiAgICBpZiAocmF3T3B0aW9ucy5jb250ZW50KSB7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBjb250ZW50L2NsYXNzTmFtZXMvZGlkTW91bnQvZXRjIGZyb20gb3B0aW9ucz9cbiAgICAgICAgY29tcG9uZW50ID0gY3JlYXRlVmlld0hvb2tDb21wb25lbnQocmF3T3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbXBvbmVudCAmJiAhKGNvbXBvbmVudC5wcm90b3R5cGUgaW5zdGFuY2VvZiBCYXNlQ29tcG9uZW50KSkge1xuICAgICAgICAvLyBXSFk/OiBwZW9wbGUgd2VyZSB1c2luZyBgY29tcG9uZW50YCBwcm9wZXJ0eSBmb3IgYGNvbnRlbnRgXG4gICAgICAgIC8vIFRPRE86IGNvbnZlcmdlIG9uIG9uZSBzZXR0aW5nIG5hbWVcbiAgICAgICAgY29tcG9uZW50ID0gY3JlYXRlVmlld0hvb2tDb21wb25lbnQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByYXdPcHRpb25zKSwgeyBjb250ZW50OiBjb21wb25lbnQgfSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdXBlclR5cGU6IHJhd09wdGlvbnMudHlwZSxcbiAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgIHJhd09wdGlvbnMsIC8vIGluY2x1ZGVzIHR5cGUgYW5kIGNvbXBvbmVudCB0b28gOihcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVmlld0hvb2tDb21wb25lbnQob3B0aW9ucykge1xuICAgIHJldHVybiAodmlld1Byb3BzKSA9PiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IGJ1aWxkVmlld0NsYXNzTmFtZXMoY29udGV4dC52aWV3U3BlYyksIHJlbmRlclByb3BzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZXdQcm9wcyksIHsgbmV4dERheVRocmVzaG9sZDogY29udGV4dC5vcHRpb25zLm5leHREYXlUaHJlc2hvbGQgfSksIGdlbmVyYXRvck5hbWU6IHVuZGVmaW5lZCwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5jbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMud2lsbFVubW91bnQgfSkpKSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVmlld1NwZWNzKGRlZmF1bHRJbnB1dHMsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpIHtcbiAgICBsZXQgZGVmYXVsdENvbmZpZ3MgPSBwYXJzZVZpZXdDb25maWdzKGRlZmF1bHRJbnB1dHMpO1xuICAgIGxldCBvdmVycmlkZUNvbmZpZ3MgPSBwYXJzZVZpZXdDb25maWdzKG9wdGlvbk92ZXJyaWRlcy52aWV3cyk7XG4gICAgbGV0IHZpZXdEZWZzID0gY29tcGlsZVZpZXdEZWZzKGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIHJldHVybiBtYXBIYXNoKHZpZXdEZWZzLCAodmlld0RlZikgPT4gYnVpbGRWaWV3U3BlYyh2aWV3RGVmLCBvdmVycmlkZUNvbmZpZ3MsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld1NwZWModmlld0RlZiwgb3ZlcnJpZGVDb25maWdzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKSB7XG4gICAgbGV0IGR1cmF0aW9uSW5wdXQgPSB2aWV3RGVmLm92ZXJyaWRlcy5kdXJhdGlvbiB8fFxuICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmR1cmF0aW9uIHx8XG4gICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMuZHVyYXRpb24gfHxcbiAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLmR1cmF0aW9uO1xuICAgIGxldCBkdXJhdGlvbiA9IG51bGw7XG4gICAgbGV0IGR1cmF0aW9uVW5pdCA9ICcnO1xuICAgIGxldCBzaW5nbGVVbml0ID0gJyc7XG4gICAgbGV0IHNpbmdsZVVuaXRPdmVycmlkZXMgPSB7fTtcbiAgICBpZiAoZHVyYXRpb25JbnB1dCkge1xuICAgICAgICBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uQ2FjaGVkKGR1cmF0aW9uSW5wdXQpO1xuICAgICAgICBpZiAoZHVyYXRpb24pIHsgLy8gdmFsaWQ/XG4gICAgICAgICAgICBsZXQgZGVub20gPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZHVyYXRpb24pO1xuICAgICAgICAgICAgZHVyYXRpb25Vbml0ID0gZGVub20udW5pdDtcbiAgICAgICAgICAgIGlmIChkZW5vbS52YWx1ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHNpbmdsZVVuaXQgPSBkdXJhdGlvblVuaXQ7XG4gICAgICAgICAgICAgICAgc2luZ2xlVW5pdE92ZXJyaWRlcyA9IG92ZXJyaWRlQ29uZmlnc1tkdXJhdGlvblVuaXRdID8gb3ZlcnJpZGVDb25maWdzW2R1cmF0aW9uVW5pdF0ucmF3T3B0aW9ucyA6IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBxdWVyeUJ1dHRvblRleHQgPSAob3B0aW9uc1N1YnNldCkgPT4ge1xuICAgICAgICBsZXQgYnV0dG9uVGV4dE1hcCA9IG9wdGlvbnNTdWJzZXQuYnV0dG9uVGV4dCB8fCB7fTtcbiAgICAgICAgbGV0IGJ1dHRvblRleHRLZXkgPSB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHRLZXk7XG4gICAgICAgIGlmIChidXR0b25UZXh0S2V5ICE9IG51bGwgJiYgYnV0dG9uVGV4dE1hcFtidXR0b25UZXh0S2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFtidXR0b25UZXh0S2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW3ZpZXdEZWYudHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvblRleHRNYXBbc2luZ2xlVW5pdF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbc2luZ2xlVW5pdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBsZXQgcXVlcnlCdXR0b25UaXRsZSA9IChvcHRpb25zU3Vic2V0KSA9PiB7XG4gICAgICAgIGxldCBidXR0b25IaW50cyA9IG9wdGlvbnNTdWJzZXQuYnV0dG9uSGludHMgfHwge307XG4gICAgICAgIGxldCBidXR0b25LZXkgPSB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHRLZXk7IC8vIHVzZSBzYW1lIGtleSBhcyB0ZXh0XG4gICAgICAgIGlmIChidXR0b25LZXkgIT0gbnVsbCAmJiBidXR0b25IaW50c1tidXR0b25LZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25IaW50c1tidXR0b25LZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25IaW50c1t2aWV3RGVmLnR5cGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25IaW50c1t2aWV3RGVmLnR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25IaW50c1tzaW5nbGVVbml0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uSGludHNbc2luZ2xlVW5pdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB2aWV3RGVmLnR5cGUsXG4gICAgICAgIGNvbXBvbmVudDogdmlld0RlZi5jb21wb25lbnQsXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBkdXJhdGlvblVuaXQsXG4gICAgICAgIHNpbmdsZVVuaXQsXG4gICAgICAgIG9wdGlvbkRlZmF1bHRzOiB2aWV3RGVmLmRlZmF1bHRzLFxuICAgICAgICBvcHRpb25PdmVycmlkZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2luZ2xlVW5pdE92ZXJyaWRlcyksIHZpZXdEZWYub3ZlcnJpZGVzKSxcbiAgICAgICAgYnV0dG9uVGV4dE92ZXJyaWRlOiBxdWVyeUJ1dHRvblRleHQoZHluYW1pY09wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25PdmVycmlkZXMpIHx8IC8vIGNvbnN0cnVjdG9yLXNwZWNpZmllZCBidXR0b25UZXh0IGxvb2t1cCBoYXNoIHRha2VzIHByZWNlZGVuY2VcbiAgICAgICAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvblRleHQsXG4gICAgICAgIGJ1dHRvblRleHREZWZhdWx0OiBxdWVyeUJ1dHRvblRleHQobG9jYWxlRGVmYXVsdHMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHQgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChCQVNFX09QVElPTl9ERUZBVUxUUykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYudHlwZSxcbiAgICAgICAgLy8gbm90IERSWVxuICAgICAgICBidXR0b25UaXRsZU92ZXJyaWRlOiBxdWVyeUJ1dHRvblRpdGxlKGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRpdGxlKG9wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvbkhpbnQsXG4gICAgICAgIGJ1dHRvblRpdGxlRGVmYXVsdDogcXVlcnlCdXR0b25UaXRsZShsb2NhbGVEZWZhdWx0cykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uSGludCB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UaXRsZShCQVNFX09QVElPTl9ERUZBVUxUUyksXG4gICAgICAgIC8vIHdpbGwgZXZlbnR1YWxseSBmYWxsIGJhY2sgdG8gYnV0dG9uVGV4dFxuICAgIH07XG59XG4vLyBoYWNrIHRvIGdldCBtZW1vaXphdGlvbiB3b3JraW5nXG5sZXQgZHVyYXRpb25JbnB1dE1hcCA9IHt9O1xuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dCkge1xuICAgIGxldCBqc29uID0gSlNPTi5zdHJpbmdpZnkoZHVyYXRpb25JbnB1dCk7XG4gICAgbGV0IHJlcyA9IGR1cmF0aW9uSW5wdXRNYXBbanNvbl07XG4gICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcyA9IGNyZWF0ZUR1cmF0aW9uKGR1cmF0aW9uSW5wdXQpO1xuICAgICAgICBkdXJhdGlvbklucHV0TWFwW2pzb25dID0gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VWaWV3VHlwZSh2aWV3VHlwZSwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgICAgICAgIHZpZXdUeXBlID0gYWN0aW9uLnZpZXdUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gdmlld1R5cGU7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMoZHluYW1pY09wdGlvbk92ZXJyaWRlcywgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdTRVRfT1BUSU9OJzpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpLCB7IFthY3Rpb24ub3B0aW9uTmFtZV06IGFjdGlvbi5yYXdPcHRpb25WYWx1ZSB9KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlRGF0ZVByb2ZpbGUoY3VycmVudERhdGVQcm9maWxlLCBhY3Rpb24sIGN1cnJlbnREYXRlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xuICAgIGxldCBkcDtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyIHx8IGN1cnJlbnREYXRlKTtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyKTtcbiAgICAgICAgY2FzZSAnUFJFVic6XG4gICAgICAgICAgICBkcCA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkUHJldihjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKTtcbiAgICAgICAgICAgIGlmIChkcC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ05FWFQnOlxuICAgICAgICAgICAgZHAgPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSk7XG4gICAgICAgICAgICBpZiAoZHAuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudERhdGVQcm9maWxlO1xufVxuXG5mdW5jdGlvbiBpbml0RXZlbnRTb3VyY2VzKGNhbGVuZGFyT3B0aW9ucywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBsZXQgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDtcbiAgICByZXR1cm4gYWRkU291cmNlcyh7fSwgcGFyc2VJbml0aWFsU291cmNlcyhjYWxlbmRhck9wdGlvbnMsIGNvbnRleHQpLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiByZWR1Y2VFdmVudFNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3Rpb24sIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgbGV0IGFjdGl2ZVJhbmdlID0gZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGw7IC8vIG5lZWQgdGhpcyBjaGVjaz9cbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0FERF9FVkVOVF9TT1VSQ0VTJzogLy8gYWxyZWFkeSBwYXJzZWRcbiAgICAgICAgICAgIHJldHVybiBhZGRTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aW9uLnNvdXJjZXMsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0VWRU5UX1NPVVJDRSc6XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlU291cmNlKGV2ZW50U291cmNlcywgYWN0aW9uLnNvdXJjZUlkKTtcbiAgICAgICAgY2FzZSAnUFJFVic6IC8vIFRPRE86IGhvdyBkbyB3ZSB0cmFjayBhbGwgYWN0aW9ucyB0aGF0IGFmZmVjdCBkYXRlUHJvZmlsZSA6KFxuICAgICAgICBjYXNlICdORVhUJzpcbiAgICAgICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgICAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgICAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaERpcnR5U291cmNlcyhldmVudFNvdXJjZXMsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZXM7XG4gICAgICAgIGNhc2UgJ0ZFVENIX0VWRU5UX1NPVVJDRVMnOlxuICAgICAgICAgICAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKGV2ZW50U291cmNlcywgYWN0aW9uLnNvdXJjZUlkcyA/IC8vIHdoeSBubyB0eXBlP1xuICAgICAgICAgICAgICAgIGFycmF5VG9IYXNoKGFjdGlvbi5zb3VyY2VJZHMpIDpcbiAgICAgICAgICAgICAgICBleGNsdWRlU3RhdGljU291cmNlcyhldmVudFNvdXJjZXMsIGNvbnRleHQpLCBhY3RpdmVSYW5nZSwgYWN0aW9uLmlzUmVmZXRjaCB8fCBmYWxzZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRTJzpcbiAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVF9FUlJPUic6XG4gICAgICAgICAgICByZXR1cm4gcmVjZWl2ZVJlc3BvbnNlKGV2ZW50U291cmNlcywgYWN0aW9uLnNvdXJjZUlkLCBhY3Rpb24uZmV0Y2hJZCwgYWN0aW9uLmZldGNoUmFuZ2UpO1xuICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UX1NPVVJDRVMnOlxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlcztcbiAgICB9XG59XG5mdW5jdGlvbiByZWR1Y2VFdmVudFNvdXJjZXNOZXdUaW1lWm9uZShldmVudFNvdXJjZXMsIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgbGV0IGFjdGl2ZVJhbmdlID0gZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGw7IC8vIG5lZWQgdGhpcyBjaGVjaz9cbiAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoZXZlbnRTb3VyY2VzLCBleGNsdWRlU3RhdGljU291cmNlcyhldmVudFNvdXJjZXMsIGNvbnRleHQpLCBhY3RpdmVSYW5nZSwgdHJ1ZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhldmVudFNvdXJjZXMpIHtcbiAgICBmb3IgKGxldCBzb3VyY2VJZCBpbiBldmVudFNvdXJjZXMpIHtcbiAgICAgICAgaWYgKGV2ZW50U291cmNlc1tzb3VyY2VJZF0uaXNGZXRjaGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYWRkU291cmNlcyhldmVudFNvdXJjZUhhc2gsIHNvdXJjZXMsIGZldGNoUmFuZ2UsIGNvbnRleHQpIHtcbiAgICBsZXQgaGFzaCA9IHt9O1xuICAgIGZvciAobGV0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgIGhhc2hbc291cmNlLnNvdXJjZUlkXSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICAgICAgaGFzaCA9IGZldGNoRGlydHlTb3VyY2VzKGhhc2gsIGZldGNoUmFuZ2UsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFNvdXJjZUhhc2gpLCBoYXNoKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVNvdXJjZShldmVudFNvdXJjZUhhc2gsIHNvdXJjZUlkKSB7XG4gICAgcmV0dXJuIGZpbHRlckhhc2goZXZlbnRTb3VyY2VIYXNoLCAoZXZlbnRTb3VyY2UpID0+IGV2ZW50U291cmNlLnNvdXJjZUlkICE9PSBzb3VyY2VJZCk7XG59XG5mdW5jdGlvbiBmZXRjaERpcnR5U291cmNlcyhzb3VyY2VIYXNoLCBmZXRjaFJhbmdlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKHNvdXJjZUhhc2gsIGZpbHRlckhhc2goc291cmNlSGFzaCwgKGV2ZW50U291cmNlKSA9PiBpc1NvdXJjZURpcnR5KGV2ZW50U291cmNlLCBmZXRjaFJhbmdlLCBjb250ZXh0KSksIGZldGNoUmFuZ2UsIGZhbHNlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzU291cmNlRGlydHkoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGNvbnRleHQpIHtcbiAgICBpZiAoIWRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNvbnRleHQpKSB7XG4gICAgICAgIHJldHVybiAhZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZDtcbiAgICB9XG4gICAgcmV0dXJuICFjb250ZXh0Lm9wdGlvbnMubGF6eUZldGNoaW5nIHx8XG4gICAgICAgICFldmVudFNvdXJjZS5mZXRjaFJhbmdlIHx8XG4gICAgICAgIGV2ZW50U291cmNlLmlzRmV0Y2hpbmcgfHwgLy8gYWx3YXlzIGNhbmNlbCBvdXRkYXRlZCBpbi1wcm9ncmVzcyBmZXRjaGVzXG4gICAgICAgIGZldGNoUmFuZ2Uuc3RhcnQgPCBldmVudFNvdXJjZS5mZXRjaFJhbmdlLnN0YXJ0IHx8XG4gICAgICAgIGZldGNoUmFuZ2UuZW5kID4gZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZS5lbmQ7XG59XG5mdW5jdGlvbiBmZXRjaFNvdXJjZXNCeUlkcyhwcmV2U291cmNlcywgc291cmNlSWRIYXNoLCBmZXRjaFJhbmdlLCBpc1JlZmV0Y2gsIGNvbnRleHQpIHtcbiAgICBsZXQgbmV4dFNvdXJjZXMgPSB7fTtcbiAgICBmb3IgKGxldCBzb3VyY2VJZCBpbiBwcmV2U291cmNlcykge1xuICAgICAgICBsZXQgc291cmNlID0gcHJldlNvdXJjZXNbc291cmNlSWRdO1xuICAgICAgICBpZiAoc291cmNlSWRIYXNoW3NvdXJjZUlkXSkge1xuICAgICAgICAgICAgbmV4dFNvdXJjZXNbc291cmNlSWRdID0gZmV0Y2hTb3VyY2Uoc291cmNlLCBmZXRjaFJhbmdlLCBpc1JlZmV0Y2gsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV4dFNvdXJjZXNbc291cmNlSWRdID0gc291cmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0U291cmNlcztcbn1cbmZ1bmN0aW9uIGZldGNoU291cmNlKGV2ZW50U291cmNlLCBmZXRjaFJhbmdlLCBpc1JlZmV0Y2gsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBvcHRpb25zLCBjYWxlbmRhckFwaSB9ID0gY29udGV4dDtcbiAgICBsZXQgc291cmNlRGVmID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdO1xuICAgIGxldCBmZXRjaElkID0gZ3VpZCgpO1xuICAgIHNvdXJjZURlZi5mZXRjaCh7XG4gICAgICAgIGV2ZW50U291cmNlLFxuICAgICAgICByYW5nZTogZmV0Y2hSYW5nZSxcbiAgICAgICAgaXNSZWZldGNoLFxuICAgICAgICBjb250ZXh0LFxuICAgIH0sIChyZXMpID0+IHtcbiAgICAgICAgbGV0IHsgcmF3RXZlbnRzIH0gPSByZXM7XG4gICAgICAgIGlmIChvcHRpb25zLmV2ZW50U291cmNlU3VjY2Vzcykge1xuICAgICAgICAgICAgcmF3RXZlbnRzID0gb3B0aW9ucy5ldmVudFNvdXJjZVN1Y2Nlc3MuY2FsbChjYWxlbmRhckFwaSwgcmF3RXZlbnRzLCByZXMucmVzcG9uc2UpIHx8IHJhd0V2ZW50cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRTb3VyY2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmF3RXZlbnRzID0gZXZlbnRTb3VyY2Uuc3VjY2Vzcy5jYWxsKGNhbGVuZGFyQXBpLCByYXdFdmVudHMsIHJlcy5yZXNwb25zZSkgfHwgcmF3RXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFQ0VJVkVfRVZFTlRTJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiBldmVudFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgICAgIGZldGNoSWQsXG4gICAgICAgICAgICBmZXRjaFJhbmdlLFxuICAgICAgICAgICAgcmF3RXZlbnRzLFxuICAgICAgICB9KTtcbiAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgbGV0IGVycm9ySGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0aW9ucy5ldmVudFNvdXJjZUZhaWx1cmUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZXZlbnRTb3VyY2VGYWlsdXJlLmNhbGwoY2FsZW5kYXJBcGksIGVycm9yKTtcbiAgICAgICAgICAgIGVycm9ySGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50U291cmNlLmZhaWx1cmUpIHtcbiAgICAgICAgICAgIGV2ZW50U291cmNlLmZhaWx1cmUoZXJyb3IpO1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVycm9ySGFuZGxlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRUNFSVZFX0VWRU5UX0VSUk9SJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiBldmVudFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgICAgIGZldGNoSWQsXG4gICAgICAgICAgICBmZXRjaFJhbmdlLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50U291cmNlKSwgeyBpc0ZldGNoaW5nOiB0cnVlLCBsYXRlc3RGZXRjaElkOiBmZXRjaElkIH0pO1xufVxuZnVuY3Rpb24gcmVjZWl2ZVJlc3BvbnNlKHNvdXJjZUhhc2gsIHNvdXJjZUlkLCBmZXRjaElkLCBmZXRjaFJhbmdlKSB7XG4gICAgbGV0IGV2ZW50U291cmNlID0gc291cmNlSGFzaFtzb3VyY2VJZF07XG4gICAgaWYgKGV2ZW50U291cmNlICYmIC8vIG5vdCBhbHJlYWR5IHJlbW92ZWRcbiAgICAgICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzb3VyY2VIYXNoKSwgeyBbc291cmNlSWRdOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50U291cmNlKSwgeyBpc0ZldGNoaW5nOiBmYWxzZSwgZmV0Y2hSYW5nZSB9KSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZUhhc2g7XG59XG5mdW5jdGlvbiBleGNsdWRlU3RhdGljU291cmNlcyhldmVudFNvdXJjZXMsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmlsdGVySGFzaChldmVudFNvdXJjZXMsIChldmVudFNvdXJjZSkgPT4gZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkpO1xufVxuZnVuY3Rpb24gcGFyc2VJbml0aWFsU291cmNlcyhyYXdPcHRpb25zLCBjb250ZXh0KSB7XG4gICAgbGV0IHJlZmluZXJzID0gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpO1xuICAgIGxldCByYXdTb3VyY2VzID0gW10uY29uY2F0KHJhd09wdGlvbnMuZXZlbnRTb3VyY2VzIHx8IFtdKTtcbiAgICBsZXQgc291cmNlcyA9IFtdOyAvLyBwYXJzZWRcbiAgICBpZiAocmF3T3B0aW9ucy5pbml0aWFsRXZlbnRzKSB7XG4gICAgICAgIHJhd1NvdXJjZXMudW5zaGlmdChyYXdPcHRpb25zLmluaXRpYWxFdmVudHMpO1xuICAgIH1cbiAgICBpZiAocmF3T3B0aW9ucy5ldmVudHMpIHtcbiAgICAgICAgcmF3U291cmNlcy51bnNoaWZ0KHJhd09wdGlvbnMuZXZlbnRzKTtcbiAgICB9XG4gICAgZm9yIChsZXQgcmF3U291cmNlIG9mIHJhd1NvdXJjZXMpIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHBhcnNlRXZlbnRTb3VyY2UocmF3U291cmNlLCBjb250ZXh0LCByZWZpbmVycyk7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xufVxuZnVuY3Rpb24gZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIGxldCBkZWZzID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnM7XG4gICAgcmV0dXJuICFkZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXS5pZ25vcmVSYW5nZTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRGF0ZVNlbGVjdGlvbihjdXJyZW50U2VsZWN0aW9uLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VMRUNUX0RBVEVTJzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdTRUxFQ1RfREFURVMnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5zZWxlY3Rpb247XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVNlbGVjdGVkRXZlbnQoY3VycmVudEluc3RhbmNlSWQsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRUxFQ1RfRVZFTlQnOlxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjYXNlICdTRUxFQ1RfRVZFTlQnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5ldmVudEluc3RhbmNlSWQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEluc3RhbmNlSWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudERyYWcoY3VycmVudERyYWcsIGFjdGlvbikge1xuICAgIGxldCBuZXdEcmFnO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRVRfRVZFTlRfRFJBRyc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgICAgICAgbmV3RHJhZyA9IGFjdGlvbi5zdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IG5ld0RyYWcuYWZmZWN0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3RHJhZy5tdXRhdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IG5ld0RyYWcuaXNFdmVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERyYWc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudFJlc2l6ZShjdXJyZW50UmVzaXplLCBhY3Rpb24pIHtcbiAgICBsZXQgbmV3UmVzaXplO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdTRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgICAgIG5ld1Jlc2l6ZSA9IGFjdGlvbi5zdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IG5ld1Jlc2l6ZS5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdSZXNpemUubXV0YXRlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiBuZXdSZXNpemUuaXNFdmVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFJlc2l6ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9vbGJhcnMoY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICBsZXQgaGVhZGVyID0gY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIgPyBwYXJzZVRvb2xiYXIoY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSA6IG51bGw7XG4gICAgbGV0IGZvb3RlciA9IGNhbGVuZGFyT3B0aW9ucy5mb290ZXJUb29sYmFyID8gcGFyc2VUb29sYmFyKGNhbGVuZGFyT3B0aW9ucy5mb290ZXJUb29sYmFyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkgOiBudWxsO1xuICAgIHJldHVybiB7IGhlYWRlciwgZm9vdGVyIH07XG59XG5mdW5jdGlvbiBwYXJzZVRvb2xiYXIoc2VjdGlvblN0ckhhc2gsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSB7XG4gICAgbGV0IHNlY3Rpb25XaWRnZXRzID0ge307XG4gICAgbGV0IHZpZXdzV2l0aEJ1dHRvbnMgPSBbXTtcbiAgICBsZXQgaGFzVGl0bGUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBzZWN0aW9uTmFtZSBpbiBzZWN0aW9uU3RySGFzaCkge1xuICAgICAgICBsZXQgc2VjdGlvblN0ciA9IHNlY3Rpb25TdHJIYXNoW3NlY3Rpb25OYW1lXTtcbiAgICAgICAgbGV0IHNlY3Rpb25SZXMgPSBwYXJzZVNlY3Rpb24oc2VjdGlvblN0ciwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpO1xuICAgICAgICBzZWN0aW9uV2lkZ2V0c1tzZWN0aW9uTmFtZV0gPSBzZWN0aW9uUmVzLndpZGdldHM7XG4gICAgICAgIHZpZXdzV2l0aEJ1dHRvbnMucHVzaCguLi5zZWN0aW9uUmVzLnZpZXdzV2l0aEJ1dHRvbnMpO1xuICAgICAgICBoYXNUaXRsZSA9IGhhc1RpdGxlIHx8IHNlY3Rpb25SZXMuaGFzVGl0bGU7XG4gICAgfVxuICAgIHJldHVybiB7IHNlY3Rpb25XaWRnZXRzLCB2aWV3c1dpdGhCdXR0b25zLCBoYXNUaXRsZSB9O1xufVxuLypcbkJBRDogcXVlcnlpbmcgaWNvbnMgYW5kIHRleHQgaGVyZS4gc2hvdWxkIGJlIGRvbmUgYXQgcmVuZGVyIHRpbWVcbiovXG5mdW5jdGlvbiBwYXJzZVNlY3Rpb24oc2VjdGlvblN0ciwgY2FsZW5kYXJPcHRpb25zLCAvLyBkZWZhdWx0cytvdmVycmlkZXMsIHRoZW4gcmVmaW5lZFxuY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIC8vIG92ZXJyaWRlcyBvbmx5ISwgdW5yZWZpbmVkIDooXG50aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xuICAgIGxldCBpc1J0bCA9IGNhbGVuZGFyT3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnO1xuICAgIGxldCBjYWxlbmRhckN1c3RvbUJ1dHRvbnMgPSBjYWxlbmRhck9wdGlvbnMuY3VzdG9tQnV0dG9ucyB8fCB7fTtcbiAgICBsZXQgY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzID0gY2FsZW5kYXJPcHRpb25PdmVycmlkZXMuYnV0dG9uVGV4dCB8fCB7fTtcbiAgICBsZXQgY2FsZW5kYXJCdXR0b25UZXh0ID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvblRleHQgfHwge307XG4gICAgbGV0IGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlcyA9IGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgIGxldCBjYWxlbmRhckJ1dHRvbkhpbnRzID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgIGxldCBzZWN0aW9uU3Vic3RycyA9IHNlY3Rpb25TdHIgPyBzZWN0aW9uU3RyLnNwbGl0KCcgJykgOiBbXTtcbiAgICBsZXQgdmlld3NXaXRoQnV0dG9ucyA9IFtdO1xuICAgIGxldCBoYXNUaXRsZSA9IGZhbHNlO1xuICAgIGxldCB3aWRnZXRzID0gc2VjdGlvblN1YnN0cnMubWFwKChidXR0b25Hcm91cFN0cikgPT4gKGJ1dHRvbkdyb3VwU3RyLnNwbGl0KCcsJykubWFwKChidXR0b25OYW1lKSA9PiB7XG4gICAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XG4gICAgICAgICAgICBoYXNUaXRsZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4geyBidXR0b25OYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1c3RvbUJ1dHRvblByb3BzO1xuICAgICAgICBsZXQgdmlld1NwZWM7XG4gICAgICAgIGxldCBidXR0b25DbGljaztcbiAgICAgICAgbGV0IGJ1dHRvbkljb247IC8vIG9ubHkgb25lIG9mIHRoZXNlIHdpbGwgYmUgc2V0XG4gICAgICAgIGxldCBidXR0b25UZXh0OyAvLyBcIlxuICAgICAgICBsZXQgYnV0dG9uSGludDtcbiAgICAgICAgLy8gXiBmb3IgdGhlIHRpdGxlPVwiXCIgYXR0cmlidXRlLCBmb3IgYWNjZXNzaWJpbGl0eVxuICAgICAgICBpZiAoKGN1c3RvbUJ1dHRvblByb3BzID0gY2FsZW5kYXJDdXN0b21CdXR0b25zW2J1dHRvbk5hbWVdKSkge1xuICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSAoZXYpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2suY2FsbChldi50YXJnZXQsIGV2LCBldi50YXJnZXQpOyAvLyBUT0RPOiB1c2UgQ2FsZW5kYXIgdGhpcyBjb250ZXh0P1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY3VzdG9tQnV0dG9uUHJvcHMudGV4dCk7XG4gICAgICAgICAgICBidXR0b25IaW50ID0gY3VzdG9tQnV0dG9uUHJvcHMuaGludCB8fCBjdXN0b21CdXR0b25Qcm9wcy50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh2aWV3U3BlYyA9IHZpZXdTcGVjc1tidXR0b25OYW1lXSkpIHtcbiAgICAgICAgICAgIHZpZXdzV2l0aEJ1dHRvbnMucHVzaChidXR0b25OYW1lKTtcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpLmNoYW5nZVZpZXcoYnV0dG9uTmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQpO1xuICAgICAgICAgICAgbGV0IHRleHRGYWxsYmFjayA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZSB8fFxuICAgICAgICAgICAgICAgIHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0O1xuICAgICAgICAgICAgYnV0dG9uSGludCA9IGZvcm1hdFdpdGhPcmRpbmFscyh2aWV3U3BlYy5idXR0b25UaXRsZU92ZXJyaWRlIHx8XG4gICAgICAgICAgICAgICAgdmlld1NwZWMuYnV0dG9uVGl0bGVEZWZhdWx0IHx8XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJPcHRpb25zLnZpZXdIaW50LCBbdGV4dEZhbGxiYWNrLCBidXR0b25OYW1lXSwgLy8gdmlldy1uYW1lID0gYnV0dG9uTmFtZVxuICAgICAgICAgICAgdGV4dEZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYWxlbmRhckFwaVtidXR0b25OYW1lXSkgeyAvLyBhIGNhbGVuZGFyQXBpIG1ldGhvZFxuICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGlbYnV0dG9uTmFtZV0oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlc1tidXR0b25OYW1lXSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pOyAvLyBldmVyeXRoaW5nIGVsc2UgaXMgY29uc2lkZXJlZCBkZWZhdWx0XG4gICAgICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3ByZXZZZWFyJyB8fCBidXR0b25OYW1lID09PSAnbmV4dFllYXInKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZPck5leHQgPSBidXR0b25OYW1lID09PSAncHJldlllYXInID8gJ3ByZXYnIDogJ25leHQnO1xuICAgICAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmb3JtYXRXaXRoT3JkaW5hbHMoY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzW3ByZXZPck5leHRdIHx8XG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uSGludHNbcHJldk9yTmV4dF0sIFtcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25UZXh0LnllYXIgfHwgJ3llYXInLFxuICAgICAgICAgICAgICAgICAgICAneWVhcicsXG4gICAgICAgICAgICAgICAgXSwgY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSAobmF2VW5pdCkgPT4gZm9ybWF0V2l0aE9yZGluYWxzKGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlc1tidXR0b25OYW1lXSB8fFxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvbkhpbnRzW2J1dHRvbk5hbWVdLCBbXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uVGV4dFtuYXZVbml0XSB8fCBuYXZVbml0LFxuICAgICAgICAgICAgICAgICAgICBuYXZVbml0LFxuICAgICAgICAgICAgICAgIF0sIGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2ssIGJ1dHRvbkljb24sIGJ1dHRvblRleHQsIGJ1dHRvbkhpbnQgfTtcbiAgICB9KSkpO1xuICAgIHJldHVybiB7IHdpZGdldHMsIHZpZXdzV2l0aEJ1dHRvbnMsIGhhc1RpdGxlIH07XG59XG5cbi8vIGFsd2F5cyByZXByZXNlbnRzIHRoZSBjdXJyZW50IHZpZXcuIG90aGVyd2lzZSwgaXQnZCBuZWVkIHRvIGNoYW5nZSB2YWx1ZSBldmVyeSB0aW1lIGRhdGUgY2hhbmdlc1xuY2xhc3MgVmlld0ltcGwge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGdldEN1cnJlbnREYXRhLCBkYXRlRW52KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudERhdGEgPSBnZXRDdXJyZW50RGF0YTtcbiAgICAgICAgdGhpcy5kYXRlRW52ID0gZGF0ZUVudjtcbiAgICB9XG4gICAgZ2V0IGNhbGVuZGFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmNhbGVuZGFyQXBpO1xuICAgIH1cbiAgICBnZXQgdGl0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkudmlld1RpdGxlO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlU3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5zdGFydCk7XG4gICAgfVxuICAgIGdldCBhY3RpdmVFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5lbmQpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0KTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kKTtcbiAgICB9XG4gICAgZ2V0T3B0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS5vcHRpb25zW25hbWVdOyAvLyBhcmUgdGhlIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuICAgIH1cbn1cblxubGV0IGV2ZW50U291cmNlRGVmJDIgPSB7XG4gICAgaWdub3JlUmFuZ2U6IHRydWUsXG4gICAgcGFyc2VNZXRhKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmaW5lZC5ldmVudHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmaW5lZC5ldmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaChhcmcsIHN1Y2Nlc3NDYWxsYmFjaykge1xuICAgICAgICBzdWNjZXNzQ2FsbGJhY2soe1xuICAgICAgICAgICAgcmF3RXZlbnRzOiBhcmcuZXZlbnRTb3VyY2UubWV0YSxcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG5jb25zdCBhcnJheUV2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnYXJyYXktZXZlbnQtc291cmNlJyxcbiAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZiQyXSxcbn0pO1xuXG5sZXQgZXZlbnRTb3VyY2VEZWYkMSA9IHtcbiAgICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlZmluZWQuZXZlbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmaW5lZC5ldmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaChhcmcsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICBjb25zdCB7IGRhdGVFbnYgfSA9IGFyZy5jb250ZXh0O1xuICAgICAgICBjb25zdCBmdW5jID0gYXJnLmV2ZW50U291cmNlLm1ldGE7XG4gICAgICAgIHVucHJvbWlzaWZ5KGZ1bmMuYmluZChudWxsLCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKGFyZy5yYW5nZSwgZGF0ZUVudikpLCAocmF3RXZlbnRzKSA9PiBzdWNjZXNzQ2FsbGJhY2soeyByYXdFdmVudHMgfSksIGVycm9yQ2FsbGJhY2spO1xuICAgIH0sXG59O1xuY29uc3QgZnVuY0V2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnZnVuYy1ldmVudC1zb3VyY2UnLFxuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmJDFdLFxufSk7XG5cbmNvbnN0IEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMgPSB7XG4gICAgbWV0aG9kOiBTdHJpbmcsXG4gICAgZXh0cmFQYXJhbXM6IGlkZW50aXR5LFxuICAgIHN0YXJ0UGFyYW06IFN0cmluZyxcbiAgICBlbmRQYXJhbTogU3RyaW5nLFxuICAgIHRpbWVab25lUGFyYW06IFN0cmluZyxcbn07XG5cbmxldCBldmVudFNvdXJjZURlZiA9IHtcbiAgICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgICAgICBpZiAocmVmaW5lZC51cmwgJiYgKHJlZmluZWQuZm9ybWF0ID09PSAnanNvbicgfHwgIXJlZmluZWQuZm9ybWF0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6IHJlZmluZWQudXJsLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2pzb24nLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogKHJlZmluZWQubWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIGV4dHJhUGFyYW1zOiByZWZpbmVkLmV4dHJhUGFyYW1zLFxuICAgICAgICAgICAgICAgIHN0YXJ0UGFyYW06IHJlZmluZWQuc3RhcnRQYXJhbSxcbiAgICAgICAgICAgICAgICBlbmRQYXJhbTogcmVmaW5lZC5lbmRQYXJhbSxcbiAgICAgICAgICAgICAgICB0aW1lWm9uZVBhcmFtOiByZWZpbmVkLnRpbWVab25lUGFyYW0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZmV0Y2goYXJnLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgeyBtZXRhIH0gPSBhcmcuZXZlbnRTb3VyY2U7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSBidWlsZFJlcXVlc3RQYXJhbXMobWV0YSwgYXJnLnJhbmdlLCBhcmcuY29udGV4dCk7XG4gICAgICAgIHJlcXVlc3RKc29uKG1ldGEubWV0aG9kLCBtZXRhLnVybCwgcmVxdWVzdFBhcmFtcykudGhlbigoW3Jhd0V2ZW50cywgcmVzcG9uc2VdKSA9PiB7XG4gICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2soeyByYXdFdmVudHMsIHJlc3BvbnNlIH0pO1xuICAgICAgICB9LCBlcnJvckNhbGxiYWNrKTtcbiAgICB9LFxufTtcbmNvbnN0IGpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdqc29uLWV2ZW50LXNvdXJjZScsXG4gICAgZXZlbnRTb3VyY2VSZWZpbmVyczogSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyxcbiAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZl0sXG59KTtcbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhLCByYW5nZSwgY29udGV4dCkge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHN0YXJ0UGFyYW07XG4gICAgbGV0IGVuZFBhcmFtO1xuICAgIGxldCB0aW1lWm9uZVBhcmFtO1xuICAgIGxldCBjdXN0b21SZXF1ZXN0UGFyYW1zO1xuICAgIGxldCBwYXJhbXMgPSB7fTtcbiAgICBzdGFydFBhcmFtID0gbWV0YS5zdGFydFBhcmFtO1xuICAgIGlmIChzdGFydFBhcmFtID09IG51bGwpIHtcbiAgICAgICAgc3RhcnRQYXJhbSA9IG9wdGlvbnMuc3RhcnRQYXJhbTtcbiAgICB9XG4gICAgZW5kUGFyYW0gPSBtZXRhLmVuZFBhcmFtO1xuICAgIGlmIChlbmRQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgIGVuZFBhcmFtID0gb3B0aW9ucy5lbmRQYXJhbTtcbiAgICB9XG4gICAgdGltZVpvbmVQYXJhbSA9IG1ldGEudGltZVpvbmVQYXJhbTtcbiAgICBpZiAodGltZVpvbmVQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgIHRpbWVab25lUGFyYW0gPSBvcHRpb25zLnRpbWVab25lUGFyYW07XG4gICAgfVxuICAgIC8vIHJldHJpZXZlIGFueSBvdXRib3VuZCBHRVQvUE9TVCBkYXRhIGZyb20gdGhlIG9wdGlvbnNcbiAgICBpZiAodHlwZW9mIG1ldGEuZXh0cmFQYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gc3VwcGxpZWQgYXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBrZXkvdmFsdWUgb2JqZWN0XG4gICAgICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBtZXRhLmV4dHJhUGFyYW1zKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBwcm9iYWJseSBzdXBwbGllZCBhcyBhIHN0cmFpZ2h0IGtleS92YWx1ZSBvYmplY3RcbiAgICAgICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IG1ldGEuZXh0cmFQYXJhbXMgfHwge307XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24ocGFyYW1zLCBjdXN0b21SZXF1ZXN0UGFyYW1zKTtcbiAgICBwYXJhbXNbc3RhcnRQYXJhbV0gPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCk7XG4gICAgcGFyYW1zW2VuZFBhcmFtXSA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLmVuZCk7XG4gICAgaWYgKGRhdGVFbnYudGltZVpvbmUgIT09ICdsb2NhbCcpIHtcbiAgICAgICAgcGFyYW1zW3RpbWVab25lUGFyYW1dID0gZGF0ZUVudi50aW1lWm9uZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cblxuY29uc3QgU0lNUExFX1JFQ1VSUklOR19SRUZJTkVSUyA9IHtcbiAgICBkYXlzT2ZXZWVrOiBpZGVudGl0eSxcbiAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGVuZFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzdGFydFJlY3VyOiBpZGVudGl0eSxcbiAgICBlbmRSZWN1cjogaWRlbnRpdHksXG59O1xuXG5sZXQgcmVjdXJyaW5nID0ge1xuICAgIHBhcnNlKHJlZmluZWQsIGRhdGVFbnYpIHtcbiAgICAgICAgaWYgKHJlZmluZWQuZGF5c09mV2VlayB8fCByZWZpbmVkLnN0YXJ0VGltZSB8fCByZWZpbmVkLmVuZFRpbWUgfHwgcmVmaW5lZC5zdGFydFJlY3VyIHx8IHJlZmluZWQuZW5kUmVjdXIpIHtcbiAgICAgICAgICAgIGxldCByZWN1cnJpbmdEYXRhID0ge1xuICAgICAgICAgICAgICAgIGRheXNPZldlZWs6IHJlZmluZWQuZGF5c09mV2VlayB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogcmVmaW5lZC5zdGFydFRpbWUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBlbmRUaW1lOiByZWZpbmVkLmVuZFRpbWUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBzdGFydFJlY3VyOiByZWZpbmVkLnN0YXJ0UmVjdXIgPyBkYXRlRW52LmNyZWF0ZU1hcmtlcihyZWZpbmVkLnN0YXJ0UmVjdXIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbmRSZWN1cjogcmVmaW5lZC5lbmRSZWN1ciA/IGRhdGVFbnYuY3JlYXRlTWFya2VyKHJlZmluZWQuZW5kUmVjdXIpIDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgZHVyYXRpb247XG4gICAgICAgICAgICBpZiAocmVmaW5lZC5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gcmVmaW5lZC5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZHVyYXRpb24gJiYgcmVmaW5lZC5zdGFydFRpbWUgJiYgcmVmaW5lZC5lbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBzdWJ0cmFjdER1cmF0aW9ucyhyZWZpbmVkLmVuZFRpbWUsIHJlZmluZWQuc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWxsRGF5R3Vlc3M6IEJvb2xlYW4oIXJlZmluZWQuc3RhcnRUaW1lICYmICFyZWZpbmVkLmVuZFRpbWUpLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGVEYXRhOiByZWN1cnJpbmdEYXRhLCAvLyBkb2Vzbid0IG5lZWQgZW5kVGltZSBhbnltb3JlIGJ1dCBvaCB3ZWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZXhwYW5kKHR5cGVEYXRhLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYpIHtcbiAgICAgICAgbGV0IGNsaXBwZWRGcmFtaW5nUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoZnJhbWluZ1JhbmdlLCB7IHN0YXJ0OiB0eXBlRGF0YS5zdGFydFJlY3VyLCBlbmQ6IHR5cGVEYXRhLmVuZFJlY3VyIH0pO1xuICAgICAgICBpZiAoY2xpcHBlZEZyYW1pbmdSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZFJhbmdlcyh0eXBlRGF0YS5kYXlzT2ZXZWVrLCB0eXBlRGF0YS5zdGFydFRpbWUsIGNsaXBwZWRGcmFtaW5nUmFuZ2UsIGRhdGVFbnYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxufTtcbmNvbnN0IHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ3NpbXBsZS1yZWN1cnJpbmctZXZlbnQnLFxuICAgIHJlY3VycmluZ1R5cGVzOiBbcmVjdXJyaW5nXSxcbiAgICBldmVudFJlZmluZXJzOiBTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTLFxufSk7XG5mdW5jdGlvbiBleHBhbmRSYW5nZXMoZGF5c09mV2Vlaywgc3RhcnRUaW1lLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYpIHtcbiAgICBsZXQgZG93SGFzaCA9IGRheXNPZldlZWsgPyBhcnJheVRvSGFzaChkYXlzT2ZXZWVrKSA6IG51bGw7XG4gICAgbGV0IGRheU1hcmtlciA9IHN0YXJ0T2ZEYXkoZnJhbWluZ1JhbmdlLnN0YXJ0KTtcbiAgICBsZXQgZW5kTWFya2VyID0gZnJhbWluZ1JhbmdlLmVuZDtcbiAgICBsZXQgaW5zdGFuY2VTdGFydHMgPSBbXTtcbiAgICB3aGlsZSAoZGF5TWFya2VyIDwgZW5kTWFya2VyKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZVN0YXJ0O1xuICAgICAgICAvLyBpZiBldmVyeWRheSwgb3IgdGhpcyBwYXJ0aWN1bGFyIGRheS1vZi13ZWVrXG4gICAgICAgIGlmICghZG93SGFzaCB8fCBkb3dIYXNoW2RheU1hcmtlci5nZXRVVENEYXkoKV0pIHtcbiAgICAgICAgICAgIGlmIChzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF0ZUVudi5hZGQoZGF5TWFya2VyLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydCA9IGRheU1hcmtlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlU3RhcnRzLnB1c2goaW5zdGFuY2VTdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF5TWFya2VyID0gYWRkRGF5cyhkYXlNYXJrZXIsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2VTdGFydHM7XG59XG5cbmNvbnN0IGNoYW5nZUhhbmRsZXJQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdjaGFuZ2UtaGFuZGxlcicsXG4gICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IHtcbiAgICAgICAgZXZlbnRzKGV2ZW50cywgY29udGV4dCkge1xuICAgICAgICAgICAgaGFuZGxlRXZlbnRTb3VyY2VzKFtldmVudHNdLCBjb250ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRTb3VyY2VzOiBoYW5kbGVFdmVudFNvdXJjZXMsXG4gICAgfSxcbn0pO1xuLypcbkJVRzogaWYgYGV2ZW50YCB3YXMgc3VwcGxpZWQsIGFsbCBwcmV2aW91c2x5LWdpdmVuIGBldmVudFNvdXJjZXNgIHdpbGwgYmUgd2lwZWQgb3V0XG4qL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnRTb3VyY2VzKGlucHV0cywgY29udGV4dCkge1xuICAgIGxldCB1bmZvdW5kU291cmNlcyA9IGhhc2hWYWx1ZXNUb0FycmF5KGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFNvdXJjZXMpO1xuICAgIGlmICh1bmZvdW5kU291cmNlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgaW5wdXRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHVuZm91bmRTb3VyY2VzWzBdLl9yYXcpICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoaW5wdXRzWzBdKSkge1xuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRVNFVF9SQVdfRVZFTlRTJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiB1bmZvdW5kU291cmNlc1swXS5zb3VyY2VJZCxcbiAgICAgICAgICAgIHJhd0V2ZW50czogaW5wdXRzWzBdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbmV3SW5wdXRzID0gW107XG4gICAgZm9yIChsZXQgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICAgIGxldCBpbnB1dEZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5mb3VuZFNvdXJjZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh1bmZvdW5kU291cmNlc1tpXS5fcmF3ID09PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIHVuZm91bmRTb3VyY2VzLnNwbGljZShpLCAxKTsgLy8gZGVsZXRlXG4gICAgICAgICAgICAgICAgaW5wdXRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnB1dEZvdW5kKSB7XG4gICAgICAgICAgICBuZXdJbnB1dHMucHVzaChpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgdW5mb3VuZFNvdXJjZSBvZiB1bmZvdW5kU291cmNlcykge1xuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfU09VUkNFJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiB1bmZvdW5kU291cmNlLnNvdXJjZUlkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgbmV3SW5wdXQgb2YgbmV3SW5wdXRzKSB7XG4gICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkuYWRkRXZlbnRTb3VyY2UobmV3SW5wdXQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRGF0ZVByb2ZpbGUoZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZGF0ZXNTZXQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGNvbnRleHQuZGF0ZUVudikpLCB7IHZpZXc6IGNvbnRleHQudmlld0FwaSB9KSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgY29udGV4dCkge1xuICAgIGxldCB7IGVtaXR0ZXIgfSA9IGNvbnRleHQ7XG4gICAgaWYgKGVtaXR0ZXIuaGFzSGFuZGxlcnMoJ2V2ZW50c1NldCcpKSB7XG4gICAgICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRzU2V0JywgYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCkpO1xuICAgIH1cbn1cblxuLypcbnRoaXMgYXJyYXkgaXMgZXhwb3NlZCBvbiB0aGUgcm9vdCBuYW1lc3BhY2Ugc28gdGhhdCBVTUQgcGx1Z2lucyBjYW4gYWRkIHRvIGl0Llxuc2VlIHRoZSByb2xsdXAtYnVuZGxlcyBzY3JpcHQuXG4qL1xuY29uc3QgZ2xvYmFsUGx1Z2lucyA9IFtcbiAgICBhcnJheUV2ZW50U291cmNlUGx1Z2luLFxuICAgIGZ1bmNFdmVudFNvdXJjZVBsdWdpbixcbiAgICBqc29uRmVlZEV2ZW50U291cmNlUGx1Z2luLFxuICAgIHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbixcbiAgICBjaGFuZ2VIYW5kbGVyUGx1Z2luLFxuICAgIGNyZWF0ZVBsdWdpbih7XG4gICAgICAgIG5hbWU6ICdtaXNjJyxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IFtcbiAgICAgICAgICAgIChzdGF0ZSkgPT4gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoc3RhdGUuZXZlbnRTb3VyY2VzKSxcbiAgICAgICAgXSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiB7XG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogaGFuZGxlRGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBoYW5kbGVFdmVudFN0b3JlLFxuICAgICAgICB9LFxuICAgIH0pLFxuXTtcblxuY2xhc3MgVGFza1J1bm5lciB7XG4gICAgY29uc3RydWN0b3IocnVuVGFza09wdGlvbiwgZHJhaW5lZE9wdGlvbikge1xuICAgICAgICB0aGlzLnJ1blRhc2tPcHRpb24gPSBydW5UYXNrT3B0aW9uO1xuICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24gPSBkcmFpbmVkT3B0aW9uO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKHRoaXMuZHJhaW4uYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIHJlcXVlc3QodGFzaywgZGVsYXkpIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVxdWVzdChkZWxheSk7XG4gICAgfVxuICAgIHBhdXNlKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lci5wYXVzZShzY29wZSk7XG4gICAgfVxuICAgIHJlc3VtZShzY29wZSwgZm9yY2UpIHtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnJlc3VtZShzY29wZSwgZm9yY2UpO1xuICAgIH1cbiAgICBkcmFpbigpIHtcbiAgICAgICAgbGV0IHsgcXVldWUgfSA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjb21wbGV0ZWRUYXNrcyA9IFtdO1xuICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBxdWV1ZS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGFzayh0YXNrKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRUYXNrcy5wdXNoKHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmFpbmVkKGNvbXBsZXRlZFRhc2tzKTtcbiAgICAgICAgfSAvLyBrZWVwIGdvaW5nLCBpbiBjYXNlIG5ldyB0YXNrcyB3ZXJlIGFkZGVkIGluIHRoZSBkcmFpbmVkIGhhbmRsZXJcbiAgICB9XG4gICAgcnVuVGFzayh0YXNrKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1blRhc2tPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucnVuVGFza09wdGlvbih0YXNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmFpbmVkKGNvbXBsZXRlZFRhc2tzKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW5lZE9wdGlvbihjb21wbGV0ZWRUYXNrcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENvbXB1dGVzIHdoYXQgdGhlIHRpdGxlIGF0IHRoZSB0b3Agb2YgdGhlIGNhbGVuZGFyQXBpIHNob3VsZCBiZSBmb3IgdGhpcyB2aWV3XG5mdW5jdGlvbiBidWlsZFRpdGxlKGRhdGVQcm9maWxlLCB2aWV3T3B0aW9ucywgZGF0ZUVudikge1xuICAgIGxldCByYW5nZTtcbiAgICAvLyBmb3Igdmlld3MgdGhhdCBzcGFuIGEgbGFyZ2UgdW5pdCBvZiB0aW1lLCBzaG93IHRoZSBwcm9wZXIgaW50ZXJ2YWwsIGlnbm9yaW5nIHN0cmF5IGRheXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpIHtcbiAgICAgICAgcmFuZ2UgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2U7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBmb3IgZGF5IHVuaXRzIG9yIHNtYWxsZXIsIHVzZSB0aGUgYWN0dWFsIGRheSByYW5nZVxuICAgICAgICByYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBjcmVhdGVGb3JtYXR0ZXIodmlld09wdGlvbnMudGl0bGVGb3JtYXQgfHwgYnVpbGRUaXRsZUZvcm1hdChkYXRlUHJvZmlsZSkpLCB7XG4gICAgICAgIGlzRW5kRXhjbHVzaXZlOiBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5LFxuICAgICAgICBkZWZhdWx0U2VwYXJhdG9yOiB2aWV3T3B0aW9ucy50aXRsZVJhbmdlU2VwYXJhdG9yLFxuICAgIH0pO1xufVxuLy8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxuLy8gQXR0ZW1wdHMgdG8gY29tcHV0ZSB0aGUgbW9zdCBhcHByb3ByaWF0ZSBmb3JtYXQgaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIHdpdGggYHRpdGxlRm9ybWF0YC5cbmZ1bmN0aW9uIGJ1aWxkVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGUpIHtcbiAgICBsZXQgeyBjdXJyZW50UmFuZ2VVbml0IH0gPSBkYXRlUHJvZmlsZTtcbiAgICBpZiAoY3VycmVudFJhbmdlVW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJyB9O1xuICAgIH1cbiAgICBpZiAoY3VycmVudFJhbmdlVW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycgfTsgLy8gbGlrZSBcIlNlcHRlbWJlciAyMDE0XCJcbiAgICB9XG4gICAgbGV0IGRheXMgPSBkaWZmV2hvbGVEYXlzKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCwgZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLmVuZCk7XG4gICAgaWYgKGRheXMgIT09IG51bGwgJiYgZGF5cyA+IDEpIHtcbiAgICAgICAgLy8gbXVsdGktZGF5IHJhbmdlLiBzaG9ydGVyLCBsaWtlIFwiU2VwIDkgLSAxMCAyMDE0XCJcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnbnVtZXJpYycgfTtcbiAgICB9XG4gICAgLy8gb25lIGRheS4gbG9uZ2VyLCBsaWtlIFwiU2VwdGVtYmVyIDkgMjAxNFwiXG4gICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJyB9O1xufVxuXG4vLyBpbiBmdXR1cmUgcmVmYWN0b3IsIGRvIHRoZSByZWR1eC1zdHlsZSBmdW5jdGlvbihzdGF0ZT1pbml0aWFsKSBmb3IgaW5pdGlhbC1zdGF0ZVxuLy8gYWxzbywgd2hhdGV2ZXIgaXMgaGFwcGVuaW5nIGluIGNvbnN0cnVjdG9yLCBoYXZlIGl0IGhhcHBlbiBpbiBhY3Rpb24gcXVldWUgdG9vXG5jbGFzcyBDYWxlbmRhckRhdGFNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEgPSBtZW1vaXplKHRoaXMuX2NvbXB1dGVDdXJyZW50Vmlld0RhdGEpO1xuICAgICAgICB0aGlzLm9yZ2FuaXplUmF3TG9jYWxlcyA9IG1lbW9pemUob3JnYW5pemVSYXdMb2NhbGVzKTtcbiAgICAgICAgdGhpcy5idWlsZExvY2FsZSA9IG1lbW9pemUoYnVpbGRMb2NhbGUpO1xuICAgICAgICB0aGlzLmJ1aWxkUGx1Z2luSG9va3MgPSBidWlsZEJ1aWxkUGx1Z2luSG9va3MoKTtcbiAgICAgICAgdGhpcy5idWlsZERhdGVFbnYgPSBtZW1vaXplKGJ1aWxkRGF0ZUVudiQxKTtcbiAgICAgICAgdGhpcy5idWlsZFRoZW1lID0gbWVtb2l6ZShidWlsZFRoZW1lKTtcbiAgICAgICAgdGhpcy5wYXJzZVRvb2xiYXJzID0gbWVtb2l6ZShwYXJzZVRvb2xiYXJzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdTcGVjcyA9IG1lbW9pemUoYnVpbGRWaWV3U3BlY3MpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBtZW1vaXplT2JqQXJnKGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld0FwaSA9IG1lbW9pemUoYnVpbGRWaWV3QXBpKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdVaVByb3BzID0gbWVtb2l6ZU9iakFyZyhidWlsZFZpZXdVaVByb3BzKTtcbiAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlCeVNvdXJjZSA9IG1lbW9pemUoYnVpbGRFdmVudFVpQnlTb3VyY2UsIGlzUHJvcHNFcXVhbCk7XG4gICAgICAgIHRoaXMuYnVpbGRFdmVudFVpQmFzZXMgPSBtZW1vaXplKGJ1aWxkRXZlbnRVaUJhc2VzKTtcbiAgICAgICAgdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZU9iakFyZyhwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKTtcbiAgICAgICAgdGhpcy5idWlsZFRpdGxlID0gbWVtb2l6ZShidWlsZFRpdGxlKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIgPSBuZXcgVGFza1J1bm5lcih0aGlzLl9oYW5kbGVBY3Rpb24uYmluZCh0aGlzKSwgdGhpcy51cGRhdGVEYXRhLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzID0ge307XG4gICAgICAgIHRoaXMub3B0aW9uc0ZvclJlZmluaW5nID0gW107XG4gICAgICAgIHRoaXMub3B0aW9uc0ZvckhhbmRsaW5nID0gW107XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudERhdGEgPSAoKSA9PiB0aGlzLmRhdGE7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSAoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblJ1bm5lci5yZXF1ZXN0KGFjdGlvbik7IC8vIHByb3RlY3RzIGFnYWluc3QgcmVjdXJzaXZlIGNhbGxzIHRvIF9oYW5kbGVBY3Rpb25cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lci5wYXVzZSgpO1xuICAgICAgICBsZXQgZHluYW1pY09wdGlvbk92ZXJyaWRlcyA9IHt9O1xuICAgICAgICBsZXQgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgbGV0IGN1cnJlbnRWaWV3VHlwZSA9IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucy5pbml0aWFsVmlldyB8fCBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5pbml0aWFsVmlldztcbiAgICAgICAgbGV0IGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShjdXJyZW50Vmlld1R5cGUsIG9wdGlvbnNEYXRhLCBwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICAvLyB3aXJlIHRoaW5ncyB1cFxuICAgICAgICAvLyBUT0RPOiBub3QgRFJZXG4gICAgICAgIHByb3BzLmNhbGVuZGFyQXBpLmN1cnJlbnREYXRhTWFuYWdlciA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdHRlci5zZXRUaGlzQ29udGV4dChwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIHRoaXMuZW1pdHRlci5zZXRPcHRpb25zKGN1cnJlbnRWaWV3RGF0YS5vcHRpb25zKTtcbiAgICAgICAgbGV0IGN1cnJlbnREYXRlID0gZ2V0SW5pdGlhbERhdGUob3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLCBvcHRpb25zRGF0YS5kYXRlRW52KTtcbiAgICAgICAgbGV0IGRhdGVQcm9maWxlID0gY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGN1cnJlbnREYXRlKTtcbiAgICAgICAgaWYgKCFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjdXJyZW50RGF0ZSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnREYXRlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYWxlbmRhckNvbnRleHQgPSB7XG4gICAgICAgICAgICBkYXRlRW52OiBvcHRpb25zRGF0YS5kYXRlRW52LFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLFxuICAgICAgICAgICAgcGx1Z2luSG9va3M6IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgICAgICAgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsXG4gICAgICAgICAgICBlbWl0dGVyOiB0aGlzLmVtaXR0ZXIsXG4gICAgICAgICAgICBnZXRDdXJyZW50RGF0YTogdGhpcy5nZXRDdXJyZW50RGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gbmVlZHMgdG8gYmUgYWZ0ZXIgc2V0VGhpc0NvbnRleHRcbiAgICAgICAgZm9yIChsZXQgY2FsbGJhY2sgb2Ygb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuY29udGV4dEluaXQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9UIERSWVxuICAgICAgICBsZXQgZXZlbnRTb3VyY2VzID0gaW5pdEV2ZW50U291cmNlcyhvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsIGRhdGVQcm9maWxlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICBsZXQgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJzOiB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgICAgIGV2ZW50U291cmNlcyxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlczoge30sXG4gICAgICAgICAgICBldmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IG51bGwsXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogJycsXG4gICAgICAgICAgICBldmVudERyYWc6IG51bGwsXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbmZpZzogdGhpcy5idWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkuc2VsZWN0aW9uQ29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY29udGV4dEFuZFN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYWxlbmRhckNvbnRleHQpLCBpbml0aWFsU3RhdGUpO1xuICAgICAgICBmb3IgKGxldCByZWR1Y2VyIG9mIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLnJlZHVjZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGluaXRpYWxTdGF0ZSwgcmVkdWNlcihudWxsLCBudWxsLCBjb250ZXh0QW5kU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHV0ZUlzTG9hZGluZyhpbml0aWFsU3RhdGUsIGNhbGVuZGFyQ29udGV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgdHJ1ZSk7IC8vIE5PVCBEUllcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVzdW1lKCk7XG4gICAgfVxuICAgIHJlc2V0T3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGNoYW5nZWRPcHRpb25OYW1lcykge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKGNoYW5nZWRPcHRpb25OYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm9wcy5vcHRpb25PdmVycmlkZXMgPSBvcHRpb25PdmVycmlkZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9wcy5vcHRpb25PdmVycmlkZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChwcm9wcy5vcHRpb25PdmVycmlkZXMgfHwge30pKSwgb3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc0ZvclJlZmluaW5nLnB1c2goLi4uY2hhbmdlZE9wdGlvbk5hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlZE9wdGlvbk5hbWVzID09PSB1bmRlZmluZWQgfHwgY2hhbmdlZE9wdGlvbk5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ05PVEhJTkcnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2hhbmRsZUFjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBlbWl0dGVyIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZHluYW1pY09wdGlvbk92ZXJyaWRlcyA9IHJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMoc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcywgYWN0aW9uKTtcbiAgICAgICAgbGV0IG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld1R5cGUgPSByZWR1Y2VWaWV3VHlwZShzdGF0ZS5jdXJyZW50Vmlld1R5cGUsIGFjdGlvbik7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgLy8gd2lyZSB0aGluZ3MgdXBcbiAgICAgICAgLy8gVE9ETzogbm90IERSWVxuICAgICAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzO1xuICAgICAgICBlbWl0dGVyLnNldFRoaXNDb250ZXh0KHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgZW1pdHRlci5zZXRPcHRpb25zKGN1cnJlbnRWaWV3RGF0YS5vcHRpb25zKTtcbiAgICAgICAgbGV0IGNhbGVuZGFyQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICAgICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCxcbiAgICAgICAgICAgIGVtaXR0ZXIsXG4gICAgICAgICAgICBnZXRDdXJyZW50RGF0YTogdGhpcy5nZXRDdXJyZW50RGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgY3VycmVudERhdGUsIGRhdGVQcm9maWxlIH0gPSBzdGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IgIT09IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvcikgeyAvLyBoYWNrXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudERhdGUgPSByZWR1Y2VDdXJyZW50RGF0ZShjdXJyZW50RGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgZGF0ZVByb2ZpbGUgPSByZWR1Y2VEYXRlUHJvZmlsZShkYXRlUHJvZmlsZSwgYWN0aW9uLCBjdXJyZW50RGF0ZSwgY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnUFJFVicgfHwgLy8gVE9ETzogbW92ZSB0aGlzIGxvZ2ljIGludG8gRGF0ZVByb2ZpbGVHZW5lcmF0b3JcbiAgICAgICAgICAgIGFjdGlvbi50eXBlID09PSAnTkVYVCcgfHwgLy8gXCJcbiAgICAgICAgICAgICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzKHN0YXRlLmV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgbGV0IGV2ZW50U3RvcmUgPSByZWR1Y2VFdmVudFN0b3JlKHN0YXRlLmV2ZW50U3RvcmUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgbGV0IGlzRXZlbnRzTG9hZGluZyA9IGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKGV2ZW50U291cmNlcyk7IC8vIEJBRC4gYWxzbyBjYWxsZWQgaW4gdGhpcyBmdW5jIGluIGNvbXB1dGVJc0xvYWRpbmdcbiAgICAgICAgbGV0IHJlbmRlcmFibGVFdmVudFN0b3JlID0gKGlzRXZlbnRzTG9hZGluZyAmJiAhY3VycmVudFZpZXdEYXRhLm9wdGlvbnMucHJvZ3Jlc3NpdmVFdmVudFJlbmRlcmluZykgP1xuICAgICAgICAgICAgKHN0YXRlLnJlbmRlcmFibGVFdmVudFN0b3JlIHx8IGV2ZW50U3RvcmUpIDogLy8gdHJ5IGZyb20gcHJldmlvdXMgc3RhdGVcbiAgICAgICAgICAgIGV2ZW50U3RvcmU7XG4gICAgICAgIGxldCB7IGV2ZW50VWlTaW5nbGVCYXNlLCBzZWxlY3Rpb25Db25maWcgfSA9IHRoaXMuYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpOyAvLyB3aWxsIG1lbW9pemUgb2JqXG4gICAgICAgIGxldCBldmVudFVpQnlTb3VyY2UgPSB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlKGV2ZW50U291cmNlcyk7XG4gICAgICAgIGxldCBldmVudFVpQmFzZXMgPSB0aGlzLmJ1aWxkRXZlbnRVaUJhc2VzKHJlbmRlcmFibGVFdmVudFN0b3JlLmRlZnMsIGV2ZW50VWlTaW5nbGVCYXNlLCBldmVudFVpQnlTb3VyY2UpO1xuICAgICAgICBsZXQgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY3VycmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGV2ZW50U291cmNlcyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmUsXG4gICAgICAgICAgICByZW5kZXJhYmxlRXZlbnRTdG9yZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbmZpZyxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlcyxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpLFxuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogcmVkdWNlRGF0ZVNlbGVjdGlvbihzdGF0ZS5kYXRlU2VsZWN0aW9uLCBhY3Rpb24pLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHJlZHVjZVNlbGVjdGVkRXZlbnQoc3RhdGUuZXZlbnRTZWxlY3Rpb24sIGFjdGlvbiksXG4gICAgICAgICAgICBldmVudERyYWc6IHJlZHVjZUV2ZW50RHJhZyhzdGF0ZS5ldmVudERyYWcsIGFjdGlvbiksXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogcmVkdWNlRXZlbnRSZXNpemUoc3RhdGUuZXZlbnRSZXNpemUsIGFjdGlvbiksXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb250ZXh0QW5kU3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNhbGVuZGFyQ29udGV4dCksIG5ld1N0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgcmVkdWNlciBvZiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5yZWR1Y2Vycykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdTdGF0ZSwgcmVkdWNlcihzdGF0ZSwgYWN0aW9uLCBjb250ZXh0QW5kU3RhdGUpKTsgLy8gZ2l2ZSB0aGUgT0xEIHN0YXRlLCBmb3Igb2xkIHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdhc0xvYWRpbmcgPSBjb21wdXRlSXNMb2FkaW5nKHN0YXRlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICBsZXQgaXNMb2FkaW5nID0gY29tcHV0ZUlzTG9hZGluZyhuZXdTdGF0ZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgLy8gVE9ETzogdXNlIHByb3BTZXRIYW5kbGVycyBpbiBwbHVnaW4gc3lzdGVtXG4gICAgICAgIGlmICghd2FzTG9hZGluZyAmJiBpc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdhc0xvYWRpbmcgJiYgIWlzTG9hZGluZykge1xuICAgICAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgaWYgKHByb3BzLm9uQWN0aW9uKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkFjdGlvbihhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZURhdGEoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IG9sZERhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGxldCBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKHByb3BzLm9wdGlvbk92ZXJyaWRlcywgc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcywgcHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICBsZXQgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKHN0YXRlLmN1cnJlbnRWaWV3VHlwZSwgb3B0aW9uc0RhdGEsIHByb3BzLm9wdGlvbk92ZXJyaWRlcywgc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB2aWV3VGl0bGU6IHRoaXMuYnVpbGRUaXRsZShzdGF0ZS5kYXRlUHJvZmlsZSwgY3VycmVudFZpZXdEYXRhLm9wdGlvbnMsIG9wdGlvbnNEYXRhLmRhdGVFbnYpLCBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLCBlbWl0dGVyOiB0aGlzLmVtaXR0ZXIsIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhIH0sIG9wdGlvbnNEYXRhKSwgY3VycmVudFZpZXdEYXRhKSwgc3RhdGUpO1xuICAgICAgICBsZXQgY2hhbmdlSGFuZGxlcnMgPSBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5vcHRpb25DaGFuZ2VIYW5kbGVycztcbiAgICAgICAgbGV0IG9sZENhbGVuZGFyT3B0aW9ucyA9IG9sZERhdGEgJiYgb2xkRGF0YS5jYWxlbmRhck9wdGlvbnM7XG4gICAgICAgIGxldCBuZXdDYWxlbmRhck9wdGlvbnMgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnM7XG4gICAgICAgIGlmIChvbGRDYWxlbmRhck9wdGlvbnMgJiYgb2xkQ2FsZW5kYXJPcHRpb25zICE9PSBuZXdDYWxlbmRhck9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvbGRDYWxlbmRhck9wdGlvbnMudGltZVpvbmUgIT09IG5ld0NhbGVuZGFyT3B0aW9ucy50aW1lWm9uZSkge1xuICAgICAgICAgICAgICAgIC8vIGhhY2tcbiAgICAgICAgICAgICAgICBzdGF0ZS5ldmVudFNvdXJjZXMgPSBkYXRhLmV2ZW50U291cmNlcyA9IHJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lKGRhdGEuZXZlbnRTb3VyY2VzLCBzdGF0ZS5kYXRlUHJvZmlsZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuZXZlbnRTdG9yZSA9IGRhdGEuZXZlbnRTdG9yZSA9IHJlem9uZUV2ZW50U3RvcmVEYXRlcyhkYXRhLmV2ZW50U3RvcmUsIG9sZERhdGEuZGF0ZUVudiwgZGF0YS5kYXRlRW52KTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5yZW5kZXJhYmxlRXZlbnRTdG9yZSA9IGRhdGEucmVuZGVyYWJsZUV2ZW50U3RvcmUgPSByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZGF0YS5yZW5kZXJhYmxlRXZlbnRTdG9yZSwgb2xkRGF0YS5kYXRlRW52LCBkYXRhLmRhdGVFbnYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiBjaGFuZ2VIYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNGb3JIYW5kbGluZy5pbmRleE9mKG9wdGlvbk5hbWUpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICBvbGRDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0gIT09IG5ld0NhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIYW5kbGVyc1tvcHRpb25OYW1lXShuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0sIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNGb3JIYW5kbGluZyA9IFtdO1xuICAgICAgICBpZiAocHJvcHMub25EYXRhKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkRhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZU9wdGlvbnNEYXRhKG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgY2FsZW5kYXJBcGkpIHtcbiAgICAgICAgLy8gVE9ETzogYmxhY2tsaXN0IG9wdGlvbnMgdGhhdCBhcmUgaGFuZGxlZCBieSBvcHRpb25DaGFuZ2VIYW5kbGVyc1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9uc0ZvclJlZmluaW5nLmxlbmd0aCAmJlxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzID09PSB0aGlzLnN0YWJsZU9wdGlvbk92ZXJyaWRlcyAmJlxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyA9PT0gdGhpcy5zdGFibGVEeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFibGVDYWxlbmRhck9wdGlvbnNEYXRhO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcywgbG9jYWxlRGVmYXVsdHMsIGF2YWlsYWJsZUxvY2FsZURhdGEsIGV4dHJhLCB9ID0gdGhpcy5wcm9jZXNzUmF3Q2FsZW5kYXJPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIHdhcm5Vbmtub3duT3B0aW9ucyhleHRyYSk7XG4gICAgICAgIGxldCBkYXRlRW52ID0gdGhpcy5idWlsZERhdGVFbnYocmVmaW5lZE9wdGlvbnMudGltZVpvbmUsIHJlZmluZWRPcHRpb25zLmxvY2FsZSwgcmVmaW5lZE9wdGlvbnMud2Vla051bWJlckNhbGN1bGF0aW9uLCByZWZpbmVkT3B0aW9ucy5maXJzdERheSwgcmVmaW5lZE9wdGlvbnMud2Vla1RleHQsIHBsdWdpbkhvb2tzLCBhdmFpbGFibGVMb2NhbGVEYXRhLCByZWZpbmVkT3B0aW9ucy5kZWZhdWx0UmFuZ2VTZXBhcmF0b3IpO1xuICAgICAgICBsZXQgdmlld1NwZWNzID0gdGhpcy5idWlsZFZpZXdTcGVjcyhwbHVnaW5Ib29rcy52aWV3cywgdGhpcy5zdGFibGVPcHRpb25PdmVycmlkZXMsIHRoaXMuc3RhYmxlRHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpO1xuICAgICAgICBsZXQgdGhlbWUgPSB0aGlzLmJ1aWxkVGhlbWUocmVmaW5lZE9wdGlvbnMsIHBsdWdpbkhvb2tzKTtcbiAgICAgICAgbGV0IHRvb2xiYXJDb25maWcgPSB0aGlzLnBhcnNlVG9vbGJhcnMocmVmaW5lZE9wdGlvbnMsIHRoaXMuc3RhYmxlT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWJsZUNhbGVuZGFyT3B0aW9uc0RhdGEgPSB7XG4gICAgICAgICAgICBjYWxlbmRhck9wdGlvbnM6IHJlZmluZWRPcHRpb25zLFxuICAgICAgICAgICAgcGx1Z2luSG9va3MsXG4gICAgICAgICAgICBkYXRlRW52LFxuICAgICAgICAgICAgdmlld1NwZWNzLFxuICAgICAgICAgICAgdGhlbWUsXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBhdmFpbGFibGVSYXdMb2NhbGVzOiBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gYWx3YXlzIGNhbGxlZCBmcm9tIGJlaGluZCBhIG1lbW9pemVyXG4gICAgcHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgbGV0IHsgbG9jYWxlcywgbG9jYWxlIH0gPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IGF2YWlsYWJsZUxvY2FsZURhdGEgPSB0aGlzLm9yZ2FuaXplUmF3TG9jYWxlcyhsb2NhbGVzKTtcbiAgICAgICAgbGV0IGF2YWlsYWJsZVJhd0xvY2FsZXMgPSBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcDtcbiAgICAgICAgbGV0IGxvY2FsZURlZmF1bHRzID0gdGhpcy5idWlsZExvY2FsZShsb2NhbGUgfHwgYXZhaWxhYmxlTG9jYWxlRGF0YS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlUmF3TG9jYWxlcykub3B0aW9ucztcbiAgICAgICAgbGV0IHBsdWdpbkhvb2tzID0gdGhpcy5idWlsZFBsdWdpbkhvb2tzKG9wdGlvbk92ZXJyaWRlcy5wbHVnaW5zIHx8IFtdLCBnbG9iYWxQbHVnaW5zKTtcbiAgICAgICAgbGV0IHJlZmluZXJzID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEJBU0VfT1BUSU9OX1JFRklORVJTKSwgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMpLCBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMpLCBwbHVnaW5Ib29rcy5saXN0ZW5lclJlZmluZXJzKSwgcGx1Z2luSG9va3Mub3B0aW9uUmVmaW5lcnMpO1xuICAgICAgICBsZXQgZXh0cmEgPSB7fTtcbiAgICAgICAgbGV0IHJhdyA9IG1lcmdlUmF3T3B0aW9ucyhbXG4gICAgICAgICAgICBCQVNFX09QVElPTl9ERUZBVUxUUyxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgXSk7XG4gICAgICAgIGxldCByZWZpbmVkID0ge307XG4gICAgICAgIGxldCBjdXJyZW50UmF3ID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQ7XG4gICAgICAgIGxldCBjdXJyZW50UmVmaW5lZCA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQ7XG4gICAgICAgIGxldCBhbnlDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gcmF3KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zRm9yUmVmaW5pbmcuaW5kZXhPZihvcHRpb25OYW1lKSA9PT0gLTEgJiYgKHJhd1tvcHRpb25OYW1lXSA9PT0gY3VycmVudFJhd1tvcHRpb25OYW1lXSB8fCAoQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAob3B0aW9uTmFtZSBpbiBjdXJyZW50UmF3KSAmJlxuICAgICAgICAgICAgICAgIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdKGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0sIHJhd1tvcHRpb25OYW1lXSkpKSkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmVmaW5lZFtvcHRpb25OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZXJzW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHJlZmluZXJzW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSk7XG4gICAgICAgICAgICAgICAgYW55Q2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHRyYVtvcHRpb25OYW1lXSA9IGN1cnJlbnRSYXdbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFueUNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0ID0gcmF3O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCA9IHJlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnN0YWJsZU9wdGlvbk92ZXJyaWRlcyA9IG9wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgICAgIHRoaXMuc3RhYmxlRHluYW1pY09wdGlvbk92ZXJyaWRlcyA9IGR5bmFtaWNPcHRpb25PdmVycmlkZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zRm9ySGFuZGxpbmcucHVzaCguLi50aGlzLm9wdGlvbnNGb3JSZWZpbmluZyk7XG4gICAgICAgIHRoaXMub3B0aW9uc0ZvclJlZmluaW5nID0gW107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdPcHRpb25zOiB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCxcbiAgICAgICAgICAgIHJlZmluZWRPcHRpb25zOiB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkLFxuICAgICAgICAgICAgcGx1Z2luSG9va3MsXG4gICAgICAgICAgICBhdmFpbGFibGVMb2NhbGVEYXRhLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2NvbXB1dGVDdXJyZW50Vmlld0RhdGEodmlld1R5cGUsIG9wdGlvbnNEYXRhLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgbGV0IHZpZXdTcGVjID0gb3B0aW9uc0RhdGEudmlld1NwZWNzW3ZpZXdUeXBlXTtcbiAgICAgICAgaWYgKCF2aWV3U3BlYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2aWV3VHlwZSBcIiR7dmlld1R5cGV9XCIgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UndmUgbG9hZGVkIGFsbCBuZWNjZXNzYXJ5IHBsdWdpbnNgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyByZWZpbmVkT3B0aW9ucywgZXh0cmEgfSA9IHRoaXMucHJvY2Vzc1Jhd1ZpZXdPcHRpb25zKHZpZXdTcGVjLCBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcywgb3B0aW9uc0RhdGEubG9jYWxlRGVmYXVsdHMsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIHdhcm5Vbmtub3duT3B0aW9ucyhleHRyYSk7XG4gICAgICAgIGxldCBkYXRlUHJvZmlsZUdlbmVyYXRvciA9IHRoaXMuYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvcih7XG4gICAgICAgICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cy5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzLFxuICAgICAgICAgICAgZHVyYXRpb246IHZpZXdTcGVjLmR1cmF0aW9uLFxuICAgICAgICAgICAgZHVyYXRpb25Vbml0OiB2aWV3U3BlYy5kdXJhdGlvblVuaXQsXG4gICAgICAgICAgICB1c2VzTWluTWF4VGltZTogdmlld1NwZWMub3B0aW9uRGVmYXVsdHMudXNlc01pbk1heFRpbWUsXG4gICAgICAgICAgICBkYXRlRW52OiBvcHRpb25zRGF0YS5kYXRlRW52LFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHRoaXMucHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICAgICAgICBzbG90TWluVGltZTogcmVmaW5lZE9wdGlvbnMuc2xvdE1pblRpbWUsXG4gICAgICAgICAgICBzbG90TWF4VGltZTogcmVmaW5lZE9wdGlvbnMuc2xvdE1heFRpbWUsXG4gICAgICAgICAgICBzaG93Tm9uQ3VycmVudERhdGVzOiByZWZpbmVkT3B0aW9ucy5zaG93Tm9uQ3VycmVudERhdGVzLFxuICAgICAgICAgICAgZGF5Q291bnQ6IHJlZmluZWRPcHRpb25zLmRheUNvdW50LFxuICAgICAgICAgICAgZGF0ZUFsaWdubWVudDogcmVmaW5lZE9wdGlvbnMuZGF0ZUFsaWdubWVudCxcbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHJlZmluZWRPcHRpb25zLmRhdGVJbmNyZW1lbnQsXG4gICAgICAgICAgICBoaWRkZW5EYXlzOiByZWZpbmVkT3B0aW9ucy5oaWRkZW5EYXlzLFxuICAgICAgICAgICAgd2Vla2VuZHM6IHJlZmluZWRPcHRpb25zLndlZWtlbmRzLFxuICAgICAgICAgICAgbm93SW5wdXQ6IHJlZmluZWRPcHRpb25zLm5vdyxcbiAgICAgICAgICAgIHZhbGlkUmFuZ2VJbnB1dDogcmVmaW5lZE9wdGlvbnMudmFsaWRSYW5nZSxcbiAgICAgICAgICAgIHZpc2libGVSYW5nZUlucHV0OiByZWZpbmVkT3B0aW9ucy52aXNpYmxlUmFuZ2UsXG4gICAgICAgICAgICBmaXhlZFdlZWtDb3VudDogcmVmaW5lZE9wdGlvbnMuZml4ZWRXZWVrQ291bnQsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdmlld0FwaSA9IHRoaXMuYnVpbGRWaWV3QXBpKHZpZXdUeXBlLCB0aGlzLmdldEN1cnJlbnREYXRhLCBvcHRpb25zRGF0YS5kYXRlRW52KTtcbiAgICAgICAgcmV0dXJuIHsgdmlld1NwZWMsIG9wdGlvbnM6IHJlZmluZWRPcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgdmlld0FwaSB9O1xuICAgIH1cbiAgICBwcm9jZXNzUmF3Vmlld09wdGlvbnModmlld1NwZWMsIHBsdWdpbkhvb2tzLCBsb2NhbGVEZWZhdWx0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XG4gICAgICAgIGxldCByYXcgPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICAgICAgICB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cyxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgdmlld1NwZWMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgXSk7XG4gICAgICAgIGxldCByZWZpbmVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBCQVNFX09QVElPTl9SRUZJTkVSUyksIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTKSwgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTKSwgVklFV19PUFRJT05fUkVGSU5FUlMpLCBwbHVnaW5Ib29rcy5saXN0ZW5lclJlZmluZXJzKSwgcGx1Z2luSG9va3Mub3B0aW9uUmVmaW5lcnMpO1xuICAgICAgICBsZXQgcmVmaW5lZCA9IHt9O1xuICAgICAgICBsZXQgY3VycmVudFJhdyA9IHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQ7XG4gICAgICAgIGxldCBjdXJyZW50UmVmaW5lZCA9IHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZDtcbiAgICAgICAgbGV0IGFueUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgbGV0IGV4dHJhID0ge307XG4gICAgICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gcmF3KSB7XG4gICAgICAgICAgICBpZiAocmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdIHx8XG4gICAgICAgICAgICAgICAgKENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdICYmXG4gICAgICAgICAgICAgICAgICAgIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSwgY3VycmVudFJhd1tvcHRpb25OYW1lXSkpKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IGN1cnJlbnRSZWZpbmVkW29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbb3B0aW9uTmFtZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgKENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0sIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0W29wdGlvbk5hbWVdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbk5hbWUgaW4gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCkgeyAvLyBtaWdodCBiZSBhbiBcImV4dHJhXCIgcHJvcFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWRbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lcnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHJlZmluZXJzW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHRyYVtvcHRpb25OYW1lXSA9IHJhd1tvcHRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW55Q2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFueUNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQgPSByYXc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQgPSByZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdPcHRpb25zOiB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0LFxuICAgICAgICAgICAgcmVmaW5lZE9wdGlvbnM6IHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCxcbiAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZUVudiQxKHRpbWVab25lLCBleHBsaWNpdExvY2FsZSwgd2Vla051bWJlckNhbGN1bGF0aW9uLCBmaXJzdERheSwgd2Vla1RleHQsIHBsdWdpbkhvb2tzLCBhdmFpbGFibGVMb2NhbGVEYXRhLCBkZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgbGV0IGxvY2FsZSA9IGJ1aWxkTG9jYWxlKGV4cGxpY2l0TG9jYWxlIHx8IGF2YWlsYWJsZUxvY2FsZURhdGEuZGVmYXVsdENvZGUsIGF2YWlsYWJsZUxvY2FsZURhdGEubWFwKTtcbiAgICByZXR1cm4gbmV3IERhdGVFbnYoe1xuICAgICAgICBjYWxlbmRhclN5c3RlbTogJ2dyZWdvcnknLFxuICAgICAgICB0aW1lWm9uZSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZUltcGw6IHBsdWdpbkhvb2tzLm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24sXG4gICAgICAgIGZpcnN0RGF5LFxuICAgICAgICB3ZWVrVGV4dCxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBwbHVnaW5Ib29rcy5jbWRGb3JtYXR0ZXIsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3IsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZFRoZW1lKG9wdGlvbnMsIHBsdWdpbkhvb2tzKSB7XG4gICAgbGV0IFRoZW1lQ2xhc3MgPSBwbHVnaW5Ib29rcy50aGVtZUNsYXNzZXNbb3B0aW9ucy50aGVtZVN5c3RlbV0gfHwgU3RhbmRhcmRUaGVtZTtcbiAgICByZXR1cm4gbmV3IFRoZW1lQ2xhc3Mob3B0aW9ucyk7XG59XG5mdW5jdGlvbiBidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKHByb3BzKSB7XG4gICAgbGV0IERhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgPSBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIHx8IERhdGVQcm9maWxlR2VuZXJhdG9yO1xuICAgIHJldHVybiBuZXcgRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyhwcm9wcyk7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdBcGkodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpIHtcbiAgICByZXR1cm4gbmV3IFZpZXdJbXBsKHR5cGUsIGdldEN1cnJlbnREYXRhLCBkYXRlRW52KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUJ5U291cmNlKGV2ZW50U291cmNlcykge1xuICAgIHJldHVybiBtYXBIYXNoKGV2ZW50U291cmNlcywgKGV2ZW50U291cmNlKSA9PiBldmVudFNvdXJjZS51aSk7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50VWlCYXNlcyhldmVudERlZnMsIGV2ZW50VWlTaW5nbGVCYXNlLCBldmVudFVpQnlTb3VyY2UpIHtcbiAgICBsZXQgZXZlbnRVaUJhc2VzID0geyAnJzogZXZlbnRVaVNpbmdsZUJhc2UgfTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBldmVudERlZnMpIHtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50RGVmc1tkZWZJZF07XG4gICAgICAgIGlmIChkZWYuc291cmNlSWQgJiYgZXZlbnRVaUJ5U291cmNlW2RlZi5zb3VyY2VJZF0pIHtcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlc1tkZWZJZF0gPSBldmVudFVpQnlTb3VyY2VbZGVmLnNvdXJjZUlkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRVaUJhc2VzO1xufVxuZnVuY3Rpb24gYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpIHtcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjYWxlbmRhckNvbnRleHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnRVaVNpbmdsZUJhc2U6IGNyZWF0ZUV2ZW50VWkoe1xuICAgICAgICAgICAgZGlzcGxheTogb3B0aW9ucy5ldmVudERpc3BsYXksXG4gICAgICAgICAgICBlZGl0YWJsZTogb3B0aW9ucy5lZGl0YWJsZSxcbiAgICAgICAgICAgIHN0YXJ0RWRpdGFibGU6IG9wdGlvbnMuZXZlbnRTdGFydEVkaXRhYmxlLFxuICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogb3B0aW9ucy5ldmVudER1cmF0aW9uRWRpdGFibGUsXG4gICAgICAgICAgICBjb25zdHJhaW50OiBvcHRpb25zLmV2ZW50Q29uc3RyYWludCxcbiAgICAgICAgICAgIG92ZXJsYXA6IHR5cGVvZiBvcHRpb25zLmV2ZW50T3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5ldmVudE92ZXJsYXAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbGxvdzogb3B0aW9ucy5ldmVudEFsbG93LFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmV2ZW50QmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuZXZlbnRCb3JkZXJDb2xvcixcbiAgICAgICAgICAgIHRleHRDb2xvcjogb3B0aW9ucy5ldmVudFRleHRDb2xvcixcbiAgICAgICAgICAgIGNvbG9yOiBvcHRpb25zLmV2ZW50Q29sb3IsXG4gICAgICAgICAgICAvLyBjbGFzc05hbWVzOiBvcHRpb25zLmV2ZW50Q2xhc3NOYW1lcyAvLyByZW5kZXIgaG9vayB3aWxsIGhhbmRsZSB0aGlzXG4gICAgICAgIH0sIGNhbGVuZGFyQ29udGV4dCksXG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZzogY3JlYXRlRXZlbnRVaSh7XG4gICAgICAgICAgICBjb25zdHJhaW50OiBvcHRpb25zLnNlbGVjdENvbnN0cmFpbnQsXG4gICAgICAgICAgICBvdmVybGFwOiB0eXBlb2Ygb3B0aW9ucy5zZWxlY3RPdmVybGFwID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNlbGVjdE92ZXJsYXAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbGxvdzogb3B0aW9ucy5zZWxlY3RBbGxvdyxcbiAgICAgICAgfSwgY2FsZW5kYXJDb250ZXh0KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzTG9hZGluZyhzdGF0ZSwgY29udGV4dCkge1xuICAgIGZvciAobGV0IGlzTG9hZGluZ0Z1bmMgb2YgY29udGV4dC5wbHVnaW5Ib29rcy5pc0xvYWRpbmdGdW5jcykge1xuICAgICAgICBpZiAoaXNMb2FkaW5nRnVuYyhzdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlQnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQub3B0aW9ucy5idXNpbmVzc0hvdXJzLCBjYWxlbmRhckNvbnRleHQpO1xufVxuZnVuY3Rpb24gd2FyblVua25vd25PcHRpb25zKG9wdGlvbnMsIHZpZXdOYW1lKSB7XG4gICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBvcHRpb24gJyR7b3B0aW9uTmFtZX0nYCArXG4gICAgICAgICAgICAodmlld05hbWUgPyBgIGZvciB2aWV3ICcke3ZpZXdOYW1lfSdgIDogJycpKTtcbiAgICB9XG59XG5cbmNsYXNzIFRvb2xiYXJTZWN0aW9uIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLnByb3BzLndpZGdldEdyb3Vwcy5tYXAoKHdpZGdldEdyb3VwKSA9PiB0aGlzLnJlbmRlcldpZGdldEdyb3VwKHdpZGdldEdyb3VwKSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogJ2ZjLXRvb2xiYXItY2h1bmsnIH0sIC4uLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmVuZGVyV2lkZ2V0R3JvdXAod2lkZ2V0R3JvdXApIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHRoZW1lIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBsZXQgaXNPbmx5QnV0dG9ucyA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IHdpZGdldCBvZiB3aWRnZXRHcm91cCkge1xuICAgICAgICAgICAgbGV0IHsgYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2ssIGJ1dHRvblRleHQsIGJ1dHRvbkljb24sIGJ1dHRvbkhpbnQgfSA9IHdpZGdldDtcbiAgICAgICAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XG4gICAgICAgICAgICAgICAgaXNPbmx5QnV0dG9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY3JlYXRlRWxlbWVudChcImgyXCIsIHsgY2xhc3NOYW1lOiBcImZjLXRvb2xiYXItdGl0bGVcIiwgaWQ6IHByb3BzLnRpdGxlSWQgfSwgcHJvcHMudGl0bGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpc1ByZXNzZWQgPSBidXR0b25OYW1lID09PSBwcm9wcy5hY3RpdmVCdXR0b247XG4gICAgICAgICAgICAgICAgbGV0IGlzRGlzYWJsZWQgPSAoIXByb3BzLmlzVG9kYXlFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICd0b2RheScpIHx8XG4gICAgICAgICAgICAgICAgICAgICghcHJvcHMuaXNQcmV2RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAncHJldicpIHx8XG4gICAgICAgICAgICAgICAgICAgICghcHJvcHMuaXNOZXh0RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAnbmV4dCcpO1xuICAgICAgICAgICAgICAgIGxldCBidXR0b25DbGFzc2VzID0gW2BmYy0ke2J1dHRvbk5hbWV9LWJ1dHRvbmAsIHRoZW1lLmdldENsYXNzKCdidXR0b24nKV07XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b25DbGFzc2VzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkFjdGl2ZScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgdGl0bGU6IHR5cGVvZiBidXR0b25IaW50ID09PSAnZnVuY3Rpb24nID8gYnV0dG9uSGludChwcm9wcy5uYXZVbml0KSA6IGJ1dHRvbkhpbnQsIGRpc2FibGVkOiBpc0Rpc2FibGVkLCBcImFyaWEtcHJlc3NlZFwiOiBpc1ByZXNzZWQsIGNsYXNzTmFtZTogYnV0dG9uQ2xhc3Nlcy5qb2luKCcgJyksIG9uQ2xpY2s6IGJ1dHRvbkNsaWNrIH0sIGJ1dHRvblRleHQgfHwgKGJ1dHRvbkljb24gPyBjcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogYnV0dG9uSWNvbiwgcm9sZTogXCJpbWdcIiB9KSA6ICcnKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBDbGFzc05hbWUgPSAoaXNPbmx5QnV0dG9ucyAmJiB0aGVtZS5nZXRDbGFzcygnYnV0dG9uR3JvdXAnKSkgfHwgJyc7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6IGdyb3VwQ2xhc3NOYW1lIH0sIC4uLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gICAgfVxufVxuXG5jbGFzcyBUb29sYmFyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBtb2RlbCwgZXh0cmFDbGFzc05hbWUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBmb3JjZUx0ciA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnRDb250ZW50O1xuICAgICAgICBsZXQgZW5kQ29udGVudDtcbiAgICAgICAgbGV0IHNlY3Rpb25XaWRnZXRzID0gbW9kZWwuc2VjdGlvbldpZGdldHM7XG4gICAgICAgIGxldCBjZW50ZXJDb250ZW50ID0gc2VjdGlvbldpZGdldHMuY2VudGVyO1xuICAgICAgICBpZiAoc2VjdGlvbldpZGdldHMubGVmdCkge1xuICAgICAgICAgICAgZm9yY2VMdHIgPSB0cnVlO1xuICAgICAgICAgICAgc3RhcnRDb250ZW50ID0gc2VjdGlvbldpZGdldHMubGVmdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0Q29udGVudCA9IHNlY3Rpb25XaWRnZXRzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWN0aW9uV2lkZ2V0cy5yaWdodCkge1xuICAgICAgICAgICAgZm9yY2VMdHIgPSB0cnVlO1xuICAgICAgICAgICAgZW5kQ29udGVudCA9IHNlY3Rpb25XaWRnZXRzLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kQ29udGVudCA9IHNlY3Rpb25XaWRnZXRzLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgIGV4dHJhQ2xhc3NOYW1lIHx8ICcnLFxuICAgICAgICAgICAgJ2ZjLXRvb2xiYXInLFxuICAgICAgICAgICAgZm9yY2VMdHIgPyAnZmMtdG9vbGJhci1sdHInIDogJycsXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJykgfSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2VjdGlvbignc3RhcnQnLCBzdGFydENvbnRlbnQgfHwgW10pLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdjZW50ZXInLCBjZW50ZXJDb250ZW50IHx8IFtdKSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2VjdGlvbignZW5kJywgZW5kQ29udGVudCB8fCBbXSkpKTtcbiAgICB9XG4gICAgcmVuZGVyU2VjdGlvbihrZXksIHdpZGdldEdyb3Vwcykge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRvb2xiYXJTZWN0aW9uLCB7IGtleToga2V5LCB3aWRnZXRHcm91cHM6IHdpZGdldEdyb3VwcywgdGl0bGU6IHByb3BzLnRpdGxlLCBuYXZVbml0OiBwcm9wcy5uYXZVbml0LCBhY3RpdmVCdXR0b246IHByb3BzLmFjdGl2ZUJ1dHRvbiwgaXNUb2RheUVuYWJsZWQ6IHByb3BzLmlzVG9kYXlFbmFibGVkLCBpc1ByZXZFbmFibGVkOiBwcm9wcy5pc1ByZXZFbmFibGVkLCBpc05leHRFbmFibGVkOiBwcm9wcy5pc05leHRFbmFibGVkLCB0aXRsZUlkOiBwcm9wcy50aXRsZUlkIH0pKTtcbiAgICB9XG59XG5cbmNsYXNzIFZpZXdIYXJuZXNzIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBhdmFpbGFibGVXaWR0aDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXZhaWxhYmxlV2lkdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF2YWlsYWJsZVdpZHRoKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBhc3BlY3RSYXRpbyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjLXZpZXctaGFybmVzcycsXG4gICAgICAgICAgICAoYXNwZWN0UmF0aW8gfHwgcHJvcHMubGlxdWlkIHx8IHByb3BzLmhlaWdodClcbiAgICAgICAgICAgICAgICA/ICdmYy12aWV3LWhhcm5lc3MtYWN0aXZlJyAvLyBoYXJuZXNzIGNvbnRyb2xzIHRoZSBoZWlnaHRcbiAgICAgICAgICAgICAgICA6ICdmYy12aWV3LWhhcm5lc3MtcGFzc2l2ZScsIC8vIGxldCB0aGUgdmlldyBkbyB0aGUgaGVpZ2h0XG4gICAgICAgIF07XG4gICAgICAgIGxldCBoZWlnaHQgPSAnJztcbiAgICAgICAgbGV0IHBhZGRpbmdCb3R0b20gPSAnJztcbiAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYXZhaWxhYmxlV2lkdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBzdGF0ZS5hdmFpbGFibGVXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgd2FpdGluZyB0byBrbm93IGF2YWlsYWJsZVdpZHRoLCB3ZSBjYW4ndCBzZXQgaGVpZ2h0IHRvICp6ZXJvKlxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2lsbCBjYXVzZSBsb3RzIG9mIHVubmVjZXNzYXJ5IHNjcm9sbGJhcnMgd2l0aGluIHNjcm9sbGdyaWQuXG4gICAgICAgICAgICAgICAgLy8gQkVUVEVSOiBkb24ndCBzdGFydCByZW5kZXJpbmcgQU5ZVEhJTkcgeWV0IHVudGlsIHdlIGtub3cgY29udGFpbmVyIHdpZHRoXG4gICAgICAgICAgICAgICAgLy8gTk9URTogd2h5IG5vdCBhbHdheXMgdXNlIHBhZGRpbmdCb3R0b20/IENhdXNlcyBoZWlnaHQgb3NjaWxsYXRpb24gKGlzc3VlIDU2MDYpXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbSA9IGAkeygxIC8gYXNwZWN0UmF0aW8pICogMTAwfSVgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0IHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHByb3BzLmxhYmVsZWRCeUlkLCByZWY6IHRoaXMuaGFuZGxlRWwsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodCwgcGFkZGluZ0JvdHRvbSB9IH0sIHByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmNvbnRleHQuYWRkUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmNvbnRleHQucmVtb3ZlUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfVxuICAgIHVwZGF0ZUF2YWlsYWJsZVdpZHRoKCkge1xuICAgICAgICBpZiAodGhpcy5lbCAmJiAvLyBuZWVkZWQuIGJ1dCB3aHk/XG4gICAgICAgICAgICB0aGlzLnByb3BzLmFzcGVjdFJhdGlvIC8vIGFzcGVjdFJhdGlvIGlzIHRoZSBvbmx5IGhlaWdodCBzZXR0aW5nIHRoYXQgbmVlZHMgYXZhaWxhYmxlV2lkdGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgYXZhaWxhYmxlV2lkdGg6IHRoaXMuZWwub2Zmc2V0V2lkdGggfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qXG5EZXRlY3RzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGFuIGV2ZW50IHdpdGhpbiBhIERhdGVDb21wb25lbnRcbiovXG5jbGFzcyBFdmVudENsaWNraW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWdDbGljayA9IChldiwgc2VnRWwpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IGNvbnRleHQgfSA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgICAgICBpZiAoc2VnICYmIC8vIG1pZ2h0IGJlIHRoZSA8ZGl2PiBzdXJyb3VuZGluZyB0aGUgbW9yZSBsaW5rXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIG91ciB3YXkgdG8gc2ltdWxhdGUgYSBsaW5rIGNsaWNrIGZvciBlbGVtZW50cyB0aGF0IGNhbid0IGJlIDxhPiB0YWdzXG4gICAgICAgICAgICAgICAgLy8gZ3JhYiBiZWZvcmUgdHJpZ2dlciBmaXJlZCBpbiBjYXNlIHRyaWdnZXIgdHJhc2hlcyBET00gdGhydSByZXJlbmRlcmluZ1xuICAgICAgICAgICAgICAgIGxldCBoYXNVcmxDb250YWluZXIgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsICcuZmMtZXZlbnQtZm9yY2VkLXVybCcpO1xuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBoYXNVcmxDb250YWluZXIgPyBoYXNVcmxDb250YWluZXIucXVlcnlTZWxlY3RvcignYVtocmVmXScpLmhyZWYgOiAnJztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb21wb25lbnQuY29udGV4dCwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHVybCAmJiAhZXYuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVzdHJveSA9IGxpc3RlbkJ5U2VsZWN0b3Ioc2V0dGluZ3MuZWwsICdjbGljaycsICcuZmMtZXZlbnQnLCAvLyBvbiBib3RoIGZnIGFuZCBiZyBldmVudHNcbiAgICAgICAgdGhpcy5oYW5kbGVTZWdDbGljayk7XG4gICAgfVxufVxuXG4vKlxuVHJpZ2dlcnMgZXZlbnRzIGFuZCBhZGRzL3JlbW92ZXMgY29yZSBjbGFzc05hbWVzIHdoZW4gdGhlIHVzZXIncyBwb2ludGVyXG5lbnRlcnMvbGVhdmVzIGV2ZW50LWVsZW1lbnRzIG9mIGEgY29tcG9uZW50LlxuKi9cbmNsYXNzIEV2ZW50SG92ZXJpbmcgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgICAgICAvLyBmb3Igc2ltdWxhdGluZyBhbiBldmVudE1vdXNlTGVhdmUgd2hlbiB0aGUgZXZlbnQgZWwgaXMgZGVzdHJveWVkIHdoaWxlIG1vdXNlIGlzIG92ZXIgaXRcbiAgICAgICAgdGhpcy5oYW5kbGVFdmVudEVsUmVtb3ZlID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwgPT09IHRoaXMuY3VycmVudFNlZ0VsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWdMZWF2ZShudWxsLCB0aGlzLmN1cnJlbnRTZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2VnRW50ZXIgPSAoZXYsIHNlZ0VsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZ2V0RWxTZWcoc2VnRWwpKSB7IC8vIFRPRE86IGJldHRlciB3YXkgdG8gbWFrZSBzdXJlIG5vdCBob3ZlcmluZyBvdmVyIG1vcmUrIGxpbmsgb3IgaXRzIHdyYXBwZXJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWdFbCA9IHNlZ0VsO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdldmVudE1vdXNlRW50ZXInLCBldiwgc2VnRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0xlYXZlID0gKGV2LCBzZWdFbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNlZ0VsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VnRWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KCdldmVudE1vdXNlTGVhdmUnLCBldiwgc2VnRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbW92ZUhvdmVyTGlzdGVuZXJzID0gbGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3Ioc2V0dGluZ3MuZWwsICcuZmMtZXZlbnQnLCAvLyBvbiBib3RoIGZnIGFuZCBiZyBldmVudHNcbiAgICAgICAgdGhpcy5oYW5kbGVTZWdFbnRlciwgdGhpcy5oYW5kbGVTZWdMZWF2ZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdHJpZ2dlckV2ZW50KHB1YmxpY0V2TmFtZSwgZXYsIHNlZ0VsKSB7XG4gICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gY29tcG9uZW50O1xuICAgICAgICBsZXQgc2VnID0gZ2V0RWxTZWcoc2VnRWwpO1xuICAgICAgICBpZiAoIWV2IHx8IGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2LnRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKHB1YmxpY0V2TmFtZSwge1xuICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBzZWcuZXZlbnRSYW5nZS5kZWYsIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ2FsZW5kYXJDb250ZW50IGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3Q29udGV4dCA9IG1lbW9pemUoYnVpbGRWaWV3Q29udGV4dCk7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyA9IG1lbW9pemUoYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyk7XG4gICAgICAgIHRoaXMuYnVpbGRUb29sYmFyUHJvcHMgPSBtZW1vaXplKGJ1aWxkVG9vbGJhclByb3BzKTtcbiAgICAgICAgdGhpcy5oZWFkZXJSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5mb290ZXJSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZSA9IHt9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHZpZXdMYWJlbElkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICAvLyBDb21wb25lbnQgUmVnaXN0cmF0aW9uXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCA9IChjb21wb25lbnQsIHNldHRpbmdzSW5wdXQpID0+IHtcbiAgICAgICAgICAgIGxldCBzZXR0aW5ncyA9IHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyhjb21wb25lbnQsIHNldHRpbmdzSW5wdXQpO1xuICAgICAgICAgICAgbGV0IERFRkFVTFRfSU5URVJBQ1RJT05TID0gW1xuICAgICAgICAgICAgICAgIEV2ZW50Q2xpY2tpbmcsXG4gICAgICAgICAgICAgICAgRXZlbnRIb3ZlcmluZyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25DbGFzc2VzID0gREVGQVVMVF9JTlRFUkFDVElPTlMuY29uY2F0KHRoaXMucHJvcHMucGx1Z2luSG9va3MuY29tcG9uZW50SW50ZXJhY3Rpb25zKTtcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbnMgPSBpbnRlcmFjdGlvbkNsYXNzZXMubWFwKChUaGVJbnRlcmFjdGlvbkNsYXNzKSA9PiBuZXcgVGhlSW50ZXJhY3Rpb25DbGFzcyhzZXR0aW5ncykpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXSA9IGludGVyYWN0aW9ucztcbiAgICAgICAgICAgIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXSA9IHNldHRpbmdzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCA9IChjb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVzaXppbmdcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdGhpcy5yZXNpemVSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignX3Jlc2l6ZScsIHRydWUpOyAvLyBzaG91bGQgd2luZG93IHJlc2l6ZXMgYmUgY29uc2lkZXJlZCBcImZvcmNlZFwiID9cbiAgICAgICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCd3aW5kb3dSZXNpemUnLCB7IHZpZXc6IHRoaXMucHJvcHMudmlld0FwaSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlV2luZG93UmVzaXplID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFuZGxlV2luZG93UmVzaXplICYmXG4gICAgICAgICAgICAgICAgZXYudGFyZ2V0ID09PSB3aW5kb3cgLy8gYXZvaWQganF1aSBldmVudHNcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplUnVubmVyLnJlcXVlc3Qob3B0aW9ucy53aW5kb3dSZXNpemVEZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qXG4gICAgcmVuZGVycyBJTlNJREUgb2YgYW4gb3V0ZXIgZGl2XG4gICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyB0b29sYmFyQ29uZmlnLCBvcHRpb25zIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHRvb2xiYXJQcm9wcyA9IHRoaXMuYnVpbGRUb29sYmFyUHJvcHMocHJvcHMudmlld1NwZWMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvciwgcHJvcHMuY3VycmVudERhdGUsIGdldE5vdyhwcm9wcy5vcHRpb25zLm5vdywgcHJvcHMuZGF0ZUVudiksIC8vIFRPRE86IHVzZSBOb3dUaW1lcj8/Pz9cbiAgICAgICAgcHJvcHMudmlld1RpdGxlKTtcbiAgICAgICAgbGV0IHZpZXdWR3JvdyA9IGZhbHNlO1xuICAgICAgICBsZXQgdmlld0hlaWdodCA9ICcnO1xuICAgICAgICBsZXQgdmlld0FzcGVjdFJhdGlvO1xuICAgICAgICBpZiAocHJvcHMuaXNIZWlnaHRBdXRvIHx8IHByb3BzLmZvclByaW50KSB7XG4gICAgICAgICAgICB2aWV3SGVpZ2h0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmlld1ZHcm93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNvbnRlbnRIZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmlld0hlaWdodCA9IG9wdGlvbnMuY29udGVudEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXdBc3BlY3RSYXRpbyA9IE1hdGgubWF4KG9wdGlvbnMuYXNwZWN0UmF0aW8sIDAuNSk7IC8vIHByZXZlbnQgZnJvbSBnZXR0aW5nIHRvbyB0YWxsXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpZXdDb250ZXh0ID0gdGhpcy5idWlsZFZpZXdDb250ZXh0KHByb3BzLnZpZXdTcGVjLCBwcm9wcy52aWV3QXBpLCBwcm9wcy5vcHRpb25zLCBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvciwgcHJvcHMuZGF0ZUVudiwgcHJvcHMudGhlbWUsIHByb3BzLnBsdWdpbkhvb2tzLCBwcm9wcy5kaXNwYXRjaCwgcHJvcHMuZ2V0Q3VycmVudERhdGEsIHByb3BzLmVtaXR0ZXIsIHByb3BzLmNhbGVuZGFyQXBpLCB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsIHRoaXMudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KTtcbiAgICAgICAgbGV0IHZpZXdMYWJlbElkID0gKHRvb2xiYXJDb25maWcuaGVhZGVyICYmIHRvb2xiYXJDb25maWcuaGVhZGVyLmhhc1RpdGxlKVxuICAgICAgICAgICAgPyB0aGlzLnN0YXRlLnZpZXdMYWJlbElkXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Qcm92aWRlciwgeyB2YWx1ZTogdmlld0NvbnRleHQgfSxcbiAgICAgICAgICAgIHRvb2xiYXJDb25maWcuaGVhZGVyICYmIChjcmVhdGVFbGVtZW50KFRvb2xiYXIsIE9iamVjdC5hc3NpZ24oeyByZWY6IHRoaXMuaGVhZGVyUmVmLCBleHRyYUNsYXNzTmFtZTogXCJmYy1oZWFkZXItdG9vbGJhclwiLCBtb2RlbDogdG9vbGJhckNvbmZpZy5oZWFkZXIsIHRpdGxlSWQ6IHZpZXdMYWJlbElkIH0sIHRvb2xiYXJQcm9wcykpKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVmlld0hhcm5lc3MsIHsgbGlxdWlkOiB2aWV3Vkdyb3csIGhlaWdodDogdmlld0hlaWdodCwgYXNwZWN0UmF0aW86IHZpZXdBc3BlY3RSYXRpbywgbGFiZWxlZEJ5SWQ6IHZpZXdMYWJlbElkIH0sXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KHByb3BzKSxcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkQXBwZW5kQ29udGVudCgpKSxcbiAgICAgICAgICAgIHRvb2xiYXJDb25maWcuZm9vdGVyICYmIChjcmVhdGVFbGVtZW50KFRvb2xiYXIsIE9iamVjdC5hc3NpZ24oeyByZWY6IHRoaXMuZm9vdGVyUmVmLCBleHRyYUNsYXNzTmFtZTogXCJmYy1mb290ZXItdG9vbGJhclwiLCBtb2RlbDogdG9vbGJhckNvbmZpZy5mb290ZXIsIHRpdGxlSWQ6IFwiXCIgfSwgdG9vbGJhclByb3BzKSkpKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5jYWxlbmRhckludGVyYWN0aW9ucyA9IHByb3BzLnBsdWdpbkhvb2tzLmNhbGVuZGFySW50ZXJhY3Rpb25zXG4gICAgICAgICAgICAubWFwKChDYWxlbmRhckludGVyYWN0aW9uQ2xhc3MpID0+IG5ldyBDYWxlbmRhckludGVyYWN0aW9uQ2xhc3MocHJvcHMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlV2luZG93UmVzaXplKTtcbiAgICAgICAgbGV0IHsgcHJvcFNldEhhbmRsZXJzIH0gPSBwcm9wcy5wbHVnaW5Ib29rcztcbiAgICAgICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcHJvcFNldEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBwcm9wU2V0SGFuZGxlcnNbcHJvcE5hbWVdKHByb3BzW3Byb3BOYW1lXSwgcHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHByb3BTZXRIYW5kbGVycyB9ID0gcHJvcHMucGx1Z2luSG9va3M7XG4gICAgICAgIGZvciAobGV0IHByb3BOYW1lIGluIHByb3BTZXRIYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSAhPT0gcHJldlByb3BzW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyc1twcm9wTmFtZV0ocHJvcHNbcHJvcE5hbWVdLCBwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG4gICAgICAgIHRoaXMucmVzaXplUnVubmVyLmNsZWFyKCk7XG4gICAgICAgIGZvciAobGV0IGludGVyYWN0aW9uIG9mIHRoaXMuY2FsZW5kYXJJbnRlcmFjdGlvbnMpIHtcbiAgICAgICAgICAgIGludGVyYWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignX3VubW91bnQnKTtcbiAgICB9XG4gICAgYnVpbGRBcHBlbmRDb250ZW50KCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gcHJvcHMucGx1Z2luSG9va3Mudmlld0NvbnRhaW5lckFwcGVuZHMubWFwKChidWlsZEFwcGVuZENvbnRlbnQpID0+IGJ1aWxkQXBwZW5kQ29udGVudChwcm9wcykpO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwge30sIC4uLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmVuZGVyVmlldyhwcm9wcykge1xuICAgICAgICBsZXQgeyBwbHVnaW5Ib29rcyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB7IHZpZXdTcGVjIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHZpZXdQcm9wcyA9IHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBwcm9wcy5yZW5kZXJhYmxlRXZlbnRTdG9yZSxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlczogcHJvcHMuZXZlbnRVaUJhc2VzLFxuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogcHJvcHMuZGF0ZVNlbGVjdGlvbixcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbixcbiAgICAgICAgICAgIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLFxuICAgICAgICAgICAgaXNIZWlnaHRBdXRvOiBwcm9wcy5pc0hlaWdodEF1dG8sXG4gICAgICAgICAgICBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsXG4gICAgICAgIH07XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lcnMgPSB0aGlzLmJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMocGx1Z2luSG9va3Mudmlld1Byb3BzVHJhbnNmb3JtZXJzKTtcbiAgICAgICAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHZpZXdQcm9wcywgdHJhbnNmb3JtZXIudHJhbnNmb3JtKHZpZXdQcm9wcywgcHJvcHMpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgVmlld0NvbXBvbmVudCA9IHZpZXdTcGVjLmNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb21wb25lbnQsIE9iamVjdC5hc3NpZ24oe30sIHZpZXdQcm9wcykpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFRvb2xiYXJQcm9wcyh2aWV3U3BlYywgZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCBjdXJyZW50RGF0ZSwgbm93LCB0aXRsZSkge1xuICAgIC8vIGRvbid0IGZvcmNlIGFueSBkYXRlLXByb2ZpbGVzIHRvIHZhbGlkIGRhdGUgcHJvZmlsZXMgKHRoZSBgZmFsc2VgKSBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIGl0J3MgaW52YWxpZFxuICAgIGxldCB0b2RheUluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChub3csIHVuZGVmaW5lZCwgZmFsc2UpOyAvLyBUT0RPOiBuZWVkIGB1bmRlZmluZWRgIG9yIGVsc2UgSU5GSU5JVEUgTE9PUCBmb3Igc29tZSByZWFzb25cbiAgICBsZXQgcHJldkluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYoZGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmYWxzZSk7XG4gICAgbGV0IG5leHRJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICBhY3RpdmVCdXR0b246IHZpZXdTcGVjLnR5cGUsXG4gICAgICAgIG5hdlVuaXQ6IHZpZXdTcGVjLnNpbmdsZVVuaXQsXG4gICAgICAgIGlzVG9kYXlFbmFibGVkOiB0b2RheUluZm8uaXNWYWxpZCAmJiAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIG5vdyksXG4gICAgICAgIGlzUHJldkVuYWJsZWQ6IHByZXZJbmZvLmlzVmFsaWQsXG4gICAgICAgIGlzTmV4dEVuYWJsZWQ6IG5leHRJbmZvLmlzVmFsaWQsXG4gICAgfTtcbn1cbi8vIFBsdWdpblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnModGhlQ2xhc3Nlcykge1xuICAgIHJldHVybiB0aGVDbGFzc2VzLm1hcCgoVGhlQ2xhc3MpID0+IG5ldyBUaGVDbGFzcygpKTtcbn1cblxuY2xhc3MgQ2FsZW5kYXIgZXh0ZW5kcyBDYWxlbmRhckltcGwge1xuICAgIGNvbnN0cnVjdG9yKGVsLCBvcHRpb25PdmVycmlkZXMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnRDbGFzc05hbWVzID0gW107XG4gICAgICAgIHRoaXMuY3VzdG9tQ29udGVudFJlbmRlcklkID0gMDtcbiAgICAgICAgdGhpcy5oYW5kbGVBY3Rpb24gPSAoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAvLyBhY3Rpb25zIHdlIGtub3cgd2Ugd2FudCB0byByZW5kZXIgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdTRVRfRVZFTlRfRFJBRyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnRyeURyYWluKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRGF0YSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlcXVlc3QoZGF0YS5jYWxlbmRhck9wdGlvbnMucmVyZW5kZXJEZWxheSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUmVuZGVyUmVxdWVzdCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgeyBjdXJyZW50RGF0YSB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXIoY3JlYXRlRWxlbWVudChDYWxlbmRhclJvb3QsIHsgb3B0aW9uczogY3VycmVudERhdGEuY2FsZW5kYXJPcHRpb25zLCB0aGVtZTogY3VycmVudERhdGEudGhlbWUsIGVtaXR0ZXI6IGN1cnJlbnREYXRhLmVtaXR0ZXIgfSwgKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDbGFzc05hbWVzKGNsYXNzTmFtZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQoaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChSZW5kZXJJZC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcy5jdXN0b21Db250ZW50UmVuZGVySWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KENhbGVuZGFyQ29udGVudCwgT2JqZWN0LmFzc2lnbih7IGlzSGVpZ2h0QXV0bzogaXNIZWlnaHRBdXRvLCBmb3JQcmludDogZm9yUHJpbnQgfSwgY3VycmVudERhdGEpKSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSwgdGhpcy5lbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzUmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUmVuZGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZW5kZXIobnVsbCwgdGhpcy5lbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDbGFzc05hbWVzKFtdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhlaWdodCgnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGVuc3VyZUVsSGFzU3R5bGVzKGVsKTtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLnJlbmRlclJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKHRoaXMuaGFuZGxlUmVuZGVyUmVxdWVzdCk7XG4gICAgICAgIG5ldyBDYWxlbmRhckRhdGFNYW5hZ2VyKHtcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiB0aGlzLFxuICAgICAgICAgICAgb25BY3Rpb246IHRoaXMuaGFuZGxlQWN0aW9uLFxuICAgICAgICAgICAgb25EYXRhOiB0aGlzLmhhbmRsZURhdGEsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB3YXNSZW5kZXJpbmcgPSB0aGlzLmlzUmVuZGVyaW5nO1xuICAgICAgICBpZiAoIXdhc1JlbmRlcmluZykge1xuICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbUNvbnRlbnRSZW5kZXJJZCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlcXVlc3QoKTtcbiAgICAgICAgaWYgKHdhc1JlbmRlcmluZykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlcXVlc3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTaXplKCkge1xuICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgc3VwZXIudXBkYXRlU2l6ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYmF0Y2hSZW5kZXJpbmcoZnVuYykge1xuICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5wYXVzZSgnYmF0Y2hSZW5kZXJpbmcnKTtcbiAgICAgICAgZnVuYygpO1xuICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXN1bWUoJ2JhdGNoUmVuZGVyaW5nJyk7XG4gICAgfVxuICAgIHBhdXNlUmVuZGVyaW5nKCkge1xuICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5wYXVzZSgncGF1c2VSZW5kZXJpbmcnKTtcbiAgICB9XG4gICAgcmVzdW1lUmVuZGVyaW5nKCkge1xuICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXN1bWUoJ3BhdXNlUmVuZGVyaW5nJywgdHJ1ZSk7XG4gICAgfVxuICAgIHJlc2V0T3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGNoYW5nZWRPcHRpb25OYW1lcykge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5yZXNldE9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBjaGFuZ2VkT3B0aW9uTmFtZXMpO1xuICAgIH1cbiAgICBzZXRDbGFzc05hbWVzKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgaWYgKCFpc0FycmF5c0VxdWFsKGNsYXNzTmFtZXMsIHRoaXMuY3VycmVudENsYXNzTmFtZXMpKSB7XG4gICAgICAgICAgICBsZXQgeyBjbGFzc0xpc3QgfSA9IHRoaXMuZWw7XG4gICAgICAgICAgICBmb3IgKGxldCBjbGFzc05hbWUgb2YgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcykge1xuICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICBhcHBseVN0eWxlUHJvcCh0aGlzLmVsLCAnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZUlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgZGF0ZUVudiA9IGJ1aWxkRGF0ZUVudihvcHRpb25zKTtcbiAgICBsZXQgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMpO1xuICAgIGxldCBkYXRlTWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShkYXRlSW5wdXQpO1xuICAgIGlmICghZGF0ZU1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZU1ldGEubWFya2VyLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgZm9yY2VkVHpvOiBkYXRlTWV0YS5mb3JjZWRUem8sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRSYW5nZShzdGFydElucHV0LCBlbmRJbnB1dCwgb3B0aW9ucykge1xuICAgIGxldCBkYXRlRW52ID0gYnVpbGREYXRlRW52KHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zID8gb3B0aW9ucyA6IHt9KTsgLy8gcGFzcyBpbiBpZiBub24tbnVsbCBvYmplY3RcbiAgICBsZXQgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMpO1xuICAgIGxldCBzdGFydE1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhcnRJbnB1dCk7XG4gICAgbGV0IGVuZE1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoZW5kSW5wdXQpO1xuICAgIGlmICghc3RhcnRNZXRhIHx8ICFlbmRNZXRhKSB7IC8vIFRPRE86IHdhcm5pbmc/XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2Uoc3RhcnRNZXRhLm1hcmtlciwgZW5kTWV0YS5tYXJrZXIsIGZvcm1hdHRlciwge1xuICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRNZXRhLmZvcmNlZFR6byxcbiAgICAgICAgZm9yY2VkRW5kVHpvOiBlbmRNZXRhLmZvcmNlZFR6byxcbiAgICAgICAgaXNFbmRFeGNsdXNpdmU6IG9wdGlvbnMuaXNFbmRFeGNsdXNpdmUsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmRlZmF1bHRSYW5nZVNlcGFyYXRvcixcbiAgICB9KTtcbn1cbi8vIFRPRE86IG1vcmUgRFJZIGFuZCBvcHRpbWl6ZWRcbmZ1bmN0aW9uIGJ1aWxkRGF0ZUVudihzZXR0aW5ncykge1xuICAgIGxldCBsb2NhbGUgPSBidWlsZExvY2FsZShzZXR0aW5ncy5sb2NhbGUgfHwgJ2VuJywgb3JnYW5pemVSYXdMb2NhbGVzKFtdKS5tYXApOyAvLyBUT0RPOiBkb24ndCBoYXJkY29kZSAnZW4nIGV2ZXJ5d2hlcmVcbiAgICByZXR1cm4gbmV3IERhdGVFbnYoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdGltZVpvbmU6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLnRpbWVab25lLCBjYWxlbmRhclN5c3RlbTogJ2dyZWdvcnknIH0sIHNldHRpbmdzKSwgeyBsb2NhbGUgfSkpO1xufVxuXG4vLyBIRUxQRVJTXG4vKlxuaWYgbmV4dERheVRocmVzaG9sZCBpcyBzcGVjaWZpZWQsIHNsaWNpbmcgaXMgZG9uZSBpbiBhbiBhbGwtZGF5IGZhc2hpb24uXG55b3UgY2FuIGdldCBuZXh0RGF5VGhyZXNob2xkIGZyb20gY29udGV4dC5uZXh0RGF5VGhyZXNob2xkXG4qL1xuZnVuY3Rpb24gc2xpY2VFdmVudHMocHJvcHMsIGFsbERheSkge1xuICAgIHJldHVybiBzbGljZUV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgcHJvcHMuZXZlbnRVaUJhc2VzLCBwcm9wcy5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgYWxsRGF5ID8gcHJvcHMubmV4dERheVRocmVzaG9sZCA6IG51bGwpLmZnO1xufVxuXG5jb25zdCB2ZXJzaW9uID0gJzYuMS4xNSc7XG5cbmV4cG9ydCB7IENhbGVuZGFyLCBjcmVhdGVQbHVnaW4sIGZvcm1hdERhdGUsIGZvcm1hdFJhbmdlLCBnbG9iYWxMb2NhbGVzLCBnbG9iYWxQbHVnaW5zLCBzbGljZUV2ZW50cywgdmVyc2lvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@fullcalendar/core/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@fullcalendar/core/internal-common.js":
/*!*************************************************************!*\
  !*** ../node_modules/@fullcalendar/core/internal-common.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: function() { return /* binding */ elementClosest; },\n/* harmony export */   A: function() { return /* binding */ memoizeObjArg; },\n/* harmony export */   B: function() { return /* binding */ BaseComponent; },\n/* harmony export */   C: function() { return /* binding */ ContentContainer; },\n/* harmony export */   D: function() { return /* binding */ DelayedRunner; },\n/* harmony export */   E: function() { return /* binding */ isPropsEqual; },\n/* harmony export */   F: function() { return /* binding */ Emitter; },\n/* harmony export */   G: function() { return /* binding */ getInitialDate; },\n/* harmony export */   H: function() { return /* binding */ rangeContainsMarker; },\n/* harmony export */   I: function() { return /* binding */ createEmptyEventStore; },\n/* harmony export */   J: function() { return /* binding */ reduceCurrentDate; },\n/* harmony export */   K: function() { return /* binding */ reduceEventStore; },\n/* harmony export */   L: function() { return /* binding */ rezoneEventStoreDates; },\n/* harmony export */   M: function() { return /* binding */ mergeRawOptions; },\n/* harmony export */   N: function() { return /* binding */ BASE_OPTION_REFINERS; },\n/* harmony export */   O: function() { return /* binding */ CALENDAR_LISTENER_REFINERS; },\n/* harmony export */   P: function() { return /* binding */ CALENDAR_OPTION_REFINERS; },\n/* harmony export */   Q: function() { return /* binding */ COMPLEX_OPTION_COMPARATORS; },\n/* harmony export */   R: function() { return /* binding */ VIEW_OPTION_REFINERS; },\n/* harmony export */   S: function() { return /* binding */ DateEnv; },\n/* harmony export */   T: function() { return /* binding */ Theme; },\n/* harmony export */   U: function() { return /* binding */ DateProfileGenerator; },\n/* harmony export */   V: function() { return /* binding */ ViewContextType; },\n/* harmony export */   W: function() { return /* binding */ createEventUi; },\n/* harmony export */   X: function() { return /* binding */ parseBusinessHours; },\n/* harmony export */   Y: function() { return /* binding */ setRef; },\n/* harmony export */   Z: function() { return /* binding */ Interaction; },\n/* harmony export */   _: function() { return /* binding */ getElSeg; },\n/* harmony export */   a: function() { return /* binding */ mapHash; },\n/* harmony export */   a$: function() { return /* binding */ getSlotClassNames; },\n/* harmony export */   a0: function() { return /* binding */ EventImpl; },\n/* harmony export */   a1: function() { return /* binding */ listenBySelector; },\n/* harmony export */   a2: function() { return /* binding */ listenToHoverBySelector; },\n/* harmony export */   a3: function() { return /* binding */ PureComponent; },\n/* harmony export */   a4: function() { return /* binding */ buildViewContext; },\n/* harmony export */   a5: function() { return /* binding */ getUniqueDomId; },\n/* harmony export */   a6: function() { return /* binding */ parseInteractionSettings; },\n/* harmony export */   a7: function() { return /* binding */ interactionSettingsStore; },\n/* harmony export */   a8: function() { return /* binding */ getNow; },\n/* harmony export */   a9: function() { return /* binding */ CalendarImpl; },\n/* harmony export */   aA: function() { return /* binding */ diffDates; },\n/* harmony export */   aB: function() { return /* binding */ removeExact; },\n/* harmony export */   aC: function() { return /* binding */ memoizeArraylike; },\n/* harmony export */   aD: function() { return /* binding */ memoizeHashlike; },\n/* harmony export */   aE: function() { return /* binding */ intersectRects; },\n/* harmony export */   aF: function() { return /* binding */ pointInsideRect; },\n/* harmony export */   aG: function() { return /* binding */ constrainPoint; },\n/* harmony export */   aH: function() { return /* binding */ getRectCenter; },\n/* harmony export */   aI: function() { return /* binding */ diffPoints; },\n/* harmony export */   aJ: function() { return /* binding */ translateRect; },\n/* harmony export */   aK: function() { return /* binding */ compareObjs; },\n/* harmony export */   aL: function() { return /* binding */ collectFromHash; },\n/* harmony export */   aM: function() { return /* binding */ findElements; },\n/* harmony export */   aN: function() { return /* binding */ findDirectChildren; },\n/* harmony export */   aO: function() { return /* binding */ removeElement; },\n/* harmony export */   aP: function() { return /* binding */ applyStyle; },\n/* harmony export */   aQ: function() { return /* binding */ elementMatches; },\n/* harmony export */   aR: function() { return /* binding */ getEventTargetViaRoot; },\n/* harmony export */   aS: function() { return /* binding */ parseClassNames; },\n/* harmony export */   aT: function() { return /* binding */ getCanVGrowWithinCell; },\n/* harmony export */   aU: function() { return /* binding */ mergeEventStores; },\n/* harmony export */   aV: function() { return /* binding */ getRelevantEvents; },\n/* harmony export */   aW: function() { return /* binding */ eventTupleToStore; },\n/* harmony export */   aX: function() { return /* binding */ combineEventUis; },\n/* harmony export */   aY: function() { return /* binding */ Splitter; },\n/* harmony export */   aZ: function() { return /* binding */ getDayClassNames; },\n/* harmony export */   a_: function() { return /* binding */ getDateMeta; },\n/* harmony export */   aa: function() { return /* binding */ flushSync; },\n/* harmony export */   ab: function() { return /* binding */ CalendarRoot; },\n/* harmony export */   ac: function() { return /* binding */ RenderId; },\n/* harmony export */   ad: function() { return /* binding */ ensureElHasStyles; },\n/* harmony export */   ae: function() { return /* binding */ applyStyleProp; },\n/* harmony export */   af: function() { return /* binding */ sliceEventStore; },\n/* harmony export */   ag: function() { return /* binding */ JsonRequestError; },\n/* harmony export */   ah: function() { return /* binding */ createContext; },\n/* harmony export */   ai: function() { return /* binding */ refineProps; },\n/* harmony export */   aj: function() { return /* binding */ createEventInstance; },\n/* harmony export */   ak: function() { return /* binding */ parseEventDef; },\n/* harmony export */   al: function() { return /* binding */ refineEventDef; },\n/* harmony export */   am: function() { return /* binding */ padStart; },\n/* harmony export */   an: function() { return /* binding */ isInt; },\n/* harmony export */   ao: function() { return /* binding */ parseFieldSpecs; },\n/* harmony export */   ap: function() { return /* binding */ compareByFieldSpecs; },\n/* harmony export */   aq: function() { return /* binding */ flexibleCompare; },\n/* harmony export */   ar: function() { return /* binding */ preventSelection; },\n/* harmony export */   as: function() { return /* binding */ allowSelection; },\n/* harmony export */   at: function() { return /* binding */ preventContextMenu; },\n/* harmony export */   au: function() { return /* binding */ allowContextMenu; },\n/* harmony export */   av: function() { return /* binding */ compareNumbers; },\n/* harmony export */   aw: function() { return /* binding */ enableCursor; },\n/* harmony export */   ax: function() { return /* binding */ disableCursor; },\n/* harmony export */   ay: function() { return /* binding */ computeVisibleDayRange; },\n/* harmony export */   az: function() { return /* binding */ isMultiDayRange; },\n/* harmony export */   b: function() { return /* binding */ buildViewClassNames; },\n/* harmony export */   b$: function() { return /* binding */ SimpleScrollGrid; },\n/* harmony export */   b0: function() { return /* binding */ buildNavLinkAttrs; },\n/* harmony export */   b1: function() { return /* binding */ preventDefault; },\n/* harmony export */   b2: function() { return /* binding */ whenTransitionDone; },\n/* harmony export */   b3: function() { return /* binding */ computeInnerRect; },\n/* harmony export */   b4: function() { return /* binding */ computeEdges; },\n/* harmony export */   b5: function() { return /* binding */ getClippingParents; },\n/* harmony export */   b6: function() { return /* binding */ computeRect; },\n/* harmony export */   b7: function() { return /* binding */ rangesEqual; },\n/* harmony export */   b8: function() { return /* binding */ rangesIntersect; },\n/* harmony export */   b9: function() { return /* binding */ rangeContainsRange; },\n/* harmony export */   bA: function() { return /* binding */ SegHierarchy; },\n/* harmony export */   bB: function() { return /* binding */ buildEntryKey; },\n/* harmony export */   bC: function() { return /* binding */ getEntrySpanEnd; },\n/* harmony export */   bD: function() { return /* binding */ binarySearch; },\n/* harmony export */   bE: function() { return /* binding */ groupIntersectingEntries; },\n/* harmony export */   bF: function() { return /* binding */ intersectSpans; },\n/* harmony export */   bG: function() { return /* binding */ interactionSettingsToStore; },\n/* harmony export */   bH: function() { return /* binding */ ElementDragging; },\n/* harmony export */   bI: function() { return /* binding */ config; },\n/* harmony export */   bJ: function() { return /* binding */ parseDragMeta; },\n/* harmony export */   bK: function() { return /* binding */ DayHeader; },\n/* harmony export */   bL: function() { return /* binding */ computeFallbackHeaderFormat; },\n/* harmony export */   bM: function() { return /* binding */ TableDateCell; },\n/* harmony export */   bN: function() { return /* binding */ TableDowCell; },\n/* harmony export */   bO: function() { return /* binding */ DaySeriesModel; },\n/* harmony export */   bP: function() { return /* binding */ hasBgRendering; },\n/* harmony export */   bQ: function() { return /* binding */ buildSegTimeText; },\n/* harmony export */   bR: function() { return /* binding */ sortEventSegs; },\n/* harmony export */   bS: function() { return /* binding */ getSegMeta; },\n/* harmony export */   bT: function() { return /* binding */ buildEventRangeKey; },\n/* harmony export */   bU: function() { return /* binding */ getSegAnchorAttrs; },\n/* harmony export */   bV: function() { return /* binding */ DayTableModel; },\n/* harmony export */   bW: function() { return /* binding */ Slicer; },\n/* harmony export */   bX: function() { return /* binding */ applyMutationToEventStore; },\n/* harmony export */   bY: function() { return /* binding */ isPropsValid; },\n/* harmony export */   bZ: function() { return /* binding */ isInteractionValid; },\n/* harmony export */   b_: function() { return /* binding */ isDateSelectionValid; },\n/* harmony export */   ba: function() { return /* binding */ PositionCache; },\n/* harmony export */   bb: function() { return /* binding */ ScrollController; },\n/* harmony export */   bc: function() { return /* binding */ ElementScrollController; },\n/* harmony export */   bd: function() { return /* binding */ WindowScrollController; },\n/* harmony export */   be: function() { return /* binding */ DateComponent; },\n/* harmony export */   bf: function() { return /* binding */ isDateSpansEqual; },\n/* harmony export */   bg: function() { return /* binding */ addMs; },\n/* harmony export */   bh: function() { return /* binding */ addWeeks; },\n/* harmony export */   bi: function() { return /* binding */ diffWeeks; },\n/* harmony export */   bj: function() { return /* binding */ diffWholeWeeks; },\n/* harmony export */   bk: function() { return /* binding */ diffDayAndTime; },\n/* harmony export */   bl: function() { return /* binding */ diffDays; },\n/* harmony export */   bm: function() { return /* binding */ isValidDate; },\n/* harmony export */   bn: function() { return /* binding */ asCleanDays; },\n/* harmony export */   bo: function() { return /* binding */ multiplyDuration; },\n/* harmony export */   bp: function() { return /* binding */ addDurations; },\n/* harmony export */   bq: function() { return /* binding */ asRoughMinutes; },\n/* harmony export */   br: function() { return /* binding */ asRoughSeconds; },\n/* harmony export */   bs: function() { return /* binding */ asRoughMs; },\n/* harmony export */   bt: function() { return /* binding */ wholeDivideDurations; },\n/* harmony export */   bu: function() { return /* binding */ formatIsoTimeString; },\n/* harmony export */   bv: function() { return /* binding */ formatDayString; },\n/* harmony export */   bw: function() { return /* binding */ buildIsoString; },\n/* harmony export */   bx: function() { return /* binding */ formatIsoMonthStr; },\n/* harmony export */   by: function() { return /* binding */ NamedTimeZoneImpl; },\n/* harmony export */   bz: function() { return /* binding */ parse; },\n/* harmony export */   c: function() { return /* binding */ greatestDurationDenominator; },\n/* harmony export */   c0: function() { return /* binding */ hasShrinkWidth; },\n/* harmony export */   c1: function() { return /* binding */ renderMicroColGroup; },\n/* harmony export */   c2: function() { return /* binding */ getScrollGridClassNames; },\n/* harmony export */   c3: function() { return /* binding */ getSectionClassNames; },\n/* harmony export */   c4: function() { return /* binding */ getSectionHasLiquidHeight; },\n/* harmony export */   c5: function() { return /* binding */ getAllowYScrolling; },\n/* harmony export */   c6: function() { return /* binding */ renderChunkContent; },\n/* harmony export */   c7: function() { return /* binding */ computeShrinkWidth; },\n/* harmony export */   c8: function() { return /* binding */ sanitizeShrinkWidth; },\n/* harmony export */   c9: function() { return /* binding */ isColPropsEqual; },\n/* harmony export */   ca: function() { return /* binding */ renderScrollShim; },\n/* harmony export */   cb: function() { return /* binding */ getStickyFooterScrollbar; },\n/* harmony export */   cc: function() { return /* binding */ getStickyHeaderDates; },\n/* harmony export */   cd: function() { return /* binding */ Scroller; },\n/* harmony export */   ce: function() { return /* binding */ getScrollbarWidths; },\n/* harmony export */   cf: function() { return /* binding */ RefMap; },\n/* harmony export */   cg: function() { return /* binding */ getIsRtlScrollbarOnLeft; },\n/* harmony export */   ch: function() { return /* binding */ NowTimer; },\n/* harmony export */   ci: function() { return /* binding */ ScrollResponder; },\n/* harmony export */   cj: function() { return /* binding */ StandardEvent; },\n/* harmony export */   ck: function() { return /* binding */ NowIndicatorContainer; },\n/* harmony export */   cl: function() { return /* binding */ DayCellContainer; },\n/* harmony export */   cm: function() { return /* binding */ hasCustomDayCellContent; },\n/* harmony export */   cn: function() { return /* binding */ EventContainer; },\n/* harmony export */   co: function() { return /* binding */ renderFill; },\n/* harmony export */   cp: function() { return /* binding */ BgEvent; },\n/* harmony export */   cq: function() { return /* binding */ WeekNumberContainer; },\n/* harmony export */   cr: function() { return /* binding */ MoreLinkContainer; },\n/* harmony export */   cs: function() { return /* binding */ computeEarliestSegStart; },\n/* harmony export */   ct: function() { return /* binding */ ViewContainer; },\n/* harmony export */   cu: function() { return /* binding */ triggerDateSelect; },\n/* harmony export */   cv: function() { return /* binding */ getDefaultEventEnd; },\n/* harmony export */   cw: function() { return /* binding */ injectStyles; },\n/* harmony export */   cx: function() { return /* binding */ buildElAttrs; },\n/* harmony export */   cy: function() { return /* binding */ CustomRenderingStore; },\n/* harmony export */   d: function() { return /* binding */ createDuration; },\n/* harmony export */   e: function() { return /* binding */ BASE_OPTION_DEFAULTS; },\n/* harmony export */   f: function() { return /* binding */ arrayToHash; },\n/* harmony export */   g: function() { return /* binding */ guid; },\n/* harmony export */   h: function() { return /* binding */ filterHash; },\n/* harmony export */   i: function() { return /* binding */ isArraysEqual; },\n/* harmony export */   j: function() { return /* binding */ buildEventSourceRefiners; },\n/* harmony export */   k: function() { return /* binding */ formatWithOrdinals; },\n/* harmony export */   l: function() { return /* binding */ buildRangeApiWithTimeZone; },\n/* harmony export */   m: function() { return /* binding */ mergeProps; },\n/* harmony export */   n: function() { return /* binding */ identity; },\n/* harmony export */   o: function() { return /* binding */ intersectRanges; },\n/* harmony export */   p: function() { return /* binding */ parseEventSource; },\n/* harmony export */   q: function() { return /* binding */ startOfDay; },\n/* harmony export */   r: function() { return /* binding */ requestJson; },\n/* harmony export */   s: function() { return /* binding */ subtractDurations; },\n/* harmony export */   t: function() { return /* binding */ addDays; },\n/* harmony export */   u: function() { return /* binding */ unpromisify; },\n/* harmony export */   v: function() { return /* binding */ hashValuesToArray; },\n/* harmony export */   w: function() { return /* binding */ buildEventApis; },\n/* harmony export */   x: function() { return /* binding */ createFormatter; },\n/* harmony export */   y: function() { return /* binding */ diffWholeDays; },\n/* harmony export */   z: function() { return /* binding */ memoize; }\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"(app-pages-browser)/../node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var preact_compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/compat */ \"(app-pages-browser)/../node_modules/preact/compat/dist/compat.module.js\");\n\n\n\n\nconst styleTexts = [];\nconst styleEls = new Map();\nfunction injectStyles(styleText) {\n    styleTexts.push(styleText);\n    styleEls.forEach((styleEl) => {\n        appendStylesTo(styleEl, styleText);\n    });\n}\nfunction ensureElHasStyles(el) {\n    if (el.isConnected && // sometimes true if SSR system simulates DOM\n        el.getRootNode // sometimes undefined if SSR system simulates DOM\n    ) {\n        registerStylesRoot(el.getRootNode());\n    }\n}\nfunction registerStylesRoot(rootNode) {\n    let styleEl = styleEls.get(rootNode);\n    if (!styleEl || !styleEl.isConnected) {\n        styleEl = rootNode.querySelector('style[data-fullcalendar]');\n        if (!styleEl) {\n            styleEl = document.createElement('style');\n            styleEl.setAttribute('data-fullcalendar', '');\n            const nonce = getNonceValue();\n            if (nonce) {\n                styleEl.nonce = nonce;\n            }\n            const parentEl = rootNode === document ? document.head : rootNode;\n            const insertBefore = rootNode === document\n                ? parentEl.querySelector('script,link[rel=stylesheet],link[as=style],style')\n                : parentEl.firstChild;\n            parentEl.insertBefore(styleEl, insertBefore);\n        }\n        styleEls.set(rootNode, styleEl);\n        hydrateStylesRoot(styleEl);\n    }\n}\nfunction hydrateStylesRoot(styleEl) {\n    for (const styleText of styleTexts) {\n        appendStylesTo(styleEl, styleText);\n    }\n}\nfunction appendStylesTo(styleEl, styleText) {\n    const { sheet } = styleEl;\n    const ruleCnt = sheet.cssRules.length;\n    styleText.split('}').forEach((styleStr, i) => {\n        styleStr = styleStr.trim();\n        if (styleStr) {\n            sheet.insertRule(styleStr + '}', ruleCnt + i);\n        }\n    });\n}\n// nonce\n// -------------------------------------------------------------------------------------------------\nlet queriedNonceValue;\nfunction getNonceValue() {\n    if (queriedNonceValue === undefined) {\n        queriedNonceValue = queryNonceValue();\n    }\n    return queriedNonceValue;\n}\n/*\nTODO: discourage meta tag and instead put nonce attribute on placeholder <style> tag\n*/\nfunction queryNonceValue() {\n    const metaWithNonce = document.querySelector('meta[name=\"csp-nonce\"]');\n    if (metaWithNonce && metaWithNonce.hasAttribute('content')) {\n        return metaWithNonce.getAttribute('content');\n    }\n    const elWithNonce = document.querySelector('script[nonce]');\n    if (elWithNonce) {\n        return elWithNonce.nonce || '';\n    }\n    return '';\n}\n// main\n// -------------------------------------------------------------------------------------------------\nif (typeof document !== 'undefined') {\n    registerStylesRoot(document);\n}\n\nvar css_248z = \":root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url(\\\"data:application/x-font-ttf;charset=utf-8;base64,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\\\") format(\\\"truetype\\\")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:\\\"\\\\e900\\\"}.fc-icon-chevron-right:before{content:\\\"\\\\e901\\\"}.fc-icon-chevrons-left:before{content:\\\"\\\\e902\\\"}.fc-icon-chevrons-right:before{content:\\\"\\\\e903\\\"}.fc-icon-minus-square:before{content:\\\"\\\\e904\\\"}.fc-icon-plus-square:before{content:\\\"\\\\e905\\\"}.fc-icon-x:before{content:\\\"\\\\e906\\\"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:\\\"\\\";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:\\\"\\\";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:\\\"\\\";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}\";\ninjectStyles(css_248z);\n\nclass DelayedRunner {\n    constructor(drainedOption) {\n        this.drainedOption = drainedOption;\n        this.isRunning = false;\n        this.isDirty = false;\n        this.pauseDepths = {};\n        this.timeoutId = 0;\n    }\n    request(delay) {\n        this.isDirty = true;\n        if (!this.isPaused()) {\n            this.clearTimeout();\n            if (delay == null) {\n                this.tryDrain();\n            }\n            else {\n                this.timeoutId = setTimeout(// NOT OPTIMAL! TODO: look at debounce\n                this.tryDrain.bind(this), delay);\n            }\n        }\n    }\n    pause(scope = '') {\n        let { pauseDepths } = this;\n        pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n        this.clearTimeout();\n    }\n    resume(scope = '', force) {\n        let { pauseDepths } = this;\n        if (scope in pauseDepths) {\n            if (force) {\n                delete pauseDepths[scope];\n            }\n            else {\n                pauseDepths[scope] -= 1;\n                let depth = pauseDepths[scope];\n                if (depth <= 0) {\n                    delete pauseDepths[scope];\n                }\n            }\n            this.tryDrain();\n        }\n    }\n    isPaused() {\n        return Object.keys(this.pauseDepths).length;\n    }\n    tryDrain() {\n        if (!this.isRunning && !this.isPaused()) {\n            this.isRunning = true;\n            while (this.isDirty) {\n                this.isDirty = false;\n                this.drained(); // might set isDirty to true again\n            }\n            this.isRunning = false;\n        }\n    }\n    clear() {\n        this.clearTimeout();\n        this.isDirty = false;\n        this.pauseDepths = {};\n    }\n    clearTimeout() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = 0;\n        }\n    }\n    drained() {\n        if (this.drainedOption) {\n            this.drainedOption();\n        }\n    }\n}\n\nfunction removeElement(el) {\n    if (el.parentNode) {\n        el.parentNode.removeChild(el);\n    }\n}\n// Querying\n// ----------------------------------------------------------------------------------------------------------------\nfunction elementClosest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n        // really bad fallback for IE\n        // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n    }\n    if (!document.documentElement.contains(el)) {\n        return null;\n    }\n    do {\n        if (elementMatches(el, selector)) {\n            return el;\n        }\n        el = (el.parentElement || el.parentNode);\n    } while (el !== null && el.nodeType === 1);\n    return null;\n}\nfunction elementMatches(el, selector) {\n    let method = el.matches || el.matchesSelector || el.msMatchesSelector;\n    return method.call(el, selector);\n}\n// accepts multiple subject els\n// returns a real array. good for methods like forEach\n// TODO: accept the document\nfunction findElements(container, selector) {\n    let containers = container instanceof HTMLElement ? [container] : container;\n    let allMatches = [];\n    for (let i = 0; i < containers.length; i += 1) {\n        let matches = containers[i].querySelectorAll(selector);\n        for (let j = 0; j < matches.length; j += 1) {\n            allMatches.push(matches[j]);\n        }\n    }\n    return allMatches;\n}\n// accepts multiple subject els\n// only queries direct child elements // TODO: rename to findDirectChildren!\nfunction findDirectChildren(parent, selector) {\n    let parents = parent instanceof HTMLElement ? [parent] : parent;\n    let allMatches = [];\n    for (let i = 0; i < parents.length; i += 1) {\n        let childNodes = parents[i].children; // only ever elements\n        for (let j = 0; j < childNodes.length; j += 1) {\n            let childNode = childNodes[j];\n            if (!selector || elementMatches(childNode, selector)) {\n                allMatches.push(childNode);\n            }\n        }\n    }\n    return allMatches;\n}\n// Style\n// ----------------------------------------------------------------------------------------------------------------\nconst PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\nfunction applyStyle(el, props) {\n    for (let propName in props) {\n        applyStyleProp(el, propName, props[propName]);\n    }\n}\nfunction applyStyleProp(el, name, val) {\n    if (val == null) {\n        el.style[name] = '';\n    }\n    else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {\n        el.style[name] = `${val}px`;\n    }\n    else {\n        el.style[name] = val;\n    }\n}\n// Event Handling\n// ----------------------------------------------------------------------------------------------------------------\n// if intercepting bubbled events at the document/window/body level,\n// and want to see originating element (the 'target'), use this util instead\n// of `ev.target` because it goes within web-component boundaries.\nfunction getEventTargetViaRoot(ev) {\n    var _a, _b;\n    return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;\n}\n// Unique ID for DOM attribute\nlet guid$1 = 0;\nfunction getUniqueDomId() {\n    guid$1 += 1;\n    return 'fc-dom-' + guid$1;\n}\n\n// Stops a mouse/touch event from doing it's native browser action\nfunction preventDefault(ev) {\n    ev.preventDefault();\n}\n// Event Delegation\n// ----------------------------------------------------------------------------------------------------------------\nfunction buildDelegationHandler(selector, handler) {\n    return (ev) => {\n        let matchedChild = elementClosest(ev.target, selector);\n        if (matchedChild) {\n            handler.call(matchedChild, ev, matchedChild);\n        }\n    };\n}\nfunction listenBySelector(container, eventType, selector, handler) {\n    let attachedHandler = buildDelegationHandler(selector, handler);\n    container.addEventListener(eventType, attachedHandler);\n    return () => {\n        container.removeEventListener(eventType, attachedHandler);\n    };\n}\nfunction listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n    let currentMatchedChild;\n    return listenBySelector(container, 'mouseover', selector, (mouseOverEv, matchedChild) => {\n        if (matchedChild !== currentMatchedChild) {\n            currentMatchedChild = matchedChild;\n            onMouseEnter(mouseOverEv, matchedChild);\n            let realOnMouseLeave = (mouseLeaveEv) => {\n                currentMatchedChild = null;\n                onMouseLeave(mouseLeaveEv, matchedChild);\n                matchedChild.removeEventListener('mouseleave', realOnMouseLeave);\n            };\n            // listen to the next mouseleave, and then unattach\n            matchedChild.addEventListener('mouseleave', realOnMouseLeave);\n        }\n    });\n}\n// Animation\n// ----------------------------------------------------------------------------------------------------------------\nconst transitionEventNames = [\n    'webkitTransitionEnd',\n    'otransitionend',\n    'oTransitionEnd',\n    'msTransitionEnd',\n    'transitionend',\n];\n// triggered only when the next single subsequent transition finishes\nfunction whenTransitionDone(el, callback) {\n    let realCallback = (ev) => {\n        callback(ev);\n        transitionEventNames.forEach((eventName) => {\n            el.removeEventListener(eventName, realCallback);\n        });\n    };\n    transitionEventNames.forEach((eventName) => {\n        el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n    });\n}\n// ARIA workarounds\n// ----------------------------------------------------------------------------------------------------------------\nfunction createAriaClickAttrs(handler) {\n    return Object.assign({ onClick: handler }, createAriaKeyboardAttrs(handler));\n}\nfunction createAriaKeyboardAttrs(handler) {\n    return {\n        tabIndex: 0,\n        onKeyDown(ev) {\n            if (ev.key === 'Enter' || ev.key === ' ') {\n                handler(ev);\n                ev.preventDefault(); // if space, don't scroll down page\n            }\n        },\n    };\n}\n\nlet guidNumber = 0;\nfunction guid() {\n    guidNumber += 1;\n    return String(guidNumber);\n}\n/* FullCalendar-specific DOM Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n// Make the mouse cursor express that an event is not allowed in the current area\nfunction disableCursor() {\n    document.body.classList.add('fc-not-allowed');\n}\n// Returns the mouse cursor to its original look\nfunction enableCursor() {\n    document.body.classList.remove('fc-not-allowed');\n}\n/* Selection\n----------------------------------------------------------------------------------------------------------------------*/\nfunction preventSelection(el) {\n    el.style.userSelect = 'none';\n    el.style.webkitUserSelect = 'none';\n    el.addEventListener('selectstart', preventDefault);\n}\nfunction allowSelection(el) {\n    el.style.userSelect = '';\n    el.style.webkitUserSelect = '';\n    el.removeEventListener('selectstart', preventDefault);\n}\n/* Context Menu\n----------------------------------------------------------------------------------------------------------------------*/\nfunction preventContextMenu(el) {\n    el.addEventListener('contextmenu', preventDefault);\n}\nfunction allowContextMenu(el) {\n    el.removeEventListener('contextmenu', preventDefault);\n}\nfunction parseFieldSpecs(input) {\n    let specs = [];\n    let tokens = [];\n    let i;\n    let token;\n    if (typeof input === 'string') {\n        tokens = input.split(/\\s*,\\s*/);\n    }\n    else if (typeof input === 'function') {\n        tokens = [input];\n    }\n    else if (Array.isArray(input)) {\n        tokens = input;\n    }\n    for (i = 0; i < tokens.length; i += 1) {\n        token = tokens[i];\n        if (typeof token === 'string') {\n            specs.push(token.charAt(0) === '-' ?\n                { field: token.substring(1), order: -1 } :\n                { field: token, order: 1 });\n        }\n        else if (typeof token === 'function') {\n            specs.push({ func: token });\n        }\n    }\n    return specs;\n}\nfunction compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n    let i;\n    let cmp;\n    for (i = 0; i < fieldSpecs.length; i += 1) {\n        cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n        if (cmp) {\n            return cmp;\n        }\n    }\n    return 0;\n}\nfunction compareByFieldSpec(obj0, obj1, fieldSpec) {\n    if (fieldSpec.func) {\n        return fieldSpec.func(obj0, obj1);\n    }\n    return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field])\n        * (fieldSpec.order || 1);\n}\nfunction flexibleCompare(a, b) {\n    if (!a && !b) {\n        return 0;\n    }\n    if (b == null) {\n        return -1;\n    }\n    if (a == null) {\n        return 1;\n    }\n    if (typeof a === 'string' || typeof b === 'string') {\n        return String(a).localeCompare(String(b));\n    }\n    return a - b;\n}\n/* String Utilities\n----------------------------------------------------------------------------------------------------------------------*/\nfunction padStart(val, len) {\n    let s = String(val);\n    return '000'.substr(0, len - s.length) + s;\n}\nfunction formatWithOrdinals(formatter, args, fallbackText) {\n    if (typeof formatter === 'function') {\n        return formatter(...args);\n    }\n    if (typeof formatter === 'string') { // non-blank string\n        return args.reduce((str, arg, index) => (str.replace('$' + index, arg || '')), formatter);\n    }\n    return fallbackText;\n}\n/* Number Utilities\n----------------------------------------------------------------------------------------------------------------------*/\nfunction compareNumbers(a, b) {\n    return a - b;\n}\nfunction isInt(n) {\n    return n % 1 === 0;\n}\n/* FC-specific DOM dimension stuff\n----------------------------------------------------------------------------------------------------------------------*/\nfunction computeSmallestCellWidth(cellEl) {\n    let allWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-frame');\n    let contentWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-cushion');\n    if (!allWidthEl) {\n        throw new Error('needs fc-scrollgrid-shrink-frame className'); // TODO: use const\n    }\n    if (!contentWidthEl) {\n        throw new Error('needs fc-scrollgrid-shrink-cushion className');\n    }\n    return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n        contentWidthEl.getBoundingClientRect().width;\n}\n\nconst INTERNAL_UNITS = ['years', 'months', 'days', 'milliseconds'];\nconst PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/;\n// Parsing and Creation\nfunction createDuration(input, unit) {\n    if (typeof input === 'string') {\n        return parseString(input);\n    }\n    if (typeof input === 'object' && input) { // non-null object\n        return parseObject(input);\n    }\n    if (typeof input === 'number') {\n        return parseObject({ [unit || 'milliseconds']: input });\n    }\n    return null;\n}\nfunction parseString(s) {\n    let m = PARSE_RE.exec(s);\n    if (m) {\n        let sign = m[1] ? -1 : 1;\n        return {\n            years: 0,\n            months: 0,\n            days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n            milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n                (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n                (m[5] ? parseInt(m[5], 10) : 0) * 1000 + // seconds\n                (m[6] ? parseInt(m[6], 10) : 0) // ms\n            ),\n        };\n    }\n    return null;\n}\nfunction parseObject(obj) {\n    let duration = {\n        years: obj.years || obj.year || 0,\n        months: obj.months || obj.month || 0,\n        days: obj.days || obj.day || 0,\n        milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n            (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n            (obj.seconds || obj.second || 0) * 1000 + // seconds\n            (obj.milliseconds || obj.millisecond || obj.ms || 0), // ms\n    };\n    let weeks = obj.weeks || obj.week;\n    if (weeks) {\n        duration.days += weeks * 7;\n        duration.specifiedWeeks = true;\n    }\n    return duration;\n}\n// Equality\nfunction durationsEqual(d0, d1) {\n    return d0.years === d1.years &&\n        d0.months === d1.months &&\n        d0.days === d1.days &&\n        d0.milliseconds === d1.milliseconds;\n}\nfunction asCleanDays(dur) {\n    if (!dur.years && !dur.months && !dur.milliseconds) {\n        return dur.days;\n    }\n    return 0;\n}\n// Simple Math\nfunction addDurations(d0, d1) {\n    return {\n        years: d0.years + d1.years,\n        months: d0.months + d1.months,\n        days: d0.days + d1.days,\n        milliseconds: d0.milliseconds + d1.milliseconds,\n    };\n}\nfunction subtractDurations(d1, d0) {\n    return {\n        years: d1.years - d0.years,\n        months: d1.months - d0.months,\n        days: d1.days - d0.days,\n        milliseconds: d1.milliseconds - d0.milliseconds,\n    };\n}\nfunction multiplyDuration(d, n) {\n    return {\n        years: d.years * n,\n        months: d.months * n,\n        days: d.days * n,\n        milliseconds: d.milliseconds * n,\n    };\n}\n// Conversions\n// \"Rough\" because they are based on average-case Gregorian months/years\nfunction asRoughYears(dur) {\n    return asRoughDays(dur) / 365;\n}\nfunction asRoughMonths(dur) {\n    return asRoughDays(dur) / 30;\n}\nfunction asRoughDays(dur) {\n    return asRoughMs(dur) / 864e5;\n}\nfunction asRoughMinutes(dur) {\n    return asRoughMs(dur) / (1000 * 60);\n}\nfunction asRoughSeconds(dur) {\n    return asRoughMs(dur) / 1000;\n}\nfunction asRoughMs(dur) {\n    return dur.years * (365 * 864e5) +\n        dur.months * (30 * 864e5) +\n        dur.days * 864e5 +\n        dur.milliseconds;\n}\n// Advanced Math\nfunction wholeDivideDurations(numerator, denominator) {\n    let res = null;\n    for (let i = 0; i < INTERNAL_UNITS.length; i += 1) {\n        let unit = INTERNAL_UNITS[i];\n        if (denominator[unit]) {\n            let localRes = numerator[unit] / denominator[unit];\n            if (!isInt(localRes) || (res !== null && res !== localRes)) {\n                return null;\n            }\n            res = localRes;\n        }\n        else if (numerator[unit]) {\n            // needs to divide by something but can't!\n            return null;\n        }\n    }\n    return res;\n}\nfunction greatestDurationDenominator(dur) {\n    let ms = dur.milliseconds;\n    if (ms) {\n        if (ms % 1000 !== 0) {\n            return { unit: 'millisecond', value: ms };\n        }\n        if (ms % (1000 * 60) !== 0) {\n            return { unit: 'second', value: ms / 1000 };\n        }\n        if (ms % (1000 * 60 * 60) !== 0) {\n            return { unit: 'minute', value: ms / (1000 * 60) };\n        }\n        if (ms) {\n            return { unit: 'hour', value: ms / (1000 * 60 * 60) };\n        }\n    }\n    if (dur.days) {\n        if (dur.specifiedWeeks && dur.days % 7 === 0) {\n            return { unit: 'week', value: dur.days / 7 };\n        }\n        return { unit: 'day', value: dur.days };\n    }\n    if (dur.months) {\n        return { unit: 'month', value: dur.months };\n    }\n    if (dur.years) {\n        return { unit: 'year', value: dur.years };\n    }\n    return { unit: 'millisecond', value: 0 };\n}\n\n// TODO: new util arrayify?\nfunction removeExact(array, exactVal) {\n    let removeCnt = 0;\n    let i = 0;\n    while (i < array.length) {\n        if (array[i] === exactVal) {\n            array.splice(i, 1);\n            removeCnt += 1;\n        }\n        else {\n            i += 1;\n        }\n    }\n    return removeCnt;\n}\nfunction isArraysEqual(a0, a1, equalityFunc) {\n    if (a0 === a1) {\n        return true;\n    }\n    let len = a0.length;\n    let i;\n    if (len !== a1.length) { // not array? or not same length?\n        return false;\n    }\n    for (i = 0; i < len; i += 1) {\n        if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];\n// Adding\nfunction addWeeks(m, n) {\n    let a = dateToUtcArray(m);\n    a[2] += n * 7;\n    return arrayToUtcDate(a);\n}\nfunction addDays(m, n) {\n    let a = dateToUtcArray(m);\n    a[2] += n;\n    return arrayToUtcDate(a);\n}\nfunction addMs(m, n) {\n    let a = dateToUtcArray(m);\n    a[6] += n;\n    return arrayToUtcDate(a);\n}\n// Diffing (all return floats)\n// TODO: why not use ranges?\nfunction diffWeeks(m0, m1) {\n    return diffDays(m0, m1) / 7;\n}\nfunction diffDays(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n}\nfunction diffHours(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n}\nfunction diffMinutes(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n}\nfunction diffSeconds(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / 1000;\n}\nfunction diffDayAndTime(m0, m1) {\n    let m0day = startOfDay(m0);\n    let m1day = startOfDay(m1);\n    return {\n        years: 0,\n        months: 0,\n        days: Math.round(diffDays(m0day, m1day)),\n        milliseconds: (m1.valueOf() - m1day.valueOf()) - (m0.valueOf() - m0day.valueOf()),\n    };\n}\n// Diffing Whole Units\nfunction diffWholeWeeks(m0, m1) {\n    let d = diffWholeDays(m0, m1);\n    if (d !== null && d % 7 === 0) {\n        return d / 7;\n    }\n    return null;\n}\nfunction diffWholeDays(m0, m1) {\n    if (timeAsMs(m0) === timeAsMs(m1)) {\n        return Math.round(diffDays(m0, m1));\n    }\n    return null;\n}\n// Start-Of\nfunction startOfDay(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n    ]);\n}\nfunction startOfHour(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n    ]);\n}\nfunction startOfMinute(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n        m.getUTCMinutes(),\n    ]);\n}\nfunction startOfSecond(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n        m.getUTCMinutes(),\n        m.getUTCSeconds(),\n    ]);\n}\n// Week Computation\nfunction weekOfYear(marker, dow, doy) {\n    let y = marker.getUTCFullYear();\n    let w = weekOfGivenYear(marker, y, dow, doy);\n    if (w < 1) {\n        return weekOfGivenYear(marker, y - 1, dow, doy);\n    }\n    let nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n    if (nextW >= 1) {\n        return Math.min(w, nextW);\n    }\n    return w;\n}\nfunction weekOfGivenYear(marker, year, dow, doy) {\n    let firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);\n    let dayStart = startOfDay(marker);\n    let days = Math.round(diffDays(firstWeekStart, dayStart));\n    return Math.floor(days / 7) + 1; // zero-indexed\n}\n// start-of-first-week - start-of-year\nfunction firstWeekOffset(year, dow, doy) {\n    // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n    let fwd = 7 + dow - doy;\n    // first-week day local weekday -- which local weekday is fwd\n    let fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;\n    return -fwdlw + fwd - 1;\n}\n// Array Conversion\nfunction dateToLocalArray(date) {\n    return [\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes(),\n        date.getSeconds(),\n        date.getMilliseconds(),\n    ];\n}\nfunction arrayToLocalDate(a) {\n    return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month\n    a[3] || 0, a[4] || 0, a[5] || 0);\n}\nfunction dateToUtcArray(date) {\n    return [\n        date.getUTCFullYear(),\n        date.getUTCMonth(),\n        date.getUTCDate(),\n        date.getUTCHours(),\n        date.getUTCMinutes(),\n        date.getUTCSeconds(),\n        date.getUTCMilliseconds(),\n    ];\n}\nfunction arrayToUtcDate(a) {\n    // according to web standards (and Safari), a month index is required.\n    // massage if only given a year.\n    if (a.length === 1) {\n        a = a.concat([0]);\n    }\n    return new Date(Date.UTC(...a));\n}\n// Other Utils\nfunction isValidDate(m) {\n    return !isNaN(m.valueOf());\n}\nfunction timeAsMs(m) {\n    return m.getUTCHours() * 1000 * 60 * 60 +\n        m.getUTCMinutes() * 1000 * 60 +\n        m.getUTCSeconds() * 1000 +\n        m.getUTCMilliseconds();\n}\n\n// timeZoneOffset is in minutes\nfunction buildIsoString(marker, timeZoneOffset, stripZeroTime = false) {\n    let s = marker.toISOString();\n    s = s.replace('.000', '');\n    if (stripZeroTime) {\n        s = s.replace('T00:00:00Z', '');\n    }\n    if (s.length > 10) { // time part wasn't stripped, can add timezone info\n        if (timeZoneOffset == null) {\n            s = s.replace('Z', '');\n        }\n        else if (timeZoneOffset !== 0) {\n            s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));\n        }\n        // otherwise, its UTC-0 and we want to keep the Z\n    }\n    return s;\n}\n// formats the date, but with no time part\n// TODO: somehow merge with buildIsoString and stripZeroTime\n// TODO: rename. omit \"string\"\nfunction formatDayString(marker) {\n    return marker.toISOString().replace(/T.*$/, '');\n}\nfunction formatIsoMonthStr(marker) {\n    return marker.toISOString().match(/^\\d{4}-\\d{2}/)[0];\n}\n// TODO: use Date::toISOString and use everything after the T?\nfunction formatIsoTimeString(marker) {\n    return padStart(marker.getUTCHours(), 2) + ':' +\n        padStart(marker.getUTCMinutes(), 2) + ':' +\n        padStart(marker.getUTCSeconds(), 2);\n}\nfunction formatTimeZoneOffset(minutes, doIso = false) {\n    let sign = minutes < 0 ? '-' : '+';\n    let abs = Math.abs(minutes);\n    let hours = Math.floor(abs / 60);\n    let mins = Math.round(abs % 60);\n    if (doIso) {\n        return `${sign + padStart(hours, 2)}:${padStart(mins, 2)}`;\n    }\n    return `GMT${sign}${hours}${mins ? `:${padStart(mins, 2)}` : ''}`;\n}\n\nfunction memoize(workerFunc, resEquality, teardownFunc) {\n    let currentArgs;\n    let currentRes;\n    return function (...newArgs) {\n        if (!currentArgs) {\n            currentRes = workerFunc.apply(this, newArgs);\n        }\n        else if (!isArraysEqual(currentArgs, newArgs)) {\n            if (teardownFunc) {\n                teardownFunc(currentRes);\n            }\n            let res = workerFunc.apply(this, newArgs);\n            if (!resEquality || !resEquality(res, currentRes)) {\n                currentRes = res;\n            }\n        }\n        currentArgs = newArgs;\n        return currentRes;\n    };\n}\nfunction memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n    let currentArg;\n    let currentRes;\n    return (newArg) => {\n        if (!currentArg) {\n            currentRes = workerFunc.call(this, newArg);\n        }\n        else if (!isPropsEqual(currentArg, newArg)) {\n            if (teardownFunc) {\n                teardownFunc(currentRes);\n            }\n            let res = workerFunc.call(this, newArg);\n            if (!resEquality || !resEquality(res, currentRes)) {\n                currentRes = res;\n            }\n        }\n        currentArg = newArg;\n        return currentRes;\n    };\n}\nfunction memoizeArraylike(// used at all?\nworkerFunc, resEquality, teardownFunc) {\n    let currentArgSets = [];\n    let currentResults = [];\n    return (newArgSets) => {\n        let currentLen = currentArgSets.length;\n        let newLen = newArgSets.length;\n        let i = 0;\n        for (; i < currentLen; i += 1) {\n            if (!newArgSets[i]) { // one of the old sets no longer exists\n                if (teardownFunc) {\n                    teardownFunc(currentResults[i]);\n                }\n            }\n            else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n                if (teardownFunc) {\n                    teardownFunc(currentResults[i]);\n                }\n                let res = workerFunc.apply(this, newArgSets[i]);\n                if (!resEquality || !resEquality(res, currentResults[i])) {\n                    currentResults[i] = res;\n                }\n            }\n        }\n        for (; i < newLen; i += 1) {\n            currentResults[i] = workerFunc.apply(this, newArgSets[i]);\n        }\n        currentArgSets = newArgSets;\n        currentResults.splice(newLen); // remove excess\n        return currentResults;\n    };\n}\nfunction memoizeHashlike(workerFunc, resEquality, teardownFunc) {\n    let currentArgHash = {};\n    let currentResHash = {};\n    return (newArgHash) => {\n        let newResHash = {};\n        for (let key in newArgHash) {\n            if (!currentResHash[key]) {\n                newResHash[key] = workerFunc.apply(this, newArgHash[key]);\n            }\n            else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n                if (teardownFunc) {\n                    teardownFunc(currentResHash[key]);\n                }\n                let res = workerFunc.apply(this, newArgHash[key]);\n                newResHash[key] = (resEquality && resEquality(res, currentResHash[key]))\n                    ? currentResHash[key]\n                    : res;\n            }\n            else {\n                newResHash[key] = currentResHash[key];\n            }\n        }\n        currentArgHash = newArgHash;\n        currentResHash = newResHash;\n        return newResHash;\n    };\n}\n\nconst EXTENDED_SETTINGS_AND_SEVERITIES = {\n    week: 3,\n    separator: 0,\n    omitZeroMinute: 0,\n    meridiem: 0,\n    omitCommas: 0,\n};\nconst STANDARD_DATE_PROP_SEVERITIES = {\n    timeZoneName: 7,\n    era: 6,\n    year: 5,\n    month: 4,\n    day: 2,\n    weekday: 2,\n    hour: 1,\n    minute: 1,\n    second: 1,\n};\nconst MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\nconst COMMA_RE = /,/g; // we need re for globalness\nconst MULTI_SPACE_RE = /\\s+/g;\nconst LTR_RE = /\\u200e/g; // control character\nconst UTC_RE = /UTC|GMT/;\nclass NativeFormatter {\n    constructor(formatSettings) {\n        let standardDateProps = {};\n        let extendedSettings = {};\n        let severity = 0;\n        for (let name in formatSettings) {\n            if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {\n                extendedSettings[name] = formatSettings[name];\n                severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name], severity);\n            }\n            else {\n                standardDateProps[name] = formatSettings[name];\n                if (name in STANDARD_DATE_PROP_SEVERITIES) { // TODO: what about hour12? no severity\n                    severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name], severity);\n                }\n            }\n        }\n        this.standardDateProps = standardDateProps;\n        this.extendedSettings = extendedSettings;\n        this.severity = severity;\n        this.buildFormattingFunc = memoize(buildFormattingFunc);\n    }\n    format(date, context) {\n        return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n    }\n    formatRange(start, end, context, betterDefaultSeparator) {\n        let { standardDateProps, extendedSettings } = this;\n        let diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n        if (!diffSeverity) {\n            return this.format(start, context);\n        }\n        let biggestUnitForPartial = diffSeverity;\n        if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time\n            (standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') &&\n            (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') &&\n            (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {\n            biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n        }\n        let full0 = this.format(start, context);\n        let full1 = this.format(end, context);\n        if (full0 === full1) {\n            return full0;\n        }\n        let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n        let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n        let partial0 = partialFormattingFunc(start);\n        let partial1 = partialFormattingFunc(end);\n        let insertion = findCommonInsertion(full0, partial0, full1, partial1);\n        let separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || '';\n        if (insertion) {\n            return insertion.before + partial0 + separator + partial1 + insertion.after;\n        }\n        return full0 + separator + full1;\n    }\n    getLargestUnit() {\n        switch (this.severity) {\n            case 7:\n            case 6:\n            case 5:\n                return 'year';\n            case 4:\n                return 'month';\n            case 3:\n                return 'week';\n            case 2:\n                return 'day';\n            default:\n                return 'time'; // really?\n        }\n    }\n}\nfunction buildFormattingFunc(standardDateProps, extendedSettings, context) {\n    let standardDatePropCnt = Object.keys(standardDateProps).length;\n    if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {\n        return (date) => (formatTimeZoneOffset(date.timeZoneOffset));\n    }\n    if (standardDatePropCnt === 0 && extendedSettings.week) {\n        return (date) => (formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week));\n    }\n    return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n}\nfunction buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n    standardDateProps = Object.assign({}, standardDateProps); // copy\n    extendedSettings = Object.assign({}, extendedSettings); // copy\n    sanitizeSettings(standardDateProps, extendedSettings);\n    standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers\n    let normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n    let zeroFormat; // needed?\n    if (extendedSettings.omitZeroMinute) {\n        let zeroProps = Object.assign({}, standardDateProps);\n        delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n        zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n    }\n    return (date) => {\n        let { marker } = date;\n        let format;\n        if (zeroFormat && !marker.getUTCMinutes()) {\n            format = zeroFormat;\n        }\n        else {\n            format = normalFormat;\n        }\n        let s = format.format(marker);\n        return postProcess(s, date, standardDateProps, extendedSettings, context);\n    };\n}\nfunction sanitizeSettings(standardDateProps, extendedSettings) {\n    // deal with a browser inconsistency where formatting the timezone\n    // requires that the hour/minute be present.\n    if (standardDateProps.timeZoneName) {\n        if (!standardDateProps.hour) {\n            standardDateProps.hour = '2-digit';\n        }\n        if (!standardDateProps.minute) {\n            standardDateProps.minute = '2-digit';\n        }\n    }\n    // only support short timezone names\n    if (standardDateProps.timeZoneName === 'long') {\n        standardDateProps.timeZoneName = 'short';\n    }\n    // if requesting to display seconds, MUST display minutes\n    if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n        delete extendedSettings.omitZeroMinute;\n    }\n}\nfunction postProcess(s, date, standardDateProps, extendedSettings, context) {\n    s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes\n    if (standardDateProps.timeZoneName === 'short') {\n        s = injectTzoStr(s, (context.timeZone === 'UTC' || date.timeZoneOffset == null) ?\n            'UTC' : // important to normalize for IE, which does \"GMT\"\n            formatTimeZoneOffset(date.timeZoneOffset));\n    }\n    if (extendedSettings.omitCommas) {\n        s = s.replace(COMMA_RE, '').trim();\n    }\n    if (extendedSettings.omitZeroMinute) {\n        s = s.replace(':00', ''); // zeroFormat doesn't always achieve this\n    }\n    // ^ do anything that might create adjacent spaces before this point,\n    // because MERIDIEM_RE likes to eat up loading spaces\n    if (extendedSettings.meridiem === false) {\n        s = s.replace(MERIDIEM_RE, '').trim();\n    }\n    else if (extendedSettings.meridiem === 'narrow') { // a/p\n        s = s.replace(MERIDIEM_RE, (m0, m1) => m1.toLocaleLowerCase());\n    }\n    else if (extendedSettings.meridiem === 'short') { // am/pm\n        s = s.replace(MERIDIEM_RE, (m0, m1) => `${m1.toLocaleLowerCase()}m`);\n    }\n    else if (extendedSettings.meridiem === 'lowercase') { // other meridiem transformers already converted to lowercase\n        s = s.replace(MERIDIEM_RE, (m0) => m0.toLocaleLowerCase());\n    }\n    s = s.replace(MULTI_SPACE_RE, ' ');\n    s = s.trim();\n    return s;\n}\nfunction injectTzoStr(s, tzoStr) {\n    let replaced = false;\n    s = s.replace(UTC_RE, () => {\n        replaced = true;\n        return tzoStr;\n    });\n    // IE11 doesn't include UTC/GMT in the original string, so append to end\n    if (!replaced) {\n        s += ` ${tzoStr}`;\n    }\n    return s;\n}\nfunction formatWeekNumber(num, weekText, weekTextLong, locale, display) {\n    let parts = [];\n    if (display === 'long') {\n        parts.push(weekTextLong);\n    }\n    else if (display === 'short' || display === 'narrow') {\n        parts.push(weekText);\n    }\n    if (display === 'long' || display === 'short') {\n        parts.push(' ');\n    }\n    parts.push(locale.simpleNumberFormat.format(num));\n    if (locale.options.direction === 'rtl') { // TODO: use control characters instead?\n        parts.reverse();\n    }\n    return parts.join('');\n}\n// Range Formatting Utils\n// 0 = exactly the same\n// 1 = different by time\n// and bigger\nfunction computeMarkerDiffSeverity(d0, d1, ca) {\n    if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n        return 5;\n    }\n    if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n        return 4;\n    }\n    if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n        return 2;\n    }\n    if (timeAsMs(d0) !== timeAsMs(d1)) {\n        return 1;\n    }\n    return 0;\n}\nfunction computePartialFormattingOptions(options, biggestUnit) {\n    let partialOptions = {};\n    for (let name in options) {\n        if (!(name in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n            STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {\n            partialOptions[name] = options[name];\n        }\n    }\n    return partialOptions;\n}\nfunction findCommonInsertion(full0, partial0, full1, partial1) {\n    let i0 = 0;\n    while (i0 < full0.length) {\n        let found0 = full0.indexOf(partial0, i0);\n        if (found0 === -1) {\n            break;\n        }\n        let before0 = full0.substr(0, found0);\n        i0 = found0 + partial0.length;\n        let after0 = full0.substr(i0);\n        let i1 = 0;\n        while (i1 < full1.length) {\n            let found1 = full1.indexOf(partial1, i1);\n            if (found1 === -1) {\n                break;\n            }\n            let before1 = full1.substr(0, found1);\n            i1 = found1 + partial1.length;\n            let after1 = full1.substr(i1);\n            if (before0 === before1 && after0 === after1) {\n                return {\n                    before: before0,\n                    after: after0,\n                };\n            }\n        }\n    }\n    return null;\n}\n\nfunction expandZonedMarker(dateInfo, calendarSystem) {\n    let a = calendarSystem.markerToArray(dateInfo.marker);\n    return {\n        marker: dateInfo.marker,\n        timeZoneOffset: dateInfo.timeZoneOffset,\n        array: a,\n        year: a[0],\n        month: a[1],\n        day: a[2],\n        hour: a[3],\n        minute: a[4],\n        second: a[5],\n        millisecond: a[6],\n    };\n}\n\nfunction createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {\n    let startInfo = expandZonedMarker(start, context.calendarSystem);\n    let endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n    return {\n        date: startInfo,\n        start: startInfo,\n        end: endInfo,\n        timeZone: context.timeZone,\n        localeCodes: context.locale.codes,\n        defaultSeparator: betterDefaultSeparator || context.defaultSeparator,\n    };\n}\n\n/*\nTODO: fix the terminology of \"formatter\" vs \"formatting func\"\n*/\n/*\nAt the time of instantiation, this object does not know which cmd-formatting system it will use.\nIt receives this at the time of formatting, as a setting.\n*/\nclass CmdFormatter {\n    constructor(cmdStr) {\n        this.cmdStr = cmdStr;\n    }\n    format(date, context, betterDefaultSeparator) {\n        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n    }\n    formatRange(start, end, context, betterDefaultSeparator) {\n        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n    }\n}\n\nclass FuncFormatter {\n    constructor(func) {\n        this.func = func;\n    }\n    format(date, context, betterDefaultSeparator) {\n        return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n    }\n    formatRange(start, end, context, betterDefaultSeparator) {\n        return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n    }\n}\n\nfunction createFormatter(input) {\n    if (typeof input === 'object' && input) { // non-null object\n        return new NativeFormatter(input);\n    }\n    if (typeof input === 'string') {\n        return new CmdFormatter(input);\n    }\n    if (typeof input === 'function') {\n        return new FuncFormatter(input);\n    }\n    return null;\n}\n\n// base options\n// ------------\nconst BASE_OPTION_REFINERS = {\n    navLinkDayClick: identity,\n    navLinkWeekClick: identity,\n    duration: createDuration,\n    bootstrapFontAwesome: identity,\n    buttonIcons: identity,\n    customButtons: identity,\n    defaultAllDayEventDuration: createDuration,\n    defaultTimedEventDuration: createDuration,\n    nextDayThreshold: createDuration,\n    scrollTime: createDuration,\n    scrollTimeReset: Boolean,\n    slotMinTime: createDuration,\n    slotMaxTime: createDuration,\n    dayPopoverFormat: createFormatter,\n    slotDuration: createDuration,\n    snapDuration: createDuration,\n    headerToolbar: identity,\n    footerToolbar: identity,\n    defaultRangeSeparator: String,\n    titleRangeSeparator: String,\n    forceEventDuration: Boolean,\n    dayHeaders: Boolean,\n    dayHeaderFormat: createFormatter,\n    dayHeaderClassNames: identity,\n    dayHeaderContent: identity,\n    dayHeaderDidMount: identity,\n    dayHeaderWillUnmount: identity,\n    dayCellClassNames: identity,\n    dayCellContent: identity,\n    dayCellDidMount: identity,\n    dayCellWillUnmount: identity,\n    initialView: String,\n    aspectRatio: Number,\n    weekends: Boolean,\n    weekNumberCalculation: identity,\n    weekNumbers: Boolean,\n    weekNumberClassNames: identity,\n    weekNumberContent: identity,\n    weekNumberDidMount: identity,\n    weekNumberWillUnmount: identity,\n    editable: Boolean,\n    viewClassNames: identity,\n    viewDidMount: identity,\n    viewWillUnmount: identity,\n    nowIndicator: Boolean,\n    nowIndicatorClassNames: identity,\n    nowIndicatorContent: identity,\n    nowIndicatorDidMount: identity,\n    nowIndicatorWillUnmount: identity,\n    showNonCurrentDates: Boolean,\n    lazyFetching: Boolean,\n    startParam: String,\n    endParam: String,\n    timeZoneParam: String,\n    timeZone: String,\n    locales: identity,\n    locale: identity,\n    themeSystem: String,\n    dragRevertDuration: Number,\n    dragScroll: Boolean,\n    allDayMaintainDuration: Boolean,\n    unselectAuto: Boolean,\n    dropAccept: identity,\n    eventOrder: parseFieldSpecs,\n    eventOrderStrict: Boolean,\n    handleWindowResize: Boolean,\n    windowResizeDelay: Number,\n    longPressDelay: Number,\n    eventDragMinDistance: Number,\n    expandRows: Boolean,\n    height: identity,\n    contentHeight: identity,\n    direction: String,\n    weekNumberFormat: createFormatter,\n    eventResizableFromStart: Boolean,\n    displayEventTime: Boolean,\n    displayEventEnd: Boolean,\n    weekText: String,\n    weekTextLong: String,\n    progressiveEventRendering: Boolean,\n    businessHours: identity,\n    initialDate: identity,\n    now: identity,\n    eventDataTransform: identity,\n    stickyHeaderDates: identity,\n    stickyFooterScrollbar: identity,\n    viewHeight: identity,\n    defaultAllDay: Boolean,\n    eventSourceFailure: identity,\n    eventSourceSuccess: identity,\n    eventDisplay: String,\n    eventStartEditable: Boolean,\n    eventDurationEditable: Boolean,\n    eventOverlap: identity,\n    eventConstraint: identity,\n    eventAllow: identity,\n    eventBackgroundColor: String,\n    eventBorderColor: String,\n    eventTextColor: String,\n    eventColor: String,\n    eventClassNames: identity,\n    eventContent: identity,\n    eventDidMount: identity,\n    eventWillUnmount: identity,\n    selectConstraint: identity,\n    selectOverlap: identity,\n    selectAllow: identity,\n    droppable: Boolean,\n    unselectCancel: String,\n    slotLabelFormat: identity,\n    slotLaneClassNames: identity,\n    slotLaneContent: identity,\n    slotLaneDidMount: identity,\n    slotLaneWillUnmount: identity,\n    slotLabelClassNames: identity,\n    slotLabelContent: identity,\n    slotLabelDidMount: identity,\n    slotLabelWillUnmount: identity,\n    dayMaxEvents: identity,\n    dayMaxEventRows: identity,\n    dayMinWidth: Number,\n    slotLabelInterval: createDuration,\n    allDayText: String,\n    allDayClassNames: identity,\n    allDayContent: identity,\n    allDayDidMount: identity,\n    allDayWillUnmount: identity,\n    slotMinWidth: Number,\n    navLinks: Boolean,\n    eventTimeFormat: createFormatter,\n    rerenderDelay: Number,\n    moreLinkText: identity,\n    moreLinkHint: identity,\n    selectMinDistance: Number,\n    selectable: Boolean,\n    selectLongPressDelay: Number,\n    eventLongPressDelay: Number,\n    selectMirror: Boolean,\n    eventMaxStack: Number,\n    eventMinHeight: Number,\n    eventMinWidth: Number,\n    eventShortHeight: Number,\n    slotEventOverlap: Boolean,\n    plugins: identity,\n    firstDay: Number,\n    dayCount: Number,\n    dateAlignment: String,\n    dateIncrement: createDuration,\n    hiddenDays: identity,\n    fixedWeekCount: Boolean,\n    validRange: identity,\n    visibleRange: identity,\n    titleFormat: identity,\n    eventInteractive: Boolean,\n    // only used by list-view, but languages define the value, so we need it in base options\n    noEventsText: String,\n    viewHint: identity,\n    navLinkHint: identity,\n    closeHint: String,\n    timeHint: String,\n    eventHint: String,\n    moreLinkClick: identity,\n    moreLinkClassNames: identity,\n    moreLinkContent: identity,\n    moreLinkDidMount: identity,\n    moreLinkWillUnmount: identity,\n    monthStartFormat: createFormatter,\n    // for connectors\n    // (can't be part of plugin system b/c must be provided at runtime)\n    handleCustomRendering: identity,\n    customRenderingMetaMap: identity,\n    customRenderingReplaces: Boolean,\n};\n// do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n// raw values.\nconst BASE_OPTION_DEFAULTS = {\n    eventDisplay: 'auto',\n    defaultRangeSeparator: ' - ',\n    titleRangeSeparator: ' \\u2013 ',\n    defaultTimedEventDuration: '01:00:00',\n    defaultAllDayEventDuration: { day: 1 },\n    forceEventDuration: false,\n    nextDayThreshold: '00:00:00',\n    dayHeaders: true,\n    initialView: '',\n    aspectRatio: 1.35,\n    headerToolbar: {\n        start: 'title',\n        center: '',\n        end: 'today prev,next',\n    },\n    weekends: true,\n    weekNumbers: false,\n    weekNumberCalculation: 'local',\n    editable: false,\n    nowIndicator: false,\n    scrollTime: '06:00:00',\n    scrollTimeReset: true,\n    slotMinTime: '00:00:00',\n    slotMaxTime: '24:00:00',\n    showNonCurrentDates: true,\n    lazyFetching: true,\n    startParam: 'start',\n    endParam: 'end',\n    timeZoneParam: 'timeZone',\n    timeZone: 'local',\n    locales: [],\n    locale: '',\n    themeSystem: 'standard',\n    dragRevertDuration: 500,\n    dragScroll: true,\n    allDayMaintainDuration: false,\n    unselectAuto: true,\n    dropAccept: '*',\n    eventOrder: 'start,-duration,allDay,title',\n    dayPopoverFormat: { month: 'long', day: 'numeric', year: 'numeric' },\n    handleWindowResize: true,\n    windowResizeDelay: 100,\n    longPressDelay: 1000,\n    eventDragMinDistance: 5,\n    expandRows: false,\n    navLinks: false,\n    selectable: false,\n    eventMinHeight: 15,\n    eventMinWidth: 30,\n    eventShortHeight: 30,\n    monthStartFormat: { month: 'long', day: 'numeric' },\n};\n// calendar listeners\n// ------------------\nconst CALENDAR_LISTENER_REFINERS = {\n    datesSet: identity,\n    eventsSet: identity,\n    eventAdd: identity,\n    eventChange: identity,\n    eventRemove: identity,\n    windowResize: identity,\n    eventClick: identity,\n    eventMouseEnter: identity,\n    eventMouseLeave: identity,\n    select: identity,\n    unselect: identity,\n    loading: identity,\n    // internal\n    _unmount: identity,\n    _beforeprint: identity,\n    _afterprint: identity,\n    _noEventDrop: identity,\n    _noEventResize: identity,\n    _resize: identity,\n    _scrollRequest: identity,\n};\n// calendar-specific options\n// -------------------------\nconst CALENDAR_OPTION_REFINERS = {\n    buttonText: identity,\n    buttonHints: identity,\n    views: identity,\n    plugins: identity,\n    initialEvents: identity,\n    events: identity,\n    eventSources: identity,\n};\nconst COMPLEX_OPTION_COMPARATORS = {\n    headerToolbar: isMaybeObjectsEqual,\n    footerToolbar: isMaybeObjectsEqual,\n    buttonText: isMaybeObjectsEqual,\n    buttonHints: isMaybeObjectsEqual,\n    buttonIcons: isMaybeObjectsEqual,\n    dateIncrement: isMaybeObjectsEqual,\n    plugins: isMaybeArraysEqual,\n    events: isMaybeArraysEqual,\n    eventSources: isMaybeArraysEqual,\n    ['resources']: isMaybeArraysEqual,\n};\nfunction isMaybeObjectsEqual(a, b) {\n    if (typeof a === 'object' && typeof b === 'object' && a && b) { // both non-null objects\n        return isPropsEqual(a, b);\n    }\n    return a === b;\n}\nfunction isMaybeArraysEqual(a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return isArraysEqual(a, b);\n    }\n    return a === b;\n}\n// view-specific options\n// ---------------------\nconst VIEW_OPTION_REFINERS = {\n    type: String,\n    component: identity,\n    buttonText: String,\n    buttonTextKey: String,\n    dateProfileGeneratorClass: identity,\n    usesMinMaxTime: Boolean,\n    classNames: identity,\n    content: identity,\n    didMount: identity,\n    willUnmount: identity,\n};\n// util funcs\n// ----------------------------------------------------------------------------------------------------\nfunction mergeRawOptions(optionSets) {\n    return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n}\nfunction refineProps(input, refiners) {\n    let refined = {};\n    let extra = {};\n    for (let propName in refiners) {\n        if (propName in input) {\n            refined[propName] = refiners[propName](input[propName]);\n        }\n    }\n    for (let propName in input) {\n        if (!(propName in refiners)) {\n            extra[propName] = input[propName];\n        }\n    }\n    return { refined, extra };\n}\nfunction identity(raw) {\n    return raw;\n}\n\nconst { hasOwnProperty } = Object.prototype;\n// Merges an array of objects into a single object.\n// The second argument allows for an array of property names who's object values will be merged together.\nfunction mergeProps(propObjs, complexPropsMap) {\n    let dest = {};\n    if (complexPropsMap) {\n        for (let name in complexPropsMap) {\n            if (complexPropsMap[name] === isMaybeObjectsEqual) { // implies that it's object-mergeable\n                let complexObjs = [];\n                // collect the trailing object values, stopping when a non-object is discovered\n                for (let i = propObjs.length - 1; i >= 0; i -= 1) {\n                    let val = propObjs[i][name];\n                    if (typeof val === 'object' && val) { // non-null object\n                        complexObjs.unshift(val);\n                    }\n                    else if (val !== undefined) {\n                        dest[name] = val; // if there were no objects, this value will be used\n                        break;\n                    }\n                }\n                // if the trailing values were objects, use the merged value\n                if (complexObjs.length) {\n                    dest[name] = mergeProps(complexObjs);\n                }\n            }\n        }\n    }\n    // copy values into the destination, going from last to first\n    for (let i = propObjs.length - 1; i >= 0; i -= 1) {\n        let props = propObjs[i];\n        for (let name in props) {\n            if (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign\n                dest[name] = props[name];\n            }\n        }\n    }\n    return dest;\n}\nfunction filterHash(hash, func) {\n    let filtered = {};\n    for (let key in hash) {\n        if (func(hash[key], key)) {\n            filtered[key] = hash[key];\n        }\n    }\n    return filtered;\n}\nfunction mapHash(hash, func) {\n    let newHash = {};\n    for (let key in hash) {\n        newHash[key] = func(hash[key], key);\n    }\n    return newHash;\n}\nfunction arrayToHash(a) {\n    let hash = {};\n    for (let item of a) {\n        hash[item] = true;\n    }\n    return hash;\n}\n// TODO: reassess browser support\n// https://caniuse.com/?search=object.values\nfunction hashValuesToArray(obj) {\n    let a = [];\n    for (let key in obj) {\n        a.push(obj[key]);\n    }\n    return a;\n}\nfunction isPropsEqual(obj0, obj1) {\n    if (obj0 === obj1) {\n        return true;\n    }\n    for (let key in obj0) {\n        if (hasOwnProperty.call(obj0, key)) {\n            if (!(key in obj1)) {\n                return false;\n            }\n        }\n    }\n    for (let key in obj1) {\n        if (hasOwnProperty.call(obj1, key)) {\n            if (obj0[key] !== obj1[key]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nconst HANDLER_RE = /^on[A-Z]/;\nfunction isNonHandlerPropsEqual(obj0, obj1) {\n    const keys = getUnequalProps(obj0, obj1);\n    for (let key of keys) {\n        if (!HANDLER_RE.test(key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getUnequalProps(obj0, obj1) {\n    let keys = [];\n    for (let key in obj0) {\n        if (hasOwnProperty.call(obj0, key)) {\n            if (!(key in obj1)) {\n                keys.push(key);\n            }\n        }\n    }\n    for (let key in obj1) {\n        if (hasOwnProperty.call(obj1, key)) {\n            if (obj0[key] !== obj1[key]) {\n                keys.push(key);\n            }\n        }\n    }\n    return keys;\n}\nfunction compareObjs(oldProps, newProps, equalityFuncs = {}) {\n    if (oldProps === newProps) {\n        return true;\n    }\n    for (let key in newProps) {\n        if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;\n        else {\n            return false;\n        }\n    }\n    // check for props that were omitted in the new\n    for (let key in oldProps) {\n        if (!(key in newProps)) {\n            return false;\n        }\n    }\n    return true;\n}\n/*\nassumed \"true\" equality for handler names like \"onReceiveSomething\"\n*/\nfunction isObjValsEqual(val0, val1, comparator) {\n    if (val0 === val1 || comparator === true) {\n        return true;\n    }\n    if (comparator) {\n        return comparator(val0, val1);\n    }\n    return false;\n}\nfunction collectFromHash(hash, startIndex = 0, endIndex, step = 1) {\n    let res = [];\n    if (endIndex == null) {\n        endIndex = Object.keys(hash).length;\n    }\n    for (let i = startIndex; i < endIndex; i += step) {\n        let val = hash[i];\n        if (val !== undefined) { // will disregard undefined for sparse arrays\n            res.push(val);\n        }\n    }\n    return res;\n}\n\nlet calendarSystemClassMap = {};\nfunction registerCalendarSystem(name, theClass) {\n    calendarSystemClassMap[name] = theClass;\n}\nfunction createCalendarSystem(name) {\n    return new calendarSystemClassMap[name]();\n}\nclass GregorianCalendarSystem {\n    getMarkerYear(d) {\n        return d.getUTCFullYear();\n    }\n    getMarkerMonth(d) {\n        return d.getUTCMonth();\n    }\n    getMarkerDay(d) {\n        return d.getUTCDate();\n    }\n    arrayToMarker(arr) {\n        return arrayToUtcDate(arr);\n    }\n    markerToArray(marker) {\n        return dateToUtcArray(marker);\n    }\n}\nregisterCalendarSystem('gregory', GregorianCalendarSystem);\n\nconst ISO_RE = /^\\s*(\\d{4})(-?(\\d{2})(-?(\\d{2})([T ](\\d{2}):?(\\d{2})(:?(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\nfunction parse(str) {\n    let m = ISO_RE.exec(str);\n    if (m) {\n        let marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(`0.${m[12]}`) * 1000 : 0));\n        if (isValidDate(marker)) {\n            let timeZoneOffset = null;\n            if (m[13]) {\n                timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 +\n                    Number(m[18] || 0));\n            }\n            return {\n                marker,\n                isTimeUnspecified: !m[6],\n                timeZoneOffset,\n            };\n        }\n    }\n    return null;\n}\n\nclass DateEnv {\n    constructor(settings) {\n        let timeZone = this.timeZone = settings.timeZone;\n        let isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';\n        if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n            this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n        }\n        this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n        this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n        this.locale = settings.locale;\n        this.weekDow = settings.locale.week.dow;\n        this.weekDoy = settings.locale.week.doy;\n        if (settings.weekNumberCalculation === 'ISO') {\n            this.weekDow = 1;\n            this.weekDoy = 4;\n        }\n        if (typeof settings.firstDay === 'number') {\n            this.weekDow = settings.firstDay;\n        }\n        if (typeof settings.weekNumberCalculation === 'function') {\n            this.weekNumberFunc = settings.weekNumberCalculation;\n        }\n        this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n        this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;\n        this.cmdFormatter = settings.cmdFormatter;\n        this.defaultSeparator = settings.defaultSeparator;\n    }\n    // Creating / Parsing\n    createMarker(input) {\n        let meta = this.createMarkerMeta(input);\n        if (meta === null) {\n            return null;\n        }\n        return meta.marker;\n    }\n    createNowMarker() {\n        if (this.canComputeOffset) {\n            return this.timestampToMarker(new Date().valueOf());\n        }\n        // if we can't compute the current date val for a timezone,\n        // better to give the current local date vals than UTC\n        return arrayToUtcDate(dateToLocalArray(new Date()));\n    }\n    createMarkerMeta(input) {\n        if (typeof input === 'string') {\n            return this.parse(input);\n        }\n        let marker = null;\n        if (typeof input === 'number') {\n            marker = this.timestampToMarker(input);\n        }\n        else if (input instanceof Date) {\n            input = input.valueOf();\n            if (!isNaN(input)) {\n                marker = this.timestampToMarker(input);\n            }\n        }\n        else if (Array.isArray(input)) {\n            marker = arrayToUtcDate(input);\n        }\n        if (marker === null || !isValidDate(marker)) {\n            return null;\n        }\n        return { marker, isTimeUnspecified: false, forcedTzo: null };\n    }\n    parse(s) {\n        let parts = parse(s);\n        if (parts === null) {\n            return null;\n        }\n        let { marker } = parts;\n        let forcedTzo = null;\n        if (parts.timeZoneOffset !== null) {\n            if (this.canComputeOffset) {\n                marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n            }\n            else {\n                forcedTzo = parts.timeZoneOffset;\n            }\n        }\n        return { marker, isTimeUnspecified: parts.isTimeUnspecified, forcedTzo };\n    }\n    // Accessors\n    getYear(marker) {\n        return this.calendarSystem.getMarkerYear(marker);\n    }\n    getMonth(marker) {\n        return this.calendarSystem.getMarkerMonth(marker);\n    }\n    getDay(marker) {\n        return this.calendarSystem.getMarkerDay(marker);\n    }\n    // Adding / Subtracting\n    add(marker, dur) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[0] += dur.years;\n        a[1] += dur.months;\n        a[2] += dur.days;\n        a[6] += dur.milliseconds;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    subtract(marker, dur) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[0] -= dur.years;\n        a[1] -= dur.months;\n        a[2] -= dur.days;\n        a[6] -= dur.milliseconds;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    addYears(marker, n) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[0] += n;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    addMonths(marker, n) {\n        let a = this.calendarSystem.markerToArray(marker);\n        a[1] += n;\n        return this.calendarSystem.arrayToMarker(a);\n    }\n    // Diffing Whole Units\n    diffWholeYears(m0, m1) {\n        let { calendarSystem } = this;\n        if (timeAsMs(m0) === timeAsMs(m1) &&\n            calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) &&\n            calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n            return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n        }\n        return null;\n    }\n    diffWholeMonths(m0, m1) {\n        let { calendarSystem } = this;\n        if (timeAsMs(m0) === timeAsMs(m1) &&\n            calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n            return (calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0)) +\n                (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n        }\n        return null;\n    }\n    // Range / Duration\n    greatestWholeUnit(m0, m1) {\n        let n = this.diffWholeYears(m0, m1);\n        if (n !== null) {\n            return { unit: 'year', value: n };\n        }\n        n = this.diffWholeMonths(m0, m1);\n        if (n !== null) {\n            return { unit: 'month', value: n };\n        }\n        n = diffWholeWeeks(m0, m1);\n        if (n !== null) {\n            return { unit: 'week', value: n };\n        }\n        n = diffWholeDays(m0, m1);\n        if (n !== null) {\n            return { unit: 'day', value: n };\n        }\n        n = diffHours(m0, m1);\n        if (isInt(n)) {\n            return { unit: 'hour', value: n };\n        }\n        n = diffMinutes(m0, m1);\n        if (isInt(n)) {\n            return { unit: 'minute', value: n };\n        }\n        n = diffSeconds(m0, m1);\n        if (isInt(n)) {\n            return { unit: 'second', value: n };\n        }\n        return { unit: 'millisecond', value: m1.valueOf() - m0.valueOf() };\n    }\n    countDurationsBetween(m0, m1, d) {\n        // TODO: can use greatestWholeUnit\n        let diff;\n        if (d.years) {\n            diff = this.diffWholeYears(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughYears(d);\n            }\n        }\n        if (d.months) {\n            diff = this.diffWholeMonths(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughMonths(d);\n            }\n        }\n        if (d.days) {\n            diff = diffWholeDays(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughDays(d);\n            }\n        }\n        return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n    }\n    // Start-Of\n    // these DON'T return zoned-dates. only UTC start-of dates\n    startOf(m, unit) {\n        if (unit === 'year') {\n            return this.startOfYear(m);\n        }\n        if (unit === 'month') {\n            return this.startOfMonth(m);\n        }\n        if (unit === 'week') {\n            return this.startOfWeek(m);\n        }\n        if (unit === 'day') {\n            return startOfDay(m);\n        }\n        if (unit === 'hour') {\n            return startOfHour(m);\n        }\n        if (unit === 'minute') {\n            return startOfMinute(m);\n        }\n        if (unit === 'second') {\n            return startOfSecond(m);\n        }\n        return null;\n    }\n    startOfYear(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n        ]);\n    }\n    startOfMonth(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n            this.calendarSystem.getMarkerMonth(m),\n        ]);\n    }\n    startOfWeek(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n            this.calendarSystem.getMarkerMonth(m),\n            m.getUTCDate() - ((m.getUTCDay() - this.weekDow + 7) % 7),\n        ]);\n    }\n    // Week Number\n    computeWeekNumber(marker) {\n        if (this.weekNumberFunc) {\n            return this.weekNumberFunc(this.toDate(marker));\n        }\n        return weekOfYear(marker, this.weekDow, this.weekDoy);\n    }\n    // TODO: choke on timeZoneName: long\n    format(marker, formatter, dateOptions = {}) {\n        return formatter.format({\n            marker,\n            timeZoneOffset: dateOptions.forcedTzo != null ?\n                dateOptions.forcedTzo :\n                this.offsetForMarker(marker),\n        }, this);\n    }\n    formatRange(start, end, formatter, dateOptions = {}) {\n        if (dateOptions.isEndExclusive) {\n            end = addMs(end, -1);\n        }\n        return formatter.formatRange({\n            marker: start,\n            timeZoneOffset: dateOptions.forcedStartTzo != null ?\n                dateOptions.forcedStartTzo :\n                this.offsetForMarker(start),\n        }, {\n            marker: end,\n            timeZoneOffset: dateOptions.forcedEndTzo != null ?\n                dateOptions.forcedEndTzo :\n                this.offsetForMarker(end),\n        }, this, dateOptions.defaultSeparator);\n    }\n    /*\n    DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\n    might as well use buildIsoString or some other util directly\n    */\n    formatIso(marker, extraOptions = {}) {\n        let timeZoneOffset = null;\n        if (!extraOptions.omitTimeZoneOffset) {\n            if (extraOptions.forcedTzo != null) {\n                timeZoneOffset = extraOptions.forcedTzo;\n            }\n            else {\n                timeZoneOffset = this.offsetForMarker(marker);\n            }\n        }\n        return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n    }\n    // TimeZone\n    timestampToMarker(ms) {\n        if (this.timeZone === 'local') {\n            return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n        }\n        if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {\n            return new Date(ms);\n        }\n        return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n    }\n    offsetForMarker(m) {\n        if (this.timeZone === 'local') {\n            return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n        }\n        if (this.timeZone === 'UTC') {\n            return 0;\n        }\n        if (this.namedTimeZoneImpl) {\n            return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n        }\n        return null;\n    }\n    // Conversion\n    toDate(m, forcedTzo) {\n        if (this.timeZone === 'local') {\n            return arrayToLocalDate(dateToUtcArray(m));\n        }\n        if (this.timeZone === 'UTC') {\n            return new Date(m.valueOf()); // make sure it's a copy\n        }\n        if (!this.namedTimeZoneImpl) {\n            return new Date(m.valueOf() - (forcedTzo || 0));\n        }\n        return new Date(m.valueOf() -\n            this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);\n    }\n}\n\nclass Theme {\n    constructor(calendarOptions) {\n        if (this.iconOverrideOption) {\n            this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n        }\n    }\n    setIconOverride(iconOverrideHash) {\n        let iconClassesCopy;\n        let buttonName;\n        if (typeof iconOverrideHash === 'object' && iconOverrideHash) { // non-null object\n            iconClassesCopy = Object.assign({}, this.iconClasses);\n            for (buttonName in iconOverrideHash) {\n                iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n            }\n            this.iconClasses = iconClassesCopy;\n        }\n        else if (iconOverrideHash === false) {\n            this.iconClasses = {};\n        }\n    }\n    applyIconOverridePrefix(className) {\n        let prefix = this.iconOverridePrefix;\n        if (prefix && className.indexOf(prefix) !== 0) { // if not already present\n            className = prefix + className;\n        }\n        return className;\n    }\n    getClass(key) {\n        return this.classes[key] || '';\n    }\n    getIconClass(buttonName, isRtl) {\n        let className;\n        if (isRtl && this.rtlIconClasses) {\n            className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n        }\n        else {\n            className = this.iconClasses[buttonName];\n        }\n        if (className) {\n            return `${this.baseIconClass} ${className}`;\n        }\n        return '';\n    }\n    getCustomButtonIconClass(customButtonProps) {\n        let className;\n        if (this.iconOverrideCustomButtonOption) {\n            className = customButtonProps[this.iconOverrideCustomButtonOption];\n            if (className) {\n                return `${this.baseIconClass} ${this.applyIconOverridePrefix(className)}`;\n            }\n        }\n        return '';\n    }\n}\nTheme.prototype.classes = {};\nTheme.prototype.iconClasses = {};\nTheme.prototype.baseIconClass = '';\nTheme.prototype.iconOverridePrefix = '';\n\n/*\nNOTE: this can be a public API, especially createElement for hooks.\nSee examples/typescript-scheduler/src/index.ts\n*/\nfunction flushSync(runBeforeFlush) {\n    runBeforeFlush();\n    let oldDebounceRendering = preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering; // orig\n    let callbackQ = [];\n    function execCallbackSync(callback) {\n        callbackQ.push(callback);\n    }\n    preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering = execCallbackSync;\n    preact__WEBPACK_IMPORTED_MODULE_0__.render(preact__WEBPACK_IMPORTED_MODULE_0__.createElement(FakeComponent, {}), document.createElement('div'));\n    while (callbackQ.length) {\n        callbackQ.shift()();\n    }\n    preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering = oldDebounceRendering;\n}\nclass FakeComponent extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    render() { return preact__WEBPACK_IMPORTED_MODULE_0__.createElement('div', {}); }\n    componentDidMount() { this.setState({}); }\n}\n// TODO: use preact/compat instead?\nfunction createContext(defaultValue) {\n    let ContextType = preact__WEBPACK_IMPORTED_MODULE_0__.createContext(defaultValue);\n    let origProvider = ContextType.Provider;\n    ContextType.Provider = function () {\n        let isNew = !this.getChildContext;\n        let children = origProvider.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        if (isNew) {\n            let subs = [];\n            this.shouldComponentUpdate = (_props) => {\n                if (this.props.value !== _props.value) {\n                    subs.forEach((c) => {\n                        c.context = _props.value;\n                        c.forceUpdate();\n                    });\n                }\n            };\n            this.sub = (c) => {\n                subs.push(c);\n                let old = c.componentWillUnmount;\n                c.componentWillUnmount = () => {\n                    subs.splice(subs.indexOf(c), 1);\n                    old && old.call(c);\n                };\n            };\n        }\n        return children;\n    };\n    return ContextType;\n}\n\nclass ScrollResponder {\n    constructor(execFunc, emitter, scrollTime, scrollTimeReset) {\n        this.execFunc = execFunc;\n        this.emitter = emitter;\n        this.scrollTime = scrollTime;\n        this.scrollTimeReset = scrollTimeReset;\n        this.handleScrollRequest = (request) => {\n            this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);\n            this.drain();\n        };\n        emitter.on('_scrollRequest', this.handleScrollRequest);\n        this.fireInitialScroll();\n    }\n    detach() {\n        this.emitter.off('_scrollRequest', this.handleScrollRequest);\n    }\n    update(isDatesNew) {\n        if (isDatesNew && this.scrollTimeReset) {\n            this.fireInitialScroll(); // will drain\n        }\n        else {\n            this.drain();\n        }\n    }\n    fireInitialScroll() {\n        this.handleScrollRequest({\n            time: this.scrollTime,\n        });\n    }\n    drain() {\n        if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n            this.queuedRequest = null;\n        }\n    }\n}\n\nconst ViewContextType = createContext({}); // for Components\nfunction buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n    return {\n        dateEnv,\n        options: viewOptions,\n        pluginHooks,\n        emitter,\n        dispatch,\n        getCurrentData,\n        calendarApi,\n        viewSpec,\n        viewApi,\n        dateProfileGenerator,\n        theme,\n        isRtl: viewOptions.direction === 'rtl',\n        addResizeHandler(handler) {\n            emitter.on('_resize', handler);\n        },\n        removeResizeHandler(handler) {\n            emitter.off('_resize', handler);\n        },\n        createScrollResponder(execFunc) {\n            return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);\n        },\n        registerInteractiveComponent,\n        unregisterInteractiveComponent,\n    };\n}\n\n/* eslint max-classes-per-file: off */\nclass PureComponent extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    shouldComponentUpdate(nextProps, nextState) {\n        if (this.debug) {\n            // eslint-disable-next-line no-console\n            console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n        }\n        return !compareObjs(this.props, nextProps, this.propEquality) ||\n            !compareObjs(this.state, nextState, this.stateEquality);\n    }\n    // HACK for freakin' React StrictMode\n    safeSetState(newState) {\n        if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {\n            this.setState(newState);\n        }\n    }\n}\nPureComponent.addPropsEquality = addPropsEquality;\nPureComponent.addStateEquality = addStateEquality;\nPureComponent.contextType = ViewContextType;\nPureComponent.prototype.propEquality = {};\nPureComponent.prototype.stateEquality = {};\nclass BaseComponent extends PureComponent {\n}\nBaseComponent.contextType = ViewContextType;\nfunction addPropsEquality(propEquality) {\n    let hash = Object.create(this.prototype.propEquality);\n    Object.assign(hash, propEquality);\n    this.prototype.propEquality = hash;\n}\nfunction addStateEquality(stateEquality) {\n    let hash = Object.create(this.prototype.stateEquality);\n    Object.assign(hash, stateEquality);\n    this.prototype.stateEquality = hash;\n}\n// use other one\nfunction setRef(ref, current) {\n    if (typeof ref === 'function') {\n        ref(current);\n    }\n    else if (ref) {\n        // see https://github.com/facebook/react/issues/13029\n        ref.current = current;\n    }\n}\n\nclass ContentInjector extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.id = guid();\n        this.queuedDomNodes = [];\n        this.currentDomNodes = [];\n        this.handleEl = (el) => {\n            const { options } = this.context;\n            const { generatorName } = this.props;\n            if (!options.customRenderingReplaces || !hasCustomRenderingHandler(generatorName, options)) {\n                this.updateElRef(el);\n            }\n        };\n        this.updateElRef = (el) => {\n            if (this.props.elRef) {\n                setRef(this.props.elRef, el);\n            }\n        };\n    }\n    render() {\n        const { props, context } = this;\n        const { options } = context;\n        const { customGenerator, defaultGenerator, renderProps } = props;\n        const attrs = buildElAttrs(props, [], this.handleEl);\n        let useDefault = false;\n        let innerContent;\n        let queuedDomNodes = [];\n        let currentGeneratorMeta;\n        if (customGenerator != null) {\n            const customGeneratorRes = typeof customGenerator === 'function' ?\n                customGenerator(renderProps, preact__WEBPACK_IMPORTED_MODULE_0__.createElement) :\n                customGenerator;\n            if (customGeneratorRes === true) {\n                useDefault = true;\n            }\n            else {\n                const isObject = customGeneratorRes && typeof customGeneratorRes === 'object'; // non-null\n                if (isObject && ('html' in customGeneratorRes)) {\n                    attrs.dangerouslySetInnerHTML = { __html: customGeneratorRes.html };\n                }\n                else if (isObject && ('domNodes' in customGeneratorRes)) {\n                    queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);\n                }\n                else if (isObject\n                    ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(customGeneratorRes) // vdom node\n                    : typeof customGeneratorRes !== 'function' // primitive value (like string or number)\n                ) {\n                    // use in vdom\n                    innerContent = customGeneratorRes;\n                }\n                else {\n                    // an exotic object for handleCustomRendering\n                    currentGeneratorMeta = customGeneratorRes;\n                }\n            }\n        }\n        else {\n            useDefault = !hasCustomRenderingHandler(props.generatorName, options);\n        }\n        if (useDefault && defaultGenerator) {\n            innerContent = defaultGenerator(renderProps);\n        }\n        this.queuedDomNodes = queuedDomNodes;\n        this.currentGeneratorMeta = currentGeneratorMeta;\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(props.elTag, attrs, innerContent);\n    }\n    componentDidMount() {\n        this.applyQueueudDomNodes();\n        this.triggerCustomRendering(true);\n    }\n    componentDidUpdate() {\n        this.applyQueueudDomNodes();\n        this.triggerCustomRendering(true);\n    }\n    componentWillUnmount() {\n        this.triggerCustomRendering(false); // TODO: different API for removal?\n    }\n    triggerCustomRendering(isActive) {\n        var _a;\n        const { props, context } = this;\n        const { handleCustomRendering, customRenderingMetaMap } = context.options;\n        if (handleCustomRendering) {\n            const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== void 0 ? _a : customRenderingMetaMap === null || customRenderingMetaMap === void 0 ? void 0 : customRenderingMetaMap[props.generatorName];\n            if (generatorMeta) {\n                handleCustomRendering(Object.assign(Object.assign({ id: this.id, isActive, containerEl: this.base, reportNewContainerEl: this.updateElRef, // front-end framework tells us about new container els\n                    generatorMeta }, props), { elClasses: (props.elClasses || []).filter(isTruthy) }));\n            }\n        }\n    }\n    applyQueueudDomNodes() {\n        const { queuedDomNodes, currentDomNodes } = this;\n        const el = this.base;\n        if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {\n            currentDomNodes.forEach(removeElement);\n            for (let newNode of queuedDomNodes) {\n                el.appendChild(newNode);\n            }\n            this.currentDomNodes = queuedDomNodes;\n        }\n    }\n}\nContentInjector.addPropsEquality({\n    elClasses: isArraysEqual,\n    elStyle: isPropsEqual,\n    elAttrs: isNonHandlerPropsEqual,\n    renderProps: isPropsEqual,\n});\n// Util\n/*\nDoes UI-framework provide custom way of rendering that does not use Preact VDOM\nAND does the calendar's options define custom rendering?\nAKA. Should we NOT render the default content?\n*/\nfunction hasCustomRenderingHandler(generatorName, options) {\n    var _a;\n    return Boolean(options.handleCustomRendering &&\n        generatorName &&\n        ((_a = options.customRenderingMetaMap) === null || _a === void 0 ? void 0 : _a[generatorName]));\n}\nfunction buildElAttrs(props, extraClassNames, elRef) {\n    const attrs = Object.assign(Object.assign({}, props.elAttrs), { ref: elRef });\n    if (props.elClasses || extraClassNames) {\n        attrs.className = (props.elClasses || [])\n            .concat(extraClassNames || [])\n            .concat(attrs.className || [])\n            .filter(Boolean)\n            .join(' ');\n    }\n    if (props.elStyle) {\n        attrs.style = props.elStyle;\n    }\n    return attrs;\n}\nfunction isTruthy(val) {\n    return Boolean(val);\n}\n\nconst RenderId = createContext(0);\n\nclass ContentContainer extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor() {\n        super(...arguments);\n        this.InnerContent = InnerContentInjector.bind(undefined, this);\n        this.handleEl = (el) => {\n            this.el = el;\n            if (this.props.elRef) {\n                setRef(this.props.elRef, el);\n                if (el && this.didMountMisfire) {\n                    this.componentDidMount();\n                }\n            }\n        };\n    }\n    render() {\n        const { props } = this;\n        const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);\n        if (props.children) {\n            const elAttrs = buildElAttrs(props, generatedClassNames, this.handleEl);\n            const children = props.children(this.InnerContent, props.renderProps, elAttrs);\n            if (props.elTag) {\n                return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(props.elTag, elAttrs, children);\n            }\n            else {\n                return children;\n            }\n        }\n        else {\n            return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)((ContentInjector), Object.assign(Object.assign({}, props), { elRef: this.handleEl, elTag: props.elTag || 'div', elClasses: (props.elClasses || []).concat(generatedClassNames), renderId: this.context }));\n        }\n    }\n    componentDidMount() {\n        var _a, _b;\n        if (this.el) {\n            (_b = (_a = this.props).didMount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));\n        }\n        else {\n            this.didMountMisfire = true;\n        }\n    }\n    componentWillUnmount() {\n        var _a, _b;\n        (_b = (_a = this.props).willUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));\n    }\n}\nContentContainer.contextType = RenderId;\nfunction InnerContentInjector(containerComponent, props) {\n    const parentProps = containerComponent.props;\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)((ContentInjector), Object.assign({ renderProps: parentProps.renderProps, generatorName: parentProps.generatorName, customGenerator: parentProps.customGenerator, defaultGenerator: parentProps.defaultGenerator, renderId: containerComponent.context }, props));\n}\n// Utils\nfunction generateClassNames(classNameGenerator, renderProps) {\n    const classNames = typeof classNameGenerator === 'function' ?\n        classNameGenerator(renderProps) :\n        classNameGenerator || [];\n    return typeof classNames === 'string' ? [classNames] : classNames;\n}\n\nclass ViewContainer extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let renderProps = { view: context.viewApi };\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props, { elTag: props.elTag || 'div', elClasses: [\n                ...buildViewClassNames(props.viewSpec),\n                ...(props.elClasses || []),\n            ], renderProps: renderProps, classNameGenerator: options.viewClassNames, generatorName: undefined, didMount: options.viewDidMount, willUnmount: options.viewWillUnmount }), () => props.children));\n    }\n}\nfunction buildViewClassNames(viewSpec) {\n    return [\n        `fc-${viewSpec.type}-view`,\n        'fc-view',\n    ];\n}\n\nfunction parseRange(input, dateEnv) {\n    let start = null;\n    let end = null;\n    if (input.start) {\n        start = dateEnv.createMarker(input.start);\n    }\n    if (input.end) {\n        end = dateEnv.createMarker(input.end);\n    }\n    if (!start && !end) {\n        return null;\n    }\n    if (start && end && end < start) {\n        return null;\n    }\n    return { start, end };\n}\n// SIDE-EFFECT: will mutate ranges.\n// Will return a new array result.\nfunction invertRanges(ranges, constraintRange) {\n    let invertedRanges = [];\n    let { start } = constraintRange; // the end of the previous range. the start of the new range\n    let i;\n    let dateRange;\n    // ranges need to be in order. required for our date-walking algorithm\n    ranges.sort(compareRanges);\n    for (i = 0; i < ranges.length; i += 1) {\n        dateRange = ranges[i];\n        // add the span of time before the event (if there is any)\n        if (dateRange.start > start) { // compare millisecond time (skip any ambig logic)\n            invertedRanges.push({ start, end: dateRange.start });\n        }\n        if (dateRange.end > start) {\n            start = dateRange.end;\n        }\n    }\n    // add the span of time after the last event (if there is any)\n    if (start < constraintRange.end) { // compare millisecond time (skip any ambig logic)\n        invertedRanges.push({ start, end: constraintRange.end });\n    }\n    return invertedRanges;\n}\nfunction compareRanges(range0, range1) {\n    return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n}\nfunction intersectRanges(range0, range1) {\n    let { start, end } = range0;\n    let newRange = null;\n    if (range1.start !== null) {\n        if (start === null) {\n            start = range1.start;\n        }\n        else {\n            start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n        }\n    }\n    if (range1.end != null) {\n        if (end === null) {\n            end = range1.end;\n        }\n        else {\n            end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n        }\n    }\n    if (start === null || end === null || start < end) {\n        newRange = { start, end };\n    }\n    return newRange;\n}\nfunction rangesEqual(range0, range1) {\n    return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) &&\n        (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n}\nfunction rangesIntersect(range0, range1) {\n    return (range0.end === null || range1.start === null || range0.end > range1.start) &&\n        (range0.start === null || range1.end === null || range0.start < range1.end);\n}\nfunction rangeContainsRange(outerRange, innerRange) {\n    return (outerRange.start === null || (innerRange.start !== null && innerRange.start >= outerRange.start)) &&\n        (outerRange.end === null || (innerRange.end !== null && innerRange.end <= outerRange.end));\n}\nfunction rangeContainsMarker(range, date) {\n    return (range.start === null || date >= range.start) &&\n        (range.end === null || date < range.end);\n}\n// If the given date is not within the given range, move it inside.\n// (If it's past the end, make it one millisecond before the end).\nfunction constrainMarkerToRange(date, range) {\n    if (range.start != null && date < range.start) {\n        return range.start;\n    }\n    if (range.end != null && date >= range.end) {\n        return new Date(range.end.valueOf() - 1);\n    }\n    return date;\n}\n\n/* Date stuff that doesn't belong in datelib core\n----------------------------------------------------------------------------------------------------------------------*/\n// given a timed range, computes an all-day range that has the same exact duration,\n// but whose start time is aligned with the start of the day.\nfunction computeAlignedDayRange(timedRange) {\n    let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n    let start = startOfDay(timedRange.start);\n    let end = addDays(start, dayCnt);\n    return { start, end };\n}\n// given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n// TODO: give nextDayThreshold a default arg\nfunction computeVisibleDayRange(timedRange, nextDayThreshold = createDuration(0)) {\n    let startDay = null;\n    let endDay = null;\n    if (timedRange.end) {\n        endDay = startOfDay(timedRange.end);\n        let endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n        // If the end time is actually inclusively part of the next day and is equal to or\n        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n        if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n            endDay = addDays(endDay, 1);\n        }\n    }\n    if (timedRange.start) {\n        startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n        if (endDay && endDay <= startDay) {\n            endDay = addDays(startDay, 1);\n        }\n    }\n    return { start: startDay, end: endDay };\n}\n// spans from one day into another?\nfunction isMultiDayRange(range) {\n    let visibleRange = computeVisibleDayRange(range);\n    return diffDays(visibleRange.start, visibleRange.end) > 1;\n}\nfunction diffDates(date0, date1, dateEnv, largeUnit) {\n    if (largeUnit === 'year') {\n        return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');\n    }\n    if (largeUnit === 'month') {\n        return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');\n    }\n    return diffDayAndTime(date0, date1); // returns a duration\n}\n\nfunction reduceCurrentDate(currentDate, action) {\n    switch (action.type) {\n        case 'CHANGE_DATE':\n            return action.dateMarker;\n        default:\n            return currentDate;\n    }\n}\nfunction getInitialDate(options, dateEnv) {\n    let initialDateInput = options.initialDate;\n    // compute the initial ambig-timezone date\n    if (initialDateInput != null) {\n        return dateEnv.createMarker(initialDateInput);\n    }\n    return getNow(options.now, dateEnv); // getNow already returns unzoned\n}\nfunction getNow(nowInput, dateEnv) {\n    if (typeof nowInput === 'function') {\n        nowInput = nowInput();\n    }\n    if (nowInput == null) {\n        return dateEnv.createNowMarker();\n    }\n    return dateEnv.createMarker(nowInput);\n}\n\nclass DateProfileGenerator {\n    constructor(props) {\n        this.props = props;\n        this.nowDate = getNow(props.nowInput, props.dateEnv);\n        this.initHiddenDays();\n    }\n    /* Date Range Computation\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n    buildPrev(currentDateProfile, currentDate, forceToValid) {\n        let { dateEnv } = this.props;\n        let prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n        currentDateProfile.dateIncrement);\n        return this.build(prevDate, -1, forceToValid);\n    }\n    // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n    buildNext(currentDateProfile, currentDate, forceToValid) {\n        let { dateEnv } = this.props;\n        let nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n        currentDateProfile.dateIncrement);\n        return this.build(nextDate, 1, forceToValid);\n    }\n    // Builds a structure holding dates/ranges for rendering around the given date.\n    // Optional direction param indicates whether the date is being incremented/decremented\n    // from its previous value. decremented = -1, incremented = 1 (default).\n    build(currentDate, direction, forceToValid = true) {\n        let { props } = this;\n        let validRange;\n        let currentInfo;\n        let isRangeAllDay;\n        let renderRange;\n        let activeRange;\n        let isValid;\n        validRange = this.buildValidRange();\n        validRange = this.trimHiddenDays(validRange);\n        if (forceToValid) {\n            currentDate = constrainMarkerToRange(currentDate, validRange);\n        }\n        currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n        renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n        renderRange = this.trimHiddenDays(renderRange);\n        activeRange = renderRange;\n        if (!props.showNonCurrentDates) {\n            activeRange = intersectRanges(activeRange, currentInfo.range);\n        }\n        activeRange = this.adjustActiveRange(activeRange);\n        activeRange = intersectRanges(activeRange, validRange); // might return null\n        // it's invalid if the originally requested date is not contained,\n        // or if the range is completely outside of the valid range.\n        isValid = rangesIntersect(currentInfo.range, validRange);\n        // HACK: constrain to render-range so `currentDate` is more useful to view rendering\n        if (!rangeContainsMarker(renderRange, currentDate)) {\n            currentDate = renderRange.start;\n        }\n        return {\n            currentDate,\n            // constraint for where prev/next operations can go and where events can be dragged/resized to.\n            // an object with optional start and end properties.\n            validRange,\n            // range the view is formally responsible for.\n            // for example, a month view might have 1st-31st, excluding padded dates\n            currentRange: currentInfo.range,\n            // name of largest unit being displayed, like \"month\" or \"week\"\n            currentRangeUnit: currentInfo.unit,\n            isRangeAllDay,\n            // dates that display events and accept drag-n-drop\n            // will be `null` if no dates accept events\n            activeRange,\n            // date range with a rendered skeleton\n            // includes not-active days that need some sort of DOM\n            renderRange,\n            // Duration object that denotes the first visible time of any given day\n            slotMinTime: props.slotMinTime,\n            // Duration object that denotes the exclusive visible end time of any given day\n            slotMaxTime: props.slotMaxTime,\n            isValid,\n            // how far the current date will move for a prev/next operation\n            dateIncrement: this.buildDateIncrement(currentInfo.duration),\n            // pass a fallback (might be null) ^\n        };\n    }\n    // Builds an object with optional start/end properties.\n    // Indicates the minimum/maximum dates to display.\n    // not responsible for trimming hidden days.\n    buildValidRange() {\n        let input = this.props.validRangeInput;\n        let simpleInput = typeof input === 'function'\n            ? input.call(this.props.calendarApi, this.nowDate)\n            : input;\n        return this.refineRange(simpleInput) ||\n            { start: null, end: null }; // completely open-ended\n    }\n    // Builds a structure with info about the \"current\" range, the range that is\n    // highlighted as being the current month for example.\n    // See build() for a description of `direction`.\n    // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n    buildCurrentRangeInfo(date, direction) {\n        let { props } = this;\n        let duration = null;\n        let unit = null;\n        let range = null;\n        let dayCount;\n        if (props.duration) {\n            duration = props.duration;\n            unit = props.durationUnit;\n            range = this.buildRangeFromDuration(date, direction, duration, unit);\n        }\n        else if ((dayCount = this.props.dayCount)) {\n            unit = 'day';\n            range = this.buildRangeFromDayCount(date, direction, dayCount);\n        }\n        else if ((range = this.buildCustomVisibleRange(date))) {\n            unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n        }\n        else {\n            duration = this.getFallbackDuration();\n            unit = greatestDurationDenominator(duration).unit;\n            range = this.buildRangeFromDuration(date, direction, duration, unit);\n        }\n        return { duration, unit, range };\n    }\n    getFallbackDuration() {\n        return createDuration({ day: 1 });\n    }\n    // Returns a new activeRange to have time values (un-ambiguate)\n    // slotMinTime or slotMaxTime causes the range to expand.\n    adjustActiveRange(range) {\n        let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;\n        let { start, end } = range;\n        if (usesMinMaxTime) {\n            // expand active range if slotMinTime is negative (why not when positive?)\n            if (asRoughDays(slotMinTime) < 0) {\n                start = startOfDay(start); // necessary?\n                start = dateEnv.add(start, slotMinTime);\n            }\n            // expand active range if slotMaxTime is beyond one day (why not when negative?)\n            if (asRoughDays(slotMaxTime) > 1) {\n                end = startOfDay(end); // necessary?\n                end = addDays(end, -1);\n                end = dateEnv.add(end, slotMaxTime);\n            }\n        }\n        return { start, end };\n    }\n    // Builds the \"current\" range when it is specified as an explicit duration.\n    // `unit` is the already-computed greatestDurationDenominator unit of duration.\n    buildRangeFromDuration(date, direction, duration, unit) {\n        let { dateEnv, dateAlignment } = this.props;\n        let start;\n        let end;\n        let res;\n        // compute what the alignment should be\n        if (!dateAlignment) {\n            let { dateIncrement } = this.props;\n            if (dateIncrement) {\n                // use the smaller of the two units\n                if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n                    dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n                }\n                else {\n                    dateAlignment = unit;\n                }\n            }\n            else {\n                dateAlignment = unit;\n            }\n        }\n        // if the view displays a single day or smaller\n        if (asRoughDays(duration) <= 1) {\n            if (this.isHiddenDay(start)) {\n                start = this.skipHiddenDays(start, direction);\n                start = startOfDay(start);\n            }\n        }\n        function computeRes() {\n            start = dateEnv.startOf(date, dateAlignment);\n            end = dateEnv.add(start, duration);\n            res = { start, end };\n        }\n        computeRes();\n        // if range is completely enveloped by hidden days, go past the hidden days\n        if (!this.trimHiddenDays(res)) {\n            date = this.skipHiddenDays(date, direction);\n            computeRes();\n        }\n        return res;\n    }\n    // Builds the \"current\" range when a dayCount is specified.\n    buildRangeFromDayCount(date, direction, dayCount) {\n        let { dateEnv, dateAlignment } = this.props;\n        let runningCount = 0;\n        let start = date;\n        let end;\n        if (dateAlignment) {\n            start = dateEnv.startOf(start, dateAlignment);\n        }\n        start = startOfDay(start);\n        start = this.skipHiddenDays(start, direction);\n        end = start;\n        do {\n            end = addDays(end, 1);\n            if (!this.isHiddenDay(end)) {\n                runningCount += 1;\n            }\n        } while (runningCount < dayCount);\n        return { start, end };\n    }\n    // Builds a normalized range object for the \"visible\" range,\n    // which is a way to define the currentRange and activeRange at the same time.\n    buildCustomVisibleRange(date) {\n        let { props } = this;\n        let input = props.visibleRangeInput;\n        let simpleInput = typeof input === 'function'\n            ? input.call(props.calendarApi, props.dateEnv.toDate(date))\n            : input;\n        let range = this.refineRange(simpleInput);\n        if (range && (range.start == null || range.end == null)) {\n            return null;\n        }\n        return range;\n    }\n    // Computes the range that will represent the element/cells for *rendering*,\n    // but which may have voided days/times.\n    // not responsible for trimming hidden days.\n    buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {\n        return currentRange;\n    }\n    // Compute the duration value that should be added/substracted to the current date\n    // when a prev/next operation happens.\n    buildDateIncrement(fallback) {\n        let { dateIncrement } = this.props;\n        let customAlignment;\n        if (dateIncrement) {\n            return dateIncrement;\n        }\n        if ((customAlignment = this.props.dateAlignment)) {\n            return createDuration(1, customAlignment);\n        }\n        if (fallback) {\n            return fallback;\n        }\n        return createDuration({ days: 1 });\n    }\n    refineRange(rangeInput) {\n        if (rangeInput) {\n            let range = parseRange(rangeInput, this.props.dateEnv);\n            if (range) {\n                range = computeVisibleDayRange(range);\n            }\n            return range;\n        }\n        return null;\n    }\n    /* Hidden Days\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Initializes internal variables related to calculating hidden days-of-week\n    initHiddenDays() {\n        let hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n        let isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n        let dayCnt = 0;\n        let i;\n        if (this.props.weekends === false) {\n            hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n        }\n        for (i = 0; i < 7; i += 1) {\n            if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n                dayCnt += 1;\n            }\n        }\n        if (!dayCnt) {\n            throw new Error('invalid hiddenDays'); // all days were hidden? bad.\n        }\n        this.isHiddenDayHash = isHiddenDayHash;\n    }\n    // Remove days from the beginning and end of the range that are computed as hidden.\n    // If the whole range is trimmed off, returns null\n    trimHiddenDays(range) {\n        let { start, end } = range;\n        if (start) {\n            start = this.skipHiddenDays(start);\n        }\n        if (end) {\n            end = this.skipHiddenDays(end, -1, true);\n        }\n        if (start == null || end == null || start < end) {\n            return { start, end };\n        }\n        return null;\n    }\n    // Is the current day hidden?\n    // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n    isHiddenDay(day) {\n        if (day instanceof Date) {\n            day = day.getUTCDay();\n        }\n        return this.isHiddenDayHash[day];\n    }\n    // Incrementing the current day until it is no longer a hidden day, returning a copy.\n    // DOES NOT CONSIDER validRange!\n    // If the initial value of `date` is not a hidden day, don't do anything.\n    // Pass `isExclusive` as `true` if you are dealing with an end date.\n    // `inc` defaults to `1` (increment one day forward each time)\n    skipHiddenDays(date, inc = 1, isExclusive = false) {\n        while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {\n            date = addDays(date, inc);\n        }\n        return date;\n    }\n}\n\nfunction createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n    return {\n        instanceId: guid(),\n        defId,\n        range,\n        forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n        forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo,\n    };\n}\n\nfunction parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n    for (let i = 0; i < recurringTypes.length; i += 1) {\n        let parsed = recurringTypes[i].parse(refined, dateEnv);\n        if (parsed) {\n            let { allDay } = refined;\n            if (allDay == null) {\n                allDay = defaultAllDay;\n                if (allDay == null) {\n                    allDay = parsed.allDayGuess;\n                    if (allDay == null) {\n                        allDay = false;\n                    }\n                }\n            }\n            return {\n                allDay,\n                duration: parsed.duration,\n                typeData: parsed.typeData,\n                typeId: i,\n            };\n        }\n    }\n    return null;\n}\nfunction expandRecurring(eventStore, framingRange, context) {\n    let { dateEnv, pluginHooks, options } = context;\n    let { defs, instances } = eventStore;\n    // remove existing recurring instances\n    // TODO: bad. always expand events as a second step\n    instances = filterHash(instances, (instance) => !defs[instance.defId].recurringDef);\n    for (let defId in defs) {\n        let def = defs[defId];\n        if (def.recurringDef) {\n            let { duration } = def.recurringDef;\n            if (!duration) {\n                duration = def.allDay ?\n                    options.defaultAllDayEventDuration :\n                    options.defaultTimedEventDuration;\n            }\n            let starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n            for (let start of starts) {\n                let instance = createEventInstance(defId, {\n                    start,\n                    end: dateEnv.add(start, duration),\n                });\n                instances[instance.instanceId] = instance;\n            }\n        }\n    }\n    return { defs, instances };\n}\n/*\nEvent MUST have a recurringDef\n*/\nfunction expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n    let typeDef = recurringTypes[eventDef.recurringDef.typeId];\n    let markers = typeDef.expand(eventDef.recurringDef.typeData, {\n        start: dateEnv.subtract(framingRange.start, duration),\n        end: framingRange.end,\n    }, dateEnv);\n    // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n    if (eventDef.allDay) {\n        markers = markers.map(startOfDay);\n    }\n    return markers;\n}\n\nconst EVENT_NON_DATE_REFINERS = {\n    id: String,\n    groupId: String,\n    title: String,\n    url: String,\n    interactive: Boolean,\n};\nconst EVENT_DATE_REFINERS = {\n    start: identity,\n    end: identity,\n    date: identity,\n    allDay: Boolean,\n};\nconst EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), { extendedProps: identity });\nfunction parseEvent(raw, eventSource, context, allowOpenRange, refiners = buildEventRefiners(context), defIdMap, instanceIdMap) {\n    let { refined, extra } = refineEventDef(raw, context, refiners);\n    let defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n    let recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n    if (recurringRes) {\n        let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', recurringRes.allDay, Boolean(recurringRes.duration), context, defIdMap);\n        def.recurringDef = {\n            typeId: recurringRes.typeId,\n            typeData: recurringRes.typeData,\n            duration: recurringRes.duration,\n        };\n        return { def, instance: null };\n    }\n    let singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n    if (singleRes) {\n        let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', singleRes.allDay, singleRes.hasEnd, context, defIdMap);\n        let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n        if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {\n            instance.instanceId = instanceIdMap[def.publicId];\n        }\n        return { def, instance };\n    }\n    return null;\n}\nfunction refineEventDef(raw, context, refiners = buildEventRefiners(context)) {\n    return refineProps(raw, refiners);\n}\nfunction buildEventRefiners(context) {\n    return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n}\n/*\nWill NOT populate extendedProps with the leftover properties.\nWill NOT populate date-related props.\n*/\nfunction parseEventDef(refined, extra, sourceId, allDay, hasEnd, context, defIdMap) {\n    let def = {\n        title: refined.title || '',\n        groupId: refined.groupId || '',\n        publicId: refined.id || '',\n        url: refined.url || '',\n        recurringDef: null,\n        defId: ((defIdMap && refined.id) ? defIdMap[refined.id] : '') || guid(),\n        sourceId,\n        allDay,\n        hasEnd,\n        interactive: refined.interactive,\n        ui: createEventUi(refined, context),\n        extendedProps: Object.assign(Object.assign({}, (refined.extendedProps || {})), extra),\n    };\n    for (let memberAdder of context.pluginHooks.eventDefMemberAdders) {\n        Object.assign(def, memberAdder(refined));\n    }\n    // help out EventImpl from having user modify props\n    Object.freeze(def.ui.classNames);\n    Object.freeze(def.extendedProps);\n    return def;\n}\nfunction parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n    let { allDay } = refined;\n    let startMeta;\n    let startMarker = null;\n    let hasEnd = false;\n    let endMeta;\n    let endMarker = null;\n    let startInput = refined.start != null ? refined.start : refined.date;\n    startMeta = context.dateEnv.createMarkerMeta(startInput);\n    if (startMeta) {\n        startMarker = startMeta.marker;\n    }\n    else if (!allowOpenRange) {\n        return null;\n    }\n    if (refined.end != null) {\n        endMeta = context.dateEnv.createMarkerMeta(refined.end);\n    }\n    if (allDay == null) {\n        if (defaultAllDay != null) {\n            allDay = defaultAllDay;\n        }\n        else {\n            // fall back to the date props LAST\n            allDay = (!startMeta || startMeta.isTimeUnspecified) &&\n                (!endMeta || endMeta.isTimeUnspecified);\n        }\n    }\n    if (allDay && startMarker) {\n        startMarker = startOfDay(startMarker);\n    }\n    if (endMeta) {\n        endMarker = endMeta.marker;\n        if (allDay) {\n            endMarker = startOfDay(endMarker);\n        }\n        if (startMarker && endMarker <= startMarker) {\n            endMarker = null;\n        }\n    }\n    if (endMarker) {\n        hasEnd = true;\n    }\n    else if (!allowOpenRange) {\n        hasEnd = context.options.forceEventDuration || false;\n        endMarker = context.dateEnv.add(startMarker, allDay ?\n            context.options.defaultAllDayEventDuration :\n            context.options.defaultTimedEventDuration);\n    }\n    return {\n        allDay,\n        hasEnd,\n        range: { start: startMarker, end: endMarker },\n        forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n        forcedEndTzo: endMeta ? endMeta.forcedTzo : null,\n    };\n}\nfunction computeIsDefaultAllDay(eventSource, context) {\n    let res = null;\n    if (eventSource) {\n        res = eventSource.defaultAllDay;\n    }\n    if (res == null) {\n        res = context.options.defaultAllDay;\n    }\n    return res;\n}\n\nfunction parseEvents(rawEvents, eventSource, context, allowOpenRange, defIdMap, instanceIdMap) {\n    let eventStore = createEmptyEventStore();\n    let eventRefiners = buildEventRefiners(context);\n    for (let rawEvent of rawEvents) {\n        let tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);\n        if (tuple) {\n            eventTupleToStore(tuple, eventStore);\n        }\n    }\n    return eventStore;\n}\nfunction eventTupleToStore(tuple, eventStore = createEmptyEventStore()) {\n    eventStore.defs[tuple.def.defId] = tuple.def;\n    if (tuple.instance) {\n        eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n    }\n    return eventStore;\n}\n// retrieves events that have the same groupId as the instance specified by `instanceId`\n// or they are the same as the instance.\n// why might instanceId not be in the store? an event from another calendar?\nfunction getRelevantEvents(eventStore, instanceId) {\n    let instance = eventStore.instances[instanceId];\n    if (instance) {\n        let def = eventStore.defs[instance.defId];\n        // get events/instances with same group\n        let newStore = filterEventStoreDefs(eventStore, (lookDef) => isEventDefsGrouped(def, lookDef));\n        // add the original\n        // TODO: wish we could use eventTupleToStore or something like it\n        newStore.defs[def.defId] = def;\n        newStore.instances[instance.instanceId] = instance;\n        return newStore;\n    }\n    return createEmptyEventStore();\n}\nfunction isEventDefsGrouped(def0, def1) {\n    return Boolean(def0.groupId && def0.groupId === def1.groupId);\n}\nfunction createEmptyEventStore() {\n    return { defs: {}, instances: {} };\n}\nfunction mergeEventStores(store0, store1) {\n    return {\n        defs: Object.assign(Object.assign({}, store0.defs), store1.defs),\n        instances: Object.assign(Object.assign({}, store0.instances), store1.instances),\n    };\n}\nfunction filterEventStoreDefs(eventStore, filterFunc) {\n    let defs = filterHash(eventStore.defs, filterFunc);\n    let instances = filterHash(eventStore.instances, (instance) => (defs[instance.defId] // still exists?\n    ));\n    return { defs, instances };\n}\nfunction excludeSubEventStore(master, sub) {\n    let { defs, instances } = master;\n    let filteredDefs = {};\n    let filteredInstances = {};\n    for (let defId in defs) {\n        if (!sub.defs[defId]) { // not explicitly excluded\n            filteredDefs[defId] = defs[defId];\n        }\n    }\n    for (let instanceId in instances) {\n        if (!sub.instances[instanceId] && // not explicitly excluded\n            filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n        ) {\n            filteredInstances[instanceId] = instances[instanceId];\n        }\n    }\n    return {\n        defs: filteredDefs,\n        instances: filteredInstances,\n    };\n}\n\nfunction normalizeConstraint(input, context) {\n    if (Array.isArray(input)) {\n        return parseEvents(input, null, context, true); // allowOpenRange=true\n    }\n    if (typeof input === 'object' && input) { // non-null object\n        return parseEvents([input], null, context, true); // allowOpenRange=true\n    }\n    if (input != null) {\n        return String(input);\n    }\n    return null;\n}\n\nfunction parseClassNames(raw) {\n    if (Array.isArray(raw)) {\n        return raw;\n    }\n    if (typeof raw === 'string') {\n        return raw.split(/\\s+/);\n    }\n    return [];\n}\n\n// TODO: better called \"EventSettings\" or \"EventConfig\"\n// TODO: move this file into structs\n// TODO: separate constraint/overlap/allow, because selection uses only that, not other props\nconst EVENT_UI_REFINERS = {\n    display: String,\n    editable: Boolean,\n    startEditable: Boolean,\n    durationEditable: Boolean,\n    constraint: identity,\n    overlap: identity,\n    allow: identity,\n    className: parseClassNames,\n    classNames: parseClassNames,\n    color: String,\n    backgroundColor: String,\n    borderColor: String,\n    textColor: String,\n};\nconst EMPTY_EVENT_UI = {\n    display: null,\n    startEditable: null,\n    durationEditable: null,\n    constraints: [],\n    overlap: null,\n    allows: [],\n    backgroundColor: '',\n    borderColor: '',\n    textColor: '',\n    classNames: [],\n};\nfunction createEventUi(refined, context) {\n    let constraint = normalizeConstraint(refined.constraint, context);\n    return {\n        display: refined.display || null,\n        startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n        durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n        constraints: constraint != null ? [constraint] : [],\n        overlap: refined.overlap != null ? refined.overlap : null,\n        allows: refined.allow != null ? [refined.allow] : [],\n        backgroundColor: refined.backgroundColor || refined.color || '',\n        borderColor: refined.borderColor || refined.color || '',\n        textColor: refined.textColor || '',\n        classNames: (refined.className || []).concat(refined.classNames || []), // join singular and plural\n    };\n}\n// TODO: prevent against problems with <2 args!\nfunction combineEventUis(uis) {\n    return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n}\nfunction combineTwoEventUis(item0, item1) {\n    return {\n        display: item1.display != null ? item1.display : item0.display,\n        startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n        durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n        constraints: item0.constraints.concat(item1.constraints),\n        overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,\n        allows: item0.allows.concat(item1.allows),\n        backgroundColor: item1.backgroundColor || item0.backgroundColor,\n        borderColor: item1.borderColor || item0.borderColor,\n        textColor: item1.textColor || item0.textColor,\n        classNames: item0.classNames.concat(item1.classNames),\n    };\n}\n\nconst EVENT_SOURCE_REFINERS = {\n    id: String,\n    defaultAllDay: Boolean,\n    url: String,\n    format: String,\n    events: identity,\n    eventDataTransform: identity,\n    // for any network-related sources\n    success: identity,\n    failure: identity,\n};\nfunction parseEventSource(raw, context, refiners = buildEventSourceRefiners(context)) {\n    let rawObj;\n    if (typeof raw === 'string') {\n        rawObj = { url: raw };\n    }\n    else if (typeof raw === 'function' || Array.isArray(raw)) {\n        rawObj = { events: raw };\n    }\n    else if (typeof raw === 'object' && raw) { // not null\n        rawObj = raw;\n    }\n    if (rawObj) {\n        let { refined, extra } = refineProps(rawObj, refiners);\n        let metaRes = buildEventSourceMeta(refined, context);\n        if (metaRes) {\n            return {\n                _raw: raw,\n                isFetching: false,\n                latestFetchId: '',\n                fetchRange: null,\n                defaultAllDay: refined.defaultAllDay,\n                eventDataTransform: refined.eventDataTransform,\n                success: refined.success,\n                failure: refined.failure,\n                publicId: refined.id || '',\n                sourceId: guid(),\n                sourceDefId: metaRes.sourceDefId,\n                meta: metaRes.meta,\n                ui: createEventUi(refined, context),\n                extendedProps: extra,\n            };\n        }\n    }\n    return null;\n}\nfunction buildEventSourceRefiners(context) {\n    return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n}\nfunction buildEventSourceMeta(raw, context) {\n    let defs = context.pluginHooks.eventSourceDefs;\n    for (let i = defs.length - 1; i >= 0; i -= 1) { // later-added plugins take precedence\n        let def = defs[i];\n        let meta = def.parseMeta(raw);\n        if (meta) {\n            return { sourceDefId: i, meta };\n        }\n    }\n    return null;\n}\n\nfunction reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n    switch (action.type) {\n        case 'RECEIVE_EVENTS': // raw\n            return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n        case 'RESET_RAW_EVENTS':\n            return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context);\n        case 'ADD_EVENTS': // already parsed, but not expanded\n            return addEvent(eventStore, action.eventStore, // new ones\n            dateProfile ? dateProfile.activeRange : null, context);\n        case 'RESET_EVENTS':\n            return action.eventStore;\n        case 'MERGE_EVENTS': // already parsed and expanded\n            return mergeEventStores(eventStore, action.eventStore);\n        case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n        case 'NEXT':\n        case 'CHANGE_DATE':\n        case 'CHANGE_VIEW_TYPE':\n            if (dateProfile) {\n                return expandRecurring(eventStore, dateProfile.activeRange, context);\n            }\n            return eventStore;\n        case 'REMOVE_EVENTS':\n            return excludeSubEventStore(eventStore, action.eventStore);\n        case 'REMOVE_EVENT_SOURCE':\n            return excludeEventsBySourceId(eventStore, action.sourceId);\n        case 'REMOVE_ALL_EVENT_SOURCES':\n            return filterEventStoreDefs(eventStore, (eventDef) => (!eventDef.sourceId // only keep events with no source id\n            ));\n        case 'REMOVE_ALL_EVENTS':\n            return createEmptyEventStore();\n        default:\n            return eventStore;\n    }\n}\nfunction receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n    if (eventSource && // not already removed\n        fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n    ) {\n        let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n        if (fetchRange) {\n            subset = expandRecurring(subset, fetchRange, context);\n        }\n        return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n    }\n    return eventStore;\n}\nfunction resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context) {\n    const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);\n    let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context, false, defIdMap, instanceIdMap);\n    return expandRecurring(newEventStore, activeRange, context);\n}\nfunction transformRawEvents(rawEvents, eventSource, context) {\n    let calEachTransform = context.options.eventDataTransform;\n    let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n    if (sourceEachTransform) {\n        rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n    }\n    if (calEachTransform) {\n        rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n    }\n    return rawEvents;\n}\nfunction transformEachRawEvent(rawEvents, func) {\n    let refinedEvents;\n    if (!func) {\n        refinedEvents = rawEvents;\n    }\n    else {\n        refinedEvents = [];\n        for (let rawEvent of rawEvents) {\n            let refinedEvent = func(rawEvent);\n            if (refinedEvent) {\n                refinedEvents.push(refinedEvent);\n            }\n            else if (refinedEvent == null) {\n                refinedEvents.push(rawEvent);\n            } // if a different falsy value, do nothing\n        }\n    }\n    return refinedEvents;\n}\nfunction addEvent(eventStore, subset, expandRange, context) {\n    if (expandRange) {\n        subset = expandRecurring(subset, expandRange, context);\n    }\n    return mergeEventStores(eventStore, subset);\n}\nfunction rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n    let { defs } = eventStore;\n    let instances = mapHash(eventStore.instances, (instance) => {\n        let def = defs[instance.defId];\n        if (def.allDay) {\n            return instance; // isn't dependent on timezone\n        }\n        return Object.assign(Object.assign({}, instance), { range: {\n                start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n                end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo)),\n            }, forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo, forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo });\n    });\n    return { defs, instances };\n}\nfunction excludeEventsBySourceId(eventStore, sourceId) {\n    return filterEventStoreDefs(eventStore, (eventDef) => eventDef.sourceId !== sourceId);\n}\n// QUESTION: why not just return instances? do a general object-property-exclusion util\nfunction excludeInstances(eventStore, removals) {\n    return {\n        defs: eventStore.defs,\n        instances: filterHash(eventStore.instances, (instance) => !removals[instance.instanceId]),\n    };\n}\nfunction buildPublicIdMaps(eventStore) {\n    const { defs, instances } = eventStore;\n    const defIdMap = {};\n    const instanceIdMap = {};\n    for (let defId in defs) {\n        const def = defs[defId];\n        const { publicId } = def;\n        if (publicId) {\n            defIdMap[publicId] = defId;\n        }\n    }\n    for (let instanceId in instances) {\n        const instance = instances[instanceId];\n        const def = defs[instance.defId];\n        const { publicId } = def;\n        if (publicId) {\n            instanceIdMap[publicId] = instanceId;\n        }\n    }\n    return { defIdMap, instanceIdMap };\n}\n\nclass Emitter {\n    constructor() {\n        this.handlers = {};\n        this.thisContext = null;\n    }\n    setThisContext(thisContext) {\n        this.thisContext = thisContext;\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    on(type, handler) {\n        addToHash(this.handlers, type, handler);\n    }\n    off(type, handler) {\n        removeFromHash(this.handlers, type, handler);\n    }\n    trigger(type, ...args) {\n        let attachedHandlers = this.handlers[type] || [];\n        let optionHandler = this.options && this.options[type];\n        let handlers = [].concat(optionHandler || [], attachedHandlers);\n        for (let handler of handlers) {\n            handler.apply(this.thisContext, args);\n        }\n    }\n    hasHandlers(type) {\n        return Boolean((this.handlers[type] && this.handlers[type].length) ||\n            (this.options && this.options[type]));\n    }\n}\nfunction addToHash(hash, type, handler) {\n    (hash[type] || (hash[type] = []))\n        .push(handler);\n}\nfunction removeFromHash(hash, type, handler) {\n    if (handler) {\n        if (hash[type]) {\n            hash[type] = hash[type].filter((func) => func !== handler);\n        }\n    }\n    else {\n        delete hash[type]; // remove all handler funcs for this type\n    }\n}\n\nconst DEF_DEFAULTS = {\n    startTime: '09:00',\n    endTime: '17:00',\n    daysOfWeek: [1, 2, 3, 4, 5],\n    display: 'inverse-background',\n    classNames: 'fc-non-business',\n    groupId: '_businessHours', // so multiple defs get grouped\n};\n/*\nTODO: pass around as EventDefHash!!!\n*/\nfunction parseBusinessHours(input, context) {\n    return parseEvents(refineInputs(input), null, context);\n}\nfunction refineInputs(input) {\n    let rawDefs;\n    if (input === true) {\n        rawDefs = [{}]; // will get DEF_DEFAULTS verbatim\n    }\n    else if (Array.isArray(input)) {\n        // if specifying an array, every sub-definition NEEDS a day-of-week\n        rawDefs = input.filter((rawDef) => rawDef.daysOfWeek);\n    }\n    else if (typeof input === 'object' && input) { // non-null object\n        rawDefs = [input];\n    }\n    else { // is probably false\n        rawDefs = [];\n    }\n    rawDefs = rawDefs.map((rawDef) => (Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef)));\n    return rawDefs;\n}\n\nfunction triggerDateSelect(selection, pev, context) {\n    context.emitter.trigger('select', Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context)), { jsEvent: pev ? pev.origEvent : null, view: context.viewApi || context.calendarApi.view }));\n}\nfunction triggerDateUnselect(pev, context) {\n    context.emitter.trigger('unselect', {\n        jsEvent: pev ? pev.origEvent : null,\n        view: context.viewApi || context.calendarApi.view,\n    });\n}\nfunction buildDateSpanApiWithContext(dateSpan, context) {\n    let props = {};\n    for (let transform of context.pluginHooks.dateSpanTransforms) {\n        Object.assign(props, transform(dateSpan, context));\n    }\n    Object.assign(props, buildDateSpanApi(dateSpan, context.dateEnv));\n    return props;\n}\n// Given an event's allDay status and start date, return what its fallback end date should be.\n// TODO: rename to computeDefaultEventEnd\nfunction getDefaultEventEnd(allDay, marker, context) {\n    let { dateEnv, options } = context;\n    let end = marker;\n    if (allDay) {\n        end = startOfDay(end);\n        end = dateEnv.add(end, options.defaultAllDayEventDuration);\n    }\n    else {\n        end = dateEnv.add(end, options.defaultTimedEventDuration);\n    }\n    return end;\n}\n\n// applies the mutation to ALL defs/instances within the event store\nfunction applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n    let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n    let dest = createEmptyEventStore();\n    for (let defId in eventStore.defs) {\n        let def = eventStore.defs[defId];\n        dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n    }\n    for (let instanceId in eventStore.instances) {\n        let instance = eventStore.instances[instanceId];\n        let def = dest.defs[instance.defId]; // important to grab the newly modified def\n        dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n    }\n    return dest;\n}\nfunction applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n    let standardProps = mutation.standardProps || {};\n    // if hasEnd has not been specified, guess a good value based on deltas.\n    // if duration will change, there's no way the default duration will persist,\n    // and thus, we need to mark the event as having a real end\n    if (standardProps.hasEnd == null &&\n        eventConfig.durationEditable &&\n        (mutation.startDelta || mutation.endDelta)) {\n        standardProps.hasEnd = true; // TODO: is this mutation okay?\n    }\n    let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), { ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui) });\n    if (mutation.extendedProps) {\n        copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);\n    }\n    for (let applier of context.pluginHooks.eventDefMutationAppliers) {\n        applier(copy, mutation, context);\n    }\n    if (!copy.hasEnd && context.options.forceEventDuration) {\n        copy.hasEnd = true;\n    }\n    return copy;\n}\nfunction applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef\neventConfig, mutation, context) {\n    let { dateEnv } = context;\n    let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n    let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n    let copy = Object.assign({}, eventInstance);\n    if (forceAllDay) {\n        copy.range = computeAlignedDayRange(copy.range);\n    }\n    if (mutation.datesDelta && eventConfig.startEditable) {\n        copy.range = {\n            start: dateEnv.add(copy.range.start, mutation.datesDelta),\n            end: dateEnv.add(copy.range.end, mutation.datesDelta),\n        };\n    }\n    if (mutation.startDelta && eventConfig.durationEditable) {\n        copy.range = {\n            start: dateEnv.add(copy.range.start, mutation.startDelta),\n            end: copy.range.end,\n        };\n    }\n    if (mutation.endDelta && eventConfig.durationEditable) {\n        copy.range = {\n            start: copy.range.start,\n            end: dateEnv.add(copy.range.end, mutation.endDelta),\n        };\n    }\n    if (clearEnd) {\n        copy.range = {\n            start: copy.range.start,\n            end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context),\n        };\n    }\n    // in case event was all-day but the supplied deltas were not\n    // better util for this?\n    if (eventDef.allDay) {\n        copy.range = {\n            start: startOfDay(copy.range.start),\n            end: startOfDay(copy.range.end),\n        };\n    }\n    // handle invalid durations\n    if (copy.range.end < copy.range.start) {\n        copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n    }\n    return copy;\n}\n\nclass EventSourceImpl {\n    constructor(context, internalEventSource) {\n        this.context = context;\n        this.internalEventSource = internalEventSource;\n    }\n    remove() {\n        this.context.dispatch({\n            type: 'REMOVE_EVENT_SOURCE',\n            sourceId: this.internalEventSource.sourceId,\n        });\n    }\n    refetch() {\n        this.context.dispatch({\n            type: 'FETCH_EVENT_SOURCES',\n            sourceIds: [this.internalEventSource.sourceId],\n            isRefetch: true,\n        });\n    }\n    get id() {\n        return this.internalEventSource.publicId;\n    }\n    get url() {\n        return this.internalEventSource.meta.url;\n    }\n    get format() {\n        return this.internalEventSource.meta.format; // TODO: bad. not guaranteed\n    }\n}\n\nclass EventImpl {\n    // instance will be null if expressing a recurring event that has no current instances,\n    // OR if trying to validate an incoming external event that has no dates assigned\n    constructor(context, def, instance) {\n        this._context = context;\n        this._def = def;\n        this._instance = instance || null;\n    }\n    /*\n    TODO: make event struct more responsible for this\n    */\n    setProp(name, val) {\n        if (name in EVENT_DATE_REFINERS) {\n            console.warn('Could not set date-related prop \\'name\\'. Use one of the date-related methods instead.');\n            // TODO: make proper aliasing system?\n        }\n        else if (name === 'id') {\n            val = EVENT_NON_DATE_REFINERS[name](val);\n            this.mutate({\n                standardProps: { publicId: val }, // hardcoded internal name\n            });\n        }\n        else if (name in EVENT_NON_DATE_REFINERS) {\n            val = EVENT_NON_DATE_REFINERS[name](val);\n            this.mutate({\n                standardProps: { [name]: val },\n            });\n        }\n        else if (name in EVENT_UI_REFINERS) {\n            let ui = EVENT_UI_REFINERS[name](val);\n            if (name === 'color') {\n                ui = { backgroundColor: val, borderColor: val };\n            }\n            else if (name === 'editable') {\n                ui = { startEditable: val, durationEditable: val };\n            }\n            else {\n                ui = { [name]: val };\n            }\n            this.mutate({\n                standardProps: { ui },\n            });\n        }\n        else {\n            console.warn(`Could not set prop '${name}'. Use setExtendedProp instead.`);\n        }\n    }\n    setExtendedProp(name, val) {\n        this.mutate({\n            extendedProps: { [name]: val },\n        });\n    }\n    setStart(startInput, options = {}) {\n        let { dateEnv } = this._context;\n        let start = dateEnv.createMarker(startInput);\n        if (start && this._instance) { // TODO: warning if parsed bad\n            let instanceRange = this._instance.range;\n            let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n            if (options.maintainDuration) {\n                this.mutate({ datesDelta: startDelta });\n            }\n            else {\n                this.mutate({ startDelta });\n            }\n        }\n    }\n    setEnd(endInput, options = {}) {\n        let { dateEnv } = this._context;\n        let end;\n        if (endInput != null) {\n            end = dateEnv.createMarker(endInput);\n            if (!end) {\n                return; // TODO: warning if parsed bad\n            }\n        }\n        if (this._instance) {\n            if (end) {\n                let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n                this.mutate({ endDelta });\n            }\n            else {\n                this.mutate({ standardProps: { hasEnd: false } });\n            }\n        }\n    }\n    setDates(startInput, endInput, options = {}) {\n        let { dateEnv } = this._context;\n        let standardProps = { allDay: options.allDay };\n        let start = dateEnv.createMarker(startInput);\n        let end;\n        if (!start) {\n            return; // TODO: warning if parsed bad\n        }\n        if (endInput != null) {\n            end = dateEnv.createMarker(endInput);\n            if (!end) { // TODO: warning if parsed bad\n                return;\n            }\n        }\n        if (this._instance) {\n            let instanceRange = this._instance.range;\n            // when computing the diff for an event being converted to all-day,\n            // compute diff off of the all-day values the way event-mutation does.\n            if (options.allDay === true) {\n                instanceRange = computeAlignedDayRange(instanceRange);\n            }\n            let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n            if (end) {\n                let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n                if (durationsEqual(startDelta, endDelta)) {\n                    this.mutate({ datesDelta: startDelta, standardProps });\n                }\n                else {\n                    this.mutate({ startDelta, endDelta, standardProps });\n                }\n            }\n            else { // means \"clear the end\"\n                standardProps.hasEnd = false;\n                this.mutate({ datesDelta: startDelta, standardProps });\n            }\n        }\n    }\n    moveStart(deltaInput) {\n        let delta = createDuration(deltaInput);\n        if (delta) { // TODO: warning if parsed bad\n            this.mutate({ startDelta: delta });\n        }\n    }\n    moveEnd(deltaInput) {\n        let delta = createDuration(deltaInput);\n        if (delta) { // TODO: warning if parsed bad\n            this.mutate({ endDelta: delta });\n        }\n    }\n    moveDates(deltaInput) {\n        let delta = createDuration(deltaInput);\n        if (delta) { // TODO: warning if parsed bad\n            this.mutate({ datesDelta: delta });\n        }\n    }\n    setAllDay(allDay, options = {}) {\n        let standardProps = { allDay };\n        let { maintainDuration } = options;\n        if (maintainDuration == null) {\n            maintainDuration = this._context.options.allDayMaintainDuration;\n        }\n        if (this._def.allDay !== allDay) {\n            standardProps.hasEnd = maintainDuration;\n        }\n        this.mutate({ standardProps });\n    }\n    formatRange(formatInput) {\n        let { dateEnv } = this._context;\n        let instance = this._instance;\n        let formatter = createFormatter(formatInput);\n        if (this._def.hasEnd) {\n            return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n                forcedStartTzo: instance.forcedStartTzo,\n                forcedEndTzo: instance.forcedEndTzo,\n            });\n        }\n        return dateEnv.format(instance.range.start, formatter, {\n            forcedTzo: instance.forcedStartTzo,\n        });\n    }\n    mutate(mutation) {\n        let instance = this._instance;\n        if (instance) {\n            let def = this._def;\n            let context = this._context;\n            let { eventStore } = context.getCurrentData();\n            let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);\n            let eventConfigBase = {\n                '': {\n                    display: '',\n                    startEditable: true,\n                    durationEditable: true,\n                    constraints: [],\n                    overlap: null,\n                    allows: [],\n                    backgroundColor: '',\n                    borderColor: '',\n                    textColor: '',\n                    classNames: [],\n                },\n            };\n            relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context);\n            let oldEvent = new EventImpl(context, def, instance); // snapshot\n            this._def = relevantEvents.defs[def.defId];\n            this._instance = relevantEvents.instances[instance.instanceId];\n            context.dispatch({\n                type: 'MERGE_EVENTS',\n                eventStore: relevantEvents,\n            });\n            context.emitter.trigger('eventChange', {\n                oldEvent,\n                event: this,\n                relatedEvents: buildEventApis(relevantEvents, context, instance),\n                revert() {\n                    context.dispatch({\n                        type: 'RESET_EVENTS',\n                        eventStore, // the ORIGINAL store\n                    });\n                },\n            });\n        }\n    }\n    remove() {\n        let context = this._context;\n        let asStore = eventApiToStore(this);\n        context.dispatch({\n            type: 'REMOVE_EVENTS',\n            eventStore: asStore,\n        });\n        context.emitter.trigger('eventRemove', {\n            event: this,\n            relatedEvents: [],\n            revert() {\n                context.dispatch({\n                    type: 'MERGE_EVENTS',\n                    eventStore: asStore,\n                });\n            },\n        });\n    }\n    get source() {\n        let { sourceId } = this._def;\n        if (sourceId) {\n            return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);\n        }\n        return null;\n    }\n    get start() {\n        return this._instance ?\n            this._context.dateEnv.toDate(this._instance.range.start) :\n            null;\n    }\n    get end() {\n        return (this._instance && this._def.hasEnd) ?\n            this._context.dateEnv.toDate(this._instance.range.end) :\n            null;\n    }\n    get startStr() {\n        let instance = this._instance;\n        if (instance) {\n            return this._context.dateEnv.formatIso(instance.range.start, {\n                omitTime: this._def.allDay,\n                forcedTzo: instance.forcedStartTzo,\n            });\n        }\n        return '';\n    }\n    get endStr() {\n        let instance = this._instance;\n        if (instance && this._def.hasEnd) {\n            return this._context.dateEnv.formatIso(instance.range.end, {\n                omitTime: this._def.allDay,\n                forcedTzo: instance.forcedEndTzo,\n            });\n        }\n        return '';\n    }\n    // computable props that all access the def\n    // TODO: find a TypeScript-compatible way to do this at scale\n    get id() { return this._def.publicId; }\n    get groupId() { return this._def.groupId; }\n    get allDay() { return this._def.allDay; }\n    get title() { return this._def.title; }\n    get url() { return this._def.url; }\n    get display() { return this._def.ui.display || 'auto'; } // bad. just normalize the type earlier\n    get startEditable() { return this._def.ui.startEditable; }\n    get durationEditable() { return this._def.ui.durationEditable; }\n    get constraint() { return this._def.ui.constraints[0] || null; }\n    get overlap() { return this._def.ui.overlap; }\n    get allow() { return this._def.ui.allows[0] || null; }\n    get backgroundColor() { return this._def.ui.backgroundColor; }\n    get borderColor() { return this._def.ui.borderColor; }\n    get textColor() { return this._def.ui.textColor; }\n    // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n    get classNames() { return this._def.ui.classNames; }\n    get extendedProps() { return this._def.extendedProps; }\n    toPlainObject(settings = {}) {\n        let def = this._def;\n        let { ui } = def;\n        let { startStr, endStr } = this;\n        let res = {\n            allDay: def.allDay,\n        };\n        if (def.title) {\n            res.title = def.title;\n        }\n        if (startStr) {\n            res.start = startStr;\n        }\n        if (endStr) {\n            res.end = endStr;\n        }\n        if (def.publicId) {\n            res.id = def.publicId;\n        }\n        if (def.groupId) {\n            res.groupId = def.groupId;\n        }\n        if (def.url) {\n            res.url = def.url;\n        }\n        if (ui.display && ui.display !== 'auto') {\n            res.display = ui.display;\n        }\n        // TODO: what about recurring-event properties???\n        // TODO: include startEditable/durationEditable/constraint/overlap/allow\n        if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n            res.color = ui.backgroundColor;\n        }\n        else {\n            if (ui.backgroundColor) {\n                res.backgroundColor = ui.backgroundColor;\n            }\n            if (ui.borderColor) {\n                res.borderColor = ui.borderColor;\n            }\n        }\n        if (ui.textColor) {\n            res.textColor = ui.textColor;\n        }\n        if (ui.classNames.length) {\n            res.classNames = ui.classNames;\n        }\n        if (Object.keys(def.extendedProps).length) {\n            if (settings.collapseExtendedProps) {\n                Object.assign(res, def.extendedProps);\n            }\n            else {\n                res.extendedProps = def.extendedProps;\n            }\n        }\n        return res;\n    }\n    toJSON() {\n        return this.toPlainObject();\n    }\n}\nfunction eventApiToStore(eventApi) {\n    let def = eventApi._def;\n    let instance = eventApi._instance;\n    return {\n        defs: { [def.defId]: def },\n        instances: instance\n            ? { [instance.instanceId]: instance }\n            : {},\n    };\n}\nfunction buildEventApis(eventStore, context, excludeInstance) {\n    let { defs, instances } = eventStore;\n    let eventApis = [];\n    let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : '';\n    for (let id in instances) {\n        let instance = instances[id];\n        let def = defs[instance.defId];\n        if (instance.instanceId !== excludeInstanceId) {\n            eventApis.push(new EventImpl(context, def, instance));\n        }\n    }\n    return eventApis;\n}\n\n/*\nSpecifying nextDayThreshold signals that all-day ranges should be sliced.\n*/\nfunction sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n    let inverseBgByGroupId = {};\n    let inverseBgByDefId = {};\n    let defByGroupId = {};\n    let bgRanges = [];\n    let fgRanges = [];\n    let eventUis = compileEventUis(eventStore.defs, eventUiBases);\n    for (let defId in eventStore.defs) {\n        let def = eventStore.defs[defId];\n        let ui = eventUis[def.defId];\n        if (ui.display === 'inverse-background') {\n            if (def.groupId) {\n                inverseBgByGroupId[def.groupId] = [];\n                if (!defByGroupId[def.groupId]) {\n                    defByGroupId[def.groupId] = def;\n                }\n            }\n            else {\n                inverseBgByDefId[defId] = [];\n            }\n        }\n    }\n    for (let instanceId in eventStore.instances) {\n        let instance = eventStore.instances[instanceId];\n        let def = eventStore.defs[instance.defId];\n        let ui = eventUis[def.defId];\n        let origRange = instance.range;\n        let normalRange = (!def.allDay && nextDayThreshold) ?\n            computeVisibleDayRange(origRange, nextDayThreshold) :\n            origRange;\n        let slicedRange = intersectRanges(normalRange, framingRange);\n        if (slicedRange) {\n            if (ui.display === 'inverse-background') {\n                if (def.groupId) {\n                    inverseBgByGroupId[def.groupId].push(slicedRange);\n                }\n                else {\n                    inverseBgByDefId[instance.defId].push(slicedRange);\n                }\n            }\n            else if (ui.display !== 'none') {\n                (ui.display === 'background' ? bgRanges : fgRanges).push({\n                    def,\n                    ui,\n                    instance,\n                    range: slicedRange,\n                    isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n                    isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf(),\n                });\n            }\n        }\n    }\n    for (let groupId in inverseBgByGroupId) { // BY GROUP\n        let ranges = inverseBgByGroupId[groupId];\n        let invertedRanges = invertRanges(ranges, framingRange);\n        for (let invertedRange of invertedRanges) {\n            let def = defByGroupId[groupId];\n            let ui = eventUis[def.defId];\n            bgRanges.push({\n                def,\n                ui,\n                instance: null,\n                range: invertedRange,\n                isStart: false,\n                isEnd: false,\n            });\n        }\n    }\n    for (let defId in inverseBgByDefId) {\n        let ranges = inverseBgByDefId[defId];\n        let invertedRanges = invertRanges(ranges, framingRange);\n        for (let invertedRange of invertedRanges) {\n            bgRanges.push({\n                def: eventStore.defs[defId],\n                ui: eventUis[defId],\n                instance: null,\n                range: invertedRange,\n                isStart: false,\n                isEnd: false,\n            });\n        }\n    }\n    return { bg: bgRanges, fg: fgRanges };\n}\nfunction hasBgRendering(def) {\n    return def.ui.display === 'background' || def.ui.display === 'inverse-background';\n}\nfunction setElSeg(el, seg) {\n    el.fcSeg = seg;\n}\nfunction getElSeg(el) {\n    return el.fcSeg ||\n        el.parentNode.fcSeg || // for the harness\n        null;\n}\n// event ui computation\nfunction compileEventUis(eventDefs, eventUiBases) {\n    return mapHash(eventDefs, (eventDef) => compileEventUi(eventDef, eventUiBases));\n}\nfunction compileEventUi(eventDef, eventUiBases) {\n    let uis = [];\n    if (eventUiBases['']) {\n        uis.push(eventUiBases['']);\n    }\n    if (eventUiBases[eventDef.defId]) {\n        uis.push(eventUiBases[eventDef.defId]);\n    }\n    uis.push(eventDef.ui);\n    return combineEventUis(uis);\n}\nfunction sortEventSegs(segs, eventOrderSpecs) {\n    let objs = segs.map(buildSegCompareObj);\n    objs.sort((obj0, obj1) => compareByFieldSpecs(obj0, obj1, eventOrderSpecs));\n    return objs.map((c) => c._seg);\n}\n// returns a object with all primitive props that can be compared\nfunction buildSegCompareObj(seg) {\n    let { eventRange } = seg;\n    let eventDef = eventRange.def;\n    let range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n    let start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n    let end = range.end ? range.end.valueOf() : 0; // \"\n    return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), { id: eventDef.publicId, start,\n        end, duration: end - start, allDay: Number(eventDef.allDay), _seg: seg });\n}\nfunction computeSegDraggable(seg, context) {\n    let { pluginHooks } = context;\n    let transformers = pluginHooks.isDraggableTransformers;\n    let { def, ui } = seg.eventRange;\n    let val = ui.startEditable;\n    for (let transformer of transformers) {\n        val = transformer(val, def, ui, context);\n    }\n    return val;\n}\nfunction computeSegStartResizable(seg, context) {\n    return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n}\nfunction computeSegEndResizable(seg, context) {\n    return seg.isEnd && seg.eventRange.ui.durationEditable;\n}\nfunction buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, // defaults to true\ndefaultDisplayEventEnd, // defaults to true\nstartOverride, endOverride) {\n    let { dateEnv, options } = context;\n    let { displayEventTime, displayEventEnd } = options;\n    let eventDef = seg.eventRange.def;\n    let eventInstance = seg.eventRange.instance;\n    if (displayEventTime == null) {\n        displayEventTime = defaultDisplayEventTime !== false;\n    }\n    if (displayEventEnd == null) {\n        displayEventEnd = defaultDisplayEventEnd !== false;\n    }\n    let wholeEventStart = eventInstance.range.start;\n    let wholeEventEnd = eventInstance.range.end;\n    let segStart = startOverride || seg.start || seg.eventRange.range.start;\n    let segEnd = endOverride || seg.end || seg.eventRange.range.end;\n    let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();\n    let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();\n    if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {\n        segStart = isStartDay ? wholeEventStart : segStart;\n        segEnd = isEndDay ? wholeEventEnd : segEnd;\n        if (displayEventEnd && eventDef.hasEnd) {\n            return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n                forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n                forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo,\n            });\n        }\n        return dateEnv.format(segStart, timeFormat, {\n            forcedTzo: startOverride ? null : eventInstance.forcedStartTzo, // nooooo, same\n        });\n    }\n    return '';\n}\nfunction getSegMeta(seg, todayRange, nowDate) {\n    let segRange = seg.eventRange.range;\n    return {\n        isPast: segRange.end <= (nowDate || todayRange.start),\n        isFuture: segRange.start >= (nowDate || todayRange.end),\n        isToday: todayRange && rangeContainsMarker(todayRange, segRange.start),\n    };\n}\nfunction getEventClassNames(props) {\n    let classNames = ['fc-event'];\n    if (props.isMirror) {\n        classNames.push('fc-event-mirror');\n    }\n    if (props.isDraggable) {\n        classNames.push('fc-event-draggable');\n    }\n    if (props.isStartResizable || props.isEndResizable) {\n        classNames.push('fc-event-resizable');\n    }\n    if (props.isDragging) {\n        classNames.push('fc-event-dragging');\n    }\n    if (props.isResizing) {\n        classNames.push('fc-event-resizing');\n    }\n    if (props.isSelected) {\n        classNames.push('fc-event-selected');\n    }\n    if (props.isStart) {\n        classNames.push('fc-event-start');\n    }\n    if (props.isEnd) {\n        classNames.push('fc-event-end');\n    }\n    if (props.isPast) {\n        classNames.push('fc-event-past');\n    }\n    if (props.isToday) {\n        classNames.push('fc-event-today');\n    }\n    if (props.isFuture) {\n        classNames.push('fc-event-future');\n    }\n    return classNames;\n}\nfunction buildEventRangeKey(eventRange) {\n    return eventRange.instance\n        ? eventRange.instance.instanceId\n        : `${eventRange.def.defId}:${eventRange.range.start.toISOString()}`;\n    // inverse-background events don't have specific instances. TODO: better solution\n}\nfunction getSegAnchorAttrs(seg, context) {\n    let { def, instance } = seg.eventRange;\n    let { url } = def;\n    if (url) {\n        return { href: url };\n    }\n    let { emitter, options } = context;\n    let { eventInteractive } = options;\n    if (eventInteractive == null) {\n        eventInteractive = def.interactive;\n        if (eventInteractive == null) {\n            eventInteractive = Boolean(emitter.hasHandlers('eventClick'));\n        }\n    }\n    // mock what happens in EventClicking\n    if (eventInteractive) {\n        // only attach keyboard-related handlers because click handler is already done in EventClicking\n        return createAriaKeyboardAttrs((ev) => {\n            emitter.trigger('eventClick', {\n                el: ev.target,\n                event: new EventImpl(context, def, instance),\n                jsEvent: ev,\n                view: context.viewApi,\n            });\n        });\n    }\n    return {};\n}\n\nconst STANDARD_PROPS = {\n    start: identity,\n    end: identity,\n    allDay: Boolean,\n};\nfunction parseDateSpan(raw, dateEnv, defaultDuration) {\n    let span = parseOpenDateSpan(raw, dateEnv);\n    let { range } = span;\n    if (!range.start) {\n        return null;\n    }\n    if (!range.end) {\n        if (defaultDuration == null) {\n            return null;\n        }\n        range.end = dateEnv.add(range.start, defaultDuration);\n    }\n    return span;\n}\n/*\nTODO: somehow combine with parseRange?\nWill return null if the start/end props were present but parsed invalidly.\n*/\nfunction parseOpenDateSpan(raw, dateEnv) {\n    let { refined: standardProps, extra } = refineProps(raw, STANDARD_PROPS);\n    let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n    let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n    let { allDay } = standardProps;\n    if (allDay == null) {\n        allDay = (startMeta && startMeta.isTimeUnspecified) &&\n            (!endMeta || endMeta.isTimeUnspecified);\n    }\n    return Object.assign({ range: {\n            start: startMeta ? startMeta.marker : null,\n            end: endMeta ? endMeta.marker : null,\n        }, allDay }, extra);\n}\nfunction isDateSpansEqual(span0, span1) {\n    return rangesEqual(span0.range, span1.range) &&\n        span0.allDay === span1.allDay &&\n        isSpanPropsEqual(span0, span1);\n}\n// the NON-DATE-RELATED props\nfunction isSpanPropsEqual(span0, span1) {\n    for (let propName in span1) {\n        if (propName !== 'range' && propName !== 'allDay') {\n            if (span0[propName] !== span1[propName]) {\n                return false;\n            }\n        }\n    }\n    // are there any props that span0 has that span1 DOESN'T have?\n    // both have range/allDay, so no need to special-case.\n    for (let propName in span0) {\n        if (!(propName in span1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction buildDateSpanApi(span, dateEnv) {\n    return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), { allDay: span.allDay });\n}\nfunction buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n    return Object.assign(Object.assign({}, buildRangeApi(range, dateEnv, omitTime)), { timeZone: dateEnv.timeZone });\n}\nfunction buildRangeApi(range, dateEnv, omitTime) {\n    return {\n        start: dateEnv.toDate(range.start),\n        end: dateEnv.toDate(range.end),\n        startStr: dateEnv.formatIso(range.start, { omitTime }),\n        endStr: dateEnv.formatIso(range.end, { omitTime }),\n    };\n}\nfunction fabricateEventRange(dateSpan, eventUiBases, context) {\n    let res = refineEventDef({ editable: false }, context);\n    let def = parseEventDef(res.refined, res.extra, '', // sourceId\n    dateSpan.allDay, true, // hasEnd\n    context);\n    return {\n        def,\n        ui: compileEventUi(def, eventUiBases),\n        instance: createEventInstance(def.defId, dateSpan.range),\n        range: dateSpan.range,\n        isStart: true,\n        isEnd: true,\n    };\n}\n\n/*\ngiven a function that resolves a result asynchronously.\nthe function can either call passed-in success and failure callbacks,\nor it can return a promise.\nif you need to pass additional params to func, bind them first.\n*/\nfunction unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {\n    // guard against success/failure callbacks being called more than once\n    // and guard against a promise AND callback being used together.\n    let isResolved = false;\n    let wrappedSuccess = function (res) {\n        if (!isResolved) {\n            isResolved = true;\n            normalizedSuccessCallback(res);\n        }\n    };\n    let wrappedFailure = function (error) {\n        if (!isResolved) {\n            isResolved = true;\n            normalizedFailureCallback(error);\n        }\n    };\n    let res = func(wrappedSuccess, wrappedFailure);\n    if (res && typeof res.then === 'function') {\n        res.then(wrappedSuccess, wrappedFailure);\n    }\n}\n\nclass JsonRequestError extends Error {\n    constructor(message, response) {\n        super(message);\n        this.response = response;\n    }\n}\nfunction requestJson(method, url, params) {\n    method = method.toUpperCase();\n    const fetchOptions = {\n        method,\n    };\n    if (method === 'GET') {\n        url += (url.indexOf('?') === -1 ? '?' : '&') +\n            new URLSearchParams(params);\n    }\n    else {\n        fetchOptions.body = new URLSearchParams(params);\n        fetchOptions.headers = {\n            'Content-Type': 'application/x-www-form-urlencoded',\n        };\n    }\n    return fetch(url, fetchOptions).then((fetchRes) => {\n        if (fetchRes.ok) {\n            return fetchRes.json().then((parsedResponse) => {\n                return [parsedResponse, fetchRes];\n            }, () => {\n                throw new JsonRequestError('Failure parsing JSON', fetchRes);\n            });\n        }\n        else {\n            throw new JsonRequestError('Request failed', fetchRes);\n        }\n    });\n}\n\nlet canVGrowWithinCell;\nfunction getCanVGrowWithinCell() {\n    if (canVGrowWithinCell == null) {\n        canVGrowWithinCell = computeCanVGrowWithinCell();\n    }\n    return canVGrowWithinCell;\n}\nfunction computeCanVGrowWithinCell() {\n    // for SSR, because this function is call immediately at top-level\n    // TODO: just make this logic execute top-level, immediately, instead of doing lazily\n    if (typeof document === 'undefined') {\n        return true;\n    }\n    let el = document.createElement('div');\n    el.style.position = 'absolute';\n    el.style.top = '0px';\n    el.style.left = '0px';\n    el.innerHTML = '<table><tr><td><div></div></td></tr></table>';\n    el.querySelector('table').style.height = '100px';\n    el.querySelector('div').style.height = '100%';\n    document.body.appendChild(el);\n    let div = el.querySelector('div');\n    let possible = div.offsetHeight > 0;\n    document.body.removeChild(el);\n    return possible;\n}\n\nclass CalendarRoot extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            forPrint: false,\n        };\n        this.handleBeforePrint = () => {\n            flushSync(() => {\n                this.setState({ forPrint: true });\n            });\n        };\n        this.handleAfterPrint = () => {\n            flushSync(() => {\n                this.setState({ forPrint: false });\n            });\n        };\n    }\n    render() {\n        let { props } = this;\n        let { options } = props;\n        let { forPrint } = this.state;\n        let isHeightAuto = forPrint || options.height === 'auto' || options.contentHeight === 'auto';\n        let height = (!isHeightAuto && options.height != null) ? options.height : '';\n        let classNames = [\n            'fc',\n            forPrint ? 'fc-media-print' : 'fc-media-screen',\n            `fc-direction-${options.direction}`,\n            props.theme.getClass('root'),\n        ];\n        if (!getCanVGrowWithinCell()) {\n            classNames.push('fc-liquid-hack');\n        }\n        return props.children(classNames, height, isHeightAuto, forPrint);\n    }\n    componentDidMount() {\n        let { emitter } = this.props;\n        emitter.on('_beforeprint', this.handleBeforePrint);\n        emitter.on('_afterprint', this.handleAfterPrint);\n    }\n    componentWillUnmount() {\n        let { emitter } = this.props;\n        emitter.off('_beforeprint', this.handleBeforePrint);\n        emitter.off('_afterprint', this.handleAfterPrint);\n    }\n}\n\nclass Interaction {\n    constructor(settings) {\n        this.component = settings.component;\n        this.isHitComboAllowed = settings.isHitComboAllowed || null;\n    }\n    destroy() {\n    }\n}\nfunction parseInteractionSettings(component, input) {\n    return {\n        component,\n        el: input.el,\n        useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,\n        isHitComboAllowed: input.isHitComboAllowed || null,\n    };\n}\nfunction interactionSettingsToStore(settings) {\n    return {\n        [settings.component.uid]: settings,\n    };\n}\n// global state\nconst interactionSettingsStore = {};\n\nclass CalendarImpl {\n    getCurrentData() {\n        return this.currentDataManager.getCurrentData();\n    }\n    dispatch(action) {\n        this.currentDataManager.dispatch(action);\n    }\n    get view() { return this.getCurrentData().viewApi; }\n    batchRendering(callback) {\n        callback();\n    }\n    updateSize() {\n        this.trigger('_resize', true);\n    }\n    // Options\n    // -----------------------------------------------------------------------------------------------------------------\n    setOption(name, val) {\n        this.dispatch({\n            type: 'SET_OPTION',\n            optionName: name,\n            rawOptionValue: val,\n        });\n    }\n    getOption(name) {\n        return this.currentDataManager.currentCalendarOptionsInput[name];\n    }\n    getAvailableLocaleCodes() {\n        return Object.keys(this.getCurrentData().availableRawLocales);\n    }\n    // Trigger\n    // -----------------------------------------------------------------------------------------------------------------\n    on(handlerName, handler) {\n        let { currentDataManager } = this;\n        if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n            currentDataManager.emitter.on(handlerName, handler);\n        }\n        else {\n            console.warn(`Unknown listener name '${handlerName}'`);\n        }\n    }\n    off(handlerName, handler) {\n        this.currentDataManager.emitter.off(handlerName, handler);\n    }\n    // not meant for public use\n    trigger(handlerName, ...args) {\n        this.currentDataManager.emitter.trigger(handlerName, ...args);\n    }\n    // View\n    // -----------------------------------------------------------------------------------------------------------------\n    changeView(viewType, dateOrRange) {\n        this.batchRendering(() => {\n            this.unselect();\n            if (dateOrRange) {\n                if (dateOrRange.start && dateOrRange.end) { // a range\n                    this.dispatch({\n                        type: 'CHANGE_VIEW_TYPE',\n                        viewType,\n                    });\n                    this.dispatch({\n                        type: 'SET_OPTION',\n                        optionName: 'visibleRange',\n                        rawOptionValue: dateOrRange,\n                    });\n                }\n                else {\n                    let { dateEnv } = this.getCurrentData();\n                    this.dispatch({\n                        type: 'CHANGE_VIEW_TYPE',\n                        viewType,\n                        dateMarker: dateEnv.createMarker(dateOrRange),\n                    });\n                }\n            }\n            else {\n                this.dispatch({\n                    type: 'CHANGE_VIEW_TYPE',\n                    viewType,\n                });\n            }\n        });\n    }\n    // Forces navigation to a view for the given date.\n    // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n    // needs to change\n    zoomTo(dateMarker, viewType) {\n        let state = this.getCurrentData();\n        let spec;\n        viewType = viewType || 'day'; // day is default zoom\n        spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n        this.unselect();\n        if (spec) {\n            this.dispatch({\n                type: 'CHANGE_VIEW_TYPE',\n                viewType: spec.type,\n                dateMarker,\n            });\n        }\n        else {\n            this.dispatch({\n                type: 'CHANGE_DATE',\n                dateMarker,\n            });\n        }\n    }\n    // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n    // Preference is given to views that have corresponding buttons.\n    getUnitViewSpec(unit) {\n        let { viewSpecs, toolbarConfig } = this.getCurrentData();\n        let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);\n        let i;\n        let spec;\n        for (let viewType in viewSpecs) {\n            viewTypes.push(viewType);\n        }\n        for (i = 0; i < viewTypes.length; i += 1) {\n            spec = viewSpecs[viewTypes[i]];\n            if (spec) {\n                if (spec.singleUnit === unit) {\n                    return spec;\n                }\n            }\n        }\n        return null;\n    }\n    // Current Date\n    // -----------------------------------------------------------------------------------------------------------------\n    prev() {\n        this.unselect();\n        this.dispatch({ type: 'PREV' });\n    }\n    next() {\n        this.unselect();\n        this.dispatch({ type: 'NEXT' });\n    }\n    prevYear() {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: 'CHANGE_DATE',\n            dateMarker: state.dateEnv.addYears(state.currentDate, -1),\n        });\n    }\n    nextYear() {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: 'CHANGE_DATE',\n            dateMarker: state.dateEnv.addYears(state.currentDate, 1),\n        });\n    }\n    today() {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: 'CHANGE_DATE',\n            dateMarker: getNow(state.calendarOptions.now, state.dateEnv),\n        });\n    }\n    gotoDate(zonedDateInput) {\n        let state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: 'CHANGE_DATE',\n            dateMarker: state.dateEnv.createMarker(zonedDateInput),\n        });\n    }\n    incrementDate(deltaInput) {\n        let state = this.getCurrentData();\n        let delta = createDuration(deltaInput);\n        if (delta) { // else, warn about invalid input?\n            this.unselect();\n            this.dispatch({\n                type: 'CHANGE_DATE',\n                dateMarker: state.dateEnv.add(state.currentDate, delta),\n            });\n        }\n    }\n    getDate() {\n        let state = this.getCurrentData();\n        return state.dateEnv.toDate(state.currentDate);\n    }\n    // Date Formatting Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    formatDate(d, formatter) {\n        let { dateEnv } = this.getCurrentData();\n        return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n    }\n    // `settings` is for formatter AND isEndExclusive\n    formatRange(d0, d1, settings) {\n        let { dateEnv } = this.getCurrentData();\n        return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);\n    }\n    formatIso(d, omitTime) {\n        let { dateEnv } = this.getCurrentData();\n        return dateEnv.formatIso(dateEnv.createMarker(d), { omitTime });\n    }\n    // Date Selection / Event Selection / DayClick\n    // -----------------------------------------------------------------------------------------------------------------\n    select(dateOrObj, endDate) {\n        let selectionInput;\n        if (endDate == null) {\n            if (dateOrObj.start != null) {\n                selectionInput = dateOrObj;\n            }\n            else {\n                selectionInput = {\n                    start: dateOrObj,\n                    end: null,\n                };\n            }\n        }\n        else {\n            selectionInput = {\n                start: dateOrObj,\n                end: endDate,\n            };\n        }\n        let state = this.getCurrentData();\n        let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({ days: 1 }));\n        if (selection) { // throw parse error otherwise?\n            this.dispatch({ type: 'SELECT_DATES', selection });\n            triggerDateSelect(selection, null, state);\n        }\n    }\n    unselect(pev) {\n        let state = this.getCurrentData();\n        if (state.dateSelection) {\n            this.dispatch({ type: 'UNSELECT_DATES' });\n            triggerDateUnselect(pev, state);\n        }\n    }\n    // Public Events API\n    // -----------------------------------------------------------------------------------------------------------------\n    addEvent(eventInput, sourceInput) {\n        if (eventInput instanceof EventImpl) {\n            let def = eventInput._def;\n            let instance = eventInput._instance;\n            let currentData = this.getCurrentData();\n            // not already present? don't want to add an old snapshot\n            if (!currentData.eventStore.defs[def.defId]) {\n                this.dispatch({\n                    type: 'ADD_EVENTS',\n                    eventStore: eventTupleToStore({ def, instance }), // TODO: better util for two args?\n                });\n                this.triggerEventAdd(eventInput);\n            }\n            return eventInput;\n        }\n        let state = this.getCurrentData();\n        let eventSource;\n        if (sourceInput instanceof EventSourceImpl) {\n            eventSource = sourceInput.internalEventSource;\n        }\n        else if (typeof sourceInput === 'boolean') {\n            if (sourceInput) { // true. part of the first event source\n                [eventSource] = hashValuesToArray(state.eventSources);\n            }\n        }\n        else if (sourceInput != null) { // an ID. accepts a number too\n            let sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n            if (!sourceApi) {\n                console.warn(`Could not find an event source with ID \"${sourceInput}\"`); // TODO: test\n                return null;\n            }\n            eventSource = sourceApi.internalEventSource;\n        }\n        let tuple = parseEvent(eventInput, eventSource, state, false);\n        if (tuple) {\n            let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n            this.dispatch({\n                type: 'ADD_EVENTS',\n                eventStore: eventTupleToStore(tuple),\n            });\n            this.triggerEventAdd(newEventApi);\n            return newEventApi;\n        }\n        return null;\n    }\n    triggerEventAdd(eventApi) {\n        let { emitter } = this.getCurrentData();\n        emitter.trigger('eventAdd', {\n            event: eventApi,\n            relatedEvents: [],\n            revert: () => {\n                this.dispatch({\n                    type: 'REMOVE_EVENTS',\n                    eventStore: eventApiToStore(eventApi),\n                });\n            },\n        });\n    }\n    // TODO: optimize\n    getEventById(id) {\n        let state = this.getCurrentData();\n        let { defs, instances } = state.eventStore;\n        id = String(id);\n        for (let defId in defs) {\n            let def = defs[defId];\n            if (def.publicId === id) {\n                if (def.recurringDef) {\n                    return new EventImpl(state, def, null);\n                }\n                for (let instanceId in instances) {\n                    let instance = instances[instanceId];\n                    if (instance.defId === def.defId) {\n                        return new EventImpl(state, def, instance);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    getEvents() {\n        let currentData = this.getCurrentData();\n        return buildEventApis(currentData.eventStore, currentData);\n    }\n    removeAllEvents() {\n        this.dispatch({ type: 'REMOVE_ALL_EVENTS' });\n    }\n    // Public Event Sources API\n    // -----------------------------------------------------------------------------------------------------------------\n    getEventSources() {\n        let state = this.getCurrentData();\n        let sourceHash = state.eventSources;\n        let sourceApis = [];\n        for (let internalId in sourceHash) {\n            sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));\n        }\n        return sourceApis;\n    }\n    getEventSourceById(id) {\n        let state = this.getCurrentData();\n        let sourceHash = state.eventSources;\n        id = String(id);\n        for (let sourceId in sourceHash) {\n            if (sourceHash[sourceId].publicId === id) {\n                return new EventSourceImpl(state, sourceHash[sourceId]);\n            }\n        }\n        return null;\n    }\n    addEventSource(sourceInput) {\n        let state = this.getCurrentData();\n        if (sourceInput instanceof EventSourceImpl) {\n            // not already present? don't want to add an old snapshot\n            if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n                this.dispatch({\n                    type: 'ADD_EVENT_SOURCES',\n                    sources: [sourceInput.internalEventSource],\n                });\n            }\n            return sourceInput;\n        }\n        let eventSource = parseEventSource(sourceInput, state);\n        if (eventSource) { // TODO: error otherwise?\n            this.dispatch({ type: 'ADD_EVENT_SOURCES', sources: [eventSource] });\n            return new EventSourceImpl(state, eventSource);\n        }\n        return null;\n    }\n    removeAllEventSources() {\n        this.dispatch({ type: 'REMOVE_ALL_EVENT_SOURCES' });\n    }\n    refetchEvents() {\n        this.dispatch({ type: 'FETCH_EVENT_SOURCES', isRefetch: true });\n    }\n    // Scroll\n    // -----------------------------------------------------------------------------------------------------------------\n    scrollToTime(timeInput) {\n        let time = createDuration(timeInput);\n        if (time) {\n            this.trigger('_scrollRequest', { time });\n        }\n    }\n}\n\nfunction pointInsideRect(point, rect) {\n    return point.left >= rect.left &&\n        point.left < rect.right &&\n        point.top >= rect.top &&\n        point.top < rect.bottom;\n}\n// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\nfunction intersectRects(rect1, rect2) {\n    let res = {\n        left: Math.max(rect1.left, rect2.left),\n        right: Math.min(rect1.right, rect2.right),\n        top: Math.max(rect1.top, rect2.top),\n        bottom: Math.min(rect1.bottom, rect2.bottom),\n    };\n    if (res.left < res.right && res.top < res.bottom) {\n        return res;\n    }\n    return false;\n}\nfunction translateRect(rect, deltaX, deltaY) {\n    return {\n        left: rect.left + deltaX,\n        right: rect.right + deltaX,\n        top: rect.top + deltaY,\n        bottom: rect.bottom + deltaY,\n    };\n}\n// Returns a new point that will have been moved to reside within the given rectangle\nfunction constrainPoint(point, rect) {\n    return {\n        left: Math.min(Math.max(point.left, rect.left), rect.right),\n        top: Math.min(Math.max(point.top, rect.top), rect.bottom),\n    };\n}\n// Returns a point that is the center of the given rectangle\nfunction getRectCenter(rect) {\n    return {\n        left: (rect.left + rect.right) / 2,\n        top: (rect.top + rect.bottom) / 2,\n    };\n}\n// Subtracts point2's coordinates from point1's coordinates, returning a delta\nfunction diffPoints(point1, point2) {\n    return {\n        left: point1.left - point2.left,\n        top: point1.top - point2.top,\n    };\n}\n\nconst EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\nclass Splitter {\n    constructor() {\n        this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n        this.splitDateSelection = memoize(this._splitDateSpan);\n        this.splitEventStore = memoize(this._splitEventStore);\n        this.splitIndividualUi = memoize(this._splitIndividualUi);\n        this.splitEventDrag = memoize(this._splitInteraction);\n        this.splitEventResize = memoize(this._splitInteraction);\n        this.eventUiBuilders = {}; // TODO: typescript protection\n    }\n    splitProps(props) {\n        let keyInfos = this.getKeyInfo(props);\n        let defKeys = this.getKeysForEventDefs(props.eventStore);\n        let dateSelections = this.splitDateSelection(props.dateSelection);\n        let individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n        let eventStores = this.splitEventStore(props.eventStore, defKeys);\n        let eventDrags = this.splitEventDrag(props.eventDrag);\n        let eventResizes = this.splitEventResize(props.eventResize);\n        let splitProps = {};\n        this.eventUiBuilders = mapHash(keyInfos, (info, key) => this.eventUiBuilders[key] || memoize(buildEventUiForKey));\n        for (let key in keyInfos) {\n            let keyInfo = keyInfos[key];\n            let eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n            let buildEventUi = this.eventUiBuilders[key];\n            splitProps[key] = {\n                businessHours: keyInfo.businessHours || props.businessHours,\n                dateSelection: dateSelections[key] || null,\n                eventStore,\n                eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),\n                eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',\n                eventDrag: eventDrags[key] || null,\n                eventResize: eventResizes[key] || null,\n            };\n        }\n        return splitProps;\n    }\n    _splitDateSpan(dateSpan) {\n        let dateSpans = {};\n        if (dateSpan) {\n            let keys = this.getKeysForDateSpan(dateSpan);\n            for (let key of keys) {\n                dateSpans[key] = dateSpan;\n            }\n        }\n        return dateSpans;\n    }\n    _getKeysForEventDefs(eventStore) {\n        return mapHash(eventStore.defs, (eventDef) => this.getKeysForEventDef(eventDef));\n    }\n    _splitEventStore(eventStore, defKeys) {\n        let { defs, instances } = eventStore;\n        let splitStores = {};\n        for (let defId in defs) {\n            for (let key of defKeys[defId]) {\n                if (!splitStores[key]) {\n                    splitStores[key] = createEmptyEventStore();\n                }\n                splitStores[key].defs[defId] = defs[defId];\n            }\n        }\n        for (let instanceId in instances) {\n            let instance = instances[instanceId];\n            for (let key of defKeys[instance.defId]) {\n                if (splitStores[key]) { // must have already been created\n                    splitStores[key].instances[instanceId] = instance;\n                }\n            }\n        }\n        return splitStores;\n    }\n    _splitIndividualUi(eventUiBases, defKeys) {\n        let splitHashes = {};\n        for (let defId in eventUiBases) {\n            if (defId) { // not the '' key\n                for (let key of defKeys[defId]) {\n                    if (!splitHashes[key]) {\n                        splitHashes[key] = {};\n                    }\n                    splitHashes[key][defId] = eventUiBases[defId];\n                }\n            }\n        }\n        return splitHashes;\n    }\n    _splitInteraction(interaction) {\n        let splitStates = {};\n        if (interaction) {\n            let affectedStores = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));\n            // can't rely on defKeys because event data is mutated\n            let mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n            let mutatedStores = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n            let populate = (key) => {\n                if (!splitStates[key]) {\n                    splitStates[key] = {\n                        affectedEvents: affectedStores[key] || EMPTY_EVENT_STORE,\n                        mutatedEvents: mutatedStores[key] || EMPTY_EVENT_STORE,\n                        isEvent: interaction.isEvent,\n                    };\n                }\n            };\n            for (let key in affectedStores) {\n                populate(key);\n            }\n            for (let key in mutatedStores) {\n                populate(key);\n            }\n        }\n        return splitStates;\n    }\n}\nfunction buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n    let baseParts = [];\n    if (allUi) {\n        baseParts.push(allUi);\n    }\n    if (eventUiForKey) {\n        baseParts.push(eventUiForKey);\n    }\n    let stuff = {\n        '': combineEventUis(baseParts),\n    };\n    if (individualUi) {\n        Object.assign(stuff, individualUi);\n    }\n    return stuff;\n}\n\nfunction getDateMeta(date, todayRange, nowDate, dateProfile) {\n    return {\n        dow: date.getUTCDay(),\n        isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),\n        isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n        isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n        isPast: Boolean(nowDate ? (date < nowDate) : todayRange ? (date < todayRange.start) : false),\n        isFuture: Boolean(nowDate ? (date > nowDate) : todayRange ? (date >= todayRange.end) : false),\n    };\n}\nfunction getDayClassNames(meta, theme) {\n    let classNames = [\n        'fc-day',\n        `fc-day-${DAY_IDS[meta.dow]}`,\n    ];\n    if (meta.isDisabled) {\n        classNames.push('fc-day-disabled');\n    }\n    else {\n        if (meta.isToday) {\n            classNames.push('fc-day-today');\n            classNames.push(theme.getClass('today'));\n        }\n        if (meta.isPast) {\n            classNames.push('fc-day-past');\n        }\n        if (meta.isFuture) {\n            classNames.push('fc-day-future');\n        }\n        if (meta.isOther) {\n            classNames.push('fc-day-other');\n        }\n    }\n    return classNames;\n}\nfunction getSlotClassNames(meta, theme) {\n    let classNames = [\n        'fc-slot',\n        `fc-slot-${DAY_IDS[meta.dow]}`,\n    ];\n    if (meta.isDisabled) {\n        classNames.push('fc-slot-disabled');\n    }\n    else {\n        if (meta.isToday) {\n            classNames.push('fc-slot-today');\n            classNames.push(theme.getClass('today'));\n        }\n        if (meta.isPast) {\n            classNames.push('fc-slot-past');\n        }\n        if (meta.isFuture) {\n            classNames.push('fc-slot-future');\n        }\n    }\n    return classNames;\n}\n\nconst DAY_FORMAT = createFormatter({ year: 'numeric', month: 'long', day: 'numeric' });\nconst WEEK_FORMAT = createFormatter({ week: 'long' });\nfunction buildNavLinkAttrs(context, dateMarker, viewType = 'day', isTabbable = true) {\n    const { dateEnv, options, calendarApi } = context;\n    let dateStr = dateEnv.format(dateMarker, viewType === 'week' ? WEEK_FORMAT : DAY_FORMAT);\n    if (options.navLinks) {\n        let zonedDate = dateEnv.toDate(dateMarker);\n        const handleInteraction = (ev) => {\n            let customAction = viewType === 'day' ? options.navLinkDayClick :\n                viewType === 'week' ? options.navLinkWeekClick : null;\n            if (typeof customAction === 'function') {\n                customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n            }\n            else {\n                if (typeof customAction === 'string') {\n                    viewType = customAction;\n                }\n                calendarApi.zoomTo(dateMarker, viewType);\n            }\n        };\n        return Object.assign({ title: formatWithOrdinals(options.navLinkHint, [dateStr, zonedDate], dateStr), 'data-navlink': '' }, (isTabbable\n            ? createAriaClickAttrs(handleInteraction)\n            : { onClick: handleInteraction }));\n    }\n    return { 'aria-label': dateStr };\n}\n\nlet _isRtlScrollbarOnLeft = null;\nfunction getIsRtlScrollbarOnLeft() {\n    if (_isRtlScrollbarOnLeft === null) {\n        _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n    }\n    return _isRtlScrollbarOnLeft;\n}\nfunction computeIsRtlScrollbarOnLeft() {\n    let outerEl = document.createElement('div');\n    applyStyle(outerEl, {\n        position: 'absolute',\n        top: -1000,\n        left: 0,\n        border: 0,\n        padding: 0,\n        overflow: 'scroll',\n        direction: 'rtl',\n    });\n    outerEl.innerHTML = '<div></div>';\n    document.body.appendChild(outerEl);\n    let innerEl = outerEl.firstChild;\n    let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n    removeElement(outerEl);\n    return res;\n}\n\nlet _scrollbarWidths;\nfunction getScrollbarWidths() {\n    if (!_scrollbarWidths) {\n        _scrollbarWidths = computeScrollbarWidths();\n    }\n    return _scrollbarWidths;\n}\nfunction computeScrollbarWidths() {\n    let el = document.createElement('div');\n    el.style.overflow = 'scroll';\n    el.style.position = 'absolute';\n    el.style.top = '-9999px';\n    el.style.left = '-9999px';\n    document.body.appendChild(el);\n    let res = computeScrollbarWidthsForEl(el);\n    document.body.removeChild(el);\n    return res;\n}\n// WARNING: will include border\nfunction computeScrollbarWidthsForEl(el) {\n    return {\n        x: el.offsetHeight - el.clientHeight,\n        y: el.offsetWidth - el.clientWidth,\n    };\n}\n\nfunction computeEdges(el, getPadding = false) {\n    let computedStyle = window.getComputedStyle(el);\n    let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n    let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n    let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n    let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n    let badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n    let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n    let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n    let res = {\n        borderLeft,\n        borderRight,\n        borderTop,\n        borderBottom,\n        scrollbarBottom,\n        scrollbarLeft: 0,\n        scrollbarRight: 0,\n    };\n    if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') { // is the scrollbar on the left side?\n        res.scrollbarLeft = scrollbarLeftRight;\n    }\n    else {\n        res.scrollbarRight = scrollbarLeftRight;\n    }\n    if (getPadding) {\n        res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n        res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n        res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n        res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n    }\n    return res;\n}\nfunction computeInnerRect(el, goWithinPadding = false, doFromWindowViewport) {\n    let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n    let edges = computeEdges(el, goWithinPadding);\n    let res = {\n        left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n        right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n        top: outerRect.top + edges.borderTop,\n        bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom,\n    };\n    if (goWithinPadding) {\n        res.left += edges.paddingLeft;\n        res.right -= edges.paddingRight;\n        res.top += edges.paddingTop;\n        res.bottom -= edges.paddingBottom;\n    }\n    return res;\n}\nfunction computeRect(el) {\n    let rect = el.getBoundingClientRect();\n    return {\n        left: rect.left + window.scrollX,\n        top: rect.top + window.scrollY,\n        right: rect.right + window.scrollX,\n        bottom: rect.bottom + window.scrollY,\n    };\n}\nfunction computeClippedClientRect(el) {\n    let clippingParents = getClippingParents(el);\n    let rect = el.getBoundingClientRect();\n    for (let clippingParent of clippingParents) {\n        let intersection = intersectRects(rect, clippingParent.getBoundingClientRect());\n        if (intersection) {\n            rect = intersection;\n        }\n        else {\n            return null;\n        }\n    }\n    return rect;\n}\n// does not return window\nfunction getClippingParents(el) {\n    let parents = [];\n    while (el instanceof HTMLElement) { // will stop when gets to document or null\n        let computedStyle = window.getComputedStyle(el);\n        if (computedStyle.position === 'fixed') {\n            break;\n        }\n        if ((/(auto|scroll)/).test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n            parents.push(el);\n        }\n        el = el.parentNode;\n    }\n    return parents;\n}\n\n/*\nRecords offset information for a set of elements, relative to an origin element.\nCan record the left/right OR the top/bottom OR both.\nProvides methods for querying the cache by position.\n*/\nclass PositionCache {\n    constructor(originEl, els, isHorizontal, isVertical) {\n        this.els = els;\n        let originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n        if (isHorizontal) {\n            this.buildElHorizontals(originClientRect.left);\n        }\n        if (isVertical) {\n            this.buildElVerticals(originClientRect.top);\n        }\n    }\n    // Populates the left/right internal coordinate arrays\n    buildElHorizontals(originClientLeft) {\n        let lefts = [];\n        let rights = [];\n        for (let el of this.els) {\n            let rect = el.getBoundingClientRect();\n            lefts.push(rect.left - originClientLeft);\n            rights.push(rect.right - originClientLeft);\n        }\n        this.lefts = lefts;\n        this.rights = rights;\n    }\n    // Populates the top/bottom internal coordinate arrays\n    buildElVerticals(originClientTop) {\n        let tops = [];\n        let bottoms = [];\n        for (let el of this.els) {\n            let rect = el.getBoundingClientRect();\n            tops.push(rect.top - originClientTop);\n            bottoms.push(rect.bottom - originClientTop);\n        }\n        this.tops = tops;\n        this.bottoms = bottoms;\n    }\n    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n    // If no intersection is made, returns undefined.\n    leftToIndex(leftPosition) {\n        let { lefts, rights } = this;\n        let len = lefts.length;\n        let i;\n        for (i = 0; i < len; i += 1) {\n            if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n                return i;\n            }\n        }\n        return undefined; // TODO: better\n    }\n    // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n    // If no intersection is made, returns undefined.\n    topToIndex(topPosition) {\n        let { tops, bottoms } = this;\n        let len = tops.length;\n        let i;\n        for (i = 0; i < len; i += 1) {\n            if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n                return i;\n            }\n        }\n        return undefined; // TODO: better\n    }\n    // Gets the width of the element at the given index\n    getWidth(leftIndex) {\n        return this.rights[leftIndex] - this.lefts[leftIndex];\n    }\n    // Gets the height of the element at the given index\n    getHeight(topIndex) {\n        return this.bottoms[topIndex] - this.tops[topIndex];\n    }\n    similarTo(otherCache) {\n        return similarNumArrays(this.tops || [], otherCache.tops || []) &&\n            similarNumArrays(this.bottoms || [], otherCache.bottoms || []) &&\n            similarNumArrays(this.lefts || [], otherCache.lefts || []) &&\n            similarNumArrays(this.rights || [], otherCache.rights || []);\n    }\n}\nfunction similarNumArrays(a, b) {\n    const len = a.length;\n    if (len !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < len; i++) {\n        if (Math.round(a[i]) !== Math.round(b[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/* eslint max-classes-per-file: \"off\" */\n/*\nAn object for getting/setting scroll-related information for an element.\nInternally, this is done very differently for window versus DOM element,\nso this object serves as a common interface.\n*/\nclass ScrollController {\n    getMaxScrollTop() {\n        return this.getScrollHeight() - this.getClientHeight();\n    }\n    getMaxScrollLeft() {\n        return this.getScrollWidth() - this.getClientWidth();\n    }\n    canScrollVertically() {\n        return this.getMaxScrollTop() > 0;\n    }\n    canScrollHorizontally() {\n        return this.getMaxScrollLeft() > 0;\n    }\n    canScrollUp() {\n        return this.getScrollTop() > 0;\n    }\n    canScrollDown() {\n        return this.getScrollTop() < this.getMaxScrollTop();\n    }\n    canScrollLeft() {\n        return this.getScrollLeft() > 0;\n    }\n    canScrollRight() {\n        return this.getScrollLeft() < this.getMaxScrollLeft();\n    }\n}\nclass ElementScrollController extends ScrollController {\n    constructor(el) {\n        super();\n        this.el = el;\n    }\n    getScrollTop() {\n        return this.el.scrollTop;\n    }\n    getScrollLeft() {\n        return this.el.scrollLeft;\n    }\n    setScrollTop(top) {\n        this.el.scrollTop = top;\n    }\n    setScrollLeft(left) {\n        this.el.scrollLeft = left;\n    }\n    getScrollWidth() {\n        return this.el.scrollWidth;\n    }\n    getScrollHeight() {\n        return this.el.scrollHeight;\n    }\n    getClientHeight() {\n        return this.el.clientHeight;\n    }\n    getClientWidth() {\n        return this.el.clientWidth;\n    }\n}\nclass WindowScrollController extends ScrollController {\n    getScrollTop() {\n        return window.scrollY;\n    }\n    getScrollLeft() {\n        return window.scrollX;\n    }\n    setScrollTop(n) {\n        window.scroll(window.scrollX, n);\n    }\n    setScrollLeft(n) {\n        window.scroll(n, window.scrollY);\n    }\n    getScrollWidth() {\n        return document.documentElement.scrollWidth;\n    }\n    getScrollHeight() {\n        return document.documentElement.scrollHeight;\n    }\n    getClientHeight() {\n        return document.documentElement.clientHeight;\n    }\n    getClientWidth() {\n        return document.documentElement.clientWidth;\n    }\n}\n\n/*\nan INTERACTABLE date component\n\nPURPOSES:\n- hook up to fg, fill, and mirror renderers\n- interface for dragging and hits\n*/\nclass DateComponent extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.uid = guid();\n    }\n    // Hit System\n    // -----------------------------------------------------------------------------------------------------------------\n    prepareHits() {\n    }\n    queryHit(positionLeft, positionTop, elWidth, elHeight) {\n        return null; // this should be abstract\n    }\n    // Pointer Interaction Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    isValidSegDownEl(el) {\n        return !this.props.eventDrag && // HACK\n            !this.props.eventResize && // HACK\n            !elementClosest(el, '.fc-event-mirror');\n    }\n    isValidDateDownEl(el) {\n        return !elementClosest(el, '.fc-event:not(.fc-bg-event)') &&\n            !elementClosest(el, '.fc-more-link') && // a \"more..\" link\n            !elementClosest(el, 'a[data-navlink]') && // a clickable nav link\n            !elementClosest(el, '.fc-popover'); // hack\n    }\n}\n\nclass NamedTimeZoneImpl {\n    constructor(timeZoneName) {\n        this.timeZoneName = timeZoneName;\n    }\n}\n\nclass SegHierarchy {\n    constructor(getEntryThickness = (entry) => {\n        // if no thickness known, assume 1 (if 0, so small it always fits)\n        return entry.thickness || 1;\n    }) {\n        this.getEntryThickness = getEntryThickness;\n        // settings\n        this.strictOrder = false;\n        this.allowReslicing = false;\n        this.maxCoord = -1; // -1 means no max\n        this.maxStackCnt = -1; // -1 means no max\n        this.levelCoords = []; // ordered\n        this.entriesByLevel = []; // parallel with levelCoords\n        this.stackCnts = {}; // TODO: use better technique!?\n    }\n    addSegs(inputs) {\n        let hiddenEntries = [];\n        for (let input of inputs) {\n            this.insertEntry(input, hiddenEntries);\n        }\n        return hiddenEntries;\n    }\n    insertEntry(entry, hiddenEntries) {\n        let insertion = this.findInsertion(entry);\n        if (this.isInsertionValid(insertion, entry)) {\n            this.insertEntryAt(entry, insertion);\n        }\n        else {\n            this.handleInvalidInsertion(insertion, entry, hiddenEntries);\n        }\n    }\n    isInsertionValid(insertion, entry) {\n        return (this.maxCoord === -1 || insertion.levelCoord + this.getEntryThickness(entry) <= this.maxCoord) &&\n            (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);\n    }\n    handleInvalidInsertion(insertion, entry, hiddenEntries) {\n        if (this.allowReslicing && insertion.touchingEntry) {\n            const hiddenEntry = Object.assign(Object.assign({}, entry), { span: intersectSpans(entry.span, insertion.touchingEntry.span) });\n            hiddenEntries.push(hiddenEntry);\n            this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);\n        }\n        else {\n            hiddenEntries.push(entry);\n        }\n    }\n    /*\n    Does NOT add what hit the `barrier` into hiddenEntries. Should already be done.\n    */\n    splitEntry(entry, barrier, hiddenEntries) {\n        let entrySpan = entry.span;\n        let barrierSpan = barrier.span;\n        if (entrySpan.start < barrierSpan.start) {\n            this.insertEntry({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: { start: entrySpan.start, end: barrierSpan.start },\n            }, hiddenEntries);\n        }\n        if (entrySpan.end > barrierSpan.end) {\n            this.insertEntry({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: { start: barrierSpan.end, end: entrySpan.end },\n            }, hiddenEntries);\n        }\n    }\n    insertEntryAt(entry, insertion) {\n        let { entriesByLevel, levelCoords } = this;\n        if (insertion.lateral === -1) {\n            // create a new level\n            insertAt(levelCoords, insertion.level, insertion.levelCoord);\n            insertAt(entriesByLevel, insertion.level, [entry]);\n        }\n        else {\n            // insert into existing level\n            insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);\n        }\n        this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;\n    }\n    /*\n    does not care about limits\n    */\n    findInsertion(newEntry) {\n        let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;\n        let levelCnt = levelCoords.length;\n        let candidateCoord = 0;\n        let touchingLevel = -1;\n        let touchingLateral = -1;\n        let touchingEntry = null;\n        let stackCnt = 0;\n        for (let trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {\n            const trackingCoord = levelCoords[trackingLevel];\n            // if the current level is past the placed entry, we have found a good empty space and can stop.\n            // if strictOrder, keep finding more lateral intersections.\n            if (!strictOrder && trackingCoord >= candidateCoord + this.getEntryThickness(newEntry)) {\n                break;\n            }\n            let trackingEntries = entriesByLevel[trackingLevel];\n            let trackingEntry;\n            let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end\n            let lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one\n            while ( // loop through entries that horizontally intersect\n            (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list\n                trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry\n            ) {\n                let trackingEntryBottom = trackingCoord + this.getEntryThickness(trackingEntry);\n                // intersects into the top of the candidate?\n                if (trackingEntryBottom > candidateCoord) {\n                    candidateCoord = trackingEntryBottom;\n                    touchingEntry = trackingEntry;\n                    touchingLevel = trackingLevel;\n                    touchingLateral = lateralIndex;\n                }\n                // butts up against top of candidate? (will happen if just intersected as well)\n                if (trackingEntryBottom === candidateCoord) {\n                    // accumulate the highest possible stackCnt of the trackingEntries that butt up\n                    stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);\n                }\n                lateralIndex += 1;\n            }\n        }\n        // the destination level will be after touchingEntry's level. find it\n        let destLevel = 0;\n        if (touchingEntry) {\n            destLevel = touchingLevel + 1;\n            while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {\n                destLevel += 1;\n            }\n        }\n        // if adding to an existing level, find where to insert\n        let destLateral = -1;\n        if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {\n            destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];\n        }\n        return {\n            touchingLevel,\n            touchingLateral,\n            touchingEntry,\n            stackCnt,\n            levelCoord: candidateCoord,\n            level: destLevel,\n            lateral: destLateral,\n        };\n    }\n    // sorted by levelCoord (lowest to highest)\n    toRects() {\n        let { entriesByLevel, levelCoords } = this;\n        let levelCnt = entriesByLevel.length;\n        let rects = [];\n        for (let level = 0; level < levelCnt; level += 1) {\n            let entries = entriesByLevel[level];\n            let levelCoord = levelCoords[level];\n            for (let entry of entries) {\n                rects.push(Object.assign(Object.assign({}, entry), { thickness: this.getEntryThickness(entry), levelCoord }));\n            }\n        }\n        return rects;\n    }\n}\nfunction getEntrySpanEnd(entry) {\n    return entry.span.end;\n}\nfunction buildEntryKey(entry) {\n    return entry.index + ':' + entry.span.start;\n}\n// returns groups with entries sorted by input order\nfunction groupIntersectingEntries(entries) {\n    let merges = [];\n    for (let entry of entries) {\n        let filteredMerges = [];\n        let hungryMerge = {\n            span: entry.span,\n            entries: [entry],\n        };\n        for (let merge of merges) {\n            if (intersectSpans(merge.span, hungryMerge.span)) {\n                hungryMerge = {\n                    entries: merge.entries.concat(hungryMerge.entries),\n                    span: joinSpans(merge.span, hungryMerge.span),\n                };\n            }\n            else {\n                filteredMerges.push(merge);\n            }\n        }\n        filteredMerges.push(hungryMerge);\n        merges = filteredMerges;\n    }\n    return merges;\n}\nfunction joinSpans(span0, span1) {\n    return {\n        start: Math.min(span0.start, span1.start),\n        end: Math.max(span0.end, span1.end),\n    };\n}\nfunction intersectSpans(span0, span1) {\n    let start = Math.max(span0.start, span1.start);\n    let end = Math.min(span0.end, span1.end);\n    if (start < end) {\n        return { start, end };\n    }\n    return null;\n}\n// general util\n// ---------------------------------------------------------------------------------------------------------------------\nfunction insertAt(arr, index, item) {\n    arr.splice(index, 0, item);\n}\nfunction binarySearch(a, searchVal, getItemVal) {\n    let startIndex = 0;\n    let endIndex = a.length; // exclusive\n    if (!endIndex || searchVal < getItemVal(a[startIndex])) { // no items OR before first item\n        return [0, 0];\n    }\n    if (searchVal > getItemVal(a[endIndex - 1])) { // after last item\n        return [endIndex, 0];\n    }\n    while (startIndex < endIndex) {\n        let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);\n        let middleVal = getItemVal(a[middleIndex]);\n        if (searchVal < middleVal) {\n            endIndex = middleIndex;\n        }\n        else if (searchVal > middleVal) {\n            startIndex = middleIndex + 1;\n        }\n        else { // equal!\n            return [middleIndex, 1];\n        }\n    }\n    return [startIndex, 0];\n}\n\n/*\nAn abstraction for a dragging interaction originating on an event.\nDoes higher-level things than PointerDragger, such as possibly:\n- a \"mirror\" that moves with the pointer\n- a minimum number of pixels or other criteria for a true drag to begin\n\nsubclasses must emit:\n- pointerdown\n- dragstart\n- dragmove\n- pointerup\n- dragend\n*/\nclass ElementDragging {\n    constructor(el, selector) {\n        this.emitter = new Emitter();\n    }\n    destroy() {\n    }\n    setMirrorIsVisible(bool) {\n        // optional if subclass doesn't want to support a mirror\n    }\n    setMirrorNeedsRevert(bool) {\n        // optional if subclass doesn't want to support a mirror\n    }\n    setAutoScrollEnabled(bool) {\n        // optional\n    }\n}\n\n// TODO: get rid of this in favor of options system,\n// tho it's really easy to access this globally rather than pass thru options.\nconst config = {};\n\n/*\nInformation about what will happen when an external element is dragged-and-dropped\nonto a calendar. Contains information for creating an event.\n*/\nconst DRAG_META_REFINERS = {\n    startTime: createDuration,\n    duration: createDuration,\n    create: Boolean,\n    sourceId: String,\n};\nfunction parseDragMeta(raw) {\n    let { refined, extra } = refineProps(raw, DRAG_META_REFINERS);\n    return {\n        startTime: refined.startTime || null,\n        duration: refined.duration || null,\n        create: refined.create != null ? refined.create : true,\n        sourceId: refined.sourceId,\n        leftoverProps: extra,\n    };\n}\n\n// Computes a default column header formatting string if `colFormat` is not explicitly defined\nfunction computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n    // if more than one week row, or if there are a lot of columns with not much space,\n    // put just the day numbers will be in each cell\n    if (!datesRepDistinctDays || dayCnt > 10) {\n        return createFormatter({ weekday: 'short' }); // \"Sat\"\n    }\n    if (dayCnt > 1) {\n        return createFormatter({ weekday: 'short', month: 'numeric', day: 'numeric', omitCommas: true }); // \"Sat 11/12\"\n    }\n    return createFormatter({ weekday: 'long' }); // \"Saturday\"\n}\n\nconst CLASS_NAME = 'fc-col-header-cell'; // do the cushion too? no\nfunction renderInner$1(renderProps) {\n    return renderProps.text;\n}\n\n// BAD name for this class now. used in the Header\nclass TableDateCell extends BaseComponent {\n    render() {\n        let { dateEnv, options, theme, viewApi } = this.context;\n        let { props } = this;\n        let { date, dateProfile } = props;\n        let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n        let classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));\n        let text = dateEnv.format(date, props.dayHeaderFormat);\n        // if colCnt is 1, we are already in a day-view and don't need a navlink\n        let navLinkAttrs = (!dayMeta.isDisabled && props.colCnt > 1)\n            ? buildNavLinkAttrs(this.context, date)\n            : {};\n        let renderProps = Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: viewApi }, props.extraRenderProps), { text }), dayMeta);\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, { elTag: \"th\", elClasses: classNames, elAttrs: Object.assign({ role: 'columnheader', colSpan: props.colSpan, 'data-date': !dayMeta.isDisabled ? formatDayString(date) : undefined }, props.extraDataAttrs), renderProps: renderProps, generatorName: \"dayHeaderContent\", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContainer) => ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { className: \"fc-scrollgrid-sync-inner\" }, !dayMeta.isDisabled && ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContainer, { elTag: \"a\", elAttrs: navLinkAttrs, elClasses: [\n                'fc-col-header-cell-cushion',\n                props.isSticky && 'fc-sticky',\n            ] }))))));\n    }\n}\n\nconst WEEKDAY_FORMAT = createFormatter({ weekday: 'long' });\nclass TableDowCell extends BaseComponent {\n    render() {\n        let { props } = this;\n        let { dateEnv, theme, viewApi, options } = this.context;\n        let date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n        let dateMeta = {\n            dow: props.dow,\n            isDisabled: false,\n            isFuture: false,\n            isPast: false,\n            isToday: false,\n            isOther: false,\n        };\n        let text = dateEnv.format(date, props.dayHeaderFormat);\n        let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({ // TODO: make this public?\n            date }, dateMeta), { view: viewApi }), props.extraRenderProps), { text });\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, { elTag: \"th\", elClasses: [\n                CLASS_NAME,\n                ...getDayClassNames(dateMeta, theme),\n                ...(props.extraClassNames || []),\n            ], elAttrs: Object.assign({ role: 'columnheader', colSpan: props.colSpan }, props.extraDataAttrs), renderProps: renderProps, generatorName: \"dayHeaderContent\", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { className: \"fc-scrollgrid-sync-inner\" },\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContent, { elTag: \"a\", elClasses: [\n                    'fc-col-header-cell-cushion',\n                    props.isSticky && 'fc-sticky',\n                ], elAttrs: {\n                    'aria-label': dateEnv.format(date, WEEKDAY_FORMAT),\n                } })))));\n    }\n}\n\nclass NowTimer extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props, context) {\n        super(props, context);\n        this.initialNowDate = getNow(context.options.now, context.dateEnv);\n        this.initialNowQueriedMs = new Date().valueOf();\n        this.state = this.computeTiming().currentState;\n    }\n    render() {\n        let { props, state } = this;\n        return props.children(state.nowDate, state.todayRange);\n    }\n    componentDidMount() {\n        this.setTimeout();\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.unit !== this.props.unit) {\n            this.clearTimeout();\n            this.setTimeout();\n        }\n    }\n    componentWillUnmount() {\n        this.clearTimeout();\n    }\n    computeTiming() {\n        let { props, context } = this;\n        let unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);\n        let currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n        let nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n        let waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();\n        // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)\n        // ensure no longer than a day\n        waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);\n        return {\n            currentState: { nowDate: currentUnitStart, todayRange: buildDayRange(currentUnitStart) },\n            nextState: { nowDate: nextUnitStart, todayRange: buildDayRange(nextUnitStart) },\n            waitMs,\n        };\n    }\n    setTimeout() {\n        let { nextState, waitMs } = this.computeTiming();\n        this.timeoutId = setTimeout(() => {\n            this.setState(nextState, () => {\n                this.setTimeout();\n            });\n        }, waitMs);\n    }\n    clearTimeout() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n        }\n    }\n}\nNowTimer.contextType = ViewContextType;\nfunction buildDayRange(date) {\n    let start = startOfDay(date);\n    let end = addDays(start, 1);\n    return { start, end };\n}\n\nclass DayHeader extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n    }\n    render() {\n        let { context } = this;\n        let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;\n        let dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(NowTimer, { unit: \"day\" }, (nowDate, todayRange) => ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", { role: \"row\" },\n            renderIntro && renderIntro('day'),\n            dates.map((date) => (datesRepDistinctDays ? ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableDateCell, { key: date.toISOString(), date: date, dateProfile: dateProfile, todayRange: todayRange, colCnt: dates.length, dayHeaderFormat: dayHeaderFormat })) : ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(TableDowCell, { key: date.getUTCDay(), dow: date.getUTCDay(), dayHeaderFormat: dayHeaderFormat }))))))));\n    }\n}\nfunction createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n    return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n}\n\nclass DaySeriesModel {\n    constructor(range, dateProfileGenerator) {\n        let date = range.start;\n        let { end } = range;\n        let indices = [];\n        let dates = [];\n        let dayIndex = -1;\n        while (date < end) { // loop each day from start to end\n            if (dateProfileGenerator.isHiddenDay(date)) {\n                indices.push(dayIndex + 0.5); // mark that it's between indices\n            }\n            else {\n                dayIndex += 1;\n                indices.push(dayIndex);\n                dates.push(date);\n            }\n            date = addDays(date, 1);\n        }\n        this.dates = dates;\n        this.indices = indices;\n        this.cnt = dates.length;\n    }\n    sliceRange(range) {\n        let firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n        let lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n        let clippedFirstIndex = Math.max(0, firstIndex);\n        let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);\n        // deal with in-between indices\n        clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n        clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n        if (clippedFirstIndex <= clippedLastIndex) {\n            return {\n                firstIndex: clippedFirstIndex,\n                lastIndex: clippedLastIndex,\n                isStart: firstIndex === clippedFirstIndex,\n                isEnd: lastIndex === clippedLastIndex,\n            };\n        }\n        return null;\n    }\n    // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n    // If before the first offset, returns a negative number.\n    // If after the last offset, returns an offset past the last cell offset.\n    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n    getDateDayIndex(date) {\n        let { indices } = this;\n        let dayOffset = Math.floor(diffDays(this.dates[0], date));\n        if (dayOffset < 0) {\n            return indices[0] - 1;\n        }\n        if (dayOffset >= indices.length) {\n            return indices[indices.length - 1] + 1;\n        }\n        return indices[dayOffset];\n    }\n}\n\nclass DayTableModel {\n    constructor(daySeries, breakOnWeeks) {\n        let { dates } = daySeries;\n        let daysPerRow;\n        let firstDay;\n        let rowCnt;\n        if (breakOnWeeks) {\n            // count columns until the day-of-week repeats\n            firstDay = dates[0].getUTCDay();\n            for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {\n                if (dates[daysPerRow].getUTCDay() === firstDay) {\n                    break;\n                }\n            }\n            rowCnt = Math.ceil(dates.length / daysPerRow);\n        }\n        else {\n            rowCnt = 1;\n            daysPerRow = dates.length;\n        }\n        this.rowCnt = rowCnt;\n        this.colCnt = daysPerRow;\n        this.daySeries = daySeries;\n        this.cells = this.buildCells();\n        this.headerDates = this.buildHeaderDates();\n    }\n    buildCells() {\n        let rows = [];\n        for (let row = 0; row < this.rowCnt; row += 1) {\n            let cells = [];\n            for (let col = 0; col < this.colCnt; col += 1) {\n                cells.push(this.buildCell(row, col));\n            }\n            rows.push(cells);\n        }\n        return rows;\n    }\n    buildCell(row, col) {\n        let date = this.daySeries.dates[row * this.colCnt + col];\n        return {\n            key: date.toISOString(),\n            date,\n        };\n    }\n    buildHeaderDates() {\n        let dates = [];\n        for (let col = 0; col < this.colCnt; col += 1) {\n            dates.push(this.cells[0][col].date);\n        }\n        return dates;\n    }\n    sliceRange(range) {\n        let { colCnt } = this;\n        let seriesSeg = this.daySeries.sliceRange(range);\n        let segs = [];\n        if (seriesSeg) {\n            let { firstIndex, lastIndex } = seriesSeg;\n            let index = firstIndex;\n            while (index <= lastIndex) {\n                let row = Math.floor(index / colCnt);\n                let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n                segs.push({\n                    row,\n                    firstCol: index % colCnt,\n                    lastCol: (nextIndex - 1) % colCnt,\n                    isStart: seriesSeg.isStart && index === firstIndex,\n                    isEnd: seriesSeg.isEnd && (nextIndex - 1) === lastIndex,\n                });\n                index = nextIndex;\n            }\n        }\n        return segs;\n    }\n}\n\nclass Slicer {\n    constructor() {\n        this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n        this.sliceDateSelection = memoize(this._sliceDateSpan);\n        this.sliceEventStore = memoize(this._sliceEventStore);\n        this.sliceEventDrag = memoize(this._sliceInteraction);\n        this.sliceEventResize = memoize(this._sliceInteraction);\n        this.forceDayIfListItem = false; // hack\n    }\n    sliceProps(props, dateProfile, nextDayThreshold, context, ...extraArgs) {\n        let { eventUiBases } = props;\n        let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);\n        return {\n            dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs),\n            businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context, ...extraArgs),\n            fgEventSegs: eventSegs.fg,\n            bgEventSegs: eventSegs.bg,\n            eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),\n            eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),\n            eventSelection: props.eventSelection,\n        }; // TODO: give interactionSegs?\n    }\n    sliceNowDate(// does not memoize\n    date, dateProfile, nextDayThreshold, context, ...extraArgs) {\n        return this._sliceDateSpan({ range: { start: date, end: addMs(date, 1) }, allDay: false }, // add 1 ms, protect against null range\n        dateProfile, nextDayThreshold, {}, context, ...extraArgs);\n    }\n    _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context, ...extraArgs) {\n        if (!businessHours) {\n            return [];\n        }\n        return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;\n    }\n    _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {\n        if (eventStore) {\n            let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n            return {\n                bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n                fg: this.sliceEventRanges(rangeRes.fg, extraArgs),\n            };\n        }\n        return { bg: [], fg: [] };\n    }\n    _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {\n        if (!interaction) {\n            return null;\n        }\n        let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n        return {\n            segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n            affectedInstances: interaction.affectedEvents.instances,\n            isEvent: interaction.isEvent,\n        };\n    }\n    _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs) {\n        if (!dateSpan) {\n            return [];\n        }\n        let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));\n        let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);\n        if (activeDateSpanRange) {\n            dateSpan = Object.assign(Object.assign({}, dateSpan), { range: activeDateSpanRange });\n            let eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n            let segs = this.sliceRange(dateSpan.range, ...extraArgs);\n            for (let seg of segs) {\n                seg.eventRange = eventRange;\n            }\n            return segs;\n        }\n        return [];\n    }\n    /*\n    \"complete\" seg means it has component and eventRange\n    */\n    sliceEventRanges(eventRanges, extraArgs) {\n        let segs = [];\n        for (let eventRange of eventRanges) {\n            segs.push(...this.sliceEventRange(eventRange, extraArgs));\n        }\n        return segs;\n    }\n    /*\n    \"complete\" seg means it has component and eventRange\n    */\n    sliceEventRange(eventRange, extraArgs) {\n        let dateRange = eventRange.range;\n        // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n        if (this.forceDayIfListItem && eventRange.ui.display === 'list-item') {\n            dateRange = {\n                start: dateRange.start,\n                end: addDays(dateRange.start, 1),\n            };\n        }\n        let segs = this.sliceRange(dateRange, ...extraArgs);\n        for (let seg of segs) {\n            seg.eventRange = eventRange;\n            seg.isStart = eventRange.isStart && seg.isStart;\n            seg.isEnd = eventRange.isEnd && seg.isEnd;\n        }\n        return segs;\n    }\n}\n/*\nfor incorporating slotMinTime/slotMaxTime if appropriate\nTODO: should be part of DateProfile!\nTimelineDateProfile already does this btw\n*/\nfunction computeActiveRange(dateProfile, isComponentAllDay) {\n    let range = dateProfile.activeRange;\n    if (isComponentAllDay) {\n        return range;\n    }\n    return {\n        start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n        end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5), // 864e5 = ms in a day\n    };\n}\n\n// high-level segmenting-aware tester functions\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isInteractionValid(interaction, dateProfile, context) {\n    let { instances } = interaction.mutatedEvents;\n    for (let instanceId in instances) {\n        if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n            return false;\n        }\n    }\n    return isNewPropsValid({ eventDrag: interaction }, context); // HACK: the eventDrag props is used for ALL interactions\n}\nfunction isDateSelectionValid(dateSelection, dateProfile, context) {\n    if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {\n        return false;\n    }\n    return isNewPropsValid({ dateSelection }, context);\n}\nfunction isNewPropsValid(newProps, context) {\n    let calendarState = context.getCurrentData();\n    let props = Object.assign({ businessHours: calendarState.businessHours, dateSelection: '', eventStore: calendarState.eventStore, eventUiBases: calendarState.eventUiBases, eventSelection: '', eventDrag: null, eventResize: null }, newProps);\n    return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n}\nfunction isPropsValid(state, context, dateSpanMeta = {}, filterConfig) {\n    if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n        return false;\n    }\n    if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n        return false;\n    }\n    return true;\n}\n// Moving Event Validation\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n    let currentState = context.getCurrentData();\n    let interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n    let subjectEventStore = interaction.mutatedEvents;\n    let subjectDefs = subjectEventStore.defs;\n    let subjectInstances = subjectEventStore.instances;\n    let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ?\n        state.eventUiBases :\n        { '': currentState.selectionConfig });\n    if (filterConfig) {\n        subjectConfigs = mapHash(subjectConfigs, filterConfig);\n    }\n    // exclude the subject events. TODO: exclude defs too?\n    let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);\n    let otherDefs = otherEventStore.defs;\n    let otherInstances = otherEventStore.instances;\n    let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n    for (let subjectInstanceId in subjectInstances) {\n        let subjectInstance = subjectInstances[subjectInstanceId];\n        let subjectRange = subjectInstance.range;\n        let subjectConfig = subjectConfigs[subjectInstance.defId];\n        let subjectDef = subjectDefs[subjectInstance.defId];\n        // constraint\n        if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n            return false;\n        }\n        // overlap\n        let { eventOverlap } = context.options;\n        let eventOverlapFunc = typeof eventOverlap === 'function' ? eventOverlap : null;\n        for (let otherInstanceId in otherInstances) {\n            let otherInstance = otherInstances[otherInstanceId];\n            // intersect! evaluate\n            if (rangesIntersect(subjectRange, otherInstance.range)) {\n                let otherOverlap = otherConfigs[otherInstance.defId].overlap;\n                // consider the other event's overlap. only do this if the subject event is a \"real\" event\n                if (otherOverlap === false && interaction.isEvent) {\n                    return false;\n                }\n                if (subjectConfig.overlap === false) {\n                    return false;\n                }\n                if (eventOverlapFunc && !eventOverlapFunc(new EventImpl(context, otherDefs[otherInstance.defId], otherInstance), // still event\n                new EventImpl(context, subjectDef, subjectInstance))) {\n                    return false;\n                }\n            }\n        }\n        // allow (a function)\n        let calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n        for (let subjectAllow of subjectConfig.allows) {\n            let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), { range: subjectInstance.range, allDay: subjectDef.allDay });\n            let origDef = calendarEventStore.defs[subjectDef.defId];\n            let origInstance = calendarEventStore.instances[subjectInstanceId];\n            let eventApi;\n            if (origDef) { // was previously in the calendar\n                eventApi = new EventImpl(context, origDef, origInstance);\n            }\n            else { // was an external event\n                eventApi = new EventImpl(context, subjectDef); // no instance, because had no dates\n            }\n            if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n// Date Selection Validation\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n    let relevantEventStore = state.eventStore;\n    let relevantDefs = relevantEventStore.defs;\n    let relevantInstances = relevantEventStore.instances;\n    let selection = state.dateSelection;\n    let selectionRange = selection.range;\n    let { selectionConfig } = context.getCurrentData();\n    if (filterConfig) {\n        selectionConfig = filterConfig(selectionConfig);\n    }\n    // constraint\n    if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n        return false;\n    }\n    // overlap\n    let { selectOverlap } = context.options;\n    let selectOverlapFunc = typeof selectOverlap === 'function' ? selectOverlap : null;\n    for (let relevantInstanceId in relevantInstances) {\n        let relevantInstance = relevantInstances[relevantInstanceId];\n        // intersect! evaluate\n        if (rangesIntersect(selectionRange, relevantInstance.range)) {\n            if (selectionConfig.overlap === false) {\n                return false;\n            }\n            if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n                return false;\n            }\n        }\n    }\n    // allow (a function)\n    for (let selectionAllow of selectionConfig.allows) {\n        let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);\n        if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n            return false;\n        }\n    }\n    return true;\n}\n// Constraint Utils\n// ------------------------------------------------------------------------------------------------------------------------\nfunction allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n    for (let constraint of constraints) {\n        if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction constraintToRanges(constraint, subjectRange, // for expanding a recurring constraint, or expanding business hours\notherEventStore, // for if constraint is an even group ID\nbusinessHoursUnexpanded, // for if constraint is 'businessHours'\ncontext) {\n    if (constraint === 'businessHours') {\n        return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n    }\n    if (typeof constraint === 'string') { // an group ID\n        return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef) => eventDef.groupId === constraint));\n    }\n    if (typeof constraint === 'object' && constraint) { // non-null object\n        return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n    }\n    return []; // if it's false\n}\n// TODO: move to event-store file?\nfunction eventStoreToRanges(eventStore) {\n    let { instances } = eventStore;\n    let ranges = [];\n    for (let instanceId in instances) {\n        ranges.push(instances[instanceId].range);\n    }\n    return ranges;\n}\n// TODO: move to geom file?\nfunction anyRangesContainRange(outerRanges, innerRange) {\n    for (let outerRange of outerRanges) {\n        if (rangeContainsRange(outerRange, innerRange)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\nclass Scroller extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.handleEl = (el) => {\n            this.el = el;\n            setRef(this.props.elRef, el);\n        };\n    }\n    render() {\n        let { props } = this;\n        let { liquid, liquidIsAbsolute } = props;\n        let isAbsolute = liquid && liquidIsAbsolute;\n        let className = ['fc-scroller'];\n        if (liquid) {\n            if (liquidIsAbsolute) {\n                className.push('fc-scroller-liquid-absolute');\n            }\n            else {\n                className.push('fc-scroller-liquid');\n            }\n        }\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { ref: this.handleEl, className: className.join(' '), style: {\n                overflowX: props.overflowX,\n                overflowY: props.overflowY,\n                left: (isAbsolute && -(props.overcomeLeft || 0)) || '',\n                right: (isAbsolute && -(props.overcomeRight || 0)) || '',\n                bottom: (isAbsolute && -(props.overcomeBottom || 0)) || '',\n                marginLeft: (!isAbsolute && -(props.overcomeLeft || 0)) || '',\n                marginRight: (!isAbsolute && -(props.overcomeRight || 0)) || '',\n                marginBottom: (!isAbsolute && -(props.overcomeBottom || 0)) || '',\n                maxHeight: props.maxHeight || '',\n            } }, props.children));\n    }\n    needsXScrolling() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n            return false;\n        }\n        // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n        // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n        // inner-child margins and absolute positioning\n        let { el } = this;\n        let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n        let { children } = el;\n        for (let i = 0; i < children.length; i += 1) {\n            let childEl = children[i];\n            if (childEl.getBoundingClientRect().width > realClientWidth) {\n                return true;\n            }\n        }\n        return false;\n    }\n    needsYScrolling() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n            return false;\n        }\n        // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n        // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n        // inner-child margins and absolute positioning\n        let { el } = this;\n        let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n        let { children } = el;\n        for (let i = 0; i < children.length; i += 1) {\n            let childEl = children[i];\n            if (childEl.getBoundingClientRect().height > realClientHeight) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getXScrollbarWidth() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n            return 0;\n        }\n        return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n    }\n    getYScrollbarWidth() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n            return 0;\n        }\n        return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n    }\n}\n\n/*\nTODO: somehow infer OtherArgs from masterCallback?\nTODO: infer RefType from masterCallback if provided\n*/\nclass RefMap {\n    constructor(masterCallback) {\n        this.masterCallback = masterCallback;\n        this.currentMap = {};\n        this.depths = {};\n        this.callbackMap = {};\n        this.handleValue = (val, key) => {\n            let { depths, currentMap } = this;\n            let removed = false;\n            let added = false;\n            if (val !== null) {\n                // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n                removed = (key in currentMap);\n                currentMap[key] = val;\n                depths[key] = (depths[key] || 0) + 1;\n                added = true;\n            }\n            else {\n                depths[key] -= 1;\n                if (!depths[key]) {\n                    delete currentMap[key];\n                    delete this.callbackMap[key];\n                    removed = true;\n                }\n            }\n            if (this.masterCallback) {\n                if (removed) {\n                    this.masterCallback(null, String(key));\n                }\n                if (added) {\n                    this.masterCallback(val, String(key));\n                }\n            }\n        };\n    }\n    createRef(key) {\n        let refCallback = this.callbackMap[key];\n        if (!refCallback) {\n            refCallback = this.callbackMap[key] = (val) => {\n                this.handleValue(val, String(key));\n            };\n        }\n        return refCallback;\n    }\n    // TODO: check callers that don't care about order. should use getAll instead\n    // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n    // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n    collect(startIndex, endIndex, step) {\n        return collectFromHash(this.currentMap, startIndex, endIndex, step);\n    }\n    getAll() {\n        return hashValuesToArray(this.currentMap);\n    }\n}\n\nfunction computeShrinkWidth(chunkEls) {\n    let shrinkCells = findElements(chunkEls, '.fc-scrollgrid-shrink');\n    let largestWidth = 0;\n    for (let shrinkCell of shrinkCells) {\n        largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n    }\n    return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n}\nfunction getSectionHasLiquidHeight(props, sectionConfig) {\n    return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n}\nfunction getAllowYScrolling(props, sectionConfig) {\n    return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n        getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n}\n// TODO: ONLY use `arg`. force out internal function to use same API\nfunction renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {\n    let { expandRows } = arg;\n    let content = typeof chunkConfig.content === 'function' ?\n        chunkConfig.content(arg) :\n        (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)('table', {\n            role: 'presentation',\n            className: [\n                chunkConfig.tableClassName,\n                sectionConfig.syncRowHeights ? 'fc-scrollgrid-sync-table' : '',\n            ].join(' '),\n            style: {\n                minWidth: arg.tableMinWidth,\n                width: arg.clientWidth,\n                height: expandRows ? arg.clientHeight : '', // css `height` on a <table> serves as a min-height\n            },\n        }, arg.tableColGroupNode, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(isHeader ? 'thead' : 'tbody', {\n            role: 'presentation',\n        }, typeof chunkConfig.rowContent === 'function'\n            ? chunkConfig.rowContent(arg)\n            : chunkConfig.rowContent));\n    return content;\n}\nfunction isColPropsEqual(cols0, cols1) {\n    return isArraysEqual(cols0, cols1, isPropsEqual);\n}\nfunction renderMicroColGroup(cols, shrinkWidth) {\n    let colNodes = [];\n    /*\n    for ColProps with spans, it would have been great to make a single <col span=\"\">\n    HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\n    SOLUTION: making individual <col> elements makes Chrome behave.\n    */\n    for (let colProps of cols) {\n        let span = colProps.span || 1;\n        for (let i = 0; i < span; i += 1) {\n            colNodes.push((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"col\", { style: {\n                    width: colProps.width === 'shrink' ? sanitizeShrinkWidth(shrinkWidth) : (colProps.width || ''),\n                    minWidth: colProps.minWidth || '',\n                } }));\n        }\n    }\n    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)('colgroup', {}, ...colNodes);\n}\nfunction sanitizeShrinkWidth(shrinkWidth) {\n    /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\n    4 accounts for 2 2-pixel borders. TODO: better solution? */\n    return shrinkWidth == null ? 4 : shrinkWidth;\n}\nfunction hasShrinkWidth(cols) {\n    for (let col of cols) {\n        if (col.width === 'shrink') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getScrollGridClassNames(liquid, context) {\n    let classNames = [\n        'fc-scrollgrid',\n        context.theme.getClass('table'),\n    ];\n    if (liquid) {\n        classNames.push('fc-scrollgrid-liquid');\n    }\n    return classNames;\n}\nfunction getSectionClassNames(sectionConfig, wholeTableVGrow) {\n    let classNames = [\n        'fc-scrollgrid-section',\n        `fc-scrollgrid-section-${sectionConfig.type}`,\n        sectionConfig.className, // used?\n    ];\n    if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n        classNames.push('fc-scrollgrid-section-liquid');\n    }\n    if (sectionConfig.isSticky) {\n        classNames.push('fc-scrollgrid-section-sticky');\n    }\n    return classNames;\n}\nfunction renderScrollShim(arg) {\n    return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { className: \"fc-scrollgrid-sticky-shim\", style: {\n            width: arg.clientWidth,\n            minWidth: arg.tableMinWidth,\n        } }));\n}\nfunction getStickyHeaderDates(options) {\n    let { stickyHeaderDates } = options;\n    if (stickyHeaderDates == null || stickyHeaderDates === 'auto') {\n        stickyHeaderDates = options.height === 'auto' || options.viewHeight === 'auto';\n    }\n    return stickyHeaderDates;\n}\nfunction getStickyFooterScrollbar(options) {\n    let { stickyFooterScrollbar } = options;\n    if (stickyFooterScrollbar == null || stickyFooterScrollbar === 'auto') {\n        stickyFooterScrollbar = options.height === 'auto' || options.viewHeight === 'auto';\n    }\n    return stickyFooterScrollbar;\n}\n\nclass SimpleScrollGrid extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.processCols = memoize((a) => a, isColPropsEqual); // so we get same `cols` props every time\n        // yucky to memoize VNodes, but much more efficient for consumers\n        this.renderMicroColGroup = memoize(renderMicroColGroup);\n        this.scrollerRefs = new RefMap();\n        this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));\n        this.state = {\n            shrinkWidth: null,\n            forceYScrollbars: false,\n            scrollerClientWidths: {},\n            scrollerClientHeights: {},\n        };\n        // TODO: can do a really simple print-view. dont need to join rows\n        this.handleSizing = () => {\n            this.safeSetState(Object.assign({ shrinkWidth: this.computeShrinkWidth() }, this.computeScrollerDims()));\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let sectionConfigs = props.sections || [];\n        let cols = this.processCols(props.cols);\n        let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n        let classNames = getScrollGridClassNames(props.liquid, context);\n        if (props.collapsibleWidth) {\n            classNames.push('fc-scrollgrid-collapsible');\n        }\n        // TODO: make DRY\n        let configCnt = sectionConfigs.length;\n        let configI = 0;\n        let currentConfig;\n        let headSectionNodes = [];\n        let bodySectionNodes = [];\n        let footSectionNodes = [];\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n            headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n            configI += 1;\n        }\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n            bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));\n            configI += 1;\n        }\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n            footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n            configI += 1;\n        }\n        // firefox bug: when setting height on table and there is a thead or tfoot,\n        // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)\n        // use getCanVGrowWithinCell as a way to detect table-stupid firefox.\n        // if so, use a simpler dom structure, jam everything into a lone tbody.\n        let isBuggy = !getCanVGrowWithinCell();\n        const roleAttrs = { role: 'rowgroup' };\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)('table', {\n            role: 'grid',\n            className: classNames.join(' '),\n            style: { height: props.height },\n        }, Boolean(!isBuggy && headSectionNodes.length) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)('thead', roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)('tbody', roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)('tfoot', roleAttrs, ...footSectionNodes), isBuggy && (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)('tbody', roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));\n    }\n    renderSection(sectionConfig, microColGroupNode, isHeader) {\n        if ('outerContent' in sectionConfig) {\n            return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, { key: sectionConfig.key }, sectionConfig.outerContent));\n        }\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"tr\", { key: sectionConfig.key, role: \"presentation\", className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ') }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader)));\n    }\n    renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {\n        if ('outerContent' in chunkConfig) {\n            return chunkConfig.outerContent;\n        }\n        let { props } = this;\n        let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;\n        let needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n        let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);\n        // for `!props.liquid` - is WHOLE scrollgrid natural height?\n        // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n        let overflowY = !props.liquid ? 'visible' :\n            forceYScrollbars ? 'scroll' :\n                !needsYScrolling ? 'hidden' :\n                    'auto';\n        let sectionKey = sectionConfig.key;\n        let content = renderChunkContent(sectionConfig, chunkConfig, {\n            tableColGroupNode: microColGroupNode,\n            tableMinWidth: '',\n            clientWidth: (!props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined) ? scrollerClientWidths[sectionKey] : null,\n            clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,\n            expandRows: sectionConfig.expandRows,\n            syncRowHeights: false,\n            rowSyncHeights: [],\n            reportRowHeightChange: () => { },\n        }, isHeader);\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(isHeader ? 'th' : 'td', {\n            ref: chunkConfig.elRef,\n            role: 'presentation',\n        }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { className: `fc-scroller-harness${isLiquid ? ' fc-scroller-harness-liquid' : ''}` },\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(Scroller, { ref: this.scrollerRefs.createRef(sectionKey), elRef: this.scrollerElRefs.createRef(sectionKey), overflowY: overflowY, overflowX: !props.liquid ? 'visible' : 'hidden' /* natural height? */, maxHeight: sectionConfig.maxHeight, liquid: isLiquid, liquidIsAbsolute // because its within a harness\n                : true }, content)));\n    }\n    _handleScrollerEl(scrollerEl, key) {\n        let section = getSectionByKey(this.props.sections, key);\n        if (section) {\n            setRef(section.chunk.scrollerElRef, scrollerEl);\n        }\n    }\n    componentDidMount() {\n        this.handleSizing();\n        this.context.addResizeHandler(this.handleSizing);\n    }\n    componentDidUpdate() {\n        // TODO: need better solution when state contains non-sizing things\n        this.handleSizing();\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleSizing);\n    }\n    computeShrinkWidth() {\n        return hasShrinkWidth(this.props.cols)\n            ? computeShrinkWidth(this.scrollerElRefs.getAll())\n            : 0;\n    }\n    computeScrollerDims() {\n        let scrollbarWidth = getScrollbarWidths();\n        let { scrollerRefs, scrollerElRefs } = this;\n        let forceYScrollbars = false;\n        let scrollerClientWidths = {};\n        let scrollerClientHeights = {};\n        for (let sectionKey in scrollerRefs.currentMap) {\n            let scroller = scrollerRefs.currentMap[sectionKey];\n            if (scroller && scroller.needsYScrolling()) {\n                forceYScrollbars = true;\n                break;\n            }\n        }\n        for (let section of this.props.sections) {\n            let sectionKey = section.key;\n            let scrollerEl = scrollerElRefs.currentMap[sectionKey];\n            if (scrollerEl) {\n                let harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n                scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars\n                    ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                    : 0));\n                scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);\n            }\n        }\n        return { forceYScrollbars, scrollerClientWidths, scrollerClientHeights };\n    }\n}\nSimpleScrollGrid.addStateEquality({\n    scrollerClientWidths: isPropsEqual,\n    scrollerClientHeights: isPropsEqual,\n});\nfunction getSectionByKey(sections, key) {\n    for (let section of sections) {\n        if (section.key === key) {\n            return section;\n        }\n    }\n    return null;\n}\n\nclass EventContainer extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.handleEl = (el) => {\n            this.el = el;\n            if (el) {\n                setElSeg(el, this.props.seg);\n            }\n        };\n    }\n    render() {\n        const { props, context } = this;\n        const { options } = context;\n        const { seg } = props;\n        const { eventRange } = seg;\n        const { ui } = eventRange;\n        const renderProps = {\n            event: new EventImpl(context, eventRange.def, eventRange.instance),\n            view: context.viewApi,\n            timeText: props.timeText,\n            textColor: ui.textColor,\n            backgroundColor: ui.backgroundColor,\n            borderColor: ui.borderColor,\n            isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n            isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n            isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n            isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n            isStart: Boolean(seg.isStart),\n            isEnd: Boolean(seg.isEnd),\n            isPast: Boolean(props.isPast),\n            isFuture: Boolean(props.isFuture),\n            isToday: Boolean(props.isToday),\n            isSelected: Boolean(props.isSelected),\n            isDragging: Boolean(props.isDragging),\n            isResizing: Boolean(props.isResizing),\n        };\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props /* contains children */, { elRef: this.handleEl, elClasses: [\n                ...getEventClassNames(renderProps),\n                ...seg.eventRange.ui.classNames,\n                ...(props.elClasses || []),\n            ], renderProps: renderProps, generatorName: \"eventContent\", customGenerator: options.eventContent, defaultGenerator: props.defaultGenerator, classNameGenerator: options.eventClassNames, didMount: options.eventDidMount, willUnmount: options.eventWillUnmount })));\n    }\n    componentDidUpdate(prevProps) {\n        if (this.el && this.props.seg !== prevProps.seg) {\n            setElSeg(this.el, this.props.seg);\n        }\n    }\n}\n\n// should not be a purecomponent\nclass StandardEvent extends BaseComponent {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let { seg } = props;\n        let { ui } = seg.eventRange;\n        let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;\n        let timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(EventContainer, Object.assign({}, props /* includes elRef */, { elTag: \"a\", elStyle: {\n                borderColor: ui.borderColor,\n                backgroundColor: ui.backgroundColor,\n            }, elAttrs: getSegAnchorAttrs(seg, context), defaultGenerator: renderInnerContent$1, timeText: timeText }), (InnerContent, eventContentArg) => ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContent, { elTag: \"div\", elClasses: ['fc-event-main'], elStyle: { color: eventContentArg.textColor } }),\n            Boolean(eventContentArg.isStartResizable) && ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { className: \"fc-event-resizer fc-event-resizer-start\" })),\n            Boolean(eventContentArg.isEndResizable) && ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { className: \"fc-event-resizer fc-event-resizer-end\" }))))));\n    }\n}\nfunction renderInnerContent$1(innerProps) {\n    return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { className: \"fc-event-main-frame\" },\n        innerProps.timeText && ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { className: \"fc-event-time\" }, innerProps.timeText)),\n        (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { className: \"fc-event-title-container\" },\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { className: \"fc-event-title fc-sticky\" }, innerProps.event.title || (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \"\\u00A0\")))));\n}\n\nconst NowIndicatorContainer = (props) => ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, (context) => {\n    let { options } = context;\n    let renderProps = {\n        isAxis: props.isAxis,\n        date: context.dateEnv.toDate(props.date),\n        view: context.viewApi,\n    };\n    return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props /* includes children */, { elTag: props.elTag || 'div', renderProps: renderProps, generatorName: \"nowIndicatorContent\", customGenerator: options.nowIndicatorContent, classNameGenerator: options.nowIndicatorClassNames, didMount: options.nowIndicatorDidMount, willUnmount: options.nowIndicatorWillUnmount })));\n}));\n\nconst DAY_NUM_FORMAT = createFormatter({ day: 'numeric' });\nclass DayCellContainer extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.refineRenderProps = memoizeObjArg(refineRenderProps);\n    }\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let renderProps = this.refineRenderProps({\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            isMonthStart: props.isMonthStart || false,\n            showDayNumber: props.showDayNumber,\n            extraRenderProps: props.extraRenderProps,\n            viewApi: context.viewApi,\n            dateEnv: context.dateEnv,\n            monthStartFormat: options.monthStartFormat,\n        });\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, Object.assign({}, props /* includes children */, { elClasses: [\n                ...getDayClassNames(renderProps, context.theme),\n                ...(props.elClasses || []),\n            ], elAttrs: Object.assign(Object.assign({}, props.elAttrs), (renderProps.isDisabled ? {} : { 'data-date': formatDayString(props.date) })), renderProps: renderProps, generatorName: \"dayCellContent\", customGenerator: options.dayCellContent, defaultGenerator: props.defaultGenerator, classNameGenerator: \n            // don't use custom classNames if disabled\n            renderProps.isDisabled ? undefined : options.dayCellClassNames, didMount: options.dayCellDidMount, willUnmount: options.dayCellWillUnmount })));\n    }\n}\nfunction hasCustomDayCellContent(options) {\n    return Boolean(options.dayCellContent || hasCustomRenderingHandler('dayCellContent', options));\n}\nfunction refineRenderProps(raw) {\n    let { date, dateEnv, dateProfile, isMonthStart } = raw;\n    let dayMeta = getDateMeta(date, raw.todayRange, null, dateProfile);\n    let dayNumberText = raw.showDayNumber ? (dateEnv.format(date, isMonthStart ? raw.monthStartFormat : DAY_NUM_FORMAT)) : '';\n    return Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: raw.viewApi }, dayMeta), { isMonthStart,\n        dayNumberText }), raw.extraRenderProps);\n}\n\nclass BgEvent extends BaseComponent {\n    render() {\n        let { props } = this;\n        let { seg } = props;\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(EventContainer, { elTag: \"div\", elClasses: ['fc-bg-event'], elStyle: { backgroundColor: seg.eventRange.ui.backgroundColor }, defaultGenerator: renderInnerContent, seg: seg, timeText: \"\", isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday, disableDragging: true, disableResizing: true }));\n    }\n}\nfunction renderInnerContent(props) {\n    let { title } = props.event;\n    return title && ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { className: \"fc-event-title\" }, props.event.title));\n}\nfunction renderFill(fillType) {\n    return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { className: `fc-${fillType}` }));\n}\n\nconst WeekNumberContainer = (props) => ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, (context) => {\n    let { dateEnv, options } = context;\n    let { date } = props;\n    let format = options.weekNumberFormat || props.defaultFormat;\n    let num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n    let text = dateEnv.format(date, format);\n    let renderProps = { num, text, date };\n    return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer // why isn't WeekNumberContentArg being auto-detected?\n    , Object.assign({}, props /* includes children */, { renderProps: renderProps, generatorName: \"weekNumberContent\", customGenerator: options.weekNumberContent, defaultGenerator: renderInner, classNameGenerator: options.weekNumberClassNames, didMount: options.weekNumberDidMount, willUnmount: options.weekNumberWillUnmount })));\n}));\nfunction renderInner(innerProps) {\n    return innerProps.text;\n}\n\nconst PADDING_FROM_VIEWPORT = 10;\nclass Popover extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            titleId: getUniqueDomId(),\n        };\n        this.handleRootEl = (el) => {\n            this.rootEl = el;\n            if (this.props.elRef) {\n                setRef(this.props.elRef, el);\n            }\n        };\n        // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n        this.handleDocumentMouseDown = (ev) => {\n            // only hide the popover if the click happened outside the popover\n            const target = getEventTargetViaRoot(ev);\n            if (!this.rootEl.contains(target)) {\n                this.handleCloseClick();\n            }\n        };\n        this.handleDocumentKeyDown = (ev) => {\n            if (ev.key === 'Escape') {\n                this.handleCloseClick();\n            }\n        };\n        this.handleCloseClick = () => {\n            let { onClose } = this.props;\n            if (onClose) {\n                onClose();\n            }\n        };\n    }\n    render() {\n        let { theme, options } = this.context;\n        let { props, state } = this;\n        let classNames = [\n            'fc-popover',\n            theme.getClass('popover'),\n        ].concat(props.extraClassNames || []);\n        return (0,preact_compat__WEBPACK_IMPORTED_MODULE_1__.createPortal)((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", Object.assign({}, props.extraAttrs, { id: props.id, className: classNames.join(' '), \"aria-labelledby\": state.titleId, ref: this.handleRootEl }),\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { className: 'fc-popover-header ' + theme.getClass('popoverHeader') },\n                (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", { className: \"fc-popover-title\", id: state.titleId }, props.title),\n                (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", { className: 'fc-popover-close ' + theme.getIconClass('close'), title: options.closeHint, onClick: this.handleCloseClick })),\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", { className: 'fc-popover-body ' + theme.getClass('popoverContent') }, props.children)), props.parentEl);\n    }\n    componentDidMount() {\n        document.addEventListener('mousedown', this.handleDocumentMouseDown);\n        document.addEventListener('keydown', this.handleDocumentKeyDown);\n        this.updateSize();\n    }\n    componentWillUnmount() {\n        document.removeEventListener('mousedown', this.handleDocumentMouseDown);\n        document.removeEventListener('keydown', this.handleDocumentKeyDown);\n    }\n    updateSize() {\n        let { isRtl } = this.context;\n        let { alignmentEl, alignGridTop } = this.props;\n        let { rootEl } = this;\n        let alignmentRect = computeClippedClientRect(alignmentEl);\n        if (alignmentRect) {\n            let popoverDims = rootEl.getBoundingClientRect();\n            // position relative to viewport\n            let popoverTop = alignGridTop\n                ? elementClosest(alignmentEl, '.fc-scrollgrid').getBoundingClientRect().top\n                : alignmentRect.top;\n            let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;\n            // constrain\n            popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);\n            popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);\n            popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);\n            let origin = rootEl.offsetParent.getBoundingClientRect();\n            applyStyle(rootEl, {\n                top: popoverTop - origin.top,\n                left: popoverLeft - origin.left,\n            });\n        }\n    }\n}\n\nclass MorePopover extends DateComponent {\n    constructor() {\n        super(...arguments);\n        this.handleRootEl = (rootEl) => {\n            this.rootEl = rootEl;\n            if (rootEl) {\n                this.context.registerInteractiveComponent(this, {\n                    el: rootEl,\n                    useEventCenter: false,\n                });\n            }\n            else {\n                this.context.unregisterInteractiveComponent(this);\n            }\n        };\n    }\n    render() {\n        let { options, dateEnv } = this.context;\n        let { props } = this;\n        let { startDate, todayRange, dateProfile } = props;\n        let title = dateEnv.format(startDate, options.dayPopoverFormat);\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(DayCellContainer, { elRef: this.handleRootEl, date: startDate, dateProfile: dateProfile, todayRange: todayRange }, (InnerContent, renderProps, elAttrs) => ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(Popover, { elRef: elAttrs.ref, id: props.id, title: title, extraClassNames: ['fc-more-popover'].concat(elAttrs.className || []), extraAttrs: elAttrs /* TODO: make these time-based when not whole-day? */, parentEl: props.parentEl, alignmentEl: props.alignmentEl, alignGridTop: props.alignGridTop, onClose: props.onClose },\n            hasCustomDayCellContent(options) && ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerContent, { elTag: \"div\", elClasses: ['fc-more-popover-misc'] })),\n            props.children))));\n    }\n    queryHit(positionLeft, positionTop, elWidth, elHeight) {\n        let { rootEl, props } = this;\n        if (positionLeft >= 0 && positionLeft < elWidth &&\n            positionTop >= 0 && positionTop < elHeight) {\n            return {\n                dateProfile: props.dateProfile,\n                dateSpan: Object.assign({ allDay: !props.forceTimed, range: {\n                        start: props.startDate,\n                        end: props.endDate,\n                    } }, props.extraDateSpan),\n                dayEl: rootEl,\n                rect: {\n                    left: 0,\n                    top: 0,\n                    right: elWidth,\n                    bottom: elHeight,\n                },\n                layer: 1, // important when comparing with hits from other components\n            };\n        }\n        return null;\n    }\n}\n\nclass MoreLinkContainer extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            isPopoverOpen: false,\n            popoverId: getUniqueDomId(),\n        };\n        this.handleLinkEl = (linkEl) => {\n            this.linkEl = linkEl;\n            if (this.props.elRef) {\n                setRef(this.props.elRef, linkEl);\n            }\n        };\n        this.handleClick = (ev) => {\n            let { props, context } = this;\n            let { moreLinkClick } = context.options;\n            let date = computeRange(props).start;\n            function buildPublicSeg(seg) {\n                let { def, instance, range } = seg.eventRange;\n                return {\n                    event: new EventImpl(context, def, instance),\n                    start: context.dateEnv.toDate(range.start),\n                    end: context.dateEnv.toDate(range.end),\n                    isStart: seg.isStart,\n                    isEnd: seg.isEnd,\n                };\n            }\n            if (typeof moreLinkClick === 'function') {\n                moreLinkClick = moreLinkClick({\n                    date,\n                    allDay: Boolean(props.allDayDate),\n                    allSegs: props.allSegs.map(buildPublicSeg),\n                    hiddenSegs: props.hiddenSegs.map(buildPublicSeg),\n                    jsEvent: ev,\n                    view: context.viewApi,\n                });\n            }\n            if (!moreLinkClick || moreLinkClick === 'popover') {\n                this.setState({ isPopoverOpen: true });\n            }\n            else if (typeof moreLinkClick === 'string') { // a view name\n                context.calendarApi.zoomTo(date, moreLinkClick);\n            }\n        };\n        this.handlePopoverClose = () => {\n            this.setState({ isPopoverOpen: false });\n        };\n    }\n    render() {\n        let { props, state } = this;\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ViewContextType.Consumer, null, (context) => {\n            let { viewApi, options, calendarApi } = context;\n            let { moreLinkText } = options;\n            let { moreCnt } = props;\n            let range = computeRange(props);\n            let text = typeof moreLinkText === 'function' // TODO: eventually use formatWithOrdinals\n                ? moreLinkText.call(calendarApi, moreCnt)\n                : `+${moreCnt} ${moreLinkText}`;\n            let hint = formatWithOrdinals(options.moreLinkHint, [moreCnt], text);\n            let renderProps = {\n                num: moreCnt,\n                shortText: `+${moreCnt}`,\n                text,\n                view: viewApi,\n            };\n            return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n                Boolean(props.moreCnt) && ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(ContentContainer, { elTag: props.elTag || 'a', elRef: this.handleLinkEl, elClasses: [\n                        ...(props.elClasses || []),\n                        'fc-more-link',\n                    ], elStyle: props.elStyle, elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), { title: hint, 'aria-expanded': state.isPopoverOpen, 'aria-controls': state.isPopoverOpen ? state.popoverId : '' }), renderProps: renderProps, generatorName: \"moreLinkContent\", customGenerator: options.moreLinkContent, defaultGenerator: props.defaultGenerator || renderMoreLinkInner, classNameGenerator: options.moreLinkClassNames, didMount: options.moreLinkDidMount, willUnmount: options.moreLinkWillUnmount }, props.children)),\n                state.isPopoverOpen && ((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(MorePopover, { id: state.popoverId, startDate: range.start, endDate: range.end, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: props.extraDateSpan, parentEl: this.parentEl, alignmentEl: props.alignmentElRef ?\n                        props.alignmentElRef.current :\n                        this.linkEl, alignGridTop: props.alignGridTop, forceTimed: props.forceTimed, onClose: this.handlePopoverClose }, props.popoverContent()))));\n        }));\n    }\n    componentDidMount() {\n        this.updateParentEl();\n    }\n    componentDidUpdate() {\n        this.updateParentEl();\n    }\n    updateParentEl() {\n        if (this.linkEl) {\n            this.parentEl = elementClosest(this.linkEl, '.fc-view-harness');\n        }\n    }\n}\nfunction renderMoreLinkInner(props) {\n    return props.text;\n}\nfunction computeRange(props) {\n    if (props.allDayDate) {\n        return {\n            start: props.allDayDate,\n            end: addDays(props.allDayDate, 1),\n        };\n    }\n    let { hiddenSegs } = props;\n    return {\n        start: computeEarliestSegStart(hiddenSegs),\n        end: computeLatestSegEnd(hiddenSegs),\n    };\n}\nfunction computeEarliestSegStart(segs) {\n    return segs.reduce(pickEarliestStart).eventRange.range.start;\n}\nfunction pickEarliestStart(seg0, seg1) {\n    return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;\n}\nfunction computeLatestSegEnd(segs) {\n    return segs.reduce(pickLatestEnd).eventRange.range.end;\n}\nfunction pickLatestEnd(seg0, seg1) {\n    return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;\n}\n\nclass Store {\n    constructor() {\n        this.handlers = [];\n    }\n    set(value) {\n        this.currentValue = value;\n        for (let handler of this.handlers) {\n            handler(value);\n        }\n    }\n    subscribe(handler) {\n        this.handlers.push(handler);\n        if (this.currentValue !== undefined) {\n            handler(this.currentValue);\n        }\n    }\n}\n\n/*\nSubscribers will get a LIST of CustomRenderings\n*/\nclass CustomRenderingStore extends Store {\n    constructor() {\n        super(...arguments);\n        this.map = new Map();\n    }\n    // for consistent order\n    handle(customRendering) {\n        const { map } = this;\n        let updated = false;\n        if (customRendering.isActive) {\n            map.set(customRendering.id, customRendering);\n            updated = true;\n        }\n        else if (map.has(customRendering.id)) {\n            map.delete(customRendering.id);\n            updated = true;\n        }\n        if (updated) {\n            this.set(map);\n        }\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLWNvbW1vbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUM7QUFDMkM7QUFDL0I7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsMkJBQTJCLHdCQUF3Qix3Q0FBd0MsNkJBQTZCLHVCQUF1Qiw0QkFBNEIsNkJBQTZCLGlDQUFpQyxtQ0FBbUMsdUNBQXVDLG9DQUFvQyx3Q0FBd0MsNEJBQTRCLGdDQUFnQywyQkFBMkIs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QXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBZ0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0JBQStCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLDJCQUEyQixFQUFFLFFBQVEsRUFBRTtBQUNwSDtBQUNBO0FBQ0E7QUFDQSxtTEFBbUwsTUFBTTtBQUN6TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0IsRUFBRSxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQW9CLEVBQUUsd0NBQXdDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkNBQWMsb0JBQW9CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwyQ0FBYztBQUNsQixJQUFJLDBDQUFhLENBQUMsaURBQW9CLGtCQUFrQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJDQUFjO0FBQ2xCO0FBQ0EsNEJBQTRCLDZDQUFnQjtBQUM1QyxlQUFlLE9BQU8saURBQW9CLFVBQVU7QUFDcEQsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaURBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMEJBQTBCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLEdBQUc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDZDQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QixvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixpREFBaUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaURBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixnREFBZ0Q7QUFDaEU7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLG1DQUFtQyxZQUFZLHFEQUFxRDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG9CQUFvQixZQUFZO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0IsNkNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscURBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFhLGtEQUFrRCxZQUFZLDJJQUEySTtBQUN6TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZILDZCQUE2QixhQUFhO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILDZCQUE2QixhQUFhO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFhLG9DQUFvQyxvTkFBb047QUFDaFI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxVQUFVO0FBQ3hCLDRCQUE0QjtBQUM1QixnQkFBZ0IscURBQWEsbUNBQW1DLFdBQVc7QUFDM0U7QUFDQTtBQUNBLHFMQUFxTDtBQUNyTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVEsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGtDQUFrQyw2QkFBNkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLDhCQUE4QixpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9EQUFvRDtBQUNsRSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQ0FBZ0M7QUFDMUMsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxvREFBb0QseUJBQXlCO0FBQ2hKO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDhCQUE4QjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsOENBQThDO0FBQzlDLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUSxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ3pKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLWNvbW1vbi5qcz82OWZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHByZWFjdCBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBpc1ZhbGlkRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncHJlYWN0L2NvbXBhdCc7XG5cbmNvbnN0IHN0eWxlVGV4dHMgPSBbXTtcbmNvbnN0IHN0eWxlRWxzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gaW5qZWN0U3R5bGVzKHN0eWxlVGV4dCkge1xuICAgIHN0eWxlVGV4dHMucHVzaChzdHlsZVRleHQpO1xuICAgIHN0eWxlRWxzLmZvckVhY2goKHN0eWxlRWwpID0+IHtcbiAgICAgICAgYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUVsSGFzU3R5bGVzKGVsKSB7XG4gICAgaWYgKGVsLmlzQ29ubmVjdGVkICYmIC8vIHNvbWV0aW1lcyB0cnVlIGlmIFNTUiBzeXN0ZW0gc2ltdWxhdGVzIERPTVxuICAgICAgICBlbC5nZXRSb290Tm9kZSAvLyBzb21ldGltZXMgdW5kZWZpbmVkIGlmIFNTUiBzeXN0ZW0gc2ltdWxhdGVzIERPTVxuICAgICkge1xuICAgICAgICByZWdpc3RlclN0eWxlc1Jvb3QoZWwuZ2V0Um9vdE5vZGUoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJTdHlsZXNSb290KHJvb3ROb2RlKSB7XG4gICAgbGV0IHN0eWxlRWwgPSBzdHlsZUVscy5nZXQocm9vdE5vZGUpO1xuICAgIGlmICghc3R5bGVFbCB8fCAhc3R5bGVFbC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICBzdHlsZUVsID0gcm9vdE5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1mdWxsY2FsZW5kYXJdJyk7XG4gICAgICAgIGlmICghc3R5bGVFbCkge1xuICAgICAgICAgICAgc3R5bGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICBzdHlsZUVsLnNldEF0dHJpYnV0ZSgnZGF0YS1mdWxsY2FsZW5kYXInLCAnJyk7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGdldE5vbmNlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlRWwubm9uY2UgPSBub25jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEVsID0gcm9vdE5vZGUgPT09IGRvY3VtZW50ID8gZG9jdW1lbnQuaGVhZCA6IHJvb3ROb2RlO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0QmVmb3JlID0gcm9vdE5vZGUgPT09IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgPyBwYXJlbnRFbC5xdWVyeVNlbGVjdG9yKCdzY3JpcHQsbGlua1tyZWw9c3R5bGVzaGVldF0sbGlua1thcz1zdHlsZV0sc3R5bGUnKVxuICAgICAgICAgICAgICAgIDogcGFyZW50RWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShzdHlsZUVsLCBpbnNlcnRCZWZvcmUpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlRWxzLnNldChyb290Tm9kZSwgc3R5bGVFbCk7XG4gICAgICAgIGh5ZHJhdGVTdHlsZXNSb290KHN0eWxlRWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGVTdHlsZXNSb290KHN0eWxlRWwpIHtcbiAgICBmb3IgKGNvbnN0IHN0eWxlVGV4dCBvZiBzdHlsZVRleHRzKSB7XG4gICAgICAgIGFwcGVuZFN0eWxlc1RvKHN0eWxlRWwsIHN0eWxlVGV4dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KSB7XG4gICAgY29uc3QgeyBzaGVldCB9ID0gc3R5bGVFbDtcbiAgICBjb25zdCBydWxlQ250ID0gc2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xuICAgIHN0eWxlVGV4dC5zcGxpdCgnfScpLmZvckVhY2goKHN0eWxlU3RyLCBpKSA9PiB7XG4gICAgICAgIHN0eWxlU3RyID0gc3R5bGVTdHIudHJpbSgpO1xuICAgICAgICBpZiAoc3R5bGVTdHIpIHtcbiAgICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUoc3R5bGVTdHIgKyAnfScsIHJ1bGVDbnQgKyBpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gbm9uY2Vcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmxldCBxdWVyaWVkTm9uY2VWYWx1ZTtcbmZ1bmN0aW9uIGdldE5vbmNlVmFsdWUoKSB7XG4gICAgaWYgKHF1ZXJpZWROb25jZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcXVlcmllZE5vbmNlVmFsdWUgPSBxdWVyeU5vbmNlVmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJpZWROb25jZVZhbHVlO1xufVxuLypcblRPRE86IGRpc2NvdXJhZ2UgbWV0YSB0YWcgYW5kIGluc3RlYWQgcHV0IG5vbmNlIGF0dHJpYnV0ZSBvbiBwbGFjZWhvbGRlciA8c3R5bGU+IHRhZ1xuKi9cbmZ1bmN0aW9uIHF1ZXJ5Tm9uY2VWYWx1ZSgpIHtcbiAgICBjb25zdCBtZXRhV2l0aE5vbmNlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiY3NwLW5vbmNlXCJdJyk7XG4gICAgaWYgKG1ldGFXaXRoTm9uY2UgJiYgbWV0YVdpdGhOb25jZS5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnQnKSkge1xuICAgICAgICByZXR1cm4gbWV0YVdpdGhOb25jZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKTtcbiAgICB9XG4gICAgY29uc3QgZWxXaXRoTm9uY2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbbm9uY2VdJyk7XG4gICAgaWYgKGVsV2l0aE5vbmNlKSB7XG4gICAgICAgIHJldHVybiBlbFdpdGhOb25jZS5ub25jZSB8fCAnJztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuLy8gbWFpblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZWdpc3RlclN0eWxlc1Jvb3QoZG9jdW1lbnQpO1xufVxuXG52YXIgY3NzXzI0OHogPSBcIjpyb290ey0tZmMtc21hbGwtZm9udC1zaXplOi44NWVtOy0tZmMtcGFnZS1iZy1jb2xvcjojZmZmOy0tZmMtbmV1dHJhbC1iZy1jb2xvcjpoc2xhKDAsMCUsODIlLC4zKTstLWZjLW5ldXRyYWwtdGV4dC1jb2xvcjpncmV5Oy0tZmMtYm9yZGVyLWNvbG9yOiNkZGQ7LS1mYy1idXR0b24tdGV4dC1jb2xvcjojZmZmOy0tZmMtYnV0dG9uLWJnLWNvbG9yOiMyYzNlNTA7LS1mYy1idXR0b24tYm9yZGVyLWNvbG9yOiMyYzNlNTA7LS1mYy1idXR0b24taG92ZXItYmctY29sb3I6IzFlMmIzNzstLWZjLWJ1dHRvbi1ob3Zlci1ib3JkZXItY29sb3I6IzFhMjUyZjstLWZjLWJ1dHRvbi1hY3RpdmUtYmctY29sb3I6IzFhMjUyZjstLWZjLWJ1dHRvbi1hY3RpdmUtYm9yZGVyLWNvbG9yOiMxNTFlMjc7LS1mYy1ldmVudC1iZy1jb2xvcjojMzc4OGQ4Oy0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yOiMzNzg4ZDg7LS1mYy1ldmVudC10ZXh0LWNvbG9yOiNmZmY7LS1mYy1ldmVudC1zZWxlY3RlZC1vdmVybGF5LWNvbG9yOnJnYmEoMCwwLDAsLjI1KTstLWZjLW1vcmUtbGluay1iZy1jb2xvcjojZDBkMGQwOy0tZmMtbW9yZS1saW5rLXRleHQtY29sb3I6aW5oZXJpdDstLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzOjhweDstLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoOjhweDstLWZjLWV2ZW50LXJlc2l6ZXItZG90LWJvcmRlci13aWR0aDoxcHg7LS1mYy1ub24tYnVzaW5lc3MtY29sb3I6aHNsYSgwLDAlLDg0JSwuMyk7LS1mYy1iZy1ldmVudC1jb2xvcjojOGZkZjgyOy0tZmMtYmctZXZlbnQtb3BhY2l0eTowLjM7LS1mYy1oaWdobGlnaHQtY29sb3I6cmdiYSgxODgsMjMyLDI0MSwuMyk7LS1mYy10b2RheS1iZy1jb2xvcjpyZ2JhKDI1NSwyMjAsNDAsLjE1KTstLWZjLW5vdy1pbmRpY2F0b3ItY29sb3I6cmVkfS5mYy1ub3QtYWxsb3dlZCwuZmMtbm90LWFsbG93ZWQgLmZjLWV2ZW50e2N1cnNvcjpub3QtYWxsb3dlZH0uZmN7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmb250LXNpemU6MWVtfS5mYywuZmMgKiwuZmMgOmFmdGVyLC5mYyA6YmVmb3Jle2JveC1zaXppbmc6Ym9yZGVyLWJveH0uZmMgdGFibGV7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO2JvcmRlci1zcGFjaW5nOjA7Zm9udC1zaXplOjFlbX0uZmMgdGh7dGV4dC1hbGlnbjpjZW50ZXJ9LmZjIHRkLC5mYyB0aHtwYWRkaW5nOjA7dmVydGljYWwtYWxpZ246dG9wfS5mYyBhW2RhdGEtbmF2bGlua117Y3Vyc29yOnBvaW50ZXJ9LmZjIGFbZGF0YS1uYXZsaW5rXTpob3Zlcnt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfS5mYy1kaXJlY3Rpb24tbHRye2RpcmVjdGlvbjpsdHI7dGV4dC1hbGlnbjpsZWZ0fS5mYy1kaXJlY3Rpb24tcnRse2RpcmVjdGlvbjpydGw7dGV4dC1hbGlnbjpyaWdodH0uZmMtdGhlbWUtc3RhbmRhcmQgdGQsLmZjLXRoZW1lLXN0YW5kYXJkIHRoe2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtYm9yZGVyLWNvbG9yKX0uZmMtbGlxdWlkLWhhY2sgdGQsLmZjLWxpcXVpZC1oYWNrIHRoe3Bvc2l0aW9uOnJlbGF0aXZlfUBmb250LWZhY2V7Zm9udC1mYW1pbHk6ZmNpY29ucztmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDo0MDA7c3JjOnVybChcXFwiZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtdHRmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LEFBRUFBQUFMQUlBQUF3QXdUMU12TWc4U0JmQUFBQUM4QUFBQVlHTnRZWEFYVnRLTkFBQUJIQUFBQUZSbllYTndBQUFBRUFBQUFYQUFBQUFJWjJ4NVpnWXlkeElBQUFGNEFBQUZOR2hsWVdRVUo3Y0lBQUFHckFBQUFEWm9hR1ZoQjIwRHpBQUFCdVFBQUFBa2FHMTBlQ0lBQmhRQUFBY0lBQUFBTEd4dlkyRUQ0QVU2QUFBSE5BQUFBQmh0WVhod0FBOEFqQUFBQjB3QUFBQWdibUZ0WlhzcjY5MEFBQWRzQUFBQmhuQnZjM1FBQXdBQUFBQUk5QUFBQUNBQUF3UEFBWkFBQlFBQUFwa0N6QUFBQUk4Q21RTE1BQUFCNndBekFRa0FBQUFBQUFBQUFBQUFBQUFBQUFBQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBRHBCZ1BBLzhBQVFBUEFBRUFBQUFBQkFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBREFBQUFBd0FBQUJ3QUFRQURBQUFBSEFBREFBRUFBQUFjQUFRQU9BQUFBQW9BQ0FBQ0FBSUFBUUFnNlFiLy9mLy9BQUFBQUFBZzZRRC8vZi8vQUFILzR4Y0VBQU1BQVFBQUFBQUFBQUFBQUFBQUFRQUIvLzhBRHdBQkFBQUFBQUFBQUFBQUFnQUFOemtCQUFBQUFBRUFBQUFBQUFBQUFBQUNBQUEzT1FFQUFBQUFBUUFBQUFBQUFBQUFBQUlBQURjNUFRQUFBQUFCQVdJQWpRS2VBc2tBRXdBQUpTYzNOalFuSmlJSEFRWVVGd0VXTWpjMk5DY0NudUxpRFEwTUpBei9BQTBOQVFBTUpBd05EY25pNGd3akRRd00vd0FOSXd6L0FBME5EQ01OQUFBQUFRRmlBSTBDbmdMSkFCTUFBQ1VCTmpRbkFTWWlCd1lVSHdFSEJoUVhGakkzQVo0QkFBME4vd0FNSkF3TkRlTGlEUTBNSkF5TkFRQU1JdzBCQUF3TURTTU00dUlOSXd3TkRRQUFBQUlBNGdDM0F4NENuZ0FUQUNjQUFDVW5OelkwSnlZaUR3RUdGQjhCRmpJM05qUW5JU2MzTmpRbkppSVBBUVlVSHdFV01qYzJOQ2NCODdlM0RRME1JdzNWRFEzVkRTTU1EUTBCSzdlM0RRME1KQXpWRFEzVkRDUU1EUTN6dUxjTUpBd05EZFVOSXd6V0RBd05Jd3k0dHd3a0RBME4xUTBqRE5ZTURBMGpEQUFBQWdEaUFMY0RIZ0tlQUJNQUp3QUFKVGMyTkM4QkppSUhCaFFmQVFjR0ZCY1dNamNoTnpZMEx3RW1JZ2NHRkI4QkJ3WVVGeFl5TndKSjFRME4xUTBqREEwTnQ3Y05EUXdqRGY3VjFRME4xUXdrREEwTnQ3Y05EUXdrRExmV0RDTU4xUTBORENRTXQ3Z01JdzBNRE5ZTUl3M1ZEUTBNSkF5M3VBd2pEUXdNQUFBREFGVUFBQU9yQTFVQU13Qm9BSGNBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE1oTWpZMU5DWWpJU0lHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQUFWWVJHUmtSL3FvUkdSa1JBMVVGQkFVT0NRa1ZEQXNaRGYyckRSa0xEQlVKQ0E0RkJRVUZCUVVPQ1FnVkRBc1pEUUpWRFJrTERCVUpDUTRGQkFWVkFnRUNCUU1DQndRRUNBWDlxd1FKQXdRSEF3TUZBUUlDQWdJQkJRTURCd1FEQ1FRQ1ZRVUlCQVFIQWdNRkFnRUMvb0FaRWhFWkdSRVNHUUFBQUFBREFGVUFBQU9yQTFVQU13Qm9BSWtBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE16RlJRV016STJQUUV6TWpZMU5DWXJBVFUwSmlNaUJoMEJJeUlHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQWdCa1NFaG1BRVJrWkVZQVpFaElaZ0JFWkdSRURWUVVFQlE0SkNSVU1DeGtOL2FzTkdRc01GUWtJRGdVRkJRVUZCUTRKQ0JVTUN4a05BbFVOR1FzTUZRa0pEZ1VFQlZVQ0FRSUZBd0lIQkFRSUJmMnJCQWtEQkFjREF3VUJBZ0lDQWdFRkF3TUhCQU1KQkFKVkJRZ0VCQWNDQXdVQ0FRTCtnSUFTR1JrU2dCa1NFUm1BRWhrWkVvQVpFUklaQUFBQkFPSUFqUU1lQXNrQUlBQUFFeGNIQmhRWEZqSS9BUmNXTWpjMk5DOEJOelkwSnlZaUR3RW5KaUlIQmhRWDR1TGlEUTBNSkF6aTRnd2tEQTBONHVJTkRRd2tET0xpRENRTURRMENqZUxpRFNNTURRM2g0UTBORENNTjR1SU1JdzBNRE9MaURBd05Jd3dBQUFBQkFBQUFBUUFBYTVuMHkxOFBQUFVBQ3dRQUFBQUFBTml2T1ZzQUFBQUEySzg1V3dBQUFBQURxd05WQUFBQUNBQUNBQUFBQUFBQUFBRUFBQVBBLzhBQUFBUUFBQUFBQUFPckFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBTEJBQUFBQUFBQUFBQUFBQUFBZ0FBQUFRQUFXSUVBQUZpQkFBQTRnUUFBT0lFQUFCVkJBQUFWUVFBQU9JQUFBQUFBQW9BRkFBZUFFUUFhZ0NxQU9vQm5nSmtBcG9BQVFBQUFBc0FpZ0FEQUFBQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBcmdBQkFBQUFBQUFCQUFjQUFBQUJBQUFBQUFBQ0FBY0FZQUFCQUFBQUFBQURBQWNBTmdBQkFBQUFBQUFFQUFjQWRRQUJBQUFBQUFBRkFBc0FGUUFCQUFBQUFBQUdBQWNBU3dBQkFBQUFBQUFLQUJvQWlnQURBQUVFQ1FBQkFBNEFCd0FEQUFFRUNRQUNBQTRBWndBREFBRUVDUUFEQUE0QVBRQURBQUVFQ1FBRUFBNEFmQUFEQUFFRUNRQUZBQllBSUFBREFBRUVDUUFHQUE0QVVnQURBQUVFQ1FBS0FEUUFwR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzFabGNuTnBiMjRnTVM0d0FGWUFaUUJ5QUhNQWFRQnZBRzRBSUFBeEFDNEFNR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzJaamFXTnZibk1BWmdCakFHa0FZd0J2QUc0QWMxSmxaM1ZzWVhJQVVnQmxBR2NBZFFCc0FHRUFjbVpqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzBadmJuUWdaMlZ1WlhKaGRHVmtJR0o1SUVsamIwMXZiMjR1QUVZQWJ3QnVBSFFBSUFCbkFHVUFiZ0JsQUhJQVlRQjBBR1VBWkFBZ0FHSUFlUUFnQUVrQVl3QnZBRTBBYndCdkFHNEFMZ0FBQUFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQT1cXFwiKSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIil9LmZjLWljb257c3BlYWs6bm9uZTstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZTtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LWZhbWlseTpmY2ljb25zIWltcG9ydGFudDtmb250LXN0eWxlOm5vcm1hbDtmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0OjQwMDtoZWlnaHQ6MWVtO2xpbmUtaGVpZ2h0OjE7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC10cmFuc2Zvcm06bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTt3aWR0aDoxZW19LmZjLWljb24tY2hldnJvbi1sZWZ0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwMFxcXCJ9LmZjLWljb24tY2hldnJvbi1yaWdodDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDFcXFwifS5mYy1pY29uLWNoZXZyb25zLWxlZnQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTAyXFxcIn0uZmMtaWNvbi1jaGV2cm9ucy1yaWdodDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDNcXFwifS5mYy1pY29uLW1pbnVzLXNxdWFyZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDRcXFwifS5mYy1pY29uLXBsdXMtc3F1YXJlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwNVxcXCJ9LmZjLWljb24teDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDZcXFwifS5mYyAuZmMtYnV0dG9ue2JvcmRlci1yYWRpdXM6MDtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZTppbmhlcml0O2xpbmUtaGVpZ2h0OmluaGVyaXQ7bWFyZ2luOjA7b3ZlcmZsb3c6dmlzaWJsZTt0ZXh0LXRyYW5zZm9ybTpub25lfS5mYyAuZmMtYnV0dG9uOmZvY3Vze291dGxpbmU6MXB4IGRvdHRlZDtvdXRsaW5lOjVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcn0uZmMgLmZjLWJ1dHRvbnstd2Via2l0LWFwcGVhcmFuY2U6YnV0dG9ufS5mYyAuZmMtYnV0dG9uOm5vdCg6ZGlzYWJsZWQpe2N1cnNvcjpwb2ludGVyfS5mYyAuZmMtYnV0dG9ue2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmFkaXVzOi4yNWVtO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2ZvbnQtc2l6ZToxZW07Zm9udC13ZWlnaHQ6NDAwO2xpbmUtaGVpZ2h0OjEuNTtwYWRkaW5nOi40ZW0gLjY1ZW07dGV4dC1hbGlnbjpjZW50ZXI7LW1vei11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uOmhvdmVye3RleHQtZGVjb3JhdGlvbjpub25lfS5mYyAuZmMtYnV0dG9uOmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg0NCw2Miw4MCwuMjUpO291dGxpbmU6MH0uZmMgLmZjLWJ1dHRvbjpkaXNhYmxlZHtvcGFjaXR5Oi42NX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJnLWNvbG9yKTtib3JkZXItY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1idXR0b24taG92ZXItYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24taG92ZXItYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpkaXNhYmxlZHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ib3JkZXItY29sb3IpO2NvbG9yOnZhcigtLWZjLWJ1dHRvbi10ZXh0LWNvbG9yKX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5OmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg3Niw5MSwxMDYsLjUpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCkuZmMtYnV0dG9uLWFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1wcmltYXJ5Om5vdCg6ZGlzYWJsZWQpOmFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1hY3RpdmUtYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24tYWN0aXZlLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCkuZmMtYnV0dG9uLWFjdGl2ZTpmb2N1cywuZmMgLmZjLWJ1dHRvbi1wcmltYXJ5Om5vdCg6ZGlzYWJsZWQpOmFjdGl2ZTpmb2N1c3tib3gtc2hhZG93OjAgMCAwIC4ycmVtIHJnYmEoNzYsOTEsMTA2LC41KX0uZmMgLmZjLWJ1dHRvbiAuZmMtaWNvbntmb250LXNpemU6MS41ZW07dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uLWdyb3Vwe2Rpc3BsYXk6aW5saW5lLWZsZXg7cG9zaXRpb246cmVsYXRpdmU7dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b257ZmxleDoxIDEgYXV0bztwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uLmZjLWJ1dHRvbi1hY3RpdmUsLmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjphY3RpdmUsLmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpmb2N1cywuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmhvdmVye3otaW5kZXg6MX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MDttYXJnaW4tbGVmdDotMXB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowO21hcmdpbi1yaWdodDotMXB4fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjB9LmZjIC5mYy10b29sYmFye2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59LmZjIC5mYy10b29sYmFyLmZjLWhlYWRlci10b29sYmFye21hcmdpbi1ib3R0b206MS41ZW19LmZjIC5mYy10b29sYmFyLmZjLWZvb3Rlci10b29sYmFye21hcmdpbi10b3A6MS41ZW19LmZjIC5mYy10b29sYmFyLXRpdGxle2ZvbnQtc2l6ZToxLjc1ZW07bWFyZ2luOjB9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRvb2xiYXI+Kj46bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLWxlZnQ6Ljc1ZW19LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRvb2xiYXI+Kj46bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLXJpZ2h0Oi43NWVtfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10b29sYmFyLWx0cntmbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZX0uZmMgLmZjLXNjcm9sbGVyey13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtc2Nyb2xsZXItbGlxdWlke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZXItbGlxdWlkLWFic29sdXRle2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtc2Nyb2xsZXItaGFybmVzc3tkaXJlY3Rpb246bHRyO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLXNjcm9sbGVyLWhhcm5lc3MtbGlxdWlke2hlaWdodDoxMDAlfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1zY3JvbGxlci1oYXJuZXNzPi5mYy1zY3JvbGxlcntkaXJlY3Rpb246cnRsfS5mYy10aGVtZS1zdGFuZGFyZCAuZmMtc2Nyb2xsZ3JpZHtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvcil9LmZjIC5mYy1zY3JvbGxncmlkLC5mYyAuZmMtc2Nyb2xsZ3JpZCB0YWJsZXt0YWJsZS1sYXlvdXQ6Zml4ZWQ7d2lkdGg6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQgdGFibGV7Ym9yZGVyLWxlZnQtc3R5bGU6aGlkZGVuO2JvcmRlci1yaWdodC1zdHlsZTpoaWRkZW47Ym9yZGVyLXRvcC1zdHlsZTpoaWRkZW59LmZjIC5mYy1zY3JvbGxncmlke2JvcmRlci1ib3R0b20td2lkdGg6MDtib3JkZXItY29sbGFwc2U6c2VwYXJhdGU7Ym9yZGVyLXJpZ2h0LXdpZHRoOjB9LmZjIC5mYy1zY3JvbGxncmlkLWxpcXVpZHtoZWlnaHQ6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbiwuZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbiB0YWJsZSwuZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbj50ZHtoZWlnaHQ6MXB4fS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWxpcXVpZD50ZHtoZWlnaHQ6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbj4qe2JvcmRlci1sZWZ0LXdpZHRoOjA7Ym9yZGVyLXRvcC13aWR0aDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3Rlcj4qLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWhlYWRlcj4qe2JvcmRlci1ib3R0b20td2lkdGg6MH0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1ib2R5IHRhYmxlLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3RlciB0YWJsZXtib3JkZXItYm90dG9tLXN0eWxlOmhpZGRlbn0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3k+KntiYWNrZ3JvdW5kOnZhcigtLWZjLXBhZ2UtYmctY29sb3IpO3Bvc2l0aW9uOnN0aWNreTt6LWluZGV4OjN9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24taGVhZGVyLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3k+Knt0b3A6MH0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1mb290ZXIuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe2JvdHRvbTowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbXtoZWlnaHQ6MXB4O21hcmdpbi1ib3R0b206LTFweH0uZmMtc3RpY2t5e3Bvc2l0aW9uOnN0aWNreX0uZmMgLmZjLXZpZXctaGFybmVzc3tmbGV4LWdyb3c6MTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLXZpZXctaGFybmVzcy1hY3RpdmU+LmZjLXZpZXd7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjJweCA0cHh9LmZjIC5mYy1iZy1ldmVudCwuZmMgLmZjLWhpZ2hsaWdodCwuZmMgLmZjLW5vbi1idXNpbmVzc3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLW5vbi1idXNpbmVzc3tiYWNrZ3JvdW5kOnZhcigtLWZjLW5vbi1idXNpbmVzcy1jb2xvcil9LmZjIC5mYy1iZy1ldmVudHtiYWNrZ3JvdW5kOnZhcigtLWZjLWJnLWV2ZW50LWNvbG9yKTtvcGFjaXR5OnZhcigtLWZjLWJnLWV2ZW50LW9wYWNpdHkpfS5mYyAuZmMtYmctZXZlbnQgLmZjLWV2ZW50LXRpdGxle2ZvbnQtc2l6ZTp2YXIoLS1mYy1zbWFsbC1mb250LXNpemUpO2ZvbnQtc3R5bGU6aXRhbGljO21hcmdpbjouNWVtfS5mYyAuZmMtaGlnaGxpZ2h0e2JhY2tncm91bmQ6dmFyKC0tZmMtaGlnaGxpZ2h0LWNvbG9yKX0uZmMgLmZjLWNlbGwtc2hhZGVkLC5mYyAuZmMtZGF5LWRpc2FibGVke2JhY2tncm91bmQ6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcil9YS5mYy1ldmVudCxhLmZjLWV2ZW50OmhvdmVye3RleHQtZGVjb3JhdGlvbjpub25lfS5mYy1ldmVudC5mYy1ldmVudC1kcmFnZ2FibGUsLmZjLWV2ZW50W2hyZWZde2N1cnNvcjpwb2ludGVyfS5mYy1ldmVudCAuZmMtZXZlbnQtbWFpbntwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjJ9LmZjLWV2ZW50LWRyYWdnaW5nOm5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpe29wYWNpdHk6Ljc1fS5mYy1ldmVudC1kcmFnZ2luZy5mYy1ldmVudC1zZWxlY3RlZHtib3gtc2hhZG93OjAgMnB4IDdweCByZ2JhKDAsMCwwLC4zKX0uZmMtZXZlbnQgLmZjLWV2ZW50LXJlc2l6ZXJ7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6NH0uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXIsLmZjLWV2ZW50OmhvdmVyIC5mYy1ldmVudC1yZXNpemVye2Rpc3BsYXk6YmxvY2t9LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVye2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOmluaGVyaXQ7Ym9yZGVyLXJhZGl1czpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKS8yKTtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXdpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LWJvcmRlci13aWR0aCk7aGVpZ2h0OnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKTt3aWR0aDp2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCl9LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyOmJlZm9yZXtib3R0b206LTIwcHg7Y29udGVudDpcXFwiXFxcIjtsZWZ0Oi0yMHB4O3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0Oi0yMHB4O3RvcDotMjBweH0uZmMtZXZlbnQtc2VsZWN0ZWQsLmZjLWV2ZW50OmZvY3Vze2JveC1zaGFkb3c6MCAycHggNXB4IHJnYmEoMCwwLDAsLjIpfS5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmUsLmZjLWV2ZW50OmZvY3VzOmJlZm9yZXtib3R0b206MDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowO3otaW5kZXg6M30uZmMtZXZlbnQtc2VsZWN0ZWQ6YWZ0ZXIsLmZjLWV2ZW50OmZvY3VzOmFmdGVye2JhY2tncm91bmQ6dmFyKC0tZmMtZXZlbnQtc2VsZWN0ZWQtb3ZlcmxheS1jb2xvcik7Ym90dG9tOi0xcHg7Y29udGVudDpcXFwiXFxcIjtsZWZ0Oi0xcHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTFweDt0b3A6LTFweDt6LWluZGV4OjF9LmZjLWgtZXZlbnR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1ldmVudC1iZy1jb2xvcik7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ldmVudC1ib3JkZXItY29sb3IpO2Rpc3BsYXk6YmxvY2t9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LW1haW57Y29sb3I6dmFyKC0tZmMtZXZlbnQtdGV4dC1jb2xvcil9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LW1haW4tZnJhbWV7ZGlzcGxheTpmbGV4fS5mYy1oLWV2ZW50IC5mYy1ldmVudC10aW1le21heC13aWR0aDoxMDAlO292ZXJmbG93OmhpZGRlbn0uZmMtaC1ldmVudCAuZmMtZXZlbnQtdGl0bGUtY29udGFpbmVye2ZsZXgtZ3JvdzoxO2ZsZXgtc2hyaW5rOjE7bWluLXdpZHRoOjB9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LXRpdGxle2Rpc3BsYXk6aW5saW5lLWJsb2NrO2xlZnQ6MDttYXgtd2lkdGg6MTAwJTtvdmVyZmxvdzpoaWRkZW47cmlnaHQ6MDt2ZXJ0aWNhbC1hbGlnbjp0b3B9LmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3Jle2JvdHRvbTotMTBweDt0b3A6LTEwcHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCksLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1lbmQpe2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItbGVmdC13aWR0aDowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LWVuZCksLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItcmlnaHQtd2lkdGg6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowfS5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVye2JvdHRvbTowO3RvcDowO3dpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmR7Y3Vyc29yOnctcmVzaXplO2xlZnQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykqLS41KX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7Y3Vyc29yOmUtcmVzaXplO3JpZ2h0OmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpKi0uNSl9LmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXJ7bWFyZ2luLXRvcDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpO3RvcDo1MCV9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItZW5ke2xlZnQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkqLS41KX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1lbmQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7cmlnaHQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkqLS41KX0uZmMgLmZjLXBvcG92ZXJ7Ym94LXNoYWRvdzowIDJweCA2cHggcmdiYSgwLDAsMCwuMTUpO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6OTk5OX0uZmMgLmZjLXBvcG92ZXItaGVhZGVye2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO3BhZGRpbmc6M3B4IDRweH0uZmMgLmZjLXBvcG92ZXItdGl0bGV7bWFyZ2luOjAgMnB4fS5mYyAuZmMtcG9wb3Zlci1jbG9zZXtjdXJzb3I6cG9pbnRlcjtmb250LXNpemU6MS4xZW07b3BhY2l0eTouNjV9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1wb3BvdmVye2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ib3JkZXItY29sb3IpfS5mYy10aGVtZS1zdGFuZGFyZCAuZmMtcG9wb3Zlci1oZWFkZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKX1cIjtcbmluamVjdFN0eWxlcyhjc3NfMjQ4eik7XG5cbmNsYXNzIERlbGF5ZWRSdW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKGRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uID0gZHJhaW5lZE9wdGlvbjtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSAwO1xuICAgIH1cbiAgICByZXF1ZXN0KGRlbGF5KSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgaWYgKGRlbGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoLy8gTk9UIE9QVElNQUwhIFRPRE86IGxvb2sgYXQgZGVib3VuY2VcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluLmJpbmQodGhpcyksIGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXVzZShzY29wZSA9ICcnKSB7XG4gICAgICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzO1xuICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gPSAocGF1c2VEZXB0aHNbc2NvcGVdIHx8IDApICsgMTtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB9XG4gICAgcmVzdW1lKHNjb3BlID0gJycsIGZvcmNlKSB7XG4gICAgICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc2NvcGUgaW4gcGF1c2VEZXB0aHMpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXVzZURlcHRoc1tzY29wZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gLT0gMTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGggPSBwYXVzZURlcHRoc1tzY29wZV07XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNQYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnBhdXNlRGVwdGhzKS5sZW5ndGg7XG4gICAgfVxuICAgIHRyeURyYWluKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nICYmICF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWluZWQoKTsgLy8gbWlnaHQgc2V0IGlzRGlydHkgdG8gdHJ1ZSBhZ2FpblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhaW5lZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG59XG4vLyBRdWVyeWluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZWxlbWVudENsb3Nlc3QoZWwsIHNlbGVjdG9yKSB7XG4gICAgaWYgKGVsLmNsb3Nlc3QpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgICAgICAvLyByZWFsbHkgYmFkIGZhbGxiYWNrIGZvciBJRVxuICAgICAgICAvLyBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3RcbiAgICB9XG4gICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWwpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkbyB7XG4gICAgICAgIGlmIChlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSAoZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlKTtcbiAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcbiAgICBsZXQgbWV0aG9kID0gZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3I7XG4gICAgcmV0dXJuIG1ldGhvZC5jYWxsKGVsLCBzZWxlY3Rvcik7XG59XG4vLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4vLyByZXR1cm5zIGEgcmVhbCBhcnJheS4gZ29vZCBmb3IgbWV0aG9kcyBsaWtlIGZvckVhY2hcbi8vIFRPRE86IGFjY2VwdCB0aGUgZG9jdW1lbnRcbmZ1bmN0aW9uIGZpbmRFbGVtZW50cyhjb250YWluZXIsIHNlbGVjdG9yKSB7XG4gICAgbGV0IGNvbnRhaW5lcnMgPSBjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFtjb250YWluZXJdIDogY29udGFpbmVyO1xuICAgIGxldCBhbGxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250YWluZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBtYXRjaGVzID0gY29udGFpbmVyc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBhbGxNYXRjaGVzLnB1c2gobWF0Y2hlc1tqXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbE1hdGNoZXM7XG59XG4vLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4vLyBvbmx5IHF1ZXJpZXMgZGlyZWN0IGNoaWxkIGVsZW1lbnRzIC8vIFRPRE86IHJlbmFtZSB0byBmaW5kRGlyZWN0Q2hpbGRyZW4hXG5mdW5jdGlvbiBmaW5kRGlyZWN0Q2hpbGRyZW4ocGFyZW50LCBzZWxlY3Rvcikge1xuICAgIGxldCBwYXJlbnRzID0gcGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbcGFyZW50XSA6IHBhcmVudDtcbiAgICBsZXQgYWxsTWF0Y2hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHBhcmVudHNbaV0uY2hpbGRyZW47IC8vIG9ubHkgZXZlciBlbGVtZW50c1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2pdO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCBlbGVtZW50TWF0Y2hlcyhjaGlsZE5vZGUsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIGFsbE1hdGNoZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbGxNYXRjaGVzO1xufVxuLy8gU3R5bGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IFBJWEVMX1BST1BfUkUgPSAvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbXx3aWR0aHxoZWlnaHQpJC9pO1xuZnVuY3Rpb24gYXBwbHlTdHlsZShlbCwgcHJvcHMpIHtcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgICBhcHBseVN0eWxlUHJvcChlbCwgcHJvcE5hbWUsIHByb3BzW3Byb3BOYW1lXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlTdHlsZVByb3AoZWwsIG5hbWUsIHZhbCkge1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9ICcnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiBQSVhFTF9QUk9QX1JFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSBgJHt2YWx9cHhgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSB2YWw7XG4gICAgfVxufVxuLy8gRXZlbnQgSGFuZGxpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGlmIGludGVyY2VwdGluZyBidWJibGVkIGV2ZW50cyBhdCB0aGUgZG9jdW1lbnQvd2luZG93L2JvZHkgbGV2ZWwsXG4vLyBhbmQgd2FudCB0byBzZWUgb3JpZ2luYXRpbmcgZWxlbWVudCAodGhlICd0YXJnZXQnKSwgdXNlIHRoaXMgdXRpbCBpbnN0ZWFkXG4vLyBvZiBgZXYudGFyZ2V0YCBiZWNhdXNlIGl0IGdvZXMgd2l0aGluIHdlYi1jb21wb25lbnQgYm91bmRhcmllcy5cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IGV2LmNvbXBvc2VkUGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZXYpWzBdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBldi50YXJnZXQ7XG59XG4vLyBVbmlxdWUgSUQgZm9yIERPTSBhdHRyaWJ1dGVcbmxldCBndWlkJDEgPSAwO1xuZnVuY3Rpb24gZ2V0VW5pcXVlRG9tSWQoKSB7XG4gICAgZ3VpZCQxICs9IDE7XG4gICAgcmV0dXJuICdmYy1kb20tJyArIGd1aWQkMTtcbn1cblxuLy8gU3RvcHMgYSBtb3VzZS90b3VjaCBldmVudCBmcm9tIGRvaW5nIGl0J3MgbmF0aXZlIGJyb3dzZXIgYWN0aW9uXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldikge1xuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG59XG4vLyBFdmVudCBEZWxlZ2F0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBidWlsZERlbGVnYXRpb25IYW5kbGVyKHNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIChldikgPT4ge1xuICAgICAgICBsZXQgbWF0Y2hlZENoaWxkID0gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCBzZWxlY3Rvcik7XG4gICAgICAgIGlmIChtYXRjaGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChtYXRjaGVkQ2hpbGQsIGV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCBldmVudFR5cGUsIHNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgbGV0IGF0dGFjaGVkSGFuZGxlciA9IGJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIoc2VsZWN0b3IsIGhhbmRsZXIpO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgYXR0YWNoZWRIYW5kbGVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGF0dGFjaGVkSGFuZGxlcik7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yKGNvbnRhaW5lciwgc2VsZWN0b3IsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlKSB7XG4gICAgbGV0IGN1cnJlbnRNYXRjaGVkQ2hpbGQ7XG4gICAgcmV0dXJuIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCAnbW91c2VvdmVyJywgc2VsZWN0b3IsIChtb3VzZU92ZXJFdiwgbWF0Y2hlZENoaWxkKSA9PiB7XG4gICAgICAgIGlmIChtYXRjaGVkQ2hpbGQgIT09IGN1cnJlbnRNYXRjaGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBtYXRjaGVkQ2hpbGQ7XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXIobW91c2VPdmVyRXYsIG1hdGNoZWRDaGlsZCk7XG4gICAgICAgICAgICBsZXQgcmVhbE9uTW91c2VMZWF2ZSA9IChtb3VzZUxlYXZlRXYpID0+IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmUobW91c2VMZWF2ZUV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gbGlzdGVuIHRvIHRoZSBuZXh0IG1vdXNlbGVhdmUsIGFuZCB0aGVuIHVuYXR0YWNoXG4gICAgICAgICAgICBtYXRjaGVkQ2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHJlYWxPbk1vdXNlTGVhdmUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBBbmltYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IHRyYW5zaXRpb25FdmVudE5hbWVzID0gW1xuICAgICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAnb3RyYW5zaXRpb25lbmQnLFxuICAgICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgJ21zVHJhbnNpdGlvbkVuZCcsXG4gICAgJ3RyYW5zaXRpb25lbmQnLFxuXTtcbi8vIHRyaWdnZXJlZCBvbmx5IHdoZW4gdGhlIG5leHQgc2luZ2xlIHN1YnNlcXVlbnQgdHJhbnNpdGlvbiBmaW5pc2hlc1xuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25Eb25lKGVsLCBjYWxsYmFjaykge1xuICAgIGxldCByZWFsQ2FsbGJhY2sgPSAoZXYpID0+IHtcbiAgICAgICAgY2FsbGJhY2soZXYpO1xuICAgICAgICB0cmFuc2l0aW9uRXZlbnROYW1lcy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcmVhbENhbGxiYWNrKTsgLy8gY3Jvc3MtYnJvd3NlciB3YXkgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYW5zaXRpb24gZmluaXNoZXNcbiAgICB9KTtcbn1cbi8vIEFSSUEgd29ya2Fyb3VuZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IG9uQ2xpY2s6IGhhbmRsZXIgfSwgY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikpO1xufVxuZnVuY3Rpb24gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICBvbktleURvd24oZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFbnRlcicgfHwgZXYua2V5ID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGV2KTtcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpOyAvLyBpZiBzcGFjZSwgZG9uJ3Qgc2Nyb2xsIGRvd24gcGFnZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG5cbmxldCBndWlkTnVtYmVyID0gMDtcbmZ1bmN0aW9uIGd1aWQoKSB7XG4gICAgZ3VpZE51bWJlciArPSAxO1xuICAgIHJldHVybiBTdHJpbmcoZ3VpZE51bWJlcik7XG59XG4vKiBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgRE9NIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBNYWtlIHRoZSBtb3VzZSBjdXJzb3IgZXhwcmVzcyB0aGF0IGFuIGV2ZW50IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBjdXJyZW50IGFyZWFcbmZ1bmN0aW9uIGRpc2FibGVDdXJzb3IoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdmYy1ub3QtYWxsb3dlZCcpO1xufVxuLy8gUmV0dXJucyB0aGUgbW91c2UgY3Vyc29yIHRvIGl0cyBvcmlnaW5hbCBsb29rXG5mdW5jdGlvbiBlbmFibGVDdXJzb3IoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdmYy1ub3QtYWxsb3dlZCcpO1xufVxuLyogU2VsZWN0aW9uXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIHByZXZlbnRTZWxlY3Rpb24oZWwpIHtcbiAgICBlbC5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgIGVsLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBhbGxvd1NlbGVjdGlvbihlbCkge1xuICAgIGVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnJztcbiAgICBlbC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJyc7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG4vKiBDb250ZXh0IE1lbnVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcHJldmVudENvbnRleHRNZW51KGVsKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBhbGxvd0NvbnRleHRNZW51KGVsKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBwYXJzZUZpZWxkU3BlY3MoaW5wdXQpIHtcbiAgICBsZXQgc3BlY3MgPSBbXTtcbiAgICBsZXQgdG9rZW5zID0gW107XG4gICAgbGV0IGk7XG4gICAgbGV0IHRva2VuO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRva2VucyA9IGlucHV0LnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRva2VucyA9IFtpbnB1dF07XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHRva2VucyA9IGlucHV0O1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3BlY3MucHVzaCh0b2tlbi5jaGFyQXQoMCkgPT09ICctJyA/XG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4uc3Vic3RyaW5nKDEpLCBvcmRlcjogLTEgfSA6XG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4sIG9yZGVyOiAxIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3BlY3MucHVzaCh7IGZ1bmM6IHRva2VuIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjcztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMCwgb2JqMSwgZmllbGRTcGVjcykge1xuICAgIGxldCBpO1xuICAgIGxldCBjbXA7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpZWxkU3BlY3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY21wID0gY29tcGFyZUJ5RmllbGRTcGVjKG9iajAsIG9iajEsIGZpZWxkU3BlY3NbaV0pO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjKG9iajAsIG9iajEsIGZpZWxkU3BlYykge1xuICAgIGlmIChmaWVsZFNwZWMuZnVuYykge1xuICAgICAgICByZXR1cm4gZmllbGRTcGVjLmZ1bmMob2JqMCwgb2JqMSk7XG4gICAgfVxuICAgIHJldHVybiBmbGV4aWJsZUNvbXBhcmUob2JqMFtmaWVsZFNwZWMuZmllbGRdLCBvYmoxW2ZpZWxkU3BlYy5maWVsZF0pXG4gICAgICAgICogKGZpZWxkU3BlYy5vcmRlciB8fCAxKTtcbn1cbmZ1bmN0aW9uIGZsZXhpYmxlQ29tcGFyZShhLCBiKSB7XG4gICAgaWYgKCFhICYmICFiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhKS5sb2NhbGVDb21wYXJlKFN0cmluZyhiKSk7XG4gICAgfVxuICAgIHJldHVybiBhIC0gYjtcbn1cbi8qIFN0cmluZyBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcGFkU3RhcnQodmFsLCBsZW4pIHtcbiAgICBsZXQgcyA9IFN0cmluZyh2YWwpO1xuICAgIHJldHVybiAnMDAwJy5zdWJzdHIoMCwgbGVuIC0gcy5sZW5ndGgpICsgcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFdpdGhPcmRpbmFscyhmb3JtYXR0ZXIsIGFyZ3MsIGZhbGxiYWNrVGV4dCkge1xuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIoLi4uYXJncyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykgeyAvLyBub24tYmxhbmsgc3RyaW5nXG4gICAgICAgIHJldHVybiBhcmdzLnJlZHVjZSgoc3RyLCBhcmcsIGluZGV4KSA9PiAoc3RyLnJlcGxhY2UoJyQnICsgaW5kZXgsIGFyZyB8fCAnJykpLCBmb3JtYXR0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2tUZXh0O1xufVxuLyogTnVtYmVyIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuZnVuY3Rpb24gaXNJbnQobikge1xuICAgIHJldHVybiBuICUgMSA9PT0gMDtcbn1cbi8qIEZDLXNwZWNpZmljIERPTSBkaW1lbnNpb24gc3R1ZmZcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKGNlbGxFbCkge1xuICAgIGxldCBhbGxXaWR0aEVsID0gY2VsbEVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1zY3JvbGxncmlkLXNocmluay1mcmFtZScpO1xuICAgIGxldCBjb250ZW50V2lkdGhFbCA9IGNlbGxFbC5xdWVyeVNlbGVjdG9yKCcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicpO1xuICAgIGlmICghYWxsV2lkdGhFbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lIGNsYXNzTmFtZScpOyAvLyBUT0RPOiB1c2UgY29uc3RcbiAgICB9XG4gICAgaWYgKCFjb250ZW50V2lkdGhFbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24gY2xhc3NOYW1lJyk7XG4gICAgfVxuICAgIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBhbGxXaWR0aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgLy8gdGhlIGNlbGwgcGFkZGluZytib3JkZXJcbiAgICAgICAgY29udGVudFdpZHRoRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG59XG5cbmNvbnN0IElOVEVSTkFMX1VOSVRTID0gWyd5ZWFycycsICdtb250aHMnLCAnZGF5cycsICdtaWxsaXNlY29uZHMnXTtcbmNvbnN0IFBBUlNFX1JFID0gL14oLT8pKD86KFxcZCspXFwuKT8oXFxkKyk6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpcXC4oXFxkXFxkXFxkKSk/KT8vO1xuLy8gUGFyc2luZyBhbmQgQ3JlYXRpb25cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB1bml0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdChpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdCh7IFt1bml0IHx8ICdtaWxsaXNlY29uZHMnXTogaW5wdXQgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcocykge1xuICAgIGxldCBtID0gUEFSU0VfUkUuZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgICBsZXQgc2lnbiA9IG1bMV0gPyAtMSA6IDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICAgIGRheXM6IHNpZ24gKiAobVsyXSA/IHBhcnNlSW50KG1bMl0sIDEwKSA6IDApLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBzaWduICogKChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgICAgICAgICAgKG1bNF0gPyBwYXJzZUludChtWzRdLCAxMCkgOiAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICAobVs1XSA/IHBhcnNlSW50KG1bNV0sIDEwKSA6IDApICogMTAwMCArIC8vIHNlY29uZHNcbiAgICAgICAgICAgICAgICAobVs2XSA/IHBhcnNlSW50KG1bNl0sIDEwKSA6IDApIC8vIG1zXG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaikge1xuICAgIGxldCBkdXJhdGlvbiA9IHtcbiAgICAgICAgeWVhcnM6IG9iai55ZWFycyB8fCBvYmoueWVhciB8fCAwLFxuICAgICAgICBtb250aHM6IG9iai5tb250aHMgfHwgb2JqLm1vbnRoIHx8IDAsXG4gICAgICAgIGRheXM6IG9iai5kYXlzIHx8IG9iai5kYXkgfHwgMCxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAob2JqLmhvdXJzIHx8IG9iai5ob3VyIHx8IDApICogNjAgKiA2MCAqIDEwMDAgKyAvLyBob3Vyc1xuICAgICAgICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXG4gICAgICAgICAgICAob2JqLnNlY29uZHMgfHwgb2JqLnNlY29uZCB8fCAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXG4gICAgICAgICAgICAob2JqLm1pbGxpc2Vjb25kcyB8fCBvYmoubWlsbGlzZWNvbmQgfHwgb2JqLm1zIHx8IDApLCAvLyBtc1xuICAgIH07XG4gICAgbGV0IHdlZWtzID0gb2JqLndlZWtzIHx8IG9iai53ZWVrO1xuICAgIGlmICh3ZWVrcykge1xuICAgICAgICBkdXJhdGlvbi5kYXlzICs9IHdlZWtzICogNztcbiAgICAgICAgZHVyYXRpb24uc3BlY2lmaWVkV2Vla3MgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb247XG59XG4vLyBFcXVhbGl0eVxuZnVuY3Rpb24gZHVyYXRpb25zRXF1YWwoZDAsIGQxKSB7XG4gICAgcmV0dXJuIGQwLnllYXJzID09PSBkMS55ZWFycyAmJlxuICAgICAgICBkMC5tb250aHMgPT09IGQxLm1vbnRocyAmJlxuICAgICAgICBkMC5kYXlzID09PSBkMS5kYXlzICYmXG4gICAgICAgIGQwLm1pbGxpc2Vjb25kcyA9PT0gZDEubWlsbGlzZWNvbmRzO1xufVxuZnVuY3Rpb24gYXNDbGVhbkRheXMoZHVyKSB7XG4gICAgaWYgKCFkdXIueWVhcnMgJiYgIWR1ci5tb250aHMgJiYgIWR1ci5taWxsaXNlY29uZHMpIHtcbiAgICAgICAgcmV0dXJuIGR1ci5kYXlzO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbi8vIFNpbXBsZSBNYXRoXG5mdW5jdGlvbiBhZGREdXJhdGlvbnMoZDAsIGQxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXG4gICAgICAgIG1vbnRoczogZDAubW9udGhzICsgZDEubW9udGhzLFxuICAgICAgICBkYXlzOiBkMC5kYXlzICsgZDEuZGF5cyxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN1YnRyYWN0RHVyYXRpb25zKGQxLCBkMCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBkMS55ZWFycyAtIGQwLnllYXJzLFxuICAgICAgICBtb250aHM6IGQxLm1vbnRocyAtIGQwLm1vbnRocyxcbiAgICAgICAgZGF5czogZDEuZGF5cyAtIGQwLmRheXMsXG4gICAgICAgIG1pbGxpc2Vjb25kczogZDEubWlsbGlzZWNvbmRzIC0gZDAubWlsbGlzZWNvbmRzLFxuICAgIH07XG59XG5mdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGQsIG4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogZC55ZWFycyAqIG4sXG4gICAgICAgIG1vbnRoczogZC5tb250aHMgKiBuLFxuICAgICAgICBkYXlzOiBkLmRheXMgKiBuLFxuICAgICAgICBtaWxsaXNlY29uZHM6IGQubWlsbGlzZWNvbmRzICogbixcbiAgICB9O1xufVxuLy8gQ29udmVyc2lvbnNcbi8vIFwiUm91Z2hcIiBiZWNhdXNlIHRoZXkgYXJlIGJhc2VkIG9uIGF2ZXJhZ2UtY2FzZSBHcmVnb3JpYW4gbW9udGhzL3llYXJzXG5mdW5jdGlvbiBhc1JvdWdoWWVhcnMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzNjU7XG59XG5mdW5jdGlvbiBhc1JvdWdoTW9udGhzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoRGF5cyhkdXIpIC8gMzA7XG59XG5mdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyA4NjRlNTtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNaW51dGVzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvICgxMDAwICogNjApO1xufVxuZnVuY3Rpb24gYXNSb3VnaFNlY29uZHMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gMTAwMDtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNcyhkdXIpIHtcbiAgICByZXR1cm4gZHVyLnllYXJzICogKDM2NSAqIDg2NGU1KSArXG4gICAgICAgIGR1ci5tb250aHMgKiAoMzAgKiA4NjRlNSkgK1xuICAgICAgICBkdXIuZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgZHVyLm1pbGxpc2Vjb25kcztcbn1cbi8vIEFkdmFuY2VkIE1hdGhcbmZ1bmN0aW9uIHdob2xlRGl2aWRlRHVyYXRpb25zKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICBsZXQgcmVzID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IElOVEVSTkFMX1VOSVRTLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCB1bml0ID0gSU5URVJOQUxfVU5JVFNbaV07XG4gICAgICAgIGlmIChkZW5vbWluYXRvclt1bml0XSkge1xuICAgICAgICAgICAgbGV0IGxvY2FsUmVzID0gbnVtZXJhdG9yW3VuaXRdIC8gZGVub21pbmF0b3JbdW5pdF07XG4gICAgICAgICAgICBpZiAoIWlzSW50KGxvY2FsUmVzKSB8fCAocmVzICE9PSBudWxsICYmIHJlcyAhPT0gbG9jYWxSZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSBsb2NhbFJlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1lcmF0b3JbdW5pdF0pIHtcbiAgICAgICAgICAgIC8vIG5lZWRzIHRvIGRpdmlkZSBieSBzb21ldGhpbmcgYnV0IGNhbid0IVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXIpIHtcbiAgICBsZXQgbXMgPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgIGlmIChtcykge1xuICAgICAgICBpZiAobXMgJSAxMDAwICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBtcyAvIDEwMDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwICogNjApICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCAqIDYwKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkdXIuZGF5cykge1xuICAgICAgICBpZiAoZHVyLnNwZWNpZmllZFdlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogZHVyLmRheXMgLyA3IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLm1vbnRocykge1xuICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLnllYXJzKSB7XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9O1xuICAgIH1cbiAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogMCB9O1xufVxuXG4vLyBUT0RPOiBuZXcgdXRpbCBhcnJheWlmeT9cbmZ1bmN0aW9uIHJlbW92ZUV4YWN0KGFycmF5LCBleGFjdFZhbCkge1xuICAgIGxldCByZW1vdmVDbnQgPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGV4YWN0VmFsKSB7XG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZW1vdmVDbnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlQ250O1xufVxuZnVuY3Rpb24gaXNBcnJheXNFcXVhbChhMCwgYTEsIGVxdWFsaXR5RnVuYykge1xuICAgIGlmIChhMCA9PT0gYTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBsZW4gPSBhMC5sZW5ndGg7XG4gICAgbGV0IGk7XG4gICAgaWYgKGxlbiAhPT0gYTEubGVuZ3RoKSB7IC8vIG5vdCBhcnJheT8gb3Igbm90IHNhbWUgbGVuZ3RoP1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoIShlcXVhbGl0eUZ1bmMgPyBlcXVhbGl0eUZ1bmMoYTBbaV0sIGExW2ldKSA6IGEwW2ldID09PSBhMVtpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgREFZX0lEUyA9IFsnc3VuJywgJ21vbicsICd0dWUnLCAnd2VkJywgJ3RodScsICdmcmknLCAnc2F0J107XG4vLyBBZGRpbmdcbmZ1bmN0aW9uIGFkZFdlZWtzKG0sIG4pIHtcbiAgICBsZXQgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xuICAgIGFbMl0gKz0gbiAqIDc7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkRGF5cyhtLCBuKSB7XG4gICAgbGV0IGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICBhWzJdICs9IG47XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkTXMobSwgbikge1xuICAgIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XG4gICAgYVs2XSArPSBuO1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKTtcbn1cbi8vIERpZmZpbmcgKGFsbCByZXR1cm4gZmxvYXRzKVxuLy8gVE9ETzogd2h5IG5vdCB1c2UgcmFuZ2VzP1xuZnVuY3Rpb24gZGlmZldlZWtzKG0wLCBtMSkge1xuICAgIHJldHVybiBkaWZmRGF5cyhtMCwgbTEpIC8gNztcbn1cbmZ1bmN0aW9uIGRpZmZEYXlzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbn1cbmZ1bmN0aW9uIGRpZmZIb3VycyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwICogNjApO1xufVxuZnVuY3Rpb24gZGlmZk1pbnV0ZXMobTAsIG0xKSB7XG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCk7XG59XG5mdW5jdGlvbiBkaWZmU2Vjb25kcyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAxMDAwO1xufVxuZnVuY3Rpb24gZGlmZkRheUFuZFRpbWUobTAsIG0xKSB7XG4gICAgbGV0IG0wZGF5ID0gc3RhcnRPZkRheShtMCk7XG4gICAgbGV0IG0xZGF5ID0gc3RhcnRPZkRheShtMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IDAsXG4gICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgZGF5czogTWF0aC5yb3VuZChkaWZmRGF5cyhtMGRheSwgbTFkYXkpKSxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAobTEudmFsdWVPZigpIC0gbTFkYXkudmFsdWVPZigpKSAtIChtMC52YWx1ZU9mKCkgLSBtMGRheS52YWx1ZU9mKCkpLFxuICAgIH07XG59XG4vLyBEaWZmaW5nIFdob2xlIFVuaXRzXG5mdW5jdGlvbiBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpIHtcbiAgICBsZXQgZCA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICBpZiAoZCAhPT0gbnVsbCAmJiBkICUgNyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZCAvIDc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGlmZldob2xlRGF5cyhtMCwgbTEpIHtcbiAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZGlmZkRheXMobTAsIG0xKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gU3RhcnQtT2ZcbmZ1bmN0aW9uIHN0YXJ0T2ZEYXkobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZIb3VyKG0pIHtcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xuICAgICAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIG0uZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgbS5nZXRVVENEYXRlKCksXG4gICAgICAgIG0uZ2V0VVRDSG91cnMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZNaW51dGUobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZTZWNvbmQobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgbS5nZXRVVENTZWNvbmRzKCksXG4gICAgXSk7XG59XG4vLyBXZWVrIENvbXB1dGF0aW9uXG5mdW5jdGlvbiB3ZWVrT2ZZZWFyKG1hcmtlciwgZG93LCBkb3kpIHtcbiAgICBsZXQgeSA9IG1hcmtlci5nZXRVVENGdWxsWWVhcigpO1xuICAgIGxldCB3ID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSwgZG93LCBkb3kpO1xuICAgIGlmICh3IDwgMSkge1xuICAgICAgICByZXR1cm4gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSAtIDEsIGRvdywgZG95KTtcbiAgICB9XG4gICAgbGV0IG5leHRXID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSArIDEsIGRvdywgZG95KTtcbiAgICBpZiAobmV4dFcgPj0gMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odywgbmV4dFcpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbn1cbmZ1bmN0aW9uIHdlZWtPZkdpdmVuWWVhcihtYXJrZXIsIHllYXIsIGRvdywgZG95KSB7XG4gICAgbGV0IGZpcnN0V2Vla1N0YXJ0ID0gYXJyYXlUb1V0Y0RhdGUoW3llYXIsIDAsIDEgKyBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpXSk7XG4gICAgbGV0IGRheVN0YXJ0ID0gc3RhcnRPZkRheShtYXJrZXIpO1xuICAgIGxldCBkYXlzID0gTWF0aC5yb3VuZChkaWZmRGF5cyhmaXJzdFdlZWtTdGFydCwgZGF5U3RhcnQpKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzIC8gNykgKyAxOyAvLyB6ZXJvLWluZGV4ZWRcbn1cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICBsZXQgZndkID0gNyArIGRvdyAtIGRveTtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgbGV0IGZ3ZGx3ID0gKDcgKyBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgZndkXSkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cbi8vIEFycmF5IENvbnZlcnNpb25cbmZ1bmN0aW9uIGRhdGVUb0xvY2FsQXJyYXkoZGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgZGF0ZS5nZXRIb3VycygpLFxuICAgICAgICBkYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9Mb2NhbERhdGUoYSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShhWzBdLCBhWzFdIHx8IDAsIGFbMl0gPT0gbnVsbCA/IDEgOiBhWzJdLCAvLyBkYXkgb2YgbW9udGhcbiAgICBhWzNdIHx8IDAsIGFbNF0gfHwgMCwgYVs1XSB8fCAwKTtcbn1cbmZ1bmN0aW9uIGRhdGVUb1V0Y0FycmF5KGRhdGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENEYXRlKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgICBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICAgIF07XG59XG5mdW5jdGlvbiBhcnJheVRvVXRjRGF0ZShhKSB7XG4gICAgLy8gYWNjb3JkaW5nIHRvIHdlYiBzdGFuZGFyZHMgKGFuZCBTYWZhcmkpLCBhIG1vbnRoIGluZGV4IGlzIHJlcXVpcmVkLlxuICAgIC8vIG1hc3NhZ2UgaWYgb25seSBnaXZlbiBhIHllYXIuXG4gICAgaWYgKGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGEgPSBhLmNvbmNhdChbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoLi4uYSkpO1xufVxuLy8gT3RoZXIgVXRpbHNcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKG0pIHtcbiAgICByZXR1cm4gIWlzTmFOKG0udmFsdWVPZigpKTtcbn1cbmZ1bmN0aW9uIHRpbWVBc01zKG0pIHtcbiAgICByZXR1cm4gbS5nZXRVVENIb3VycygpICogMTAwMCAqIDYwICogNjAgK1xuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSAqIDEwMDAgKiA2MCArXG4gICAgICAgIG0uZ2V0VVRDU2Vjb25kcygpICogMTAwMCArXG4gICAgICAgIG0uZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG59XG5cbi8vIHRpbWVab25lT2Zmc2V0IGlzIGluIG1pbnV0ZXNcbmZ1bmN0aW9uIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIHN0cmlwWmVyb1RpbWUgPSBmYWxzZSkge1xuICAgIGxldCBzID0gbWFya2VyLnRvSVNPU3RyaW5nKCk7XG4gICAgcyA9IHMucmVwbGFjZSgnLjAwMCcsICcnKTtcbiAgICBpZiAoc3RyaXBaZXJvVGltZSkge1xuICAgICAgICBzID0gcy5yZXBsYWNlKCdUMDA6MDA6MDBaJywgJycpO1xuICAgIH1cbiAgICBpZiAocy5sZW5ndGggPiAxMCkgeyAvLyB0aW1lIHBhcnQgd2Fzbid0IHN0cmlwcGVkLCBjYW4gYWRkIHRpbWV6b25lIGluZm9cbiAgICAgICAgaWYgKHRpbWVab25lT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGltZVpvbmVPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCBmb3JtYXRUaW1lWm9uZU9mZnNldCh0aW1lWm9uZU9mZnNldCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSwgaXRzIFVUQy0wIGFuZCB3ZSB3YW50IHRvIGtlZXAgdGhlIFpcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG4vLyBmb3JtYXRzIHRoZSBkYXRlLCBidXQgd2l0aCBubyB0aW1lIHBhcnRcbi8vIFRPRE86IHNvbWVob3cgbWVyZ2Ugd2l0aCBidWlsZElzb1N0cmluZyBhbmQgc3RyaXBaZXJvVGltZVxuLy8gVE9ETzogcmVuYW1lLiBvbWl0IFwic3RyaW5nXCJcbmZ1bmN0aW9uIGZvcm1hdERheVN0cmluZyhtYXJrZXIpIHtcbiAgICByZXR1cm4gbWFya2VyLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvVC4qJC8sICcnKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdElzb01vbnRoU3RyKG1hcmtlcikge1xuICAgIHJldHVybiBtYXJrZXIudG9JU09TdHJpbmcoKS5tYXRjaCgvXlxcZHs0fS1cXGR7Mn0vKVswXTtcbn1cbi8vIFRPRE86IHVzZSBEYXRlOjp0b0lTT1N0cmluZyBhbmQgdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIFQ/XG5mdW5jdGlvbiBmb3JtYXRJc29UaW1lU3RyaW5nKG1hcmtlcikge1xuICAgIHJldHVybiBwYWRTdGFydChtYXJrZXIuZ2V0VVRDSG91cnMoKSwgMikgKyAnOicgK1xuICAgICAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDTWludXRlcygpLCAyKSArICc6JyArXG4gICAgICAgIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENTZWNvbmRzKCksIDIpO1xufVxuZnVuY3Rpb24gZm9ybWF0VGltZVpvbmVPZmZzZXQobWludXRlcywgZG9Jc28gPSBmYWxzZSkge1xuICAgIGxldCBzaWduID0gbWludXRlcyA8IDAgPyAnLScgOiAnKyc7XG4gICAgbGV0IGFicyA9IE1hdGguYWJzKG1pbnV0ZXMpO1xuICAgIGxldCBob3VycyA9IE1hdGguZmxvb3IoYWJzIC8gNjApO1xuICAgIGxldCBtaW5zID0gTWF0aC5yb3VuZChhYnMgJSA2MCk7XG4gICAgaWYgKGRvSXNvKSB7XG4gICAgICAgIHJldHVybiBgJHtzaWduICsgcGFkU3RhcnQoaG91cnMsIDIpfToke3BhZFN0YXJ0KG1pbnMsIDIpfWA7XG4gICAgfVxuICAgIHJldHVybiBgR01UJHtzaWdufSR7aG91cnN9JHttaW5zID8gYDoke3BhZFN0YXJ0KG1pbnMsIDIpfWAgOiAnJ31gO1xufVxuXG5mdW5jdGlvbiBtZW1vaXplKHdvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICBsZXQgY3VycmVudEFyZ3M7XG4gICAgbGV0IGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5uZXdBcmdzKSB7XG4gICAgICAgIGlmICghY3VycmVudEFyZ3MpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdzLCBuZXdBcmdzKSkge1xuICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ3MgPSBuZXdBcmdzO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVtb2l6ZU9iakFyZyh3b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgbGV0IGN1cnJlbnRBcmc7XG4gICAgbGV0IGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIChuZXdBcmcpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50QXJnKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5jYWxsKHRoaXMsIG5ld0FyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzUHJvcHNFcXVhbChjdXJyZW50QXJnLCBuZXdBcmcpKSB7XG4gICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuY2FsbCh0aGlzLCBuZXdBcmcpO1xuICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZyA9IG5ld0FyZztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVBcnJheWxpa2UoLy8gdXNlZCBhdCBhbGw/XG53b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgbGV0IGN1cnJlbnRBcmdTZXRzID0gW107XG4gICAgbGV0IGN1cnJlbnRSZXN1bHRzID0gW107XG4gICAgcmV0dXJuIChuZXdBcmdTZXRzKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50TGVuID0gY3VycmVudEFyZ1NldHMubGVuZ3RoO1xuICAgICAgICBsZXQgbmV3TGVuID0gbmV3QXJnU2V0cy5sZW5ndGg7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBjdXJyZW50TGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghbmV3QXJnU2V0c1tpXSkgeyAvLyBvbmUgb2YgdGhlIG9sZCBzZXRzIG5vIGxvbmdlciBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzdWx0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ1NldHNbaV0sIG5ld0FyZ1NldHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdTZXRzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXN1bHRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBuZXdMZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgY3VycmVudFJlc3VsdHNbaV0gPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdTZXRzID0gbmV3QXJnU2V0cztcbiAgICAgICAgY3VycmVudFJlc3VsdHMuc3BsaWNlKG5ld0xlbik7IC8vIHJlbW92ZSBleGNlc3NcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRzO1xuICAgIH07XG59XG5mdW5jdGlvbiBtZW1vaXplSGFzaGxpa2Uod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIGxldCBjdXJyZW50QXJnSGFzaCA9IHt9O1xuICAgIGxldCBjdXJyZW50UmVzSGFzaCA9IHt9O1xuICAgIHJldHVybiAobmV3QXJnSGFzaCkgPT4ge1xuICAgICAgICBsZXQgbmV3UmVzSGFzaCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gbmV3QXJnSGFzaCkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50UmVzSGFzaFtrZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ0hhc2hba2V5XSwgbmV3QXJnSGFzaFtrZXldKSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXNIYXNoW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xuICAgICAgICAgICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IChyZXNFcXVhbGl0eSAmJiByZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXNIYXNoW2tleV0pKVxuICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnRSZXNIYXNoW2tleV1cbiAgICAgICAgICAgICAgICAgICAgOiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSBjdXJyZW50UmVzSGFzaFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdIYXNoID0gbmV3QXJnSGFzaDtcbiAgICAgICAgY3VycmVudFJlc0hhc2ggPSBuZXdSZXNIYXNoO1xuICAgICAgICByZXR1cm4gbmV3UmVzSGFzaDtcbiAgICB9O1xufVxuXG5jb25zdCBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUyA9IHtcbiAgICB3ZWVrOiAzLFxuICAgIHNlcGFyYXRvcjogMCxcbiAgICBvbWl0WmVyb01pbnV0ZTogMCxcbiAgICBtZXJpZGllbTogMCxcbiAgICBvbWl0Q29tbWFzOiAwLFxufTtcbmNvbnN0IFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTID0ge1xuICAgIHRpbWVab25lTmFtZTogNyxcbiAgICBlcmE6IDYsXG4gICAgeWVhcjogNSxcbiAgICBtb250aDogNCxcbiAgICBkYXk6IDIsXG4gICAgd2Vla2RheTogMixcbiAgICBob3VyOiAxLFxuICAgIG1pbnV0ZTogMSxcbiAgICBzZWNvbmQ6IDEsXG59O1xuY29uc3QgTUVSSURJRU1fUkUgPSAvXFxzKihbYXBdKVxcLj9tXFwuPy9pOyAvLyBlYXRzIHVwIGxlYWRpbmcgc3BhY2VzIHRvb1xuY29uc3QgQ09NTUFfUkUgPSAvLC9nOyAvLyB3ZSBuZWVkIHJlIGZvciBnbG9iYWxuZXNzXG5jb25zdCBNVUxUSV9TUEFDRV9SRSA9IC9cXHMrL2c7XG5jb25zdCBMVFJfUkUgPSAvXFx1MjAwZS9nOyAvLyBjb250cm9sIGNoYXJhY3RlclxuY29uc3QgVVRDX1JFID0gL1VUQ3xHTVQvO1xuY2xhc3MgTmF0aXZlRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihmb3JtYXRTZXR0aW5ncykge1xuICAgICAgICBsZXQgc3RhbmRhcmREYXRlUHJvcHMgPSB7fTtcbiAgICAgICAgbGV0IGV4dGVuZGVkU2V0dGluZ3MgPSB7fTtcbiAgICAgICAgbGV0IHNldmVyaXR5ID0gMDtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBmb3JtYXRTZXR0aW5ncykge1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVMpIHtcbiAgICAgICAgICAgICAgICBleHRlbmRlZFNldHRpbmdzW25hbWVdID0gZm9ybWF0U2V0dGluZ3NbbmFtZV07XG4gICAgICAgICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFU1tuYW1lXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHNbbmFtZV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgeyAvLyBUT0RPOiB3aGF0IGFib3V0IGhvdXIxMj8gbm8gc2V2ZXJpdHlcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YW5kYXJkRGF0ZVByb3BzID0gc3RhbmRhcmREYXRlUHJvcHM7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncyA9IGV4dGVuZGVkU2V0dGluZ3M7XG4gICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBzZXZlcml0eTtcbiAgICAgICAgdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jID0gbWVtb2l6ZShidWlsZEZvcm1hdHRpbmdGdW5jKTtcbiAgICB9XG4gICAgZm9ybWF0KGRhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRGb3JtYXR0aW5nRnVuYyh0aGlzLnN0YW5kYXJkRGF0ZVByb3BzLCB0aGlzLmV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpKGRhdGUpO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIGxldCB7IHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZGlmZlNldmVyaXR5ID0gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShzdGFydC5tYXJrZXIsIGVuZC5tYXJrZXIsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICBpZiAoIWRpZmZTZXZlcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gZGlmZlNldmVyaXR5O1xuICAgICAgICBpZiAoYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID4gMSAmJiAvLyB0aGUgdHdvIGRhdGVzIGFyZSBkaWZmZXJlbnQgaW4gYSB3YXkgdGhhdCdzIGxhcmdlciBzY2FsZSB0aGFuIHRpbWVcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMueWVhciA9PT0gJzItZGlnaXQnKSAmJlxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLm1vbnRoID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICcyLWRpZ2l0JykgJiZcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICcyLWRpZ2l0JykpIHtcbiAgICAgICAgICAgIGJpZ2dlc3RVbml0Rm9yUGFydGlhbCA9IDE7IC8vIG1ha2UgaXQgbG9vayBsaWtlIHRoZSBkYXRlcyBhcmUgb25seSBkaWZmZXJlbnQgaW4gdGVybXMgb2YgdGltZVxuICAgICAgICB9XG4gICAgICAgIGxldCBmdWxsMCA9IHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgbGV0IGZ1bGwxID0gdGhpcy5mb3JtYXQoZW5kLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGZ1bGwwID09PSBmdWxsMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bGwwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJ0aWFsRGF0ZVByb3BzID0gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhzdGFuZGFyZERhdGVQcm9wcywgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsKTtcbiAgICAgICAgbGV0IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyA9IGJ1aWxkRm9ybWF0dGluZ0Z1bmMocGFydGlhbERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XG4gICAgICAgIGxldCBwYXJ0aWFsMCA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhzdGFydCk7XG4gICAgICAgIGxldCBwYXJ0aWFsMSA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhlbmQpO1xuICAgICAgICBsZXQgaW5zZXJ0aW9uID0gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSk7XG4gICAgICAgIGxldCBzZXBhcmF0b3IgPSBleHRlbmRlZFNldHRpbmdzLnNlcGFyYXRvciB8fCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yIHx8IGNvbnRleHQuZGVmYXVsdFNlcGFyYXRvciB8fCAnJztcbiAgICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydGlvbi5iZWZvcmUgKyBwYXJ0aWFsMCArIHNlcGFyYXRvciArIHBhcnRpYWwxICsgaW5zZXJ0aW9uLmFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdWxsMCArIHNlcGFyYXRvciArIGZ1bGwxO1xuICAgIH1cbiAgICBnZXRMYXJnZXN0VW5pdCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldmVyaXR5KSB7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd5ZWFyJztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21vbnRoJztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3dlZWsnO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZGF5JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0aW1lJzsgLy8gcmVhbGx5P1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIGxldCBzdGFuZGFyZERhdGVQcm9wQ250ID0gT2JqZWN0LmtleXMoc3RhbmRhcmREYXRlUHJvcHMpLmxlbmd0aDtcbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMSAmJiBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgcmV0dXJuIChkYXRlKSA9PiAoZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMCAmJiBleHRlbmRlZFNldHRpbmdzLndlZWspIHtcbiAgICAgICAgcmV0dXJuIChkYXRlKSA9PiAoZm9ybWF0V2Vla051bWJlcihjb250ZXh0LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUubWFya2VyKSwgY29udGV4dC53ZWVrVGV4dCwgY29udGV4dC53ZWVrVGV4dExvbmcsIGNvbnRleHQubG9jYWxlLCBleHRlbmRlZFNldHRpbmdzLndlZWspKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMoc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHN0YW5kYXJkRGF0ZVByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpOyAvLyBjb3B5XG4gICAgZXh0ZW5kZWRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIGV4dGVuZGVkU2V0dGluZ3MpOyAvLyBjb3B5XG4gICAgc2FuaXRpemVTZXR0aW5ncyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncyk7XG4gICAgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmUgPSAnVVRDJzsgLy8gd2UgbGV2ZXJhZ2UgdGhlIG9ubHkgZ3VhcmFudGVlZCB0aW1lWm9uZSBmb3Igb3VyIFVUQyBtYXJrZXJzXG4gICAgbGV0IG5vcm1hbEZvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGNvbnRleHQubG9jYWxlLmNvZGVzLCBzdGFuZGFyZERhdGVQcm9wcyk7XG4gICAgbGV0IHplcm9Gb3JtYXQ7IC8vIG5lZWRlZD9cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSkge1xuICAgICAgICBsZXQgemVyb1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpO1xuICAgICAgICBkZWxldGUgemVyb1Byb3BzLm1pbnV0ZTsgLy8gc2Vjb25kcyBhbmQgbXMgd2VyZSBhbHJlYWR5IGNvbnNpZGVyZWQgaW4gc2FuaXRpemVTZXR0aW5nc1xuICAgICAgICB6ZXJvRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHplcm9Qcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiAoZGF0ZSkgPT4ge1xuICAgICAgICBsZXQgeyBtYXJrZXIgfSA9IGRhdGU7XG4gICAgICAgIGxldCBmb3JtYXQ7XG4gICAgICAgIGlmICh6ZXJvRm9ybWF0ICYmICFtYXJrZXIuZ2V0VVRDTWludXRlcygpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSB6ZXJvRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbm9ybWFsRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzID0gZm9ybWF0LmZvcm1hdChtYXJrZXIpO1xuICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3MocywgZGF0ZSwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKSB7XG4gICAgLy8gZGVhbCB3aXRoIGEgYnJvd3NlciBpbmNvbnNpc3RlbmN5IHdoZXJlIGZvcm1hdHRpbmcgdGhlIHRpbWV6b25lXG4gICAgLy8gcmVxdWlyZXMgdGhhdCB0aGUgaG91ci9taW51dGUgYmUgcHJlc2VudC5cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lKSB7XG4gICAgICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMuaG91cikge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMuaG91ciA9ICcyLWRpZ2l0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YW5kYXJkRGF0ZVByb3BzLm1pbnV0ZSkge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMubWludXRlID0gJzItZGlnaXQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9ubHkgc3VwcG9ydCBzaG9ydCB0aW1lem9uZSBuYW1lc1xuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdsb25nJykge1xuICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPSAnc2hvcnQnO1xuICAgIH1cbiAgICAvLyBpZiByZXF1ZXN0aW5nIHRvIGRpc3BsYXkgc2Vjb25kcywgTVVTVCBkaXNwbGF5IG1pbnV0ZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSAmJiAoc3RhbmRhcmREYXRlUHJvcHMuc2Vjb25kIHx8IHN0YW5kYXJkRGF0ZVByb3BzLm1pbGxpc2Vjb25kKSkge1xuICAgICAgICBkZWxldGUgZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHMgPSBzLnJlcGxhY2UoTFRSX1JFLCAnJyk7IC8vIHJlbW92ZSBsZWZ0LXRvLXJpZ2h0IGNvbnRyb2wgY2hhcnMuIGRvIGZpcnN0LiBnb29kIGZvciBvdGhlciByZWdleGVzXG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICBzID0gaW5qZWN0VHpvU3RyKHMsIChjb250ZXh0LnRpbWVab25lID09PSAnVVRDJyB8fCBkYXRlLnRpbWVab25lT2Zmc2V0ID09IG51bGwpID9cbiAgICAgICAgICAgICdVVEMnIDogLy8gaW1wb3J0YW50IHRvIG5vcm1hbGl6ZSBmb3IgSUUsIHdoaWNoIGRvZXMgXCJHTVRcIlxuICAgICAgICAgICAgZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0Q29tbWFzKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoQ09NTUFfUkUsICcnKS50cmltKCk7XG4gICAgfVxuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJzowMCcsICcnKTsgLy8gemVyb0Zvcm1hdCBkb2Vzbid0IGFsd2F5cyBhY2hpZXZlIHRoaXNcbiAgICB9XG4gICAgLy8gXiBkbyBhbnl0aGluZyB0aGF0IG1pZ2h0IGNyZWF0ZSBhZGphY2VudCBzcGFjZXMgYmVmb3JlIHRoaXMgcG9pbnQsXG4gICAgLy8gYmVjYXVzZSBNRVJJRElFTV9SRSBsaWtlcyB0byBlYXQgdXAgbG9hZGluZyBzcGFjZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgJycpLnRyaW0oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ25hcnJvdycpIHsgLy8gYS9wXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCwgbTEpID0+IG0xLnRvTG9jYWxlTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnc2hvcnQnKSB7IC8vIGFtL3BtXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCwgbTEpID0+IGAke20xLnRvTG9jYWxlTG93ZXJDYXNlKCl9bWApO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbG93ZXJjYXNlJykgeyAvLyBvdGhlciBtZXJpZGllbSB0cmFuc2Zvcm1lcnMgYWxyZWFkeSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCkgPT4gbTAudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHMgPSBzLnJlcGxhY2UoTVVMVElfU1BBQ0VfUkUsICcgJyk7XG4gICAgcyA9IHMudHJpbSgpO1xuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gaW5qZWN0VHpvU3RyKHMsIHR6b1N0cikge1xuICAgIGxldCByZXBsYWNlZCA9IGZhbHNlO1xuICAgIHMgPSBzLnJlcGxhY2UoVVRDX1JFLCAoKSA9PiB7XG4gICAgICAgIHJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHR6b1N0cjtcbiAgICB9KTtcbiAgICAvLyBJRTExIGRvZXNuJ3QgaW5jbHVkZSBVVEMvR01UIGluIHRoZSBvcmlnaW5hbCBzdHJpbmcsIHNvIGFwcGVuZCB0byBlbmRcbiAgICBpZiAoIXJlcGxhY2VkKSB7XG4gICAgICAgIHMgKz0gYCAke3R6b1N0cn1gO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXIobnVtLCB3ZWVrVGV4dCwgd2Vla1RleHRMb25nLCBsb2NhbGUsIGRpc3BsYXkpIHtcbiAgICBsZXQgcGFydHMgPSBbXTtcbiAgICBpZiAoZGlzcGxheSA9PT0gJ2xvbmcnKSB7XG4gICAgICAgIHBhcnRzLnB1c2god2Vla1RleHRMb25nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzcGxheSA9PT0gJ3Nob3J0JyB8fCBkaXNwbGF5ID09PSAnbmFycm93Jykge1xuICAgICAgICBwYXJ0cy5wdXNoKHdlZWtUZXh0KTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXkgPT09ICdsb25nJyB8fCBkaXNwbGF5ID09PSAnc2hvcnQnKSB7XG4gICAgICAgIHBhcnRzLnB1c2goJyAnKTtcbiAgICB9XG4gICAgcGFydHMucHVzaChsb2NhbGUuc2ltcGxlTnVtYmVyRm9ybWF0LmZvcm1hdChudW0pKTtcbiAgICBpZiAobG9jYWxlLm9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJykgeyAvLyBUT0RPOiB1c2UgY29udHJvbCBjaGFyYWN0ZXJzIGluc3RlYWQ/XG4gICAgICAgIHBhcnRzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufVxuLy8gUmFuZ2UgRm9ybWF0dGluZyBVdGlsc1xuLy8gMCA9IGV4YWN0bHkgdGhlIHNhbWVcbi8vIDEgPSBkaWZmZXJlbnQgYnkgdGltZVxuLy8gYW5kIGJpZ2dlclxuZnVuY3Rpb24gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShkMCwgZDEsIGNhKSB7XG4gICAgaWYgKGNhLmdldE1hcmtlclllYXIoZDApICE9PSBjYS5nZXRNYXJrZXJZZWFyKGQxKSkge1xuICAgICAgICByZXR1cm4gNTtcbiAgICB9XG4gICAgaWYgKGNhLmdldE1hcmtlck1vbnRoKGQwKSAhPT0gY2EuZ2V0TWFya2VyTW9udGgoZDEpKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBpZiAoY2EuZ2V0TWFya2VyRGF5KGQwKSAhPT0gY2EuZ2V0TWFya2VyRGF5KGQxKSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgaWYgKHRpbWVBc01zKGQwKSAhPT0gdGltZUFzTXMoZDEpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMob3B0aW9ucywgYmlnZ2VzdFVuaXQpIHtcbiAgICBsZXQgcGFydGlhbE9wdGlvbnMgPSB7fTtcbiAgICBmb3IgKGxldCBuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEobmFtZSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgfHwgLy8gbm90IGEgZGF0ZSBwYXJ0IHByb3AgKGxpa2UgdGltZVpvbmUpXG4gICAgICAgICAgICBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXSA8PSBiaWdnZXN0VW5pdCkge1xuICAgICAgICAgICAgcGFydGlhbE9wdGlvbnNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWFsT3B0aW9ucztcbn1cbmZ1bmN0aW9uIGZpbmRDb21tb25JbnNlcnRpb24oZnVsbDAsIHBhcnRpYWwwLCBmdWxsMSwgcGFydGlhbDEpIHtcbiAgICBsZXQgaTAgPSAwO1xuICAgIHdoaWxlIChpMCA8IGZ1bGwwLmxlbmd0aCkge1xuICAgICAgICBsZXQgZm91bmQwID0gZnVsbDAuaW5kZXhPZihwYXJ0aWFsMCwgaTApO1xuICAgICAgICBpZiAoZm91bmQwID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJlZm9yZTAgPSBmdWxsMC5zdWJzdHIoMCwgZm91bmQwKTtcbiAgICAgICAgaTAgPSBmb3VuZDAgKyBwYXJ0aWFsMC5sZW5ndGg7XG4gICAgICAgIGxldCBhZnRlcjAgPSBmdWxsMC5zdWJzdHIoaTApO1xuICAgICAgICBsZXQgaTEgPSAwO1xuICAgICAgICB3aGlsZSAoaTEgPCBmdWxsMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZDEgPSBmdWxsMS5pbmRleE9mKHBhcnRpYWwxLCBpMSk7XG4gICAgICAgICAgICBpZiAoZm91bmQxID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJlZm9yZTEgPSBmdWxsMS5zdWJzdHIoMCwgZm91bmQxKTtcbiAgICAgICAgICAgIGkxID0gZm91bmQxICsgcGFydGlhbDEubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGFmdGVyMSA9IGZ1bGwxLnN1YnN0cihpMSk7XG4gICAgICAgICAgICBpZiAoYmVmb3JlMCA9PT0gYmVmb3JlMSAmJiBhZnRlcjAgPT09IGFmdGVyMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZTogYmVmb3JlMCxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IGFmdGVyMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHBhbmRab25lZE1hcmtlcihkYXRlSW5mbywgY2FsZW5kYXJTeXN0ZW0pIHtcbiAgICBsZXQgYSA9IGNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkoZGF0ZUluZm8ubWFya2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYXJrZXI6IGRhdGVJbmZvLm1hcmtlcixcbiAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVJbmZvLnRpbWVab25lT2Zmc2V0LFxuICAgICAgICBhcnJheTogYSxcbiAgICAgICAgeWVhcjogYVswXSxcbiAgICAgICAgbW9udGg6IGFbMV0sXG4gICAgICAgIGRheTogYVsyXSxcbiAgICAgICAgaG91cjogYVszXSxcbiAgICAgICAgbWludXRlOiBhWzRdLFxuICAgICAgICBzZWNvbmQ6IGFbNV0sXG4gICAgICAgIG1pbGxpc2Vjb25kOiBhWzZdLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICBsZXQgc3RhcnRJbmZvID0gZXhwYW5kWm9uZWRNYXJrZXIoc3RhcnQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgIGxldCBlbmRJbmZvID0gZW5kID8gZXhwYW5kWm9uZWRNYXJrZXIoZW5kLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZTogc3RhcnRJbmZvLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLFxuICAgICAgICBlbmQ6IGVuZEluZm8sXG4gICAgICAgIHRpbWVab25lOiBjb250ZXh0LnRpbWVab25lLFxuICAgICAgICBsb2NhbGVDb2RlczogY29udGV4dC5sb2NhbGUuY29kZXMsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yLFxuICAgIH07XG59XG5cbi8qXG5UT0RPOiBmaXggdGhlIHRlcm1pbm9sb2d5IG9mIFwiZm9ybWF0dGVyXCIgdnMgXCJmb3JtYXR0aW5nIGZ1bmNcIlxuKi9cbi8qXG5BdCB0aGUgdGltZSBvZiBpbnN0YW50aWF0aW9uLCB0aGlzIG9iamVjdCBkb2VzIG5vdCBrbm93IHdoaWNoIGNtZC1mb3JtYXR0aW5nIHN5c3RlbSBpdCB3aWxsIHVzZS5cbkl0IHJlY2VpdmVzIHRoaXMgYXQgdGhlIHRpbWUgb2YgZm9ybWF0dGluZywgYXMgYSBzZXR0aW5nLlxuKi9cbmNsYXNzIENtZEZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IoY21kU3RyKSB7XG4gICAgICAgIHRoaXMuY21kU3RyID0gY21kU3RyO1xuICAgIH1cbiAgICBmb3JtYXQoZGF0ZSwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG4gICAgZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG59XG5cbmNsYXNzIEZ1bmNGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICB9XG4gICAgZm9ybWF0KGRhdGUsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhkYXRlLCBudWxsLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfVxuICAgIGZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVGb3JtYXR0ZXIoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IENtZEZvcm1hdHRlcihpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jRm9ybWF0dGVyKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIGJhc2Ugb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tXG5jb25zdCBCQVNFX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBuYXZMaW5rRGF5Q2xpY2s6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtXZWVrQ2xpY2s6IGlkZW50aXR5LFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBib290c3RyYXBGb250QXdlc29tZTogaWRlbnRpdHksXG4gICAgYnV0dG9uSWNvbnM6IGlkZW50aXR5LFxuICAgIGN1c3RvbUJ1dHRvbnM6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBuZXh0RGF5VGhyZXNob2xkOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lUmVzZXQ6IEJvb2xlYW4sXG4gICAgc2xvdE1pblRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNsb3RNYXhUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkYXlQb3BvdmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgc2xvdER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzbmFwRHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGhlYWRlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGZvb3RlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6IFN0cmluZyxcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IEJvb2xlYW4sXG4gICAgZGF5SGVhZGVyczogQm9vbGVhbixcbiAgICBkYXlIZWFkZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICBkYXlIZWFkZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJDb250ZW50OiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJEaWRNb3VudDogaWRlbnRpdHksXG4gICAgZGF5SGVhZGVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheUNlbGxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlDZWxsQ29udGVudDogaWRlbnRpdHksXG4gICAgZGF5Q2VsbERpZE1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlDZWxsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGluaXRpYWxWaWV3OiBTdHJpbmcsXG4gICAgYXNwZWN0UmF0aW86IE51bWJlcixcbiAgICB3ZWVrZW5kczogQm9vbGVhbixcbiAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJzOiBCb29sZWFuLFxuICAgIHdlZWtOdW1iZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyQ29udGVudDogaWRlbnRpdHksXG4gICAgd2Vla051bWJlckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIHZpZXdDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB2aWV3RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHZpZXdXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yOiBCb29sZWFuLFxuICAgIG5vd0luZGljYXRvckNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3JXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2hvd05vbkN1cnJlbnREYXRlczogQm9vbGVhbixcbiAgICBsYXp5RmV0Y2hpbmc6IEJvb2xlYW4sXG4gICAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICAgIGVuZFBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxuICAgIHRpbWVab25lOiBTdHJpbmcsXG4gICAgbG9jYWxlczogaWRlbnRpdHksXG4gICAgbG9jYWxlOiBpZGVudGl0eSxcbiAgICB0aGVtZVN5c3RlbTogU3RyaW5nLFxuICAgIGRyYWdSZXZlcnREdXJhdGlvbjogTnVtYmVyLFxuICAgIGRyYWdTY3JvbGw6IEJvb2xlYW4sXG4gICAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogQm9vbGVhbixcbiAgICB1bnNlbGVjdEF1dG86IEJvb2xlYW4sXG4gICAgZHJvcEFjY2VwdDogaWRlbnRpdHksXG4gICAgZXZlbnRPcmRlcjogcGFyc2VGaWVsZFNwZWNzLFxuICAgIGV2ZW50T3JkZXJTdHJpY3Q6IEJvb2xlYW4sXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiBCb29sZWFuLFxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiBOdW1iZXIsXG4gICAgbG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBldmVudERyYWdNaW5EaXN0YW5jZTogTnVtYmVyLFxuICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4sXG4gICAgaGVpZ2h0OiBpZGVudGl0eSxcbiAgICBjb250ZW50SGVpZ2h0OiBpZGVudGl0eSxcbiAgICBkaXJlY3Rpb246IFN0cmluZyxcbiAgICB3ZWVrTnVtYmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgZXZlbnRSZXNpemFibGVGcm9tU3RhcnQ6IEJvb2xlYW4sXG4gICAgZGlzcGxheUV2ZW50VGltZTogQm9vbGVhbixcbiAgICBkaXNwbGF5RXZlbnRFbmQ6IEJvb2xlYW4sXG4gICAgd2Vla1RleHQ6IFN0cmluZyxcbiAgICB3ZWVrVGV4dExvbmc6IFN0cmluZyxcbiAgICBwcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nOiBCb29sZWFuLFxuICAgIGJ1c2luZXNzSG91cnM6IGlkZW50aXR5LFxuICAgIGluaXRpYWxEYXRlOiBpZGVudGl0eSxcbiAgICBub3c6IGlkZW50aXR5LFxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogaWRlbnRpdHksXG4gICAgc3RpY2t5SGVhZGVyRGF0ZXM6IGlkZW50aXR5LFxuICAgIHN0aWNreUZvb3RlclNjcm9sbGJhcjogaWRlbnRpdHksXG4gICAgdmlld0hlaWdodDogaWRlbnRpdHksXG4gICAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgICBldmVudFNvdXJjZUZhaWx1cmU6IGlkZW50aXR5LFxuICAgIGV2ZW50U291cmNlU3VjY2VzczogaWRlbnRpdHksXG4gICAgZXZlbnREaXNwbGF5OiBTdHJpbmcsXG4gICAgZXZlbnRTdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGV2ZW50RHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgICBldmVudE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIGV2ZW50Q29uc3RyYWludDogaWRlbnRpdHksXG4gICAgZXZlbnRBbGxvdzogaWRlbnRpdHksXG4gICAgZXZlbnRCYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgICBldmVudEJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRUZXh0Q29sb3I6IFN0cmluZyxcbiAgICBldmVudENvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBldmVudENvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50V2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdENvbnN0cmFpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIHNlbGVjdEFsbG93OiBpZGVudGl0eSxcbiAgICBkcm9wcGFibGU6IEJvb2xlYW4sXG4gICAgdW5zZWxlY3RDYW5jZWw6IFN0cmluZyxcbiAgICBzbG90TGFiZWxGb3JtYXQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgc2xvdExhbmVDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZURpZE1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxEaWRNb3VudDogaWRlbnRpdHksXG4gICAgc2xvdExhYmVsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheU1heEV2ZW50czogaWRlbnRpdHksXG4gICAgZGF5TWF4RXZlbnRSb3dzOiBpZGVudGl0eSxcbiAgICBkYXlNaW5XaWR0aDogTnVtYmVyLFxuICAgIHNsb3RMYWJlbEludGVydmFsOiBjcmVhdGVEdXJhdGlvbixcbiAgICBhbGxEYXlUZXh0OiBTdHJpbmcsXG4gICAgYWxsRGF5Q2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgYWxsRGF5Q29udGVudDogaWRlbnRpdHksXG4gICAgYWxsRGF5RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGFsbERheVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TWluV2lkdGg6IE51bWJlcixcbiAgICBuYXZMaW5rczogQm9vbGVhbixcbiAgICBldmVudFRpbWVGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICByZXJlbmRlckRlbGF5OiBOdW1iZXIsXG4gICAgbW9yZUxpbmtUZXh0OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0hpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE1pbkRpc3RhbmNlOiBOdW1iZXIsXG4gICAgc2VsZWN0YWJsZTogQm9vbGVhbixcbiAgICBzZWxlY3RMb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICAgIGV2ZW50TG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBzZWxlY3RNaXJyb3I6IEJvb2xlYW4sXG4gICAgZXZlbnRNYXhTdGFjazogTnVtYmVyLFxuICAgIGV2ZW50TWluSGVpZ2h0OiBOdW1iZXIsXG4gICAgZXZlbnRNaW5XaWR0aDogTnVtYmVyLFxuICAgIGV2ZW50U2hvcnRIZWlnaHQ6IE51bWJlcixcbiAgICBzbG90RXZlbnRPdmVybGFwOiBCb29sZWFuLFxuICAgIHBsdWdpbnM6IGlkZW50aXR5LFxuICAgIGZpcnN0RGF5OiBOdW1iZXIsXG4gICAgZGF5Q291bnQ6IE51bWJlcixcbiAgICBkYXRlQWxpZ25tZW50OiBTdHJpbmcsXG4gICAgZGF0ZUluY3JlbWVudDogY3JlYXRlRHVyYXRpb24sXG4gICAgaGlkZGVuRGF5czogaWRlbnRpdHksXG4gICAgZml4ZWRXZWVrQ291bnQ6IEJvb2xlYW4sXG4gICAgdmFsaWRSYW5nZTogaWRlbnRpdHksXG4gICAgdmlzaWJsZVJhbmdlOiBpZGVudGl0eSxcbiAgICB0aXRsZUZvcm1hdDogaWRlbnRpdHksXG4gICAgZXZlbnRJbnRlcmFjdGl2ZTogQm9vbGVhbixcbiAgICAvLyBvbmx5IHVzZWQgYnkgbGlzdC12aWV3LCBidXQgbGFuZ3VhZ2VzIGRlZmluZSB0aGUgdmFsdWUsIHNvIHdlIG5lZWQgaXQgaW4gYmFzZSBvcHRpb25zXG4gICAgbm9FdmVudHNUZXh0OiBTdHJpbmcsXG4gICAgdmlld0hpbnQ6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtIaW50OiBpZGVudGl0eSxcbiAgICBjbG9zZUhpbnQ6IFN0cmluZyxcbiAgICB0aW1lSGludDogU3RyaW5nLFxuICAgIGV2ZW50SGludDogU3RyaW5nLFxuICAgIG1vcmVMaW5rQ2xpY2s6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtDb250ZW50OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0RpZE1vdW50OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua1dpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBtb250aFN0YXJ0Rm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgLy8gZm9yIGNvbm5lY3RvcnNcbiAgICAvLyAoY2FuJ3QgYmUgcGFydCBvZiBwbHVnaW4gc3lzdGVtIGIvYyBtdXN0IGJlIHByb3ZpZGVkIGF0IHJ1bnRpbWUpXG4gICAgaGFuZGxlQ3VzdG9tUmVuZGVyaW5nOiBpZGVudGl0eSxcbiAgICBjdXN0b21SZW5kZXJpbmdNZXRhTWFwOiBpZGVudGl0eSxcbiAgICBjdXN0b21SZW5kZXJpbmdSZXBsYWNlczogQm9vbGVhbixcbn07XG4vLyBkbyBOT1QgZ2l2ZSBhIHR5cGUgaGVyZS4gbmVlZCBgdHlwZW9mIEJBU0VfT1BUSU9OX0RFRkFVTFRTYCB0byBnaXZlIHJlYWwgcmVzdWx0cy5cbi8vIHJhdyB2YWx1ZXMuXG5jb25zdCBCQVNFX09QVElPTl9ERUZBVUxUUyA9IHtcbiAgICBldmVudERpc3BsYXk6ICdhdXRvJyxcbiAgICBkZWZhdWx0UmFuZ2VTZXBhcmF0b3I6ICcgLSAnLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6ICcgXFx1MjAxMyAnLFxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246ICcwMTowMDowMCcsXG4gICAgZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IHsgZGF5OiAxIH0sXG4gICAgZm9yY2VFdmVudER1cmF0aW9uOiBmYWxzZSxcbiAgICBuZXh0RGF5VGhyZXNob2xkOiAnMDA6MDA6MDAnLFxuICAgIGRheUhlYWRlcnM6IHRydWUsXG4gICAgaW5pdGlhbFZpZXc6ICcnLFxuICAgIGFzcGVjdFJhdGlvOiAxLjM1LFxuICAgIGhlYWRlclRvb2xiYXI6IHtcbiAgICAgICAgc3RhcnQ6ICd0aXRsZScsXG4gICAgICAgIGNlbnRlcjogJycsXG4gICAgICAgIGVuZDogJ3RvZGF5IHByZXYsbmV4dCcsXG4gICAgfSxcbiAgICB3ZWVrZW5kczogdHJ1ZSxcbiAgICB3ZWVrTnVtYmVyczogZmFsc2UsXG4gICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiAnbG9jYWwnLFxuICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICBub3dJbmRpY2F0b3I6IGZhbHNlLFxuICAgIHNjcm9sbFRpbWU6ICcwNjowMDowMCcsXG4gICAgc2Nyb2xsVGltZVJlc2V0OiB0cnVlLFxuICAgIHNsb3RNaW5UaW1lOiAnMDA6MDA6MDAnLFxuICAgIHNsb3RNYXhUaW1lOiAnMjQ6MDA6MDAnLFxuICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHRydWUsXG4gICAgbGF6eUZldGNoaW5nOiB0cnVlLFxuICAgIHN0YXJ0UGFyYW06ICdzdGFydCcsXG4gICAgZW5kUGFyYW06ICdlbmQnLFxuICAgIHRpbWVab25lUGFyYW06ICd0aW1lWm9uZScsXG4gICAgdGltZVpvbmU6ICdsb2NhbCcsXG4gICAgbG9jYWxlczogW10sXG4gICAgbG9jYWxlOiAnJyxcbiAgICB0aGVtZVN5c3RlbTogJ3N0YW5kYXJkJyxcbiAgICBkcmFnUmV2ZXJ0RHVyYXRpb246IDUwMCxcbiAgICBkcmFnU2Nyb2xsOiB0cnVlLFxuICAgIGFsbERheU1haW50YWluRHVyYXRpb246IGZhbHNlLFxuICAgIHVuc2VsZWN0QXV0bzogdHJ1ZSxcbiAgICBkcm9wQWNjZXB0OiAnKicsXG4gICAgZXZlbnRPcmRlcjogJ3N0YXJ0LC1kdXJhdGlvbixhbGxEYXksdGl0bGUnLFxuICAgIGRheVBvcG92ZXJGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LFxuICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICB3aW5kb3dSZXNpemVEZWxheTogMTAwLFxuICAgIGxvbmdQcmVzc0RlbGF5OiAxMDAwLFxuICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiA1LFxuICAgIGV4cGFuZFJvd3M6IGZhbHNlLFxuICAgIG5hdkxpbmtzOiBmYWxzZSxcbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICBldmVudE1pbkhlaWdodDogMTUsXG4gICAgZXZlbnRNaW5XaWR0aDogMzAsXG4gICAgZXZlbnRTaG9ydEhlaWdodDogMzAsXG4gICAgbW9udGhTdGFydEZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJyB9LFxufTtcbi8vIGNhbGVuZGFyIGxpc3RlbmVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyA9IHtcbiAgICBkYXRlc1NldDogaWRlbnRpdHksXG4gICAgZXZlbnRzU2V0OiBpZGVudGl0eSxcbiAgICBldmVudEFkZDogaWRlbnRpdHksXG4gICAgZXZlbnRDaGFuZ2U6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVtb3ZlOiBpZGVudGl0eSxcbiAgICB3aW5kb3dSZXNpemU6IGlkZW50aXR5LFxuICAgIGV2ZW50Q2xpY2s6IGlkZW50aXR5LFxuICAgIGV2ZW50TW91c2VFbnRlcjogaWRlbnRpdHksXG4gICAgZXZlbnRNb3VzZUxlYXZlOiBpZGVudGl0eSxcbiAgICBzZWxlY3Q6IGlkZW50aXR5LFxuICAgIHVuc2VsZWN0OiBpZGVudGl0eSxcbiAgICBsb2FkaW5nOiBpZGVudGl0eSxcbiAgICAvLyBpbnRlcm5hbFxuICAgIF91bm1vdW50OiBpZGVudGl0eSxcbiAgICBfYmVmb3JlcHJpbnQ6IGlkZW50aXR5LFxuICAgIF9hZnRlcnByaW50OiBpZGVudGl0eSxcbiAgICBfbm9FdmVudERyb3A6IGlkZW50aXR5LFxuICAgIF9ub0V2ZW50UmVzaXplOiBpZGVudGl0eSxcbiAgICBfcmVzaXplOiBpZGVudGl0eSxcbiAgICBfc2Nyb2xsUmVxdWVzdDogaWRlbnRpdHksXG59O1xuLy8gY2FsZW5kYXItc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIGJ1dHRvblRleHQ6IGlkZW50aXR5LFxuICAgIGJ1dHRvbkhpbnRzOiBpZGVudGl0eSxcbiAgICB2aWV3czogaWRlbnRpdHksXG4gICAgcGx1Z2luczogaWRlbnRpdHksXG4gICAgaW5pdGlhbEV2ZW50czogaWRlbnRpdHksXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudFNvdXJjZXM6IGlkZW50aXR5LFxufTtcbmNvbnN0IENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTID0ge1xuICAgIGhlYWRlclRvb2xiYXI6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgZm9vdGVyVG9vbGJhcjogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBidXR0b25UZXh0OiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvbkhpbnRzOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvbkljb25zOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGRhdGVJbmNyZW1lbnQ6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgcGx1Z2luczogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIGV2ZW50czogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIGV2ZW50U291cmNlczogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIFsncmVzb3VyY2VzJ106IGlzTWF5YmVBcnJheXNFcXVhbCxcbn07XG5mdW5jdGlvbiBpc01heWJlT2JqZWN0c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJiBhICYmIGIpIHsgLy8gYm90aCBub24tbnVsbCBvYmplY3RzXG4gICAgICAgIHJldHVybiBpc1Byb3BzRXF1YWwoYSwgYik7XG4gICAgfVxuICAgIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gaXNNYXliZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5c0VxdWFsKGEsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cbi8vIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBWSUVXX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY29tcG9uZW50OiBpZGVudGl0eSxcbiAgICBidXR0b25UZXh0OiBTdHJpbmcsXG4gICAgYnV0dG9uVGV4dEtleTogU3RyaW5nLFxuICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IGlkZW50aXR5LFxuICAgIHVzZXNNaW5NYXhUaW1lOiBCb29sZWFuLFxuICAgIGNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGRpZE1vdW50OiBpZGVudGl0eSxcbiAgICB3aWxsVW5tb3VudDogaWRlbnRpdHksXG59O1xuLy8gdXRpbCBmdW5jc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gbWVyZ2VSYXdPcHRpb25zKG9wdGlvblNldHMpIHtcbiAgICByZXR1cm4gbWVyZ2VQcm9wcyhvcHRpb25TZXRzLCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyk7XG59XG5mdW5jdGlvbiByZWZpbmVQcm9wcyhpbnB1dCwgcmVmaW5lcnMpIHtcbiAgICBsZXQgcmVmaW5lZCA9IHt9O1xuICAgIGxldCBleHRyYSA9IHt9O1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHJlZmluZXJzKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgcmVmaW5lZFtwcm9wTmFtZV0gPSByZWZpbmVyc1twcm9wTmFtZV0oaW5wdXRbcHJvcE5hbWVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBpbnB1dCkge1xuICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiByZWZpbmVycykpIHtcbiAgICAgICAgICAgIGV4dHJhW3Byb3BOYW1lXSA9IGlucHV0W3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZpbmVkLCBleHRyYSB9O1xufVxuZnVuY3Rpb24gaWRlbnRpdHkocmF3KSB7XG4gICAgcmV0dXJuIHJhdztcbn1cblxuY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSB9ID0gT2JqZWN0LnByb3RvdHlwZTtcbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0LlxuLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXG5mdW5jdGlvbiBtZXJnZVByb3BzKHByb3BPYmpzLCBjb21wbGV4UHJvcHNNYXApIHtcbiAgICBsZXQgZGVzdCA9IHt9O1xuICAgIGlmIChjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgICAgIGlmIChjb21wbGV4UHJvcHNNYXBbbmFtZV0gPT09IGlzTWF5YmVPYmplY3RzRXF1YWwpIHsgLy8gaW1wbGllcyB0aGF0IGl0J3Mgb2JqZWN0LW1lcmdlYWJsZVxuICAgICAgICAgICAgICAgIGxldCBjb21wbGV4T2JqcyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIHRyYWlsaW5nIG9iamVjdCB2YWx1ZXMsIHN0b3BwaW5nIHdoZW4gYSBub24tb2JqZWN0IGlzIGRpc2NvdmVyZWRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHByb3BPYmpzW2ldW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsKSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxleE9ianMudW5zaGlmdCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gdmFsOyAvLyBpZiB0aGVyZSB3ZXJlIG5vIG9iamVjdHMsIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdHJhaWxpbmcgdmFsdWVzIHdlcmUgb2JqZWN0cywgdXNlIHRoZSBtZXJnZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSBtZXJnZVByb3BzKGNvbXBsZXhPYmpzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxuICAgIGZvciAobGV0IGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBsZXQgcHJvcHMgPSBwcm9wT2Jqc1tpXTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBkZXN0KSkgeyAvLyBpZiBhbHJlYWR5IGFzc2lnbmVkIGJ5IHByZXZpb3VzIHByb3BzIG9yIGNvbXBsZXggcHJvcHMsIGRvbid0IHJlYXNzaWduXG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gZmlsdGVySGFzaChoYXNoLCBmdW5jKSB7XG4gICAgbGV0IGZpbHRlcmVkID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGhhc2gpIHtcbiAgICAgICAgaWYgKGZ1bmMoaGFzaFtrZXldLCBrZXkpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrZXldID0gaGFzaFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZDtcbn1cbmZ1bmN0aW9uIG1hcEhhc2goaGFzaCwgZnVuYykge1xuICAgIGxldCBuZXdIYXNoID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGhhc2gpIHtcbiAgICAgICAgbmV3SGFzaFtrZXldID0gZnVuYyhoYXNoW2tleV0sIGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdIYXNoO1xufVxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYSkge1xuICAgIGxldCBoYXNoID0ge307XG4gICAgZm9yIChsZXQgaXRlbSBvZiBhKSB7XG4gICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbi8vIFRPRE86IHJlYXNzZXNzIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8/c2VhcmNoPW9iamVjdC52YWx1ZXNcbmZ1bmN0aW9uIGhhc2hWYWx1ZXNUb0FycmF5KG9iaikge1xuICAgIGxldCBhID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgICAgICBhLnB1c2gob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGlzUHJvcHNFcXVhbChvYmowLCBvYmoxKSB7XG4gICAgaWYgKG9iajAgPT09IG9iajEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqMSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmoxLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAob2JqMFtrZXldICE9PSBvYmoxW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBIQU5ETEVSX1JFID0gL15vbltBLVpdLztcbmZ1bmN0aW9uIGlzTm9uSGFuZGxlclByb3BzRXF1YWwob2JqMCwgb2JqMSkge1xuICAgIGNvbnN0IGtleXMgPSBnZXRVbmVxdWFsUHJvcHMob2JqMCwgb2JqMSk7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKCFIQU5ETEVSX1JFLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VW5lcXVhbFByb3BzKG9iajAsIG9iajEpIHtcbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBvYmoxKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gY29tcGFyZU9ianMob2xkUHJvcHMsIG5ld1Byb3BzLCBlcXVhbGl0eUZ1bmNzID0ge30pIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRQcm9wcyAmJiBpc09ialZhbHNFcXVhbChvbGRQcm9wc1trZXldLCBuZXdQcm9wc1trZXldLCBlcXVhbGl0eUZ1bmNzW2tleV0pKSA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBwcm9wcyB0aGF0IHdlcmUgb21pdHRlZCBpbiB0aGUgbmV3XG4gICAgZm9yIChsZXQga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qXG5hc3N1bWVkIFwidHJ1ZVwiIGVxdWFsaXR5IGZvciBoYW5kbGVyIG5hbWVzIGxpa2UgXCJvblJlY2VpdmVTb21ldGhpbmdcIlxuKi9cbmZ1bmN0aW9uIGlzT2JqVmFsc0VxdWFsKHZhbDAsIHZhbDEsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAodmFsMCA9PT0gdmFsMSB8fCBjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvcih2YWwwLCB2YWwxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdEZyb21IYXNoKGhhc2gsIHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCwgc3RlcCA9IDEpIHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgaWYgKGVuZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgZW5kSW5kZXggPSBPYmplY3Qua2V5cyhoYXNoKS5sZW5ndGg7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkgKz0gc3RlcCkge1xuICAgICAgICBsZXQgdmFsID0gaGFzaFtpXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7IC8vIHdpbGwgZGlzcmVnYXJkIHVuZGVmaW5lZCBmb3Igc3BhcnNlIGFycmF5c1xuICAgICAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5sZXQgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcCA9IHt9O1xuZnVuY3Rpb24gcmVnaXN0ZXJDYWxlbmRhclN5c3RlbShuYW1lLCB0aGVDbGFzcykge1xuICAgIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0gPSB0aGVDbGFzcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyU3lzdGVtKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0oKTtcbn1cbmNsYXNzIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIHtcbiAgICBnZXRNYXJrZXJZZWFyKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB9XG4gICAgZ2V0TWFya2VyTW9udGgoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENNb250aCgpO1xuICAgIH1cbiAgICBnZXRNYXJrZXJEYXkoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENEYXRlKCk7XG4gICAgfVxuICAgIGFycmF5VG9NYXJrZXIoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhcnIpO1xuICAgIH1cbiAgICBtYXJrZXJUb0FycmF5KG1hcmtlcikge1xuICAgICAgICByZXR1cm4gZGF0ZVRvVXRjQXJyYXkobWFya2VyKTtcbiAgICB9XG59XG5yZWdpc3RlckNhbGVuZGFyU3lzdGVtKCdncmVnb3J5JywgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0pO1xuXG5jb25zdCBJU09fUkUgPSAvXlxccyooXFxkezR9KSgtPyhcXGR7Mn0pKC0/KFxcZHsyfSkoW1QgXShcXGR7Mn0pOj8oXFxkezJ9KSg6PyhcXGR7Mn0pKFxcLihcXGQrKSk/KT8oWnwoKFstK10pKFxcZHsyfSkoOj8oXFxkezJ9KSk/KSk/KT8pPyk/JC87XG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICBsZXQgbSA9IElTT19SRS5leGVjKHN0cik7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IG5ldyBEYXRlKERhdGUuVVRDKE51bWJlcihtWzFdKSwgbVszXSA/IE51bWJlcihtWzNdKSAtIDEgOiAwLCBOdW1iZXIobVs1XSB8fCAxKSwgTnVtYmVyKG1bN10gfHwgMCksIE51bWJlcihtWzhdIHx8IDApLCBOdW1iZXIobVsxMF0gfHwgMCksIG1bMTJdID8gTnVtYmVyKGAwLiR7bVsxMl19YCkgKiAxMDAwIDogMCkpO1xuICAgICAgICBpZiAoaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgICAgICAgbGV0IHRpbWVab25lT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChtWzEzXSkge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gKG1bMTVdID09PSAnLScgPyAtMSA6IDEpICogKE51bWJlcihtWzE2XSB8fCAwKSAqIDYwICtcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1bMThdIHx8IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgICAgIGlzVGltZVVuc3BlY2lmaWVkOiAhbVs2XSxcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNsYXNzIERhdGVFbnYge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIGxldCB0aW1lWm9uZSA9IHRoaXMudGltZVpvbmUgPSBzZXR0aW5ncy50aW1lWm9uZTtcbiAgICAgICAgbGV0IGlzTmFtZWRUaW1lWm9uZSA9IHRpbWVab25lICE9PSAnbG9jYWwnICYmIHRpbWVab25lICE9PSAnVVRDJztcbiAgICAgICAgaWYgKHNldHRpbmdzLm5hbWVkVGltZVpvbmVJbXBsICYmIGlzTmFtZWRUaW1lWm9uZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbCA9IG5ldyBzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCh0aW1lWm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5Db21wdXRlT2Zmc2V0ID0gQm9vbGVhbighaXNOYW1lZFRpbWVab25lIHx8IHRoaXMubmFtZWRUaW1lWm9uZUltcGwpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtID0gY3JlYXRlQ2FsZW5kYXJTeXN0ZW0oc2V0dGluZ3MuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IHNldHRpbmdzLmxvY2FsZTtcbiAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MubG9jYWxlLndlZWsuZG93O1xuICAgICAgICB0aGlzLndlZWtEb3kgPSBzZXR0aW5ncy5sb2NhbGUud2Vlay5kb3k7XG4gICAgICAgIGlmIChzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtEb3cgPSAxO1xuICAgICAgICAgICAgdGhpcy53ZWVrRG95ID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmZpcnN0RGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MuZmlyc3REYXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla051bWJlckZ1bmMgPSBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53ZWVrVGV4dCA9IHNldHRpbmdzLndlZWtUZXh0ICE9IG51bGwgPyBzZXR0aW5ncy53ZWVrVGV4dCA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0O1xuICAgICAgICB0aGlzLndlZWtUZXh0TG9uZyA9IChzZXR0aW5ncy53ZWVrVGV4dExvbmcgIT0gbnVsbCA/IHNldHRpbmdzLndlZWtUZXh0TG9uZyA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0TG9uZykgfHwgdGhpcy53ZWVrVGV4dDtcbiAgICAgICAgdGhpcy5jbWRGb3JtYXR0ZXIgPSBzZXR0aW5ncy5jbWRGb3JtYXR0ZXI7XG4gICAgICAgIHRoaXMuZGVmYXVsdFNlcGFyYXRvciA9IHNldHRpbmdzLmRlZmF1bHRTZXBhcmF0b3I7XG4gICAgfVxuICAgIC8vIENyZWF0aW5nIC8gUGFyc2luZ1xuICAgIGNyZWF0ZU1hcmtlcihpbnB1dCkge1xuICAgICAgICBsZXQgbWV0YSA9IHRoaXMuY3JlYXRlTWFya2VyTWV0YShpbnB1dCk7XG4gICAgICAgIGlmIChtZXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YS5tYXJrZXI7XG4gICAgfVxuICAgIGNyZWF0ZU5vd01hcmtlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wVG9NYXJrZXIobmV3IERhdGUoKS52YWx1ZU9mKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGNhbid0IGNvbXB1dGUgdGhlIGN1cnJlbnQgZGF0ZSB2YWwgZm9yIGEgdGltZXpvbmUsXG4gICAgICAgIC8vIGJldHRlciB0byBnaXZlIHRoZSBjdXJyZW50IGxvY2FsIGRhdGUgdmFscyB0aGFuIFVUQ1xuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZSgpKSk7XG4gICAgfVxuICAgIGNyZWF0ZU1hcmtlck1ldGEoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFya2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSBhcnJheVRvVXRjRGF0ZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlciA9PT0gbnVsbCB8fCAhaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFya2VyLCBpc1RpbWVVbnNwZWNpZmllZDogZmFsc2UsIGZvcmNlZFR6bzogbnVsbCB9O1xuICAgIH1cbiAgICBwYXJzZShzKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IHBhcnNlKHMpO1xuICAgICAgICBpZiAocGFydHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IG1hcmtlciB9ID0gcGFydHM7XG4gICAgICAgIGxldCBmb3JjZWRUem8gPSBudWxsO1xuICAgICAgICBpZiAocGFydHMudGltZVpvbmVPZmZzZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG1hcmtlci52YWx1ZU9mKCkgLSBwYXJ0cy50aW1lWm9uZU9mZnNldCAqIDYwICogMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRUem8gPSBwYXJ0cy50aW1lWm9uZU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXJrZXIsIGlzVGltZVVuc3BlY2lmaWVkOiBwYXJ0cy5pc1RpbWVVbnNwZWNpZmllZCwgZm9yY2VkVHpvIH07XG4gICAgfVxuICAgIC8vIEFjY2Vzc29yc1xuICAgIGdldFllYXIobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobWFya2VyKTtcbiAgICB9XG4gICAgZ2V0TW9udGgobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG1hcmtlcik7XG4gICAgfVxuICAgIGdldERheShtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIEFkZGluZyAvIFN1YnRyYWN0aW5nXG4gICAgYWRkKG1hcmtlciwgZHVyKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMF0gKz0gZHVyLnllYXJzO1xuICAgICAgICBhWzFdICs9IGR1ci5tb250aHM7XG4gICAgICAgIGFbMl0gKz0gZHVyLmRheXM7XG4gICAgICAgIGFbNl0gKz0gZHVyLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9XG4gICAgc3VidHJhY3QobWFya2VyLCBkdXIpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSAtPSBkdXIueWVhcnM7XG4gICAgICAgIGFbMV0gLT0gZHVyLm1vbnRocztcbiAgICAgICAgYVsyXSAtPSBkdXIuZGF5cztcbiAgICAgICAgYVs2XSAtPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICBhZGRZZWFycyhtYXJrZXIsIG4pIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSArPSBuO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICBhZGRNb250aHMobWFya2VyLCBuKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMV0gKz0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9XG4gICAgLy8gRGlmZmluZyBXaG9sZSBVbml0c1xuICAgIGRpZmZXaG9sZVllYXJzKG0wLCBtMSkge1xuICAgICAgICBsZXQgeyBjYWxlbmRhclN5c3RlbSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHRpbWVBc01zKG0wKSA9PT0gdGltZUFzTXMobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRpZmZXaG9sZU1vbnRocyhtMCwgbTEpIHtcbiAgICAgICAgbGV0IHsgY2FsZW5kYXJTeXN0ZW0gfSA9IHRoaXM7XG4gICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIChjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkpICtcbiAgICAgICAgICAgICAgICAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0wKSkgKiAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gUmFuZ2UgLyBEdXJhdGlvblxuICAgIGdyZWF0ZXN0V2hvbGVVbml0KG0wLCBtMSkge1xuICAgICAgICBsZXQgbiA9IHRoaXMuZGlmZldob2xlWWVhcnMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gdGhpcy5kaWZmV2hvbGVNb250aHMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtb250aCcsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZXaG9sZVdlZWtzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnd2VlaycsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdkYXknLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmSG91cnMobTAsIG0xKTtcbiAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnaG91cicsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZNaW51dGVzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbnV0ZScsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZTZWNvbmRzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbGxpc2Vjb25kJywgdmFsdWU6IG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSB9O1xuICAgIH1cbiAgICBjb3VudER1cmF0aW9uc0JldHdlZW4obTAsIG0xLCBkKSB7XG4gICAgICAgIC8vIFRPRE86IGNhbiB1c2UgZ3JlYXRlc3RXaG9sZVVuaXRcbiAgICAgICAgbGV0IGRpZmY7XG4gICAgICAgIGlmIChkLnllYXJzKSB7XG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hZZWFycyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5tb250aHMpIHtcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hNb250aHMoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuZGF5cykge1xuICAgICAgICAgICAgZGlmZiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoRGF5cyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyBhc1JvdWdoTXMoZCk7XG4gICAgfVxuICAgIC8vIFN0YXJ0LU9mXG4gICAgLy8gdGhlc2UgRE9OJ1QgcmV0dXJuIHpvbmVkLWRhdGVzLiBvbmx5IFVUQyBzdGFydC1vZiBkYXRlc1xuICAgIHN0YXJ0T2YobSwgdW5pdCkge1xuICAgICAgICBpZiAodW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mWWVhcihtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZk1vbnRoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZXZWVrKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZEYXkobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdob3VyJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZIb3VyKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnbWludXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZNaW51dGUobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZlNlY29uZChtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhcnRPZlllYXIobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXJ0T2ZNb250aChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXJ0T2ZXZWVrKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgICAgICAgbS5nZXRVVENEYXRlKCkgLSAoKG0uZ2V0VVRDRGF5KCkgLSB0aGlzLndlZWtEb3cgKyA3KSAlIDcpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLy8gV2VlayBOdW1iZXJcbiAgICBjb21wdXRlV2Vla051bWJlcihtYXJrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMud2Vla051bWJlckZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWtOdW1iZXJGdW5jKHRoaXMudG9EYXRlKG1hcmtlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1hcmtlciwgdGhpcy53ZWVrRG93LCB0aGlzLndlZWtEb3kpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjaG9rZSBvbiB0aW1lWm9uZU5hbWU6IGxvbmdcbiAgICBmb3JtYXQobWFya2VyLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoe1xuICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVPcHRpb25zLmZvcmNlZFR6byAhPSBudWxsID9cbiAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRUem8gOlxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKG1hcmtlciksXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKGRhdGVPcHRpb25zLmlzRW5kRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBlbmQgPSBhZGRNcyhlbmQsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdFJhbmdlKHtcbiAgICAgICAgICAgIG1hcmtlcjogc3RhcnQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gOlxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKHN0YXJ0KSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWFya2VyOiBlbmQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZEVuZFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoZW5kKSxcbiAgICAgICAgfSwgdGhpcywgZGF0ZU9wdGlvbnMuZGVmYXVsdFNlcGFyYXRvcik7XG4gICAgfVxuICAgIC8qXG4gICAgRFVNQjogdGhlIG9taXRUaW1lIGFyZyBpcyBkdW1iLiBpZiB3ZSBvbWl0IHRoZSB0aW1lLCB3ZSB3YW50IHRvIG9taXQgdGhlIHRpbWV6b25lIG9mZnNldC4gYW5kIGlmIHdlIGRvIHRoYXQsXG4gICAgbWlnaHQgYXMgd2VsbCB1c2UgYnVpbGRJc29TdHJpbmcgb3Igc29tZSBvdGhlciB1dGlsIGRpcmVjdGx5XG4gICAgKi9cbiAgICBmb3JtYXRJc28obWFya2VyLCBleHRyYU9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgdGltZVpvbmVPZmZzZXQgPSBudWxsO1xuICAgICAgICBpZiAoIWV4dHJhT3B0aW9ucy5vbWl0VGltZVpvbmVPZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChleHRyYU9wdGlvbnMuZm9yY2VkVHpvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IGV4dHJhT3B0aW9ucy5mb3JjZWRUem87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IHRoaXMub2Zmc2V0Rm9yTWFya2VyKG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIGV4dHJhT3B0aW9ucy5vbWl0VGltZSk7XG4gICAgfVxuICAgIC8vIFRpbWVab25lXG4gICAgdGltZXN0YW1wVG9NYXJrZXIobXMpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShkYXRlVG9Mb2NhbEFycmF5KG5ldyBEYXRlKG1zKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJyB8fCAhdGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUodGhpcy5uYW1lZFRpbWVab25lSW1wbC50aW1lc3RhbXBUb0FycmF5KG1zKSk7XG4gICAgfVxuICAgIG9mZnNldEZvck1hcmtlcihtKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gLWFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpLmdldFRpbWV6b25lT2Zmc2V0KCk7IC8vIGNvbnZlcnQgXCJpbnZlcnNlXCIgb2Zmc2V0IHRvIFwibm9ybWFsXCIgb2Zmc2V0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZWRUaW1lWm9uZUltcGwub2Zmc2V0Rm9yQXJyYXkoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDb252ZXJzaW9uXG4gICAgdG9EYXRlKG0sIGZvcmNlZFR6bykge1xuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG0udmFsdWVPZigpKTsgLy8gbWFrZSBzdXJlIGl0J3MgYSBjb3B5XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLSAoZm9yY2VkVHpvIHx8IDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLVxuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbC5vZmZzZXRGb3JBcnJheShkYXRlVG9VdGNBcnJheShtKSkgKiAxMDAwICogNjApO1xuICAgIH1cbn1cblxuY2xhc3MgVGhlbWUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SWNvbk92ZXJyaWRlKGNhbGVuZGFyT3B0aW9uc1t0aGlzLmljb25PdmVycmlkZU9wdGlvbl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEljb25PdmVycmlkZShpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgIGxldCBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIGxldCBidXR0b25OYW1lO1xuICAgICAgICBpZiAodHlwZW9mIGljb25PdmVycmlkZUhhc2ggPT09ICdvYmplY3QnICYmIGljb25PdmVycmlkZUhhc2gpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHkgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmljb25DbGFzc2VzKTtcbiAgICAgICAgICAgIGZvciAoYnV0dG9uTmFtZSBpbiBpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5W2J1dHRvbk5hbWVdID0gdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChpY29uT3ZlcnJpZGVIYXNoW2J1dHRvbk5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaWNvbkNsYXNzZXMgPSBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWNvbk92ZXJyaWRlSGFzaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuaWNvbkNsYXNzZXMgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IHRoaXMuaWNvbk92ZXJyaWRlUHJlZml4O1xuICAgICAgICBpZiAocHJlZml4ICYmIGNsYXNzTmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHsgLy8gaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfVxuICAgIGdldENsYXNzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzW2tleV0gfHwgJyc7XG4gICAgfVxuICAgIGdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkge1xuICAgICAgICBsZXQgY2xhc3NOYW1lO1xuICAgICAgICBpZiAoaXNSdGwgJiYgdGhpcy5ydGxJY29uQ2xhc3Nlcykge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gdGhpcy5ydGxJY29uQ2xhc3Nlc1tidXR0b25OYW1lXSB8fCB0aGlzLmljb25DbGFzc2VzW2J1dHRvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlSWNvbkNsYXNzfSAke2NsYXNzTmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWU7XG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbikge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gY3VzdG9tQnV0dG9uUHJvcHNbdGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb25dO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VJY29uQ2xhc3N9ICR7dGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cblRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge307XG5UaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7fTtcblRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJyc7XG5UaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJyc7XG5cbi8qXG5OT1RFOiB0aGlzIGNhbiBiZSBhIHB1YmxpYyBBUEksIGVzcGVjaWFsbHkgY3JlYXRlRWxlbWVudCBmb3IgaG9va3MuXG5TZWUgZXhhbXBsZXMvdHlwZXNjcmlwdC1zY2hlZHVsZXIvc3JjL2luZGV4LnRzXG4qL1xuZnVuY3Rpb24gZmx1c2hTeW5jKHJ1bkJlZm9yZUZsdXNoKSB7XG4gICAgcnVuQmVmb3JlRmx1c2goKTtcbiAgICBsZXQgb2xkRGVib3VuY2VSZW5kZXJpbmcgPSBwcmVhY3Qub3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZzsgLy8gb3JpZ1xuICAgIGxldCBjYWxsYmFja1EgPSBbXTtcbiAgICBmdW5jdGlvbiBleGVjQ2FsbGJhY2tTeW5jKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrUS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBleGVjQ2FsbGJhY2tTeW5jO1xuICAgIHByZWFjdC5yZW5kZXIocHJlYWN0LmNyZWF0ZUVsZW1lbnQoRmFrZUNvbXBvbmVudCwge30pLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgd2hpbGUgKGNhbGxiYWNrUS5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2tRLnNoaWZ0KCkoKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBvbGREZWJvdW5jZVJlbmRlcmluZztcbn1cbmNsYXNzIEZha2VDb21wb25lbnQgZXh0ZW5kcyBwcmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7IHJldHVybiBwcmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge30pOyB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7IHRoaXMuc2V0U3RhdGUoe30pOyB9XG59XG4vLyBUT0RPOiB1c2UgcHJlYWN0L2NvbXBhdCBpbnN0ZWFkP1xuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpIHtcbiAgICBsZXQgQ29udGV4dFR5cGUgPSBwcmVhY3QuY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpO1xuICAgIGxldCBvcmlnUHJvdmlkZXIgPSBDb250ZXh0VHlwZS5Qcm92aWRlcjtcbiAgICBDb250ZXh0VHlwZS5Qcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IGlzTmV3ID0gIXRoaXMuZ2V0Q2hpbGRDb250ZXh0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBvcmlnUHJvdmlkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgICBsZXQgc3VicyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSAoX3Byb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3ViID0gKGMpID0+IHtcbiAgICAgICAgICAgICAgICBzdWJzLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgbGV0IG9sZCA9IGMuY29tcG9uZW50V2lsbFVubW91bnQ7XG4gICAgICAgICAgICAgICAgYy5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkICYmIG9sZC5jYWxsKGMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0VHlwZTtcbn1cblxuY2xhc3MgU2Nyb2xsUmVzcG9uZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihleGVjRnVuYywgZW1pdHRlciwgc2Nyb2xsVGltZSwgc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgIHRoaXMuZXhlY0Z1bmMgPSBleGVjRnVuYztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lID0gc2Nyb2xsVGltZTtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lUmVzZXQgPSBzY3JvbGxUaW1lUmVzZXQ7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZFJlcXVlc3QgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnF1ZXVlZFJlcXVlc3QgfHwge30sIHJlcXVlc3QpO1xuICAgICAgICAgICAgdGhpcy5kcmFpbigpO1xuICAgICAgICB9O1xuICAgICAgICBlbWl0dGVyLm9uKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgICAgIHRoaXMuZmlyZUluaXRpYWxTY3JvbGwoKTtcbiAgICB9XG4gICAgZGV0YWNoKCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIub2ZmKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgfVxuICAgIHVwZGF0ZShpc0RhdGVzTmV3KSB7XG4gICAgICAgIGlmIChpc0RhdGVzTmV3ICYmIHRoaXMuc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKCk7IC8vIHdpbGwgZHJhaW5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaXJlSW5pdGlhbFNjcm9sbCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KHtcbiAgICAgICAgICAgIHRpbWU6IHRoaXMuc2Nyb2xsVGltZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWRSZXF1ZXN0ICYmIHRoaXMuZXhlY0Z1bmModGhpcy5xdWV1ZWRSZXF1ZXN0KSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgVmlld0NvbnRleHRUeXBlID0gY3JlYXRlQ29udGV4dCh7fSk7IC8vIGZvciBDb21wb25lbnRzXG5mdW5jdGlvbiBidWlsZFZpZXdDb250ZXh0KHZpZXdTcGVjLCB2aWV3QXBpLCB2aWV3T3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGRhdGVFbnYsIHRoZW1lLCBwbHVnaW5Ib29rcywgZGlzcGF0Y2gsIGdldEN1cnJlbnREYXRhLCBlbWl0dGVyLCBjYWxlbmRhckFwaSwgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZUVudixcbiAgICAgICAgb3B0aW9uczogdmlld09wdGlvbnMsXG4gICAgICAgIHBsdWdpbkhvb2tzLFxuICAgICAgICBlbWl0dGVyLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIGNhbGVuZGFyQXBpLFxuICAgICAgICB2aWV3U3BlYyxcbiAgICAgICAgdmlld0FwaSxcbiAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICAgIHRoZW1lLFxuICAgICAgICBpc1J0bDogdmlld09wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJyxcbiAgICAgICAgYWRkUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9uKCdfcmVzaXplJywgaGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICAgICAgZW1pdHRlci5vZmYoJ19yZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlU2Nyb2xsUmVzcG9uZGVyKGV4ZWNGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjcm9sbFJlc3BvbmRlcihleGVjRnVuYywgZW1pdHRlciwgY3JlYXRlRHVyYXRpb24odmlld09wdGlvbnMuc2Nyb2xsVGltZSksIHZpZXdPcHRpb25zLnNjcm9sbFRpbWVSZXNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXG4gICAgICAgIHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCxcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IG9mZiAqL1xuY2xhc3MgUHVyZUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2coZ2V0VW5lcXVhbFByb3BzKG5leHRQcm9wcywgdGhpcy5wcm9wcyksIGdldFVuZXF1YWxQcm9wcyhuZXh0U3RhdGUsIHRoaXMuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWNvbXBhcmVPYmpzKHRoaXMucHJvcHMsIG5leHRQcm9wcywgdGhpcy5wcm9wRXF1YWxpdHkpIHx8XG4gICAgICAgICAgICAhY29tcGFyZU9ianModGhpcy5zdGF0ZSwgbmV4dFN0YXRlLCB0aGlzLnN0YXRlRXF1YWxpdHkpO1xuICAgIH1cbiAgICAvLyBIQUNLIGZvciBmcmVha2luJyBSZWFjdCBTdHJpY3RNb2RlXG4gICAgc2FmZVNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICghY29tcGFyZU9ianModGhpcy5zdGF0ZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlKSwgbmV3U3RhdGUpLCB0aGlzLnN0YXRlRXF1YWxpdHkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblB1cmVDb21wb25lbnQuYWRkUHJvcHNFcXVhbGl0eSA9IGFkZFByb3BzRXF1YWxpdHk7XG5QdXJlQ29tcG9uZW50LmFkZFN0YXRlRXF1YWxpdHkgPSBhZGRTdGF0ZUVxdWFsaXR5O1xuUHVyZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IHt9O1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IHt9O1xuY2xhc3MgQmFzZUNvbXBvbmVudCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xufVxuQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbmZ1bmN0aW9uIGFkZFByb3BzRXF1YWxpdHkocHJvcEVxdWFsaXR5KSB7XG4gICAgbGV0IGhhc2ggPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoLCBwcm9wRXF1YWxpdHkpO1xuICAgIHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IGhhc2g7XG59XG5mdW5jdGlvbiBhZGRTdGF0ZUVxdWFsaXR5KHN0YXRlRXF1YWxpdHkpIHtcbiAgICBsZXQgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoLCBzdGF0ZUVxdWFsaXR5KTtcbiAgICB0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5ID0gaGFzaDtcbn1cbi8vIHVzZSBvdGhlciBvbmVcbmZ1bmN0aW9uIHNldFJlZihyZWYsIGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYoY3VycmVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzAyOVxuICAgICAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgfVxufVxuXG5jbGFzcyBDb250ZW50SW5qZWN0b3IgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5xdWV1ZWREb21Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnREb21Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2VuZXJhdG9yTmFtZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5jdXN0b21SZW5kZXJpbmdSZXBsYWNlcyB8fCAhaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcihnZW5lcmF0b3JOYW1lLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxSZWYoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUVsUmVmID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5lbFJlZikge1xuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCB7IGN1c3RvbUdlbmVyYXRvciwgZGVmYXVsdEdlbmVyYXRvciwgcmVuZGVyUHJvcHMgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBhdHRycyA9IGJ1aWxkRWxBdHRycyhwcm9wcywgW10sIHRoaXMuaGFuZGxlRWwpO1xuICAgICAgICBsZXQgdXNlRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICBsZXQgaW5uZXJDb250ZW50O1xuICAgICAgICBsZXQgcXVldWVkRG9tTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xuICAgICAgICBpZiAoY3VzdG9tR2VuZXJhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUdlbmVyYXRvclJlcyA9IHR5cGVvZiBjdXN0b21HZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcihyZW5kZXJQcm9wcywgY3JlYXRlRWxlbWVudCkgOlxuICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcjtcbiAgICAgICAgICAgIGlmIChjdXN0b21HZW5lcmF0b3JSZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB1c2VEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gY3VzdG9tR2VuZXJhdG9yUmVzICYmIHR5cGVvZiBjdXN0b21HZW5lcmF0b3JSZXMgPT09ICdvYmplY3QnOyAvLyBub24tbnVsbFxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCAmJiAoJ2h0bWwnIGluIGN1c3RvbUdlbmVyYXRvclJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7IF9faHRtbDogY3VzdG9tR2VuZXJhdG9yUmVzLmh0bWwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QgJiYgKCdkb21Ob2RlcycgaW4gY3VzdG9tR2VuZXJhdG9yUmVzKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZWREb21Ob2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1c3RvbUdlbmVyYXRvclJlcy5kb21Ob2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgID8gaXNWYWxpZEVsZW1lbnQoY3VzdG9tR2VuZXJhdG9yUmVzKSAvLyB2ZG9tIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgY3VzdG9tR2VuZXJhdG9yUmVzICE9PSAnZnVuY3Rpb24nIC8vIHByaW1pdGl2ZSB2YWx1ZSAobGlrZSBzdHJpbmcgb3IgbnVtYmVyKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgaW4gdmRvbVxuICAgICAgICAgICAgICAgICAgICBpbm5lckNvbnRlbnQgPSBjdXN0b21HZW5lcmF0b3JSZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBleG90aWMgb2JqZWN0IGZvciBoYW5kbGVDdXN0b21SZW5kZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdlbmVyYXRvck1ldGEgPSBjdXN0b21HZW5lcmF0b3JSZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlRGVmYXVsdCA9ICFoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyKHByb3BzLmdlbmVyYXRvck5hbWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VEZWZhdWx0ICYmIGRlZmF1bHRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlubmVyQ29udGVudCA9IGRlZmF1bHRHZW5lcmF0b3IocmVuZGVyUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVldWVkRG9tTm9kZXMgPSBxdWV1ZWREb21Ob2RlcztcbiAgICAgICAgdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSA9IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChwcm9wcy5lbFRhZywgYXR0cnMsIGlubmVyQ29udGVudCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyhmYWxzZSk7IC8vIFRPRE86IGRpZmZlcmVudCBBUEkgZm9yIHJlbW92YWw/XG4gICAgfVxuICAgIHRyaWdnZXJDdXN0b21SZW5kZXJpbmcoaXNBY3RpdmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGhhbmRsZUN1c3RvbVJlbmRlcmluZywgY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICBpZiAoaGFuZGxlQ3VzdG9tUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0b3JNZXRhID0gKF9hID0gdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCA9PT0gbnVsbCB8fCBjdXN0b21SZW5kZXJpbmdNZXRhTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21SZW5kZXJpbmdNZXRhTWFwW3Byb3BzLmdlbmVyYXRvck5hbWVdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRvck1ldGEpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVDdXN0b21SZW5kZXJpbmcoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgaWQ6IHRoaXMuaWQsIGlzQWN0aXZlLCBjb250YWluZXJFbDogdGhpcy5iYXNlLCByZXBvcnROZXdDb250YWluZXJFbDogdGhpcy51cGRhdGVFbFJlZiwgLy8gZnJvbnQtZW5kIGZyYW1ld29yayB0ZWxscyB1cyBhYm91dCBuZXcgY29udGFpbmVyIGVsc1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0b3JNZXRhIH0sIHByb3BzKSwgeyBlbENsYXNzZXM6IChwcm9wcy5lbENsYXNzZXMgfHwgW10pLmZpbHRlcihpc1RydXRoeSkgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5UXVldWV1ZERvbU5vZGVzKCkge1xuICAgICAgICBjb25zdCB7IHF1ZXVlZERvbU5vZGVzLCBjdXJyZW50RG9tTm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5iYXNlO1xuICAgICAgICBpZiAoIWlzQXJyYXlzRXF1YWwocXVldWVkRG9tTm9kZXMsIGN1cnJlbnREb21Ob2RlcykpIHtcbiAgICAgICAgICAgIGN1cnJlbnREb21Ob2Rlcy5mb3JFYWNoKHJlbW92ZUVsZW1lbnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgbmV3Tm9kZSBvZiBxdWV1ZWREb21Ob2Rlcykge1xuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RG9tTm9kZXMgPSBxdWV1ZWREb21Ob2RlcztcbiAgICAgICAgfVxuICAgIH1cbn1cbkNvbnRlbnRJbmplY3Rvci5hZGRQcm9wc0VxdWFsaXR5KHtcbiAgICBlbENsYXNzZXM6IGlzQXJyYXlzRXF1YWwsXG4gICAgZWxTdHlsZTogaXNQcm9wc0VxdWFsLFxuICAgIGVsQXR0cnM6IGlzTm9uSGFuZGxlclByb3BzRXF1YWwsXG4gICAgcmVuZGVyUHJvcHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuLy8gVXRpbFxuLypcbkRvZXMgVUktZnJhbWV3b3JrIHByb3ZpZGUgY3VzdG9tIHdheSBvZiByZW5kZXJpbmcgdGhhdCBkb2VzIG5vdCB1c2UgUHJlYWN0IFZET01cbkFORCBkb2VzIHRoZSBjYWxlbmRhcidzIG9wdGlvbnMgZGVmaW5lIGN1c3RvbSByZW5kZXJpbmc/XG5BS0EuIFNob3VsZCB3ZSBOT1QgcmVuZGVyIHRoZSBkZWZhdWx0IGNvbnRlbnQ/XG4qL1xuZnVuY3Rpb24gaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcihnZW5lcmF0b3JOYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBCb29sZWFuKG9wdGlvbnMuaGFuZGxlQ3VzdG9tUmVuZGVyaW5nICYmXG4gICAgICAgIGdlbmVyYXRvck5hbWUgJiZcbiAgICAgICAgKChfYSA9IG9wdGlvbnMuY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2dlbmVyYXRvck5hbWVdKSk7XG59XG5mdW5jdGlvbiBidWlsZEVsQXR0cnMocHJvcHMsIGV4dHJhQ2xhc3NOYW1lcywgZWxSZWYpIHtcbiAgICBjb25zdCBhdHRycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZWxBdHRycyksIHsgcmVmOiBlbFJlZiB9KTtcbiAgICBpZiAocHJvcHMuZWxDbGFzc2VzIHx8IGV4dHJhQ2xhc3NOYW1lcykge1xuICAgICAgICBhdHRycy5jbGFzc05hbWUgPSAocHJvcHMuZWxDbGFzc2VzIHx8IFtdKVxuICAgICAgICAgICAgLmNvbmNhdChleHRyYUNsYXNzTmFtZXMgfHwgW10pXG4gICAgICAgICAgICAuY29uY2F0KGF0dHJzLmNsYXNzTmFtZSB8fCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5lbFN0eWxlKSB7XG4gICAgICAgIGF0dHJzLnN0eWxlID0gcHJvcHMuZWxTdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xufVxuZnVuY3Rpb24gaXNUcnV0aHkodmFsKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsKTtcbn1cblxuY29uc3QgUmVuZGVySWQgPSBjcmVhdGVDb250ZXh0KDApO1xuXG5jbGFzcyBDb250ZW50Q29udGFpbmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5Jbm5lckNvbnRlbnQgPSBJbm5lckNvbnRlbnRJbmplY3Rvci5iaW5kKHVuZGVmaW5lZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgdGhpcy5kaWRNb3VudE1pc2ZpcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWRDbGFzc05hbWVzID0gZ2VuZXJhdGVDbGFzc05hbWVzKHByb3BzLmNsYXNzTmFtZUdlbmVyYXRvciwgcHJvcHMucmVuZGVyUHJvcHMpO1xuICAgICAgICBpZiAocHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGVsQXR0cnMgPSBidWlsZEVsQXR0cnMocHJvcHMsIGdlbmVyYXRlZENsYXNzTmFtZXMsIHRoaXMuaGFuZGxlRWwpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbih0aGlzLklubmVyQ29udGVudCwgcHJvcHMucmVuZGVyUHJvcHMsIGVsQXR0cnMpO1xuICAgICAgICAgICAgaWYgKHByb3BzLmVsVGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQocHJvcHMuZWxUYWcsIGVsQXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KChDb250ZW50SW5qZWN0b3IpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyBlbFJlZjogdGhpcy5oYW5kbGVFbCwgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdkaXYnLCBlbENsYXNzZXM6IChwcm9wcy5lbENsYXNzZXMgfHwgW10pLmNvbmNhdChnZW5lcmF0ZWRDbGFzc05hbWVzKSwgcmVuZGVySWQ6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmVsKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS5kaWRNb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMuZWwgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaWRNb3VudE1pc2ZpcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS53aWxsVW5tb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMuZWwgfSkpO1xuICAgIH1cbn1cbkNvbnRlbnRDb250YWluZXIuY29udGV4dFR5cGUgPSBSZW5kZXJJZDtcbmZ1bmN0aW9uIElubmVyQ29udGVudEluamVjdG9yKGNvbnRhaW5lckNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICBjb25zdCBwYXJlbnRQcm9wcyA9IGNvbnRhaW5lckNvbXBvbmVudC5wcm9wcztcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgoQ29udGVudEluamVjdG9yKSwgT2JqZWN0LmFzc2lnbih7IHJlbmRlclByb3BzOiBwYXJlbnRQcm9wcy5yZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogcGFyZW50UHJvcHMuZ2VuZXJhdG9yTmFtZSwgY3VzdG9tR2VuZXJhdG9yOiBwYXJlbnRQcm9wcy5jdXN0b21HZW5lcmF0b3IsIGRlZmF1bHRHZW5lcmF0b3I6IHBhcmVudFByb3BzLmRlZmF1bHRHZW5lcmF0b3IsIHJlbmRlcklkOiBjb250YWluZXJDb21wb25lbnQuY29udGV4dCB9LCBwcm9wcykpO1xufVxuLy8gVXRpbHNcbmZ1bmN0aW9uIGdlbmVyYXRlQ2xhc3NOYW1lcyhjbGFzc05hbWVHZW5lcmF0b3IsIHJlbmRlclByb3BzKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IHR5cGVvZiBjbGFzc05hbWVHZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBjbGFzc05hbWVHZW5lcmF0b3IocmVuZGVyUHJvcHMpIDpcbiAgICAgICAgY2xhc3NOYW1lR2VuZXJhdG9yIHx8IFtdO1xuICAgIHJldHVybiB0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ3N0cmluZycgPyBbY2xhc3NOYW1lc10gOiBjbGFzc05hbWVzO1xufVxuXG5jbGFzcyBWaWV3Q29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0geyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnZGl2JywgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgLi4uYnVpbGRWaWV3Q2xhc3NOYW1lcyhwcm9wcy52aWV3U3BlYyksXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICBdLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy52aWV3Q2xhc3NOYW1lcywgZ2VuZXJhdG9yTmFtZTogdW5kZWZpbmVkLCBkaWRNb3VudDogb3B0aW9ucy52aWV3RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnZpZXdXaWxsVW5tb3VudCB9KSwgKCkgPT4gcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFZpZXdDbGFzc05hbWVzKHZpZXdTcGVjKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYGZjLSR7dmlld1NwZWMudHlwZX0tdmlld2AsXG4gICAgICAgICdmYy12aWV3JyxcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJhbmdlKGlucHV0LCBkYXRlRW52KSB7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICBsZXQgZW5kID0gbnVsbDtcbiAgICBpZiAoaW5wdXQuc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5zdGFydCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5lbmQpIHtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5wdXQuZW5kKTtcbiAgICB9XG4gICAgaWYgKCFzdGFydCAmJiAhZW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgJiYgZW5kICYmIGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG4vLyBTSURFLUVGRkVDVDogd2lsbCBtdXRhdGUgcmFuZ2VzLlxuLy8gV2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgcmVzdWx0LlxuZnVuY3Rpb24gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgY29uc3RyYWludFJhbmdlKSB7XG4gICAgbGV0IGludmVydGVkUmFuZ2VzID0gW107XG4gICAgbGV0IHsgc3RhcnQgfSA9IGNvbnN0cmFpbnRSYW5nZTsgLy8gdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgcmFuZ2UuIHRoZSBzdGFydCBvZiB0aGUgbmV3IHJhbmdlXG4gICAgbGV0IGk7XG4gICAgbGV0IGRhdGVSYW5nZTtcbiAgICAvLyByYW5nZXMgbmVlZCB0byBiZSBpbiBvcmRlci4gcmVxdWlyZWQgZm9yIG91ciBkYXRlLXdhbGtpbmcgYWxnb3JpdGhtXG4gICAgcmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcyk7XG4gICAgZm9yIChpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBkYXRlUmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGJlZm9yZSB0aGUgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcbiAgICAgICAgaWYgKGRhdGVSYW5nZS5zdGFydCA+IHN0YXJ0KSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG4gICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQsIGVuZDogZGF0ZVJhbmdlLnN0YXJ0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlUmFuZ2UuZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZVJhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBhZnRlciB0aGUgbGFzdCBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgIGlmIChzdGFydCA8IGNvbnN0cmFpbnRSYW5nZS5lbmQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgICAgaW52ZXJ0ZWRSYW5nZXMucHVzaCh7IHN0YXJ0LCBlbmQ6IGNvbnN0cmFpbnRSYW5nZS5lbmQgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbnZlcnRlZFJhbmdlcztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVSYW5nZXMocmFuZ2UwLCByYW5nZTEpIHtcbiAgICByZXR1cm4gcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSAtIHJhbmdlMS5zdGFydC52YWx1ZU9mKCk7IC8vIGVhcmxpZXIgcmFuZ2VzIGdvIGZpcnN0XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RSYW5nZXMocmFuZ2UwLCByYW5nZTEpIHtcbiAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSByYW5nZTA7XG4gICAgbGV0IG5ld1JhbmdlID0gbnVsbDtcbiAgICBpZiAocmFuZ2UxLnN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQgPSByYW5nZTEuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IG5ldyBEYXRlKE1hdGgubWF4KHN0YXJ0LnZhbHVlT2YoKSwgcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyYW5nZTEuZW5kICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gcmFuZ2UxLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZCA9IG5ldyBEYXRlKE1hdGgubWluKGVuZC52YWx1ZU9mKCksIHJhbmdlMS5lbmQudmFsdWVPZigpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCB8fCBzdGFydCA8IGVuZCkge1xuICAgICAgICBuZXdSYW5nZSA9IHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICByZXR1cm4gbmV3UmFuZ2U7XG59XG5mdW5jdGlvbiByYW5nZXNFcXVhbChyYW5nZTAsIHJhbmdlMSkge1xuICAgIHJldHVybiAocmFuZ2UwLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5zdGFydC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5zdGFydC52YWx1ZU9mKCkpICYmXG4gICAgICAgIChyYW5nZTAuZW5kID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5lbmQudmFsdWVPZigpKSA9PT0gKHJhbmdlMS5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UxLmVuZC52YWx1ZU9mKCkpO1xufVxuZnVuY3Rpb24gcmFuZ2VzSW50ZXJzZWN0KHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgcmV0dXJuIChyYW5nZTAuZW5kID09PSBudWxsIHx8IHJhbmdlMS5zdGFydCA9PT0gbnVsbCB8fCByYW5nZTAuZW5kID4gcmFuZ2UxLnN0YXJ0KSAmJlxuICAgICAgICAocmFuZ2UwLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMS5lbmQgPT09IG51bGwgfHwgcmFuZ2UwLnN0YXJ0IDwgcmFuZ2UxLmVuZCk7XG59XG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZSwgaW5uZXJSYW5nZSkge1xuICAgIHJldHVybiAob3V0ZXJSYW5nZS5zdGFydCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5zdGFydCAhPT0gbnVsbCAmJiBpbm5lclJhbmdlLnN0YXJ0ID49IG91dGVyUmFuZ2Uuc3RhcnQpKSAmJlxuICAgICAgICAob3V0ZXJSYW5nZS5lbmQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2UuZW5kICE9PSBudWxsICYmIGlubmVyUmFuZ2UuZW5kIDw9IG91dGVyUmFuZ2UuZW5kKSk7XG59XG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zTWFya2VyKHJhbmdlLCBkYXRlKSB7XG4gICAgcmV0dXJuIChyYW5nZS5zdGFydCA9PT0gbnVsbCB8fCBkYXRlID49IHJhbmdlLnN0YXJ0KSAmJlxuICAgICAgICAocmFuZ2UuZW5kID09PSBudWxsIHx8IGRhdGUgPCByYW5nZS5lbmQpO1xufVxuLy8gSWYgdGhlIGdpdmVuIGRhdGUgaXMgbm90IHdpdGhpbiB0aGUgZ2l2ZW4gcmFuZ2UsIG1vdmUgaXQgaW5zaWRlLlxuLy8gKElmIGl0J3MgcGFzdCB0aGUgZW5kLCBtYWtlIGl0IG9uZSBtaWxsaXNlY29uZCBiZWZvcmUgdGhlIGVuZCkuXG5mdW5jdGlvbiBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGRhdGUsIHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwgJiYgZGF0ZSA8IHJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiByYW5nZS5zdGFydDtcbiAgICB9XG4gICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsICYmIGRhdGUgPj0gcmFuZ2UuZW5kKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShyYW5nZS5lbmQudmFsdWVPZigpIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuXG4vKiBEYXRlIHN0dWZmIHRoYXQgZG9lc24ndCBiZWxvbmcgaW4gZGF0ZWxpYiBjb3JlXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgZXhhY3QgZHVyYXRpb24sXG4vLyBidXQgd2hvc2Ugc3RhcnQgdGltZSBpcyBhbGlnbmVkIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBkYXkuXG5mdW5jdGlvbiBjb21wdXRlQWxpZ25lZERheVJhbmdlKHRpbWVkUmFuZ2UpIHtcbiAgICBsZXQgZGF5Q250ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aW1lZFJhbmdlLnN0YXJ0LCB0aW1lZFJhbmdlLmVuZCkpIHx8IDE7XG4gICAgbGV0IHN0YXJ0ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLnN0YXJ0KTtcbiAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgZGF5Q250KTtcbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG4vLyBnaXZlbiBhIHRpbWVkIHJhbmdlLCBjb21wdXRlcyBhbiBhbGwtZGF5IHJhbmdlIGJhc2VkIG9uIGhvdyBmb3IgdGhlIGVuZCBkYXRlIGJsZWVkcyBpbnRvIHRoZSBuZXh0IGRheVxuLy8gVE9ETzogZ2l2ZSBuZXh0RGF5VGhyZXNob2xkIGEgZGVmYXVsdCBhcmdcbmZ1bmN0aW9uIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UodGltZWRSYW5nZSwgbmV4dERheVRocmVzaG9sZCA9IGNyZWF0ZUR1cmF0aW9uKDApKSB7XG4gICAgbGV0IHN0YXJ0RGF5ID0gbnVsbDtcbiAgICBsZXQgZW5kRGF5ID0gbnVsbDtcbiAgICBpZiAodGltZWRSYW5nZS5lbmQpIHtcbiAgICAgICAgZW5kRGF5ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLmVuZCk7XG4gICAgICAgIGxldCBlbmRUaW1lTVMgPSB0aW1lZFJhbmdlLmVuZC52YWx1ZU9mKCkgLSBlbmREYXkudmFsdWVPZigpOyAvLyAjIG9mIG1pbGxpc2Vjb25kcyBpbnRvIGBlbmREYXlgXG4gICAgICAgIC8vIElmIHRoZSBlbmQgdGltZSBpcyBhY3R1YWxseSBpbmNsdXNpdmVseSBwYXJ0IG9mIHRoZSBuZXh0IGRheSBhbmQgaXMgZXF1YWwgdG8gb3JcbiAgICAgICAgLy8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cbiAgICAgICAgaWYgKGVuZFRpbWVNUyAmJiBlbmRUaW1lTVMgPj0gYXNSb3VnaE1zKG5leHREYXlUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKGVuZERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVkUmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgc3RhcnREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIHN0YXJ0c1xuICAgICAgICAvLyBJZiBlbmQgaXMgd2l0aGluIGBzdGFydERheWAgYnV0IG5vdCBwYXN0IG5leHREYXlUaHJlc2hvbGQsIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxuICAgICAgICBpZiAoZW5kRGF5ICYmIGVuZERheSA8PSBzdGFydERheSkge1xuICAgICAgICAgICAgZW5kRGF5ID0gYWRkRGF5cyhzdGFydERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0RGF5LCBlbmQ6IGVuZERheSB9O1xufVxuLy8gc3BhbnMgZnJvbSBvbmUgZGF5IGludG8gYW5vdGhlcj9cbmZ1bmN0aW9uIGlzTXVsdGlEYXlSYW5nZShyYW5nZSkge1xuICAgIGxldCB2aXNpYmxlUmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcbiAgICByZXR1cm4gZGlmZkRheXModmlzaWJsZVJhbmdlLnN0YXJ0LCB2aXNpYmxlUmFuZ2UuZW5kKSA+IDE7XG59XG5mdW5jdGlvbiBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBsYXJnZVVuaXQpIHtcbiAgICBpZiAobGFyZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKGRhdGVFbnYuZGlmZldob2xlWWVhcnMoZGF0ZTAsIGRhdGUxKSwgJ3llYXInKTtcbiAgICB9XG4gICAgaWYgKGxhcmdlVW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVNb250aHMoZGF0ZTAsIGRhdGUxKSwgJ21vbnRoJyk7XG4gICAgfVxuICAgIHJldHVybiBkaWZmRGF5QW5kVGltZShkYXRlMCwgZGF0ZTEpOyAvLyByZXR1cm5zIGEgZHVyYXRpb25cbn1cblxuZnVuY3Rpb24gcmVkdWNlQ3VycmVudERhdGUoY3VycmVudERhdGUsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5kYXRlTWFya2VyO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEluaXRpYWxEYXRlKG9wdGlvbnMsIGRhdGVFbnYpIHtcbiAgICBsZXQgaW5pdGlhbERhdGVJbnB1dCA9IG9wdGlvbnMuaW5pdGlhbERhdGU7XG4gICAgLy8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXG4gICAgaWYgKGluaXRpYWxEYXRlSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5pdGlhbERhdGVJbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBnZXROb3cob3B0aW9ucy5ub3csIGRhdGVFbnYpOyAvLyBnZXROb3cgYWxyZWFkeSByZXR1cm5zIHVuem9uZWRcbn1cbmZ1bmN0aW9uIGdldE5vdyhub3dJbnB1dCwgZGF0ZUVudikge1xuICAgIGlmICh0eXBlb2Ygbm93SW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbm93SW5wdXQgPSBub3dJbnB1dCgpO1xuICAgIH1cbiAgICBpZiAobm93SW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVOb3dNYXJrZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTWFya2VyKG5vd0lucHV0KTtcbn1cblxuY2xhc3MgRGF0ZVByb2ZpbGVHZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5ub3dEYXRlID0gZ2V0Tm93KHByb3BzLm5vd0lucHV0LCBwcm9wcy5kYXRlRW52KTtcbiAgICAgICAgdGhpcy5pbml0SGlkZGVuRGF5cygpO1xuICAgIH1cbiAgICAvKiBEYXRlIFJhbmdlIENvbXB1dGF0aW9uXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cbiAgICBidWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBwcmV2RGF0ZSA9IGRhdGVFbnYuc3VidHJhY3QoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChwcmV2RGF0ZSwgLTEsIGZvcmNlVG9WYWxpZCk7XG4gICAgfVxuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxuICAgIGJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IG5leHREYXRlID0gZGF0ZUVudi5hZGQoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChuZXh0RGF0ZSwgMSwgZm9yY2VUb1ZhbGlkKTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxuICAgIC8vIE9wdGlvbmFsIGRpcmVjdGlvbiBwYXJhbSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZGF0ZSBpcyBiZWluZyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZFxuICAgIC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxuICAgIGJ1aWxkKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCA9IHRydWUpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB2YWxpZFJhbmdlO1xuICAgICAgICBsZXQgY3VycmVudEluZm87XG4gICAgICAgIGxldCBpc1JhbmdlQWxsRGF5O1xuICAgICAgICBsZXQgcmVuZGVyUmFuZ2U7XG4gICAgICAgIGxldCBhY3RpdmVSYW5nZTtcbiAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgIHZhbGlkUmFuZ2UgPSB0aGlzLmJ1aWxkVmFsaWRSYW5nZSgpO1xuICAgICAgICB2YWxpZFJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyh2YWxpZFJhbmdlKTtcbiAgICAgICAgaWYgKGZvcmNlVG9WYWxpZCkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGN1cnJlbnREYXRlLCB2YWxpZFJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5mbyA9IHRoaXMuYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgICBpc1JhbmdlQWxsRGF5ID0gL14oeWVhcnxtb250aHx3ZWVrfGRheSkkLy50ZXN0KGN1cnJlbnRJbmZvLnVuaXQpO1xuICAgICAgICByZW5kZXJSYW5nZSA9IHRoaXMuYnVpbGRSZW5kZXJSYW5nZSh0aGlzLnRyaW1IaWRkZW5EYXlzKGN1cnJlbnRJbmZvLnJhbmdlKSwgY3VycmVudEluZm8udW5pdCwgaXNSYW5nZUFsbERheSk7XG4gICAgICAgIHJlbmRlclJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyhyZW5kZXJSYW5nZSk7XG4gICAgICAgIGFjdGl2ZVJhbmdlID0gcmVuZGVyUmFuZ2U7XG4gICAgICAgIGlmICghcHJvcHMuc2hvd05vbkN1cnJlbnREYXRlcykge1xuICAgICAgICAgICAgYWN0aXZlUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoYWN0aXZlUmFuZ2UsIGN1cnJlbnRJbmZvLnJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVSYW5nZSA9IHRoaXMuYWRqdXN0QWN0aXZlUmFuZ2UoYWN0aXZlUmFuZ2UpO1xuICAgICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgdmFsaWRSYW5nZSk7IC8vIG1pZ2h0IHJldHVybiBudWxsXG4gICAgICAgIC8vIGl0J3MgaW52YWxpZCBpZiB0aGUgb3JpZ2luYWxseSByZXF1ZXN0ZWQgZGF0ZSBpcyBub3QgY29udGFpbmVkLFxuICAgICAgICAvLyBvciBpZiB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cbiAgICAgICAgaXNWYWxpZCA9IHJhbmdlc0ludGVyc2VjdChjdXJyZW50SW5mby5yYW5nZSwgdmFsaWRSYW5nZSk7XG4gICAgICAgIC8vIEhBQ0s6IGNvbnN0cmFpbiB0byByZW5kZXItcmFuZ2Ugc28gYGN1cnJlbnREYXRlYCBpcyBtb3JlIHVzZWZ1bCB0byB2aWV3IHJlbmRlcmluZ1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIocmVuZGVyUmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSByZW5kZXJSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFsaWRSYW5nZSxcbiAgICAgICAgICAgIC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cbiAgICAgICAgICAgIC8vIGZvciBleGFtcGxlLCBhIG1vbnRoIHZpZXcgbWlnaHQgaGF2ZSAxc3QtMzFzdCwgZXhjbHVkaW5nIHBhZGRlZCBkYXRlc1xuICAgICAgICAgICAgY3VycmVudFJhbmdlOiBjdXJyZW50SW5mby5yYW5nZSxcbiAgICAgICAgICAgIC8vIG5hbWUgb2YgbGFyZ2VzdCB1bml0IGJlaW5nIGRpc3BsYXllZCwgbGlrZSBcIm1vbnRoXCIgb3IgXCJ3ZWVrXCJcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6IGN1cnJlbnRJbmZvLnVuaXQsXG4gICAgICAgICAgICBpc1JhbmdlQWxsRGF5LFxuICAgICAgICAgICAgLy8gZGF0ZXMgdGhhdCBkaXNwbGF5IGV2ZW50cyBhbmQgYWNjZXB0IGRyYWctbi1kcm9wXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGBudWxsYCBpZiBubyBkYXRlcyBhY2NlcHQgZXZlbnRzXG4gICAgICAgICAgICBhY3RpdmVSYW5nZSxcbiAgICAgICAgICAgIC8vIGRhdGUgcmFuZ2Ugd2l0aCBhIHJlbmRlcmVkIHNrZWxldG9uXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyBub3QtYWN0aXZlIGRheXMgdGhhdCBuZWVkIHNvbWUgc29ydCBvZiBET01cbiAgICAgICAgICAgIHJlbmRlclJhbmdlLFxuICAgICAgICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNaW5UaW1lOiBwcm9wcy5zbG90TWluVGltZSxcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNYXhUaW1lOiBwcm9wcy5zbG90TWF4VGltZSxcbiAgICAgICAgICAgIGlzVmFsaWQsXG4gICAgICAgICAgICAvLyBob3cgZmFyIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBtb3ZlIGZvciBhIHByZXYvbmV4dCBvcGVyYXRpb25cbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKSxcbiAgICAgICAgICAgIC8vIHBhc3MgYSBmYWxsYmFjayAobWlnaHQgYmUgbnVsbCkgXlxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQvZW5kIHByb3BlcnRpZXMuXG4gICAgLy8gSW5kaWNhdGVzIHRoZSBtaW5pbXVtL21heGltdW0gZGF0ZXMgdG8gZGlzcGxheS5cbiAgICAvLyBub3QgcmVzcG9uc2libGUgZm9yIHRyaW1taW5nIGhpZGRlbiBkYXlzLlxuICAgIGJ1aWxkVmFsaWRSYW5nZSgpIHtcbiAgICAgICAgbGV0IGlucHV0ID0gdGhpcy5wcm9wcy52YWxpZFJhbmdlSW5wdXQ7XG4gICAgICAgIGxldCBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBpbnB1dC5jYWxsKHRoaXMucHJvcHMuY2FsZW5kYXJBcGksIHRoaXMubm93RGF0ZSlcbiAgICAgICAgICAgIDogaW5wdXQ7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KSB8fFxuICAgICAgICAgICAgeyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07IC8vIGNvbXBsZXRlbHkgb3Blbi1lbmRlZFxuICAgIH1cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcbiAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cbiAgICAvLyBTZWUgYnVpbGQoKSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBgZGlyZWN0aW9uYC5cbiAgICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXG4gICAgYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGRhdGUsIGRpcmVjdGlvbikge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgbGV0IHVuaXQgPSBudWxsO1xuICAgICAgICBsZXQgcmFuZ2UgPSBudWxsO1xuICAgICAgICBsZXQgZGF5Q291bnQ7XG4gICAgICAgIGlmIChwcm9wcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBwcm9wcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kdXJhdGlvblVuaXQ7XG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLnByb3BzLmRheUNvdW50KSkge1xuICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xuICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kYXRlRW52LmdyZWF0ZXN0V2hvbGVVbml0KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpLnVuaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpO1xuICAgICAgICAgICAgdW5pdCA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbikudW5pdDtcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGR1cmF0aW9uLCB1bml0LCByYW5nZSB9O1xuICAgIH1cbiAgICBnZXRGYWxsYmFja0R1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBkYXk6IDEgfSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBuZXcgYWN0aXZlUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxuICAgIC8vIHNsb3RNaW5UaW1lIG9yIHNsb3RNYXhUaW1lIGNhdXNlcyB0aGUgcmFuZ2UgdG8gZXhwYW5kLlxuICAgIGFkanVzdEFjdGl2ZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIHVzZXNNaW5NYXhUaW1lLCBzbG90TWluVGltZSwgc2xvdE1heFRpbWUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlO1xuICAgICAgICBpZiAodXNlc01pbk1heFRpbWUpIHtcbiAgICAgICAgICAgIC8vIGV4cGFuZCBhY3RpdmUgcmFuZ2UgaWYgc2xvdE1pblRpbWUgaXMgbmVnYXRpdmUgKHdoeSBub3Qgd2hlbiBwb3NpdGl2ZT8pXG4gICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoc2xvdE1pblRpbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbG90TWluVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNYXhUaW1lIGlzIGJleW9uZCBvbmUgZGF5ICh3aHkgbm90IHdoZW4gbmVnYXRpdmU/KVxuICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNYXhUaW1lKSA+IDEpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydE9mRGF5KGVuZCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBlbmQgPSBhZGREYXlzKGVuZCwgLTEpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgc2xvdE1heFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGl0IGlzIHNwZWNpZmllZCBhcyBhbiBleHBsaWNpdCBkdXJhdGlvbi5cbiAgICAvLyBgdW5pdGAgaXMgdGhlIGFscmVhZHktY29tcHV0ZWQgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yIHVuaXQgb2YgZHVyYXRpb24uXG4gICAgYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBzdGFydDtcbiAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgLy8gY29tcHV0ZSB3aGF0IHRoZSBhbGlnbm1lbnQgc2hvdWxkIGJlXG4gICAgICAgIGlmICghZGF0ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgbGV0IHsgZGF0ZUluY3JlbWVudCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcbiAgICAgICAgICAgICAgICBpZiAoYXNSb3VnaE1zKGRhdGVJbmNyZW1lbnQpIDwgYXNSb3VnaE1zKGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGRhdGVJbmNyZW1lbnQpLnVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgdmlldyBkaXNwbGF5cyBhIHNpbmdsZSBkYXkgb3Igc21hbGxlclxuICAgICAgICBpZiAoYXNSb3VnaERheXMoZHVyYXRpb24pIDw9IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGlkZGVuRGF5KHN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSZXMoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZihkYXRlLCBkYXRlQWxpZ25tZW50KTtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbik7XG4gICAgICAgICAgICByZXMgPSB7IHN0YXJ0LCBlbmQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlUmVzKCk7XG4gICAgICAgIC8vIGlmIHJhbmdlIGlzIGNvbXBsZXRlbHkgZW52ZWxvcGVkIGJ5IGhpZGRlbiBkYXlzLCBnbyBwYXN0IHRoZSBoaWRkZW4gZGF5c1xuICAgICAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbXB1dGVSZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gYSBkYXlDb3VudCBpcyBzcGVjaWZpZWQuXG4gICAgYnVpbGRSYW5nZUZyb21EYXlDb3VudChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBydW5uaW5nQ291bnQgPSAwO1xuICAgICAgICBsZXQgc3RhcnQgPSBkYXRlO1xuICAgICAgICBsZXQgZW5kO1xuICAgICAgICBpZiAoZGF0ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2Yoc3RhcnQsIGRhdGVBbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAxKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbkRheShlbmQpKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ0NvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICAvLyBCdWlsZHMgYSBub3JtYWxpemVkIHJhbmdlIG9iamVjdCBmb3IgdGhlIFwidmlzaWJsZVwiIHJhbmdlLFxuICAgIC8vIHdoaWNoIGlzIGEgd2F5IHRvIGRlZmluZSB0aGUgY3VycmVudFJhbmdlIGFuZCBhY3RpdmVSYW5nZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIGJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGUpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpbnB1dCA9IHByb3BzLnZpc2libGVSYW5nZUlucHV0O1xuICAgICAgICBsZXQgc2ltcGxlSW5wdXQgPSB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gaW5wdXQuY2FsbChwcm9wcy5jYWxlbmRhckFwaSwgcHJvcHMuZGF0ZUVudi50b0RhdGUoZGF0ZSkpXG4gICAgICAgICAgICA6IGlucHV0O1xuICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KTtcbiAgICAgICAgaWYgKHJhbmdlICYmIChyYW5nZS5zdGFydCA9PSBudWxsIHx8IHJhbmdlLmVuZCA9PSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGUgZWxlbWVudC9jZWxscyBmb3IgKnJlbmRlcmluZyosXG4gICAgLy8gYnV0IHdoaWNoIG1heSBoYXZlIHZvaWRlZCBkYXlzL3RpbWVzLlxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXG4gICAgYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSYW5nZTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgZHVyYXRpb24gdmFsdWUgdGhhdCBzaG91bGQgYmUgYWRkZWQvc3Vic3RyYWN0ZWQgdG8gdGhlIGN1cnJlbnQgZGF0ZVxuICAgIC8vIHdoZW4gYSBwcmV2L25leHQgb3BlcmF0aW9uIGhhcHBlbnMuXG4gICAgYnVpbGREYXRlSW5jcmVtZW50KGZhbGxiYWNrKSB7XG4gICAgICAgIGxldCB7IGRhdGVJbmNyZW1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBjdXN0b21BbGlnbm1lbnQ7XG4gICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUluY3JlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGN1c3RvbUFsaWdubWVudCA9IHRoaXMucHJvcHMuZGF0ZUFsaWdubWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbigxLCBjdXN0b21BbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSk7XG4gICAgfVxuICAgIHJlZmluZVJhbmdlKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgaWYgKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHBhcnNlUmFuZ2UocmFuZ2VJbnB1dCwgdGhpcy5wcm9wcy5kYXRlRW52KTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gY29tcHV0ZVZpc2libGVEYXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qIEhpZGRlbiBEYXlzXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXG4gICAgaW5pdEhpZGRlbkRheXMoKSB7XG4gICAgICAgIGxldCBoaWRkZW5EYXlzID0gdGhpcy5wcm9wcy5oaWRkZW5EYXlzIHx8IFtdOyAvLyBhcnJheSBvZiBkYXktb2Ytd2VlayBpbmRpY2VzIHRoYXQgYXJlIGhpZGRlblxuICAgICAgICBsZXQgaXNIaWRkZW5EYXlIYXNoID0gW107IC8vIGlzIHRoZSBkYXktb2Ytd2VlayBoaWRkZW4/IChoYXNoIHdpdGggZGF5LW9mLXdlZWstaW5kZXggLT4gYm9vbClcbiAgICAgICAgbGV0IGRheUNudCA9IDA7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy53ZWVrZW5kcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGhpZGRlbkRheXMucHVzaCgwLCA2KTsgLy8gMD1zdW5kYXksIDY9c2F0dXJkYXlcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIShpc0hpZGRlbkRheUhhc2hbaV0gPSBoaWRkZW5EYXlzLmluZGV4T2YoaSkgIT09IC0xKSkge1xuICAgICAgICAgICAgICAgIGRheUNudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGF5Q250KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGlkZGVuRGF5cycpOyAvLyBhbGwgZGF5cyB3ZXJlIGhpZGRlbj8gYmFkLlxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNIaWRkZW5EYXlIYXNoID0gaXNIaWRkZW5EYXlIYXNoO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgZGF5cyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdGhhdCBhcmUgY29tcHV0ZWQgYXMgaGlkZGVuLlxuICAgIC8vIElmIHRoZSB3aG9sZSByYW5nZSBpcyB0cmltbWVkIG9mZiwgcmV0dXJucyBudWxsXG4gICAgdHJpbUhpZGRlbkRheXMocmFuZ2UpIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2U7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGVuZCwgLTEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XG4gICAgLy8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBEYXRlICh1c2VkIGZvciBVVEMpXG4gICAgaXNIaWRkZW5EYXkoZGF5KSB7XG4gICAgICAgIGlmIChkYXkgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBkYXkgPSBkYXkuZ2V0VVRDRGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNIaWRkZW5EYXlIYXNoW2RheV07XG4gICAgfVxuICAgIC8vIEluY3JlbWVudGluZyB0aGUgY3VycmVudCBkYXkgdW50aWwgaXQgaXMgbm8gbG9uZ2VyIGEgaGlkZGVuIGRheSwgcmV0dXJuaW5nIGEgY29weS5cbiAgICAvLyBET0VTIE5PVCBDT05TSURFUiB2YWxpZFJhbmdlIVxuICAgIC8vIElmIHRoZSBpbml0aWFsIHZhbHVlIG9mIGBkYXRlYCBpcyBub3QgYSBoaWRkZW4gZGF5LCBkb24ndCBkbyBhbnl0aGluZy5cbiAgICAvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxuICAgIC8vIGBpbmNgIGRlZmF1bHRzIHRvIGAxYCAoaW5jcmVtZW50IG9uZSBkYXkgZm9yd2FyZCBlYWNoIHRpbWUpXG4gICAgc2tpcEhpZGRlbkRheXMoZGF0ZSwgaW5jID0gMSwgaXNFeGNsdXNpdmUgPSBmYWxzZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5pc0hpZGRlbkRheUhhc2hbKGRhdGUuZ2V0VVRDRGF5KCkgKyAoaXNFeGNsdXNpdmUgPyBpbmMgOiAwKSArIDcpICUgN10pIHtcbiAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIGluYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudEluc3RhbmNlKGRlZklkLCByYW5nZSwgZm9yY2VkU3RhcnRUem8sIGZvcmNlZEVuZFR6bykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGluc3RhbmNlSWQ6IGd1aWQoKSxcbiAgICAgICAgZGVmSWQsXG4gICAgICAgIHJhbmdlLFxuICAgICAgICBmb3JjZWRTdGFydFR6bzogZm9yY2VkU3RhcnRUem8gPT0gbnVsbCA/IG51bGwgOiBmb3JjZWRTdGFydFR6byxcbiAgICAgICAgZm9yY2VkRW5kVHpvOiBmb3JjZWRFbmRUem8gPT0gbnVsbCA/IG51bGwgOiBmb3JjZWRFbmRUem8sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VSZWN1cnJpbmcocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3VycmluZ1R5cGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBwYXJzZWQgPSByZWN1cnJpbmdUeXBlc1tpXS5wYXJzZShyZWZpbmVkLCBkYXRlRW52KTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgbGV0IHsgYWxsRGF5IH0gPSByZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gcGFyc2VkLmFsbERheUd1ZXNzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbGxEYXksXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHBhcnNlZC5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlRGF0YTogcGFyc2VkLnR5cGVEYXRhLFxuICAgICAgICAgICAgICAgIHR5cGVJZDogaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBleHBhbmRSZWN1cnJpbmcoZXZlbnRTdG9yZSwgZnJhbWluZ1JhbmdlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgcGx1Z2luSG9va3MsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgIC8vIHJlbW92ZSBleGlzdGluZyByZWN1cnJpbmcgaW5zdGFuY2VzXG4gICAgLy8gVE9ETzogYmFkLiBhbHdheXMgZXhwYW5kIGV2ZW50cyBhcyBhIHNlY29uZCBzdGVwXG4gICAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4gIWRlZnNbaW5zdGFuY2UuZGVmSWRdLnJlY3VycmluZ0RlZik7XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICBsZXQgeyBkdXJhdGlvbiB9ID0gZGVmLnJlY3VycmluZ0RlZjtcbiAgICAgICAgICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGRlZi5hbGxEYXkgP1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIDpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0cyA9IGV4cGFuZFJlY3VycmluZ1JhbmdlcyhkZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYsIHBsdWdpbkhvb2tzLnJlY3VycmluZ1R5cGVzKTtcbiAgICAgICAgICAgIGZvciAobGV0IHN0YXJ0IG9mIHN0YXJ0cykge1xuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfTtcbn1cbi8qXG5FdmVudCBNVVNUIGhhdmUgYSByZWN1cnJpbmdEZWZcbiovXG5mdW5jdGlvbiBleHBhbmRSZWN1cnJpbmdSYW5nZXMoZXZlbnREZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYsIHJlY3VycmluZ1R5cGVzKSB7XG4gICAgbGV0IHR5cGVEZWYgPSByZWN1cnJpbmdUeXBlc1tldmVudERlZi5yZWN1cnJpbmdEZWYudHlwZUlkXTtcbiAgICBsZXQgbWFya2VycyA9IHR5cGVEZWYuZXhwYW5kKGV2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlRGF0YSwge1xuICAgICAgICBzdGFydDogZGF0ZUVudi5zdWJ0cmFjdChmcmFtaW5nUmFuZ2Uuc3RhcnQsIGR1cmF0aW9uKSxcbiAgICAgICAgZW5kOiBmcmFtaW5nUmFuZ2UuZW5kLFxuICAgIH0sIGRhdGVFbnYpO1xuICAgIC8vIHRoZSByZWN1cnJlbmNlIHBsdWdpbnMgZG9uJ3QgZ3VhcmFudGVlIHRoYXQgYWxsLWRheSBldmVudHMgYXJlIHN0YXJ0LW9mLWRheSwgc28gd2UgaGF2ZSB0b1xuICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcbiAgICAgICAgbWFya2VycyA9IG1hcmtlcnMubWFwKHN0YXJ0T2ZEYXkpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2Vycztcbn1cblxuY29uc3QgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMgPSB7XG4gICAgaWQ6IFN0cmluZyxcbiAgICBncm91cElkOiBTdHJpbmcsXG4gICAgdGl0bGU6IFN0cmluZyxcbiAgICB1cmw6IFN0cmluZyxcbiAgICBpbnRlcmFjdGl2ZTogQm9vbGVhbixcbn07XG5jb25zdCBFVkVOVF9EQVRFX1JFRklORVJTID0ge1xuICAgIHN0YXJ0OiBpZGVudGl0eSxcbiAgICBlbmQ6IGlkZW50aXR5LFxuICAgIGRhdGU6IGlkZW50aXR5LFxuICAgIGFsbERheTogQm9vbGVhbixcbn07XG5jb25zdCBFVkVOVF9SRUZJTkVSUyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBFVkVOVF9OT05fREFURV9SRUZJTkVSUyksIEVWRU5UX0RBVEVfUkVGSU5FUlMpLCB7IGV4dGVuZGVkUHJvcHM6IGlkZW50aXR5IH0pO1xuZnVuY3Rpb24gcGFyc2VFdmVudChyYXcsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSwgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCksIGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwKSB7XG4gICAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZUV2ZW50RGVmKHJhdywgY29udGV4dCwgcmVmaW5lcnMpO1xuICAgIGxldCBkZWZhdWx0QWxsRGF5ID0gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCk7XG4gICAgbGV0IHJlY3VycmluZ1JlcyA9IHBhcnNlUmVjdXJyaW5nKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQuZGF0ZUVudiwgY29udGV4dC5wbHVnaW5Ib29rcy5yZWN1cnJpbmdUeXBlcyk7XG4gICAgaWYgKHJlY3VycmluZ1Jlcykge1xuICAgICAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCByZWN1cnJpbmdSZXMuYWxsRGF5LCBCb29sZWFuKHJlY3VycmluZ1Jlcy5kdXJhdGlvbiksIGNvbnRleHQsIGRlZklkTWFwKTtcbiAgICAgICAgZGVmLnJlY3VycmluZ0RlZiA9IHtcbiAgICAgICAgICAgIHR5cGVJZDogcmVjdXJyaW5nUmVzLnR5cGVJZCxcbiAgICAgICAgICAgIHR5cGVEYXRhOiByZWN1cnJpbmdSZXMudHlwZURhdGEsXG4gICAgICAgICAgICBkdXJhdGlvbjogcmVjdXJyaW5nUmVzLmR1cmF0aW9uLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBkZWYsIGluc3RhbmNlOiBudWxsIH07XG4gICAgfVxuICAgIGxldCBzaW5nbGVSZXMgPSBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSk7XG4gICAgaWYgKHNpbmdsZVJlcykge1xuICAgICAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCBzaW5nbGVSZXMuYWxsRGF5LCBzaW5nbGVSZXMuaGFzRW5kLCBjb250ZXh0LCBkZWZJZE1hcCk7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBzaW5nbGVSZXMucmFuZ2UsIHNpbmdsZVJlcy5mb3JjZWRTdGFydFR6bywgc2luZ2xlUmVzLmZvcmNlZEVuZFR6byk7XG4gICAgICAgIGlmIChpbnN0YW5jZUlkTWFwICYmIGRlZi5wdWJsaWNJZCAmJiBpbnN0YW5jZUlkTWFwW2RlZi5wdWJsaWNJZF0pIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmluc3RhbmNlSWQgPSBpbnN0YW5jZUlkTWFwW2RlZi5wdWJsaWNJZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGVmLCBpbnN0YW5jZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlZmluZUV2ZW50RGVmKHJhdywgY29udGV4dCwgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCkpIHtcbiAgICByZXR1cm4gcmVmaW5lUHJvcHMocmF3LCByZWZpbmVycyk7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRVZFTlRfVUlfUkVGSU5FUlMpLCBFVkVOVF9SRUZJTkVSUyksIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRSZWZpbmVycyk7XG59XG4vKlxuV2lsbCBOT1QgcG9wdWxhdGUgZXh0ZW5kZWRQcm9wcyB3aXRoIHRoZSBsZWZ0b3ZlciBwcm9wZXJ0aWVzLlxuV2lsbCBOT1QgcG9wdWxhdGUgZGF0ZS1yZWxhdGVkIHByb3BzLlxuKi9cbmZ1bmN0aW9uIHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIHNvdXJjZUlkLCBhbGxEYXksIGhhc0VuZCwgY29udGV4dCwgZGVmSWRNYXApIHtcbiAgICBsZXQgZGVmID0ge1xuICAgICAgICB0aXRsZTogcmVmaW5lZC50aXRsZSB8fCAnJyxcbiAgICAgICAgZ3JvdXBJZDogcmVmaW5lZC5ncm91cElkIHx8ICcnLFxuICAgICAgICBwdWJsaWNJZDogcmVmaW5lZC5pZCB8fCAnJyxcbiAgICAgICAgdXJsOiByZWZpbmVkLnVybCB8fCAnJyxcbiAgICAgICAgcmVjdXJyaW5nRGVmOiBudWxsLFxuICAgICAgICBkZWZJZDogKChkZWZJZE1hcCAmJiByZWZpbmVkLmlkKSA/IGRlZklkTWFwW3JlZmluZWQuaWRdIDogJycpIHx8IGd1aWQoKSxcbiAgICAgICAgc291cmNlSWQsXG4gICAgICAgIGFsbERheSxcbiAgICAgICAgaGFzRW5kLFxuICAgICAgICBpbnRlcmFjdGl2ZTogcmVmaW5lZC5pbnRlcmFjdGl2ZSxcbiAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXG4gICAgICAgIGV4dGVuZGVkUHJvcHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlZmluZWQuZXh0ZW5kZWRQcm9wcyB8fCB7fSkpLCBleHRyYSksXG4gICAgfTtcbiAgICBmb3IgKGxldCBtZW1iZXJBZGRlciBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50RGVmTWVtYmVyQWRkZXJzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZGVmLCBtZW1iZXJBZGRlcihyZWZpbmVkKSk7XG4gICAgfVxuICAgIC8vIGhlbHAgb3V0IEV2ZW50SW1wbCBmcm9tIGhhdmluZyB1c2VyIG1vZGlmeSBwcm9wc1xuICAgIE9iamVjdC5mcmVlemUoZGVmLnVpLmNsYXNzTmFtZXMpO1xuICAgIE9iamVjdC5mcmVlemUoZGVmLmV4dGVuZGVkUHJvcHMpO1xuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSkge1xuICAgIGxldCB7IGFsbERheSB9ID0gcmVmaW5lZDtcbiAgICBsZXQgc3RhcnRNZXRhO1xuICAgIGxldCBzdGFydE1hcmtlciA9IG51bGw7XG4gICAgbGV0IGhhc0VuZCA9IGZhbHNlO1xuICAgIGxldCBlbmRNZXRhO1xuICAgIGxldCBlbmRNYXJrZXIgPSBudWxsO1xuICAgIGxldCBzdGFydElucHV0ID0gcmVmaW5lZC5zdGFydCAhPSBudWxsID8gcmVmaW5lZC5zdGFydCA6IHJlZmluZWQuZGF0ZTtcbiAgICBzdGFydE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICBpZiAoc3RhcnRNZXRhKSB7XG4gICAgICAgIHN0YXJ0TWFya2VyID0gc3RhcnRNZXRhLm1hcmtlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVmaW5lZC5lbmQgIT0gbnVsbCkge1xuICAgICAgICBlbmRNZXRhID0gY29udGV4dC5kYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEocmVmaW5lZC5lbmQpO1xuICAgIH1cbiAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRBbGxEYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byB0aGUgZGF0ZSBwcm9wcyBMQVNUXG4gICAgICAgICAgICBhbGxEYXkgPSAoIXN0YXJ0TWV0YSB8fCBzdGFydE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpICYmXG4gICAgICAgICAgICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbGxEYXkgJiYgc3RhcnRNYXJrZXIpIHtcbiAgICAgICAgc3RhcnRNYXJrZXIgPSBzdGFydE9mRGF5KHN0YXJ0TWFya2VyKTtcbiAgICB9XG4gICAgaWYgKGVuZE1ldGEpIHtcbiAgICAgICAgZW5kTWFya2VyID0gZW5kTWV0YS5tYXJrZXI7XG4gICAgICAgIGlmIChhbGxEYXkpIHtcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IHN0YXJ0T2ZEYXkoZW5kTWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyIDw9IHN0YXJ0TWFya2VyKSB7XG4gICAgICAgICAgICBlbmRNYXJrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmRNYXJrZXIpIHtcbiAgICAgICAgaGFzRW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIGhhc0VuZCA9IGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24gfHwgZmFsc2U7XG4gICAgICAgIGVuZE1hcmtlciA9IGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnRNYXJrZXIsIGFsbERheSA/XG4gICAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgICAgY29udGV4dC5vcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxEYXksXG4gICAgICAgIGhhc0VuZCxcbiAgICAgICAgcmFuZ2U6IHsgc3RhcnQ6IHN0YXJ0TWFya2VyLCBlbmQ6IGVuZE1hcmtlciB9LFxuICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRNZXRhID8gc3RhcnRNZXRhLmZvcmNlZFR6byA6IG51bGwsXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YSA/IGVuZE1ldGEuZm9yY2VkVHpvIDogbnVsbCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIGxldCByZXMgPSBudWxsO1xuICAgIGlmIChldmVudFNvdXJjZSkge1xuICAgICAgICByZXMgPSBldmVudFNvdXJjZS5kZWZhdWx0QWxsRGF5O1xuICAgIH1cbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgICAgcmVzID0gY29udGV4dC5vcHRpb25zLmRlZmF1bHRBbGxEYXk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGFsbG93T3BlblJhbmdlLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCkge1xuICAgIGxldCBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgbGV0IGV2ZW50UmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCk7XG4gICAgZm9yIChsZXQgcmF3RXZlbnQgb2YgcmF3RXZlbnRzKSB7XG4gICAgICAgIGxldCB0dXBsZSA9IHBhcnNlRXZlbnQocmF3RXZlbnQsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSwgZXZlbnRSZWZpbmVycywgZGVmSWRNYXAsIGluc3RhbmNlSWRNYXApO1xuICAgICAgICBpZiAodHVwbGUpIHtcbiAgICAgICAgICAgIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbmZ1bmN0aW9uIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCkpIHtcbiAgICBldmVudFN0b3JlLmRlZnNbdHVwbGUuZGVmLmRlZklkXSA9IHR1cGxlLmRlZjtcbiAgICBpZiAodHVwbGUuaW5zdGFuY2UpIHtcbiAgICAgICAgZXZlbnRTdG9yZS5pbnN0YW5jZXNbdHVwbGUuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSB0dXBsZS5pbnN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG4vLyByZXRyaWV2ZXMgZXZlbnRzIHRoYXQgaGF2ZSB0aGUgc2FtZSBncm91cElkIGFzIHRoZSBpbnN0YW5jZSBzcGVjaWZpZWQgYnkgYGluc3RhbmNlSWRgXG4vLyBvciB0aGV5IGFyZSB0aGUgc2FtZSBhcyB0aGUgaW5zdGFuY2UuXG4vLyB3aHkgbWlnaHQgaW5zdGFuY2VJZCBub3QgYmUgaW4gdGhlIHN0b3JlPyBhbiBldmVudCBmcm9tIGFub3RoZXIgY2FsZW5kYXI/XG5mdW5jdGlvbiBnZXRSZWxldmFudEV2ZW50cyhldmVudFN0b3JlLCBpbnN0YW5jZUlkKSB7XG4gICAgbGV0IGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICAvLyBnZXQgZXZlbnRzL2luc3RhbmNlcyB3aXRoIHNhbWUgZ3JvdXBcbiAgICAgICAgbGV0IG5ld1N0b3JlID0gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgKGxvb2tEZWYpID0+IGlzRXZlbnREZWZzR3JvdXBlZChkZWYsIGxvb2tEZWYpKTtcbiAgICAgICAgLy8gYWRkIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyBUT0RPOiB3aXNoIHdlIGNvdWxkIHVzZSBldmVudFR1cGxlVG9TdG9yZSBvciBzb21ldGhpbmcgbGlrZSBpdFxuICAgICAgICBuZXdTdG9yZS5kZWZzW2RlZi5kZWZJZF0gPSBkZWY7XG4gICAgICAgIG5ld1N0b3JlLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlO1xuICAgICAgICByZXR1cm4gbmV3U3RvcmU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnREZWZzR3JvdXBlZChkZWYwLCBkZWYxKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZGVmMC5ncm91cElkICYmIGRlZjAuZ3JvdXBJZCA9PT0gZGVmMS5ncm91cElkKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpIHtcbiAgICByZXR1cm4geyBkZWZzOiB7fSwgaW5zdGFuY2VzOiB7fSB9O1xufVxuZnVuY3Rpb24gbWVyZ2VFdmVudFN0b3JlcyhzdG9yZTAsIHN0b3JlMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUwLmRlZnMpLCBzdG9yZTEuZGVmcyksXG4gICAgICAgIGluc3RhbmNlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdG9yZTAuaW5zdGFuY2VzKSwgc3RvcmUxLmluc3RhbmNlcyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZpbHRlckZ1bmMpIHtcbiAgICBsZXQgZGVmcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5kZWZzLCBmaWx0ZXJGdW5jKTtcbiAgICBsZXQgaW5zdGFuY2VzID0gZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlKSA9PiAoZGVmc1tpbnN0YW5jZS5kZWZJZF0gLy8gc3RpbGwgZXhpc3RzP1xuICAgICkpO1xuICAgIHJldHVybiB7IGRlZnMsIGluc3RhbmNlcyB9O1xufVxuZnVuY3Rpb24gZXhjbHVkZVN1YkV2ZW50U3RvcmUobWFzdGVyLCBzdWIpIHtcbiAgICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IG1hc3RlcjtcbiAgICBsZXQgZmlsdGVyZWREZWZzID0ge307XG4gICAgbGV0IGZpbHRlcmVkSW5zdGFuY2VzID0ge307XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBpZiAoIXN1Yi5kZWZzW2RlZklkXSkgeyAvLyBub3QgZXhwbGljaXRseSBleGNsdWRlZFxuICAgICAgICAgICAgZmlsdGVyZWREZWZzW2RlZklkXSA9IGRlZnNbZGVmSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGlmICghc3ViLmluc3RhbmNlc1tpbnN0YW5jZUlkXSAmJiAvLyBub3QgZXhwbGljaXRseSBleGNsdWRlZFxuICAgICAgICAgICAgZmlsdGVyZWREZWZzW2luc3RhbmNlc1tpbnN0YW5jZUlkXS5kZWZJZF0gLy8gZGVmIHdhc24ndCBmaWx0ZXJlZCBhd2F5XG4gICAgICAgICkge1xuICAgICAgICAgICAgZmlsdGVyZWRJbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmczogZmlsdGVyZWREZWZzLFxuICAgICAgICBpbnN0YW5jZXM6IGZpbHRlcmVkSW5zdGFuY2VzLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnN0cmFpbnQoaW5wdXQsIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKGlucHV0LCBudWxsLCBjb250ZXh0LCB0cnVlKTsgLy8gYWxsb3dPcGVuUmFuZ2U9dHJ1ZVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKFtpbnB1dF0sIG51bGwsIGNvbnRleHQsIHRydWUpOyAvLyBhbGxvd09wZW5SYW5nZT10cnVlXG4gICAgfVxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VDbGFzc05hbWVzKHJhdykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJhdykpIHtcbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByYXcuc3BsaXQoL1xccysvKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG4vLyBUT0RPOiBiZXR0ZXIgY2FsbGVkIFwiRXZlbnRTZXR0aW5nc1wiIG9yIFwiRXZlbnRDb25maWdcIlxuLy8gVE9ETzogbW92ZSB0aGlzIGZpbGUgaW50byBzdHJ1Y3RzXG4vLyBUT0RPOiBzZXBhcmF0ZSBjb25zdHJhaW50L292ZXJsYXAvYWxsb3csIGJlY2F1c2Ugc2VsZWN0aW9uIHVzZXMgb25seSB0aGF0LCBub3Qgb3RoZXIgcHJvcHNcbmNvbnN0IEVWRU5UX1VJX1JFRklORVJTID0ge1xuICAgIGRpc3BsYXk6IFN0cmluZyxcbiAgICBlZGl0YWJsZTogQm9vbGVhbixcbiAgICBzdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IEJvb2xlYW4sXG4gICAgY29uc3RyYWludDogaWRlbnRpdHksXG4gICAgb3ZlcmxhcDogaWRlbnRpdHksXG4gICAgYWxsb3c6IGlkZW50aXR5LFxuICAgIGNsYXNzTmFtZTogcGFyc2VDbGFzc05hbWVzLFxuICAgIGNsYXNzTmFtZXM6IHBhcnNlQ2xhc3NOYW1lcyxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgIGJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgdGV4dENvbG9yOiBTdHJpbmcsXG59O1xuY29uc3QgRU1QVFlfRVZFTlRfVUkgPSB7XG4gICAgZGlzcGxheTogbnVsbCxcbiAgICBzdGFydEVkaXRhYmxlOiBudWxsLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IG51bGwsXG4gICAgY29uc3RyYWludHM6IFtdLFxuICAgIG92ZXJsYXA6IG51bGwsXG4gICAgYWxsb3dzOiBbXSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgIGJvcmRlckNvbG9yOiAnJyxcbiAgICB0ZXh0Q29sb3I6ICcnLFxuICAgIGNsYXNzTmFtZXM6IFtdLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCkge1xuICAgIGxldCBjb25zdHJhaW50ID0gbm9ybWFsaXplQ29uc3RyYWludChyZWZpbmVkLmNvbnN0cmFpbnQsIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXk6IHJlZmluZWQuZGlzcGxheSB8fCBudWxsLFxuICAgICAgICBzdGFydEVkaXRhYmxlOiByZWZpbmVkLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuc3RhcnRFZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXG4gICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gcmVmaW5lZC5kdXJhdGlvbkVkaXRhYmxlIDogcmVmaW5lZC5lZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGNvbnN0cmFpbnQgIT0gbnVsbCA/IFtjb25zdHJhaW50XSA6IFtdLFxuICAgICAgICBvdmVybGFwOiByZWZpbmVkLm92ZXJsYXAgIT0gbnVsbCA/IHJlZmluZWQub3ZlcmxhcCA6IG51bGwsXG4gICAgICAgIGFsbG93czogcmVmaW5lZC5hbGxvdyAhPSBudWxsID8gW3JlZmluZWQuYWxsb3ddIDogW10sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmaW5lZC5iYWNrZ3JvdW5kQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHJlZmluZWQuYm9yZGVyQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgdGV4dENvbG9yOiByZWZpbmVkLnRleHRDb2xvciB8fCAnJyxcbiAgICAgICAgY2xhc3NOYW1lczogKHJlZmluZWQuY2xhc3NOYW1lIHx8IFtdKS5jb25jYXQocmVmaW5lZC5jbGFzc05hbWVzIHx8IFtdKSwgLy8gam9pbiBzaW5ndWxhciBhbmQgcGx1cmFsXG4gICAgfTtcbn1cbi8vIFRPRE86IHByZXZlbnQgYWdhaW5zdCBwcm9ibGVtcyB3aXRoIDwyIGFyZ3MhXG5mdW5jdGlvbiBjb21iaW5lRXZlbnRVaXModWlzKSB7XG4gICAgcmV0dXJuIHVpcy5yZWR1Y2UoY29tYmluZVR3b0V2ZW50VWlzLCBFTVBUWV9FVkVOVF9VSSk7XG59XG5mdW5jdGlvbiBjb21iaW5lVHdvRXZlbnRVaXMoaXRlbTAsIGl0ZW0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheTogaXRlbTEuZGlzcGxheSAhPSBudWxsID8gaXRlbTEuZGlzcGxheSA6IGl0ZW0wLmRpc3BsYXksXG4gICAgICAgIHN0YXJ0RWRpdGFibGU6IGl0ZW0xLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IGl0ZW0xLnN0YXJ0RWRpdGFibGUgOiBpdGVtMC5zdGFydEVkaXRhYmxlLFxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlIDogaXRlbTAuZHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGl0ZW0wLmNvbnN0cmFpbnRzLmNvbmNhdChpdGVtMS5jb25zdHJhaW50cyksXG4gICAgICAgIG92ZXJsYXA6IHR5cGVvZiBpdGVtMS5vdmVybGFwID09PSAnYm9vbGVhbicgPyBpdGVtMS5vdmVybGFwIDogaXRlbTAub3ZlcmxhcCxcbiAgICAgICAgYWxsb3dzOiBpdGVtMC5hbGxvd3MuY29uY2F0KGl0ZW0xLmFsbG93cyksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXRlbTEuYmFja2dyb3VuZENvbG9yIHx8IGl0ZW0wLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgYm9yZGVyQ29sb3I6IGl0ZW0xLmJvcmRlckNvbG9yIHx8IGl0ZW0wLmJvcmRlckNvbG9yLFxuICAgICAgICB0ZXh0Q29sb3I6IGl0ZW0xLnRleHRDb2xvciB8fCBpdGVtMC50ZXh0Q29sb3IsXG4gICAgICAgIGNsYXNzTmFtZXM6IGl0ZW0wLmNsYXNzTmFtZXMuY29uY2F0KGl0ZW0xLmNsYXNzTmFtZXMpLFxuICAgIH07XG59XG5cbmNvbnN0IEVWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBpZDogU3RyaW5nLFxuICAgIGRlZmF1bHRBbGxEYXk6IEJvb2xlYW4sXG4gICAgdXJsOiBTdHJpbmcsXG4gICAgZm9ybWF0OiBTdHJpbmcsXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudERhdGFUcmFuc2Zvcm06IGlkZW50aXR5LFxuICAgIC8vIGZvciBhbnkgbmV0d29yay1yZWxhdGVkIHNvdXJjZXNcbiAgICBzdWNjZXNzOiBpZGVudGl0eSxcbiAgICBmYWlsdXJlOiBpZGVudGl0eSxcbn07XG5mdW5jdGlvbiBwYXJzZUV2ZW50U291cmNlKHJhdywgY29udGV4dCwgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCkpIHtcbiAgICBsZXQgcmF3T2JqO1xuICAgIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgICAgICByYXdPYmogPSB7IHVybDogcmF3IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByYXcgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyYXcpKSB7XG4gICAgICAgIHJhd09iaiA9IHsgZXZlbnRzOiByYXcgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJhdyA9PT0gJ29iamVjdCcgJiYgcmF3KSB7IC8vIG5vdCBudWxsXG4gICAgICAgIHJhd09iaiA9IHJhdztcbiAgICB9XG4gICAgaWYgKHJhd09iaikge1xuICAgICAgICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lUHJvcHMocmF3T2JqLCByZWZpbmVycyk7XG4gICAgICAgIGxldCBtZXRhUmVzID0gYnVpbGRFdmVudFNvdXJjZU1ldGEocmVmaW5lZCwgY29udGV4dCk7XG4gICAgICAgIGlmIChtZXRhUmVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9yYXc6IHJhdyxcbiAgICAgICAgICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYXRlc3RGZXRjaElkOiAnJyxcbiAgICAgICAgICAgICAgICBmZXRjaFJhbmdlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRBbGxEYXk6IHJlZmluZWQuZGVmYXVsdEFsbERheSxcbiAgICAgICAgICAgICAgICBldmVudERhdGFUcmFuc2Zvcm06IHJlZmluZWQuZXZlbnREYXRhVHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlZmluZWQuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBmYWlsdXJlOiByZWZpbmVkLmZhaWx1cmUsXG4gICAgICAgICAgICAgICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IGd1aWQoKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VEZWZJZDogbWV0YVJlcy5zb3VyY2VEZWZJZCxcbiAgICAgICAgICAgICAgICBtZXRhOiBtZXRhUmVzLm1ldGEsXG4gICAgICAgICAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogZXh0cmEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEVWRU5UX1VJX1JFRklORVJTKSwgRVZFTlRfU09VUkNFX1JFRklORVJTKSwgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZVJlZmluZXJzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2VNZXRhKHJhdywgY29udGV4dCkge1xuICAgIGxldCBkZWZzID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnM7XG4gICAgZm9yIChsZXQgaSA9IGRlZnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHsgLy8gbGF0ZXItYWRkZWQgcGx1Z2lucyB0YWtlIHByZWNlZGVuY2VcbiAgICAgICAgbGV0IGRlZiA9IGRlZnNbaV07XG4gICAgICAgIGxldCBtZXRhID0gZGVmLnBhcnNlTWV0YShyYXcpO1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc291cmNlRGVmSWQ6IGksIG1ldGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRTJzogLy8gcmF3XG4gICAgICAgICAgICByZXR1cm4gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZXNbYWN0aW9uLnNvdXJjZUlkXSwgYWN0aW9uLmZldGNoSWQsIGFjdGlvbi5mZXRjaFJhbmdlLCBhY3Rpb24ucmF3RXZlbnRzLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVTRVRfUkFXX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gcmVzZXRSYXdFdmVudHMoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2VzW2FjdGlvbi5zb3VyY2VJZF0sIGFjdGlvbi5yYXdFdmVudHMsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnQUREX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkLCBidXQgbm90IGV4cGFuZGVkXG4gICAgICAgICAgICByZXR1cm4gYWRkRXZlbnQoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUsIC8vIG5ldyBvbmVzXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFU0VUX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmV2ZW50U3RvcmU7XG4gICAgICAgIGNhc2UgJ01FUkdFX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkIGFuZCBleHBhbmRlZFxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUpO1xuICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgICAgIGNhc2UgJ05FWFQnOlxuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZFJlY3VycmluZyhldmVudFN0b3JlLCBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZVN1YkV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUpO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBhY3Rpb24uc291cmNlSWQpO1xuICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UX1NPVVJDRVMnOlxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIChldmVudERlZikgPT4gKCFldmVudERlZi5zb3VyY2VJZCAvLyBvbmx5IGtlZXAgZXZlbnRzIHdpdGggbm8gc291cmNlIGlkXG4gICAgICAgICAgICApKTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVFMnOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZSwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSwgcmF3RXZlbnRzLCBjb250ZXh0KSB7XG4gICAgaWYgKGV2ZW50U291cmNlICYmIC8vIG5vdCBhbHJlYWR5IHJlbW92ZWRcbiAgICAgICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZCAvLyBUT0RPOiB3aXNoIHRoaXMgbG9naWMgd2FzIGFsd2F5cyBpbiBldmVudC1zb3VyY2VzXG4gICAgKSB7XG4gICAgICAgIGxldCBzdWJzZXQgPSBwYXJzZUV2ZW50cyh0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCksIGV2ZW50U291cmNlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICAgICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGZldGNoUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLnNvdXJjZUlkKSwgc3Vic2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG5mdW5jdGlvbiByZXNldFJhd0V2ZW50cyhleGlzdGluZ0V2ZW50U3RvcmUsIGV2ZW50U291cmNlLCByYXdFdmVudHMsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCB9ID0gYnVpbGRQdWJsaWNJZE1hcHMoZXhpc3RpbmdFdmVudFN0b3JlKTtcbiAgICBsZXQgbmV3RXZlbnRTdG9yZSA9IHBhcnNlRXZlbnRzKHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSwgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGZhbHNlLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCk7XG4gICAgcmV0dXJuIGV4cGFuZFJlY3VycmluZyhuZXdFdmVudFN0b3JlLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIGxldCBjYWxFYWNoVHJhbnNmb3JtID0gY29udGV4dC5vcHRpb25zLmV2ZW50RGF0YVRyYW5zZm9ybTtcbiAgICBsZXQgc291cmNlRWFjaFRyYW5zZm9ybSA9IGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2UuZXZlbnREYXRhVHJhbnNmb3JtIDogbnVsbDtcbiAgICBpZiAoc291cmNlRWFjaFRyYW5zZm9ybSkge1xuICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBzb3VyY2VFYWNoVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKGNhbEVhY2hUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmF3RXZlbnRzID0gdHJhbnNmb3JtRWFjaFJhd0V2ZW50KHJhd0V2ZW50cywgY2FsRWFjaFRyYW5zZm9ybSk7XG4gICAgfVxuICAgIHJldHVybiByYXdFdmVudHM7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBmdW5jKSB7XG4gICAgbGV0IHJlZmluZWRFdmVudHM7XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMgPSByYXdFdmVudHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZWZpbmVkRXZlbnRzID0gW107XG4gICAgICAgIGZvciAobGV0IHJhd0V2ZW50IG9mIHJhd0V2ZW50cykge1xuICAgICAgICAgICAgbGV0IHJlZmluZWRFdmVudCA9IGZ1bmMocmF3RXZlbnQpO1xuICAgICAgICAgICAgaWYgKHJlZmluZWRFdmVudCkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyZWZpbmVkRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lZEV2ZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkRXZlbnRzLnB1c2gocmF3RXZlbnQpO1xuICAgICAgICAgICAgfSAvLyBpZiBhIGRpZmZlcmVudCBmYWxzeSB2YWx1ZSwgZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWZpbmVkRXZlbnRzO1xufVxuZnVuY3Rpb24gYWRkRXZlbnQoZXZlbnRTdG9yZSwgc3Vic2V0LCBleHBhbmRSYW5nZSwgY29udGV4dCkge1xuICAgIGlmIChleHBhbmRSYW5nZSkge1xuICAgICAgICBzdWJzZXQgPSBleHBhbmRSZWN1cnJpbmcoc3Vic2V0LCBleHBhbmRSYW5nZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV2ZW50U3RvcmUsIHN1YnNldCk7XG59XG5mdW5jdGlvbiByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZXZlbnRTdG9yZSwgb2xkRGF0ZUVudiwgbmV3RGF0ZUVudikge1xuICAgIGxldCB7IGRlZnMgfSA9IGV2ZW50U3RvcmU7XG4gICAgbGV0IGluc3RhbmNlcyA9IG1hcEhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChkZWYuYWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7IC8vIGlzbid0IGRlcGVuZGVudCBvbiB0aW1lem9uZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc3RhbmNlKSwgeyByYW5nZToge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5zdGFydCwgaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8pKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLmVuZCwgaW5zdGFuY2UuZm9yY2VkRW5kVHpvKSksXG4gICAgICAgICAgICB9LCBmb3JjZWRTdGFydFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem86IG5ld0RhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCA/IG51bGwgOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8gfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgZGVmcywgaW5zdGFuY2VzIH07XG59XG5mdW5jdGlvbiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBzb3VyY2VJZCkge1xuICAgIHJldHVybiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCAoZXZlbnREZWYpID0+IGV2ZW50RGVmLnNvdXJjZUlkICE9PSBzb3VyY2VJZCk7XG59XG4vLyBRVUVTVElPTjogd2h5IG5vdCBqdXN0IHJldHVybiBpbnN0YW5jZXM/IGRvIGEgZ2VuZXJhbCBvYmplY3QtcHJvcGVydHktZXhjbHVzaW9uIHV0aWxcbmZ1bmN0aW9uIGV4Y2x1ZGVJbnN0YW5jZXMoZXZlbnRTdG9yZSwgcmVtb3ZhbHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiBldmVudFN0b3JlLmRlZnMsXG4gICAgICAgIGluc3RhbmNlczogZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlKSA9PiAhcmVtb3ZhbHNbaW5zdGFuY2UuaW5zdGFuY2VJZF0pLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZFB1YmxpY0lkTWFwcyhldmVudFN0b3JlKSB7XG4gICAgY29uc3QgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmU7XG4gICAgY29uc3QgZGVmSWRNYXAgPSB7fTtcbiAgICBjb25zdCBpbnN0YW5jZUlkTWFwID0ge307XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2RlZklkXTtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNJZCB9ID0gZGVmO1xuICAgICAgICBpZiAocHVibGljSWQpIHtcbiAgICAgICAgICAgIGRlZklkTWFwW3B1YmxpY0lkXSA9IGRlZklkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNJZCB9ID0gZGVmO1xuICAgICAgICBpZiAocHVibGljSWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlSWRNYXBbcHVibGljSWRdID0gaW5zdGFuY2VJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCB9O1xufVxuXG5jbGFzcyBFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnRoaXNDb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0VGhpc0NvbnRleHQodGhpc0NvbnRleHQpIHtcbiAgICAgICAgdGhpcy50aGlzQ29udGV4dCA9IHRoaXNDb250ZXh0O1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgb24odHlwZSwgaGFuZGxlcikge1xuICAgICAgICBhZGRUb0hhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIG9mZih0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHJlbW92ZUZyb21IYXNoKHRoaXMuaGFuZGxlcnMsIHR5cGUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICB0cmlnZ2VyKHR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGF0dGFjaGVkSGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW3R5cGVdIHx8IFtdO1xuICAgICAgICBsZXQgb3B0aW9uSGFuZGxlciA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV07XG4gICAgICAgIGxldCBoYW5kbGVycyA9IFtdLmNvbmNhdChvcHRpb25IYW5kbGVyIHx8IFtdLCBhdHRhY2hlZEhhbmRsZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLnRoaXNDb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNIYW5kbGVycyh0eXBlKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKCh0aGlzLmhhbmRsZXJzW3R5cGVdICYmIHRoaXMuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoKSB8fFxuICAgICAgICAgICAgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV0pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRUb0hhc2goaGFzaCwgdHlwZSwgaGFuZGxlcikge1xuICAgIChoYXNoW3R5cGVdIHx8IChoYXNoW3R5cGVdID0gW10pKVxuICAgICAgICAucHVzaChoYW5kbGVyKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUZyb21IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBpZiAoaGFzaFt0eXBlXSkge1xuICAgICAgICAgICAgaGFzaFt0eXBlXSA9IGhhc2hbdHlwZV0uZmlsdGVyKChmdW5jKSA9PiBmdW5jICE9PSBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbdHlwZV07IC8vIHJlbW92ZSBhbGwgaGFuZGxlciBmdW5jcyBmb3IgdGhpcyB0eXBlXG4gICAgfVxufVxuXG5jb25zdCBERUZfREVGQVVMVFMgPSB7XG4gICAgc3RhcnRUaW1lOiAnMDk6MDAnLFxuICAgIGVuZFRpbWU6ICcxNzowMCcsXG4gICAgZGF5c09mV2VlazogWzEsIDIsIDMsIDQsIDVdLFxuICAgIGRpc3BsYXk6ICdpbnZlcnNlLWJhY2tncm91bmQnLFxuICAgIGNsYXNzTmFtZXM6ICdmYy1ub24tYnVzaW5lc3MnLFxuICAgIGdyb3VwSWQ6ICdfYnVzaW5lc3NIb3VycycsIC8vIHNvIG11bHRpcGxlIGRlZnMgZ2V0IGdyb3VwZWRcbn07XG4vKlxuVE9ETzogcGFzcyBhcm91bmQgYXMgRXZlbnREZWZIYXNoISEhXG4qL1xuZnVuY3Rpb24gcGFyc2VCdXNpbmVzc0hvdXJzKGlucHV0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlRXZlbnRzKHJlZmluZUlucHV0cyhpbnB1dCksIG51bGwsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVmaW5lSW5wdXRzKGlucHV0KSB7XG4gICAgbGV0IHJhd0RlZnM7XG4gICAgaWYgKGlucHV0ID09PSB0cnVlKSB7XG4gICAgICAgIHJhd0RlZnMgPSBbe31dOyAvLyB3aWxsIGdldCBERUZfREVGQVVMVFMgdmVyYmF0aW1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgLy8gaWYgc3BlY2lmeWluZyBhbiBhcnJheSwgZXZlcnkgc3ViLWRlZmluaXRpb24gTkVFRFMgYSBkYXktb2Ytd2Vla1xuICAgICAgICByYXdEZWZzID0gaW5wdXQuZmlsdGVyKChyYXdEZWYpID0+IHJhd0RlZi5kYXlzT2ZXZWVrKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmF3RGVmcyA9IFtpbnB1dF07XG4gICAgfVxuICAgIGVsc2UgeyAvLyBpcyBwcm9iYWJseSBmYWxzZVxuICAgICAgICByYXdEZWZzID0gW107XG4gICAgfVxuICAgIHJhd0RlZnMgPSByYXdEZWZzLm1hcCgocmF3RGVmKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZfREVGQVVMVFMpLCByYXdEZWYpKSk7XG4gICAgcmV0dXJuIHJhd0RlZnM7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJEYXRlU2VsZWN0KHNlbGVjdGlvbiwgcGV2LCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3NlbGVjdCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KHNlbGVjdGlvbiwgY29udGV4dCkpLCB7IGpzRXZlbnQ6IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsLCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3IH0pKTtcbn1cbmZ1bmN0aW9uIHRyaWdnZXJEYXRlVW5zZWxlY3QocGV2LCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xuICAgICAgICBqc0V2ZW50OiBwZXYgPyBwZXYub3JpZ0V2ZW50IDogbnVsbCxcbiAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChkYXRlU3BhbiwgY29udGV4dCkge1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTcGFuVHJhbnNmb3Jtcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihwcm9wcywgYnVpbGREYXRlU3BhbkFwaShkYXRlU3BhbiwgY29udGV4dC5kYXRlRW52KSk7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuLy8gR2l2ZW4gYW4gZXZlbnQncyBhbGxEYXkgc3RhdHVzIGFuZCBzdGFydCBkYXRlLCByZXR1cm4gd2hhdCBpdHMgZmFsbGJhY2sgZW5kIGRhdGUgc2hvdWxkIGJlLlxuLy8gVE9ETzogcmVuYW1lIHRvIGNvbXB1dGVEZWZhdWx0RXZlbnRFbmRcbmZ1bmN0aW9uIGdldERlZmF1bHRFdmVudEVuZChhbGxEYXksIG1hcmtlciwgY29udGV4dCkge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGVuZCA9IG1hcmtlcjtcbiAgICBpZiAoYWxsRGF5KSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKTtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gYXBwbGllcyB0aGUgbXV0YXRpb24gdG8gQUxMIGRlZnMvaW5zdGFuY2VzIHdpdGhpbiB0aGUgZXZlbnQgc3RvcmVcbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRDb25maWdCYXNlLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCBldmVudENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoZXZlbnRTdG9yZS5kZWZzLCBldmVudENvbmZpZ0Jhc2UpO1xuICAgIGxldCBkZXN0ID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRTdG9yZS5kZWZzKSB7XG4gICAgICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmSWRdO1xuICAgICAgICBkZXN0LmRlZnNbZGVmSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZGVmLCBldmVudENvbmZpZ3NbZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gZXZlbnRTdG9yZS5pbnN0YW5jZXMpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIGxldCBkZWYgPSBkZXN0LmRlZnNbaW5zdGFuY2UuZGVmSWRdOyAvLyBpbXBvcnRhbnQgdG8gZ3JhYiB0aGUgbmV3bHkgbW9kaWZpZWQgZGVmXG4gICAgICAgIGRlc3QuaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShpbnN0YW5jZSwgZGVmLCBldmVudENvbmZpZ3NbaW5zdGFuY2UuZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZXZlbnREZWYsIGV2ZW50Q29uZmlnLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCBzdGFuZGFyZFByb3BzID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyB8fCB7fTtcbiAgICAvLyBpZiBoYXNFbmQgaGFzIG5vdCBiZWVuIHNwZWNpZmllZCwgZ3Vlc3MgYSBnb29kIHZhbHVlIGJhc2VkIG9uIGRlbHRhcy5cbiAgICAvLyBpZiBkdXJhdGlvbiB3aWxsIGNoYW5nZSwgdGhlcmUncyBubyB3YXkgdGhlIGRlZmF1bHQgZHVyYXRpb24gd2lsbCBwZXJzaXN0LFxuICAgIC8vIGFuZCB0aHVzLCB3ZSBuZWVkIHRvIG1hcmsgdGhlIGV2ZW50IGFzIGhhdmluZyBhIHJlYWwgZW5kXG4gICAgaWYgKHN0YW5kYXJkUHJvcHMuaGFzRW5kID09IG51bGwgJiZcbiAgICAgICAgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSAmJlxuICAgICAgICAobXV0YXRpb24uc3RhcnREZWx0YSB8fCBtdXRhdGlvbi5lbmREZWx0YSkpIHtcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSB0cnVlOyAvLyBUT0RPOiBpcyB0aGlzIG11dGF0aW9uIG9rYXk/XG4gICAgfVxuICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50RGVmKSwgc3RhbmRhcmRQcm9wcyksIHsgdWk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnREZWYudWkpLCBzdGFuZGFyZFByb3BzLnVpKSB9KTtcbiAgICBpZiAobXV0YXRpb24uZXh0ZW5kZWRQcm9wcykge1xuICAgICAgICBjb3B5LmV4dGVuZGVkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvcHkuZXh0ZW5kZWRQcm9wcyksIG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpO1xuICAgIH1cbiAgICBmb3IgKGxldCBhcHBsaWVyIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzKSB7XG4gICAgICAgIGFwcGxpZXIoY29weSwgbXV0YXRpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoIWNvcHkuaGFzRW5kICYmIGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24pIHtcbiAgICAgICAgY29weS5oYXNFbmQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50SW5zdGFuY2UoZXZlbnRJbnN0YW5jZSwgZXZlbnREZWYsIC8vIG11c3QgZmlyc3QgYmUgbW9kaWZpZWQgYnkgYXBwbHlNdXRhdGlvblRvRXZlbnREZWZcbmV2ZW50Q29uZmlnLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGZvcmNlQWxsRGF5ID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyAmJiBtdXRhdGlvbi5zdGFuZGFyZFByb3BzLmFsbERheSA9PT0gdHJ1ZTtcbiAgICBsZXQgY2xlYXJFbmQgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuaGFzRW5kID09PSBmYWxzZTtcbiAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50SW5zdGFuY2UpO1xuICAgIGlmIChmb3JjZUFsbERheSkge1xuICAgICAgICBjb3B5LnJhbmdlID0gY29tcHV0ZUFsaWduZWREYXlSYW5nZShjb3B5LnJhbmdlKTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLmRhdGVzRGVsdGEgJiYgZXZlbnRDb25maWcuc3RhcnRFZGl0YWJsZSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2Uuc3RhcnQsIG11dGF0aW9uLmRhdGVzRGVsdGEpLFxuICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLmVuZCwgbXV0YXRpb24uZGF0ZXNEZWx0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5zdGFydERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLnN0YXJ0LCBtdXRhdGlvbi5zdGFydERlbHRhKSxcbiAgICAgICAgICAgIGVuZDogY29weS5yYW5nZS5lbmQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5lbmREZWx0YSAmJiBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmVuZERlbHRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNsZWFyRW5kKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGVmLmFsbERheSwgY29weS5yYW5nZS5zdGFydCwgY29udGV4dCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGluIGNhc2UgZXZlbnQgd2FzIGFsbC1kYXkgYnV0IHRoZSBzdXBwbGllZCBkZWx0YXMgd2VyZSBub3RcbiAgICAvLyBiZXR0ZXIgdXRpbCBmb3IgdGhpcz9cbiAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRPZkRheShjb3B5LnJhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgIGVuZDogc3RhcnRPZkRheShjb3B5LnJhbmdlLmVuZCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGhhbmRsZSBpbnZhbGlkIGR1cmF0aW9uc1xuICAgIGlmIChjb3B5LnJhbmdlLmVuZCA8IGNvcHkucmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgY29weS5yYW5nZS5lbmQgPSBnZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5cbmNsYXNzIEV2ZW50U291cmNlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgaW50ZXJuYWxFdmVudFNvdXJjZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UgPSBpbnRlcm5hbEV2ZW50U291cmNlO1xuICAgIH1cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UX1NPVVJDRScsXG4gICAgICAgICAgICBzb3VyY2VJZDogdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmZXRjaCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJyxcbiAgICAgICAgICAgIHNvdXJjZUlkczogW3RoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZF0sXG4gICAgICAgICAgICBpc1JlZmV0Y2g6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UucHVibGljSWQ7XG4gICAgfVxuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UubWV0YS51cmw7XG4gICAgfVxuICAgIGdldCBmb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UubWV0YS5mb3JtYXQ7IC8vIFRPRE86IGJhZC4gbm90IGd1YXJhbnRlZWRcbiAgICB9XG59XG5cbmNsYXNzIEV2ZW50SW1wbCB7XG4gICAgLy8gaW5zdGFuY2Ugd2lsbCBiZSBudWxsIGlmIGV4cHJlc3NpbmcgYSByZWN1cnJpbmcgZXZlbnQgdGhhdCBoYXMgbm8gY3VycmVudCBpbnN0YW5jZXMsXG4gICAgLy8gT1IgaWYgdHJ5aW5nIHRvIHZhbGlkYXRlIGFuIGluY29taW5nIGV4dGVybmFsIGV2ZW50IHRoYXQgaGFzIG5vIGRhdGVzIGFzc2lnbmVkXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgZGVmLCBpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlIHx8IG51bGw7XG4gICAgfVxuICAgIC8qXG4gICAgVE9ETzogbWFrZSBldmVudCBzdHJ1Y3QgbW9yZSByZXNwb25zaWJsZSBmb3IgdGhpc1xuICAgICovXG4gICAgc2V0UHJvcChuYW1lLCB2YWwpIHtcbiAgICAgICAgaWYgKG5hbWUgaW4gRVZFTlRfREFURV9SRUZJTkVSUykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3Qgc2V0IGRhdGUtcmVsYXRlZCBwcm9wIFxcJ25hbWVcXCcuIFVzZSBvbmUgb2YgdGhlIGRhdGUtcmVsYXRlZCBtZXRob2RzIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHByb3BlciBhbGlhc2luZyBzeXN0ZW0/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgdmFsID0gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHB1YmxpY0lkOiB2YWwgfSwgLy8gaGFyZGNvZGVkIGludGVybmFsIG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgaW4gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpIHtcbiAgICAgICAgICAgIHZhbCA9IEVWRU5UX05PTl9EQVRFX1JFRklORVJTW25hbWVdKHZhbCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSBpbiBFVkVOVF9VSV9SRUZJTkVSUykge1xuICAgICAgICAgICAgbGV0IHVpID0gRVZFTlRfVUlfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IGJhY2tncm91bmRDb2xvcjogdmFsLCBib3JkZXJDb2xvcjogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnZWRpdGFibGUnKSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IHN0YXJ0RWRpdGFibGU6IHZhbCwgZHVyYXRpb25FZGl0YWJsZTogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgW25hbWVdOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHVpIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IHNldCBwcm9wICcke25hbWV9Jy4gVXNlIHNldEV4dGVuZGVkUHJvcCBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEV4dGVuZGVkUHJvcChuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0U3RhcnQoc3RhcnRJbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xuICAgICAgICBpZiAoc3RhcnQgJiYgdGhpcy5faW5zdGFuY2UpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2VSYW5nZSA9IHRoaXMuX2luc3RhbmNlLnJhbmdlO1xuICAgICAgICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpOyAvLyB3aGF0IGlmIHBhcnNlZCBiYWQhP1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRFbmQoZW5kSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgZW5kO1xuICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQsIGVuZCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBlbmREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wczogeyBoYXNFbmQ6IGZhbHNlIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RGF0ZXMoc3RhcnRJbnB1dCwgZW5kSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBvcHRpb25zLmFsbERheSB9O1xuICAgICAgICBsZXQgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KTtcbiAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFlbmQpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgICAgIC8vIHdoZW4gY29tcHV0aW5nIHRoZSBkaWZmIGZvciBhbiBldmVudCBiZWluZyBjb252ZXJ0ZWQgdG8gYWxsLWRheSxcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgZGlmZiBvZmYgb2YgdGhlIGFsbC1kYXkgdmFsdWVzIHRoZSB3YXkgZXZlbnQtbXV0YXRpb24gZG9lcy5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbERheSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlUmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGluc3RhbmNlUmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb25zRXF1YWwoc3RhcnREZWx0YSwgZW5kRGVsdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSwgZW5kRGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIG1lYW5zIFwiY2xlYXIgdGhlIGVuZFwiXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZVN0YXJ0KGRlbHRhSW5wdXQpIHtcbiAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogZGVsdGEgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZUVuZChkZWx0YUlucHV0KSB7XG4gICAgICAgIGxldCBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlRGF0ZXMoZGVsdGFJbnB1dCkge1xuICAgICAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcbiAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRBbGxEYXkoYWxsRGF5LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheSB9O1xuICAgICAgICBsZXQgeyBtYWludGFpbkR1cmF0aW9uIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAobWFpbnRhaW5EdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYWludGFpbkR1cmF0aW9uID0gdGhpcy5fY29udGV4dC5vcHRpb25zLmFsbERheU1haW50YWluRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5hbGxEYXkgIT09IGFsbERheSkge1xuICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBtYWludGFpbkR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wcyB9KTtcbiAgICB9XG4gICAgZm9ybWF0UmFuZ2UoZm9ybWF0SW5wdXQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIoZm9ybWF0SW5wdXQpO1xuICAgICAgICBpZiAodGhpcy5fZGVmLmhhc0VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLnJhbmdlLmVuZCwgZm9ybWF0dGVyLCB7XG4gICAgICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdXRhdGUobXV0YXRpb24pIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgbGV0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgICAgIGxldCB7IGV2ZW50U3RvcmUgfSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmUsIGluc3RhbmNlLmluc3RhbmNlSWQpO1xuICAgICAgICAgICAgbGV0IGV2ZW50Q29uZmlnQmFzZSA9IHtcbiAgICAgICAgICAgICAgICAnJzoge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGxldCBvbGRFdmVudCA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgZGVmLCBpbnN0YW5jZSk7IC8vIHNuYXBzaG90XG4gICAgICAgICAgICB0aGlzLl9kZWYgPSByZWxldmFudEV2ZW50cy5kZWZzW2RlZi5kZWZJZF07XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgb2xkRXZlbnQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGNvbnRleHQsIGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFU0VUX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlLCAvLyB0aGUgT1JJR0lOQUwgc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgYXNTdG9yZSA9IGV2ZW50QXBpVG9TdG9yZSh0aGlzKTtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBhc1N0b3JlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVtb3ZlJywge1xuICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFzU3RvcmUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgICAgbGV0IHsgc291cmNlSWQgfSA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKHNvdXJjZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbCh0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzW3NvdXJjZUlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlID9cbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZGF0ZUVudi50b0RhdGUodGhpcy5faW5zdGFuY2UucmFuZ2Uuc3RhcnQpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIGdldCBlbmQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkgP1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIGdldCBzdGFydFN0cigpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIHtcbiAgICAgICAgICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcbiAgICAgICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXQgZW5kU3RyKCkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIHRoaXMuX2RlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmRhdGVFbnYuZm9ybWF0SXNvKGluc3RhbmNlLnJhbmdlLmVuZCwge1xuICAgICAgICAgICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxuICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBjb21wdXRhYmxlIHByb3BzIHRoYXQgYWxsIGFjY2VzcyB0aGUgZGVmXG4gICAgLy8gVE9ETzogZmluZCBhIFR5cGVTY3JpcHQtY29tcGF0aWJsZSB3YXkgdG8gZG8gdGhpcyBhdCBzY2FsZVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuX2RlZi5wdWJsaWNJZDsgfVxuICAgIGdldCBncm91cElkKCkgeyByZXR1cm4gdGhpcy5fZGVmLmdyb3VwSWQ7IH1cbiAgICBnZXQgYWxsRGF5KCkgeyByZXR1cm4gdGhpcy5fZGVmLmFsbERheTsgfVxuICAgIGdldCB0aXRsZSgpIHsgcmV0dXJuIHRoaXMuX2RlZi50aXRsZTsgfVxuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLl9kZWYudXJsOyB9XG4gICAgZ2V0IGRpc3BsYXkoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZGlzcGxheSB8fCAnYXV0byc7IH0gLy8gYmFkLiBqdXN0IG5vcm1hbGl6ZSB0aGUgdHlwZSBlYXJsaWVyXG4gICAgZ2V0IHN0YXJ0RWRpdGFibGUoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuc3RhcnRFZGl0YWJsZTsgfVxuICAgIGdldCBkdXJhdGlvbkVkaXRhYmxlKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmR1cmF0aW9uRWRpdGFibGU7IH1cbiAgICBnZXQgY29uc3RyYWludCgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jb25zdHJhaW50c1swXSB8fCBudWxsOyB9XG4gICAgZ2V0IG92ZXJsYXAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkub3ZlcmxhcDsgfVxuICAgIGdldCBhbGxvdygpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5hbGxvd3NbMF0gfHwgbnVsbDsgfVxuICAgIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYmFja2dyb3VuZENvbG9yOyB9XG4gICAgZ2V0IGJvcmRlckNvbG9yKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmJvcmRlckNvbG9yOyB9XG4gICAgZ2V0IHRleHRDb2xvcigpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS50ZXh0Q29sb3I7IH1cbiAgICAvLyBOT1RFOiB1c2VyIGNhbid0IG1vZGlmeSB0aGVzZSBiZWNhdXNlIE9iamVjdC5mcmVlemUgd2FzIGNhbGxlZCBpbiBldmVudC1kZWYgcGFyc2luZ1xuICAgIGdldCBjbGFzc05hbWVzKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNsYXNzTmFtZXM7IH1cbiAgICBnZXQgZXh0ZW5kZWRQcm9wcygpIHsgcmV0dXJuIHRoaXMuX2RlZi5leHRlbmRlZFByb3BzOyB9XG4gICAgdG9QbGFpbk9iamVjdChzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIGxldCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGxldCB7IHVpIH0gPSBkZWY7XG4gICAgICAgIGxldCB7IHN0YXJ0U3RyLCBlbmRTdHIgfSA9IHRoaXM7XG4gICAgICAgIGxldCByZXMgPSB7XG4gICAgICAgICAgICBhbGxEYXk6IGRlZi5hbGxEYXksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWYudGl0bGUpIHtcbiAgICAgICAgICAgIHJlcy50aXRsZSA9IGRlZi50aXRsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRTdHIpIHtcbiAgICAgICAgICAgIHJlcy5zdGFydCA9IHN0YXJ0U3RyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRTdHIpIHtcbiAgICAgICAgICAgIHJlcy5lbmQgPSBlbmRTdHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5wdWJsaWNJZCkge1xuICAgICAgICAgICAgcmVzLmlkID0gZGVmLnB1YmxpY0lkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xuICAgICAgICAgICAgcmVzLmdyb3VwSWQgPSBkZWYuZ3JvdXBJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLnVybCkge1xuICAgICAgICAgICAgcmVzLnVybCA9IGRlZi51cmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLmRpc3BsYXkgJiYgdWkuZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICByZXMuZGlzcGxheSA9IHVpLmRpc3BsYXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogd2hhdCBhYm91dCByZWN1cnJpbmctZXZlbnQgcHJvcGVydGllcz8/P1xuICAgICAgICAvLyBUT0RPOiBpbmNsdWRlIHN0YXJ0RWRpdGFibGUvZHVyYXRpb25FZGl0YWJsZS9jb25zdHJhaW50L292ZXJsYXAvYWxsb3dcbiAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlQ29sb3IgJiYgdWkuYmFja2dyb3VuZENvbG9yICYmIHVpLmJhY2tncm91bmRDb2xvciA9PT0gdWkuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIHJlcy5jb2xvciA9IHVpLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh1aS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgICAgICByZXMuYmFja2dyb3VuZENvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVpLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgcmVzLmJvcmRlckNvbG9yID0gdWkuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLnRleHRDb2xvcikge1xuICAgICAgICAgICAgcmVzLnRleHRDb2xvciA9IHVpLnRleHRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodWkuY2xhc3NOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcy5jbGFzc05hbWVzID0gdWkuY2xhc3NOYW1lcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVmLmV4dGVuZGVkUHJvcHMpLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlRXh0ZW5kZWRQcm9wcykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBkZWYuZXh0ZW5kZWRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMuZXh0ZW5kZWRQcm9wcyA9IGRlZi5leHRlbmRlZFByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9QbGFpbk9iamVjdCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV2ZW50QXBpVG9TdG9yZShldmVudEFwaSkge1xuICAgIGxldCBkZWYgPSBldmVudEFwaS5fZGVmO1xuICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50QXBpLl9pbnN0YW5jZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiB7IFtkZWYuZGVmSWRdOiBkZWYgfSxcbiAgICAgICAgaW5zdGFuY2VzOiBpbnN0YW5jZVxuICAgICAgICAgICAgPyB7IFtpbnN0YW5jZS5pbnN0YW5jZUlkXTogaW5zdGFuY2UgfVxuICAgICAgICAgICAgOiB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCwgZXhjbHVkZUluc3RhbmNlKSB7XG4gICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgIGxldCBldmVudEFwaXMgPSBbXTtcbiAgICBsZXQgZXhjbHVkZUluc3RhbmNlSWQgPSBleGNsdWRlSW5zdGFuY2UgPyBleGNsdWRlSW5zdGFuY2UuaW5zdGFuY2VJZCA6ICcnO1xuICAgIGZvciAobGV0IGlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaWRdO1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChpbnN0YW5jZS5pbnN0YW5jZUlkICE9PSBleGNsdWRlSW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgZXZlbnRBcGlzLnB1c2gobmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50QXBpcztcbn1cblxuLypcblNwZWNpZnlpbmcgbmV4dERheVRocmVzaG9sZCBzaWduYWxzIHRoYXQgYWxsLWRheSByYW5nZXMgc2hvdWxkIGJlIHNsaWNlZC5cbiovXG5mdW5jdGlvbiBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBmcmFtaW5nUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIHtcbiAgICBsZXQgaW52ZXJzZUJnQnlHcm91cElkID0ge307XG4gICAgbGV0IGludmVyc2VCZ0J5RGVmSWQgPSB7fTtcbiAgICBsZXQgZGVmQnlHcm91cElkID0ge307XG4gICAgbGV0IGJnUmFuZ2VzID0gW107XG4gICAgbGV0IGZnUmFuZ2VzID0gW107XG4gICAgbGV0IGV2ZW50VWlzID0gY29tcGlsZUV2ZW50VWlzKGV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaUJhc2VzKTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XG4gICAgICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIGlmICh1aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICghZGVmQnlHcm91cElkW2RlZi5ncm91cElkXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gZGVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIGxldCBvcmlnUmFuZ2UgPSBpbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgbGV0IG5vcm1hbFJhbmdlID0gKCFkZWYuYWxsRGF5ICYmIG5leHREYXlUaHJlc2hvbGQpID9cbiAgICAgICAgICAgIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2Uob3JpZ1JhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSA6XG4gICAgICAgICAgICBvcmlnUmFuZ2U7XG4gICAgICAgIGxldCBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhub3JtYWxSYW5nZSwgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgaWYgKHNsaWNlZFJhbmdlKSB7XG4gICAgICAgICAgICBpZiAodWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXS5wdXNoKHNsaWNlZFJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbaW5zdGFuY2UuZGVmSWRdLnB1c2goc2xpY2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVpLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICh1aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgPyBiZ1JhbmdlcyA6IGZnUmFuZ2VzKS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmLFxuICAgICAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogbm9ybWFsUmFuZ2Uuc3RhcnQgJiYgbm9ybWFsUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBzbGljZWRSYW5nZS5zdGFydC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBub3JtYWxSYW5nZS5lbmQgJiYgbm9ybWFsUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gc2xpY2VkUmFuZ2UuZW5kLnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBncm91cElkIGluIGludmVyc2VCZ0J5R3JvdXBJZCkgeyAvLyBCWSBHUk9VUFxuICAgICAgICBsZXQgcmFuZ2VzID0gaW52ZXJzZUJnQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBpbnZlcnRSYW5nZXMocmFuZ2VzLCBmcmFtaW5nUmFuZ2UpO1xuICAgICAgICBmb3IgKGxldCBpbnZlcnRlZFJhbmdlIG9mIGludmVydGVkUmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICAgICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcbiAgICAgICAgICAgIGJnUmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRlZixcbiAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBkZWZJZCBpbiBpbnZlcnNlQmdCeURlZklkKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBpbnZlcnNlQmdCeURlZklkW2RlZklkXTtcbiAgICAgICAgbGV0IGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgZm9yIChsZXQgaW52ZXJ0ZWRSYW5nZSBvZiBpbnZlcnRlZFJhbmdlcykge1xuICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGVmOiBldmVudFN0b3JlLmRlZnNbZGVmSWRdLFxuICAgICAgICAgICAgICAgIHVpOiBldmVudFVpc1tkZWZJZF0sXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGludmVydGVkUmFuZ2UsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYmc6IGJnUmFuZ2VzLCBmZzogZmdSYW5nZXMgfTtcbn1cbmZ1bmN0aW9uIGhhc0JnUmVuZGVyaW5nKGRlZikge1xuICAgIHJldHVybiBkZWYudWkuZGlzcGxheSA9PT0gJ2JhY2tncm91bmQnIHx8IGRlZi51aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcbn1cbmZ1bmN0aW9uIHNldEVsU2VnKGVsLCBzZWcpIHtcbiAgICBlbC5mY1NlZyA9IHNlZztcbn1cbmZ1bmN0aW9uIGdldEVsU2VnKGVsKSB7XG4gICAgcmV0dXJuIGVsLmZjU2VnIHx8XG4gICAgICAgIGVsLnBhcmVudE5vZGUuZmNTZWcgfHwgLy8gZm9yIHRoZSBoYXJuZXNzXG4gICAgICAgIG51bGw7XG59XG4vLyBldmVudCB1aSBjb21wdXRhdGlvblxuZnVuY3Rpb24gY29tcGlsZUV2ZW50VWlzKGV2ZW50RGVmcywgZXZlbnRVaUJhc2VzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goZXZlbnREZWZzLCAoZXZlbnREZWYpID0+IGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpKTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpIHtcbiAgICBsZXQgdWlzID0gW107XG4gICAgaWYgKGV2ZW50VWlCYXNlc1snJ10pIHtcbiAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzWycnXSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpQmFzZXNbZXZlbnREZWYuZGVmSWRdKSB7XG4gICAgICAgIHVpcy5wdXNoKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pO1xuICAgIH1cbiAgICB1aXMucHVzaChldmVudERlZi51aSk7XG4gICAgcmV0dXJuIGNvbWJpbmVFdmVudFVpcyh1aXMpO1xufVxuZnVuY3Rpb24gc29ydEV2ZW50U2VncyhzZWdzLCBldmVudE9yZGVyU3BlY3MpIHtcbiAgICBsZXQgb2JqcyA9IHNlZ3MubWFwKGJ1aWxkU2VnQ29tcGFyZU9iaik7XG4gICAgb2Jqcy5zb3J0KChvYmowLCBvYmoxKSA9PiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajAsIG9iajEsIGV2ZW50T3JkZXJTcGVjcykpO1xuICAgIHJldHVybiBvYmpzLm1hcCgoYykgPT4gYy5fc2VnKTtcbn1cbi8vIHJldHVybnMgYSBvYmplY3Qgd2l0aCBhbGwgcHJpbWl0aXZlIHByb3BzIHRoYXQgY2FuIGJlIGNvbXBhcmVkXG5mdW5jdGlvbiBidWlsZFNlZ0NvbXBhcmVPYmooc2VnKSB7XG4gICAgbGV0IHsgZXZlbnRSYW5nZSB9ID0gc2VnO1xuICAgIGxldCBldmVudERlZiA9IGV2ZW50UmFuZ2UuZGVmO1xuICAgIGxldCByYW5nZSA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UgPyBldmVudFJhbmdlLmluc3RhbmNlLnJhbmdlIDogZXZlbnRSYW5nZS5yYW5nZTtcbiAgICBsZXQgc3RhcnQgPSByYW5nZS5zdGFydCA/IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA6IDA7IC8vIFRPRE86IGJldHRlciBzdXBwb3J0IGZvciBvcGVuLXJhbmdlIGV2ZW50c1xuICAgIGxldCBlbmQgPSByYW5nZS5lbmQgPyByYW5nZS5lbmQudmFsdWVPZigpIDogMDsgLy8gXCJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50RGVmLmV4dGVuZGVkUHJvcHMpLCBldmVudERlZiksIHsgaWQ6IGV2ZW50RGVmLnB1YmxpY0lkLCBzdGFydCxcbiAgICAgICAgZW5kLCBkdXJhdGlvbjogZW5kIC0gc3RhcnQsIGFsbERheTogTnVtYmVyKGV2ZW50RGVmLmFsbERheSksIF9zZWc6IHNlZyB9KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgcGx1Z2luSG9va3MgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHRyYW5zZm9ybWVycyA9IHBsdWdpbkhvb2tzLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzO1xuICAgIGxldCB7IGRlZiwgdWkgfSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIGxldCB2YWwgPSB1aS5zdGFydEVkaXRhYmxlO1xuICAgIGZvciAobGV0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xuICAgICAgICB2YWwgPSB0cmFuc2Zvcm1lcih2YWwsIGRlZiwgdWksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZywgY29udGV4dCkge1xuICAgIHJldHVybiBzZWcuaXNTdGFydCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlICYmIGNvbnRleHQub3B0aW9ucy5ldmVudFJlc2l6YWJsZUZyb21TdGFydDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdFbmRSZXNpemFibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNlZy5pc0VuZCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlO1xufVxuZnVuY3Rpb24gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLCAvLyBkZWZhdWx0cyB0byB0cnVlXG5kZWZhdWx0RGlzcGxheUV2ZW50RW5kLCAvLyBkZWZhdWx0cyB0byB0cnVlXG5zdGFydE92ZXJyaWRlLCBlbmRPdmVycmlkZSkge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZGlzcGxheUV2ZW50VGltZSwgZGlzcGxheUV2ZW50RW5kIH0gPSBvcHRpb25zO1xuICAgIGxldCBldmVudERlZiA9IHNlZy5ldmVudFJhbmdlLmRlZjtcbiAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgIGlmIChkaXNwbGF5RXZlbnRUaW1lID09IG51bGwpIHtcbiAgICAgICAgZGlzcGxheUV2ZW50VGltZSA9IGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lICE9PSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlFdmVudEVuZCA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BsYXlFdmVudEVuZCA9IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgIT09IGZhbHNlO1xuICAgIH1cbiAgICBsZXQgd2hvbGVFdmVudFN0YXJ0ID0gZXZlbnRJbnN0YW5jZS5yYW5nZS5zdGFydDtcbiAgICBsZXQgd2hvbGVFdmVudEVuZCA9IGV2ZW50SW5zdGFuY2UucmFuZ2UuZW5kO1xuICAgIGxldCBzZWdTdGFydCA9IHN0YXJ0T3ZlcnJpZGUgfHwgc2VnLnN0YXJ0IHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0O1xuICAgIGxldCBzZWdFbmQgPSBlbmRPdmVycmlkZSB8fCBzZWcuZW5kIHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLmVuZDtcbiAgICBsZXQgaXNTdGFydERheSA9IHN0YXJ0T2ZEYXkod2hvbGVFdmVudFN0YXJ0KS52YWx1ZU9mKCkgPT09IHN0YXJ0T2ZEYXkoc2VnU3RhcnQpLnZhbHVlT2YoKTtcbiAgICBsZXQgaXNFbmREYXkgPSBzdGFydE9mRGF5KGFkZE1zKHdob2xlRXZlbnRFbmQsIC0xKSkudmFsdWVPZigpID09PSBzdGFydE9mRGF5KGFkZE1zKHNlZ0VuZCwgLTEpKS52YWx1ZU9mKCk7XG4gICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgJiYgIWV2ZW50RGVmLmFsbERheSAmJiAoaXNTdGFydERheSB8fCBpc0VuZERheSkpIHtcbiAgICAgICAgc2VnU3RhcnQgPSBpc1N0YXJ0RGF5ID8gd2hvbGVFdmVudFN0YXJ0IDogc2VnU3RhcnQ7XG4gICAgICAgIHNlZ0VuZCA9IGlzRW5kRGF5ID8gd2hvbGVFdmVudEVuZCA6IHNlZ0VuZDtcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudEVuZCAmJiBldmVudERlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHNlZ1N0YXJ0LCBzZWdFbmQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogZW5kT3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoc2VnU3RhcnQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgIGZvcmNlZFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCAvLyBub29vb28sIHNhbWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSB7XG4gICAgbGV0IHNlZ1JhbmdlID0gc2VnLmV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNQYXN0OiBzZWdSYW5nZS5lbmQgPD0gKG5vd0RhdGUgfHwgdG9kYXlSYW5nZS5zdGFydCksXG4gICAgICAgIGlzRnV0dXJlOiBzZWdSYW5nZS5zdGFydCA+PSAobm93RGF0ZSB8fCB0b2RheVJhbmdlLmVuZCksXG4gICAgICAgIGlzVG9kYXk6IHRvZGF5UmFuZ2UgJiYgcmFuZ2VDb250YWluc01hcmtlcih0b2RheVJhbmdlLCBzZWdSYW5nZS5zdGFydCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50Q2xhc3NOYW1lcyhwcm9wcykge1xuICAgIGxldCBjbGFzc05hbWVzID0gWydmYy1ldmVudCddO1xuICAgIGlmIChwcm9wcy5pc01pcnJvcikge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LW1pcnJvcicpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNEcmFnZ2FibGUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1kcmFnZ2FibGUnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU3RhcnRSZXNpemFibGUgfHwgcHJvcHMuaXNFbmRSZXNpemFibGUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1yZXNpemFibGUnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1kcmFnZ2luZycpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNSZXNpemluZykge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6aW5nJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1NlbGVjdGVkKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtc2VsZWN0ZWQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU3RhcnQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1zdGFydCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNFbmQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1lbmQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzUGFzdCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXBhc3QnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzVG9kYXkpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC10b2RheScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNGdXR1cmUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1mdXR1cmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50UmFuZ2VLZXkoZXZlbnRSYW5nZSkge1xuICAgIHJldHVybiBldmVudFJhbmdlLmluc3RhbmNlXG4gICAgICAgID8gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXG4gICAgICAgIDogYCR7ZXZlbnRSYW5nZS5kZWYuZGVmSWR9OiR7ZXZlbnRSYW5nZS5yYW5nZS5zdGFydC50b0lTT1N0cmluZygpfWA7XG4gICAgLy8gaW52ZXJzZS1iYWNrZ3JvdW5kIGV2ZW50cyBkb24ndCBoYXZlIHNwZWNpZmljIGluc3RhbmNlcy4gVE9ETzogYmV0dGVyIHNvbHV0aW9uXG59XG5mdW5jdGlvbiBnZXRTZWdBbmNob3JBdHRycyhzZWcsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBkZWYsIGluc3RhbmNlIH0gPSBzZWcuZXZlbnRSYW5nZTtcbiAgICBsZXQgeyB1cmwgfSA9IGRlZjtcbiAgICBpZiAodXJsKSB7XG4gICAgICAgIHJldHVybiB7IGhyZWY6IHVybCB9O1xuICAgIH1cbiAgICBsZXQgeyBlbWl0dGVyLCBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCB7IGV2ZW50SW50ZXJhY3RpdmUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGV2ZW50SW50ZXJhY3RpdmUgPT0gbnVsbCkge1xuICAgICAgICBldmVudEludGVyYWN0aXZlID0gZGVmLmludGVyYWN0aXZlO1xuICAgICAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBldmVudEludGVyYWN0aXZlID0gQm9vbGVhbihlbWl0dGVyLmhhc0hhbmRsZXJzKCdldmVudENsaWNrJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG1vY2sgd2hhdCBoYXBwZW5zIGluIEV2ZW50Q2xpY2tpbmdcbiAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSkge1xuICAgICAgICAvLyBvbmx5IGF0dGFjaCBrZXlib2FyZC1yZWxhdGVkIGhhbmRsZXJzIGJlY2F1c2UgY2xpY2sgaGFuZGxlciBpcyBhbHJlYWR5IGRvbmUgaW4gRXZlbnRDbGlja2luZ1xuICAgICAgICByZXR1cm4gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoKGV2KSA9PiB7XG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2xpY2snLCB7XG4gICAgICAgICAgICAgICAgZWw6IGV2LnRhcmdldCxcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn1cblxuY29uc3QgU1RBTkRBUkRfUFJPUFMgPSB7XG4gICAgc3RhcnQ6IGlkZW50aXR5LFxuICAgIGVuZDogaWRlbnRpdHksXG4gICAgYWxsRGF5OiBCb29sZWFuLFxufTtcbmZ1bmN0aW9uIHBhcnNlRGF0ZVNwYW4ocmF3LCBkYXRlRW52LCBkZWZhdWx0RHVyYXRpb24pIHtcbiAgICBsZXQgc3BhbiA9IHBhcnNlT3BlbkRhdGVTcGFuKHJhdywgZGF0ZUVudik7XG4gICAgbGV0IHsgcmFuZ2UgfSA9IHNwYW47XG4gICAgaWYgKCFyYW5nZS5zdGFydCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyYW5nZS5lbmQpIHtcbiAgICAgICAgaWYgKGRlZmF1bHREdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByYW5nZS5lbmQgPSBkYXRlRW52LmFkZChyYW5nZS5zdGFydCwgZGVmYXVsdER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwYW47XG59XG4vKlxuVE9ETzogc29tZWhvdyBjb21iaW5lIHdpdGggcGFyc2VSYW5nZT9cbldpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHN0YXJ0L2VuZCBwcm9wcyB3ZXJlIHByZXNlbnQgYnV0IHBhcnNlZCBpbnZhbGlkbHkuXG4qL1xuZnVuY3Rpb24gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KSB7XG4gICAgbGV0IHsgcmVmaW5lZDogc3RhbmRhcmRQcm9wcywgZXh0cmEgfSA9IHJlZmluZVByb3BzKHJhdywgU1RBTkRBUkRfUFJPUFMpO1xuICAgIGxldCBzdGFydE1ldGEgPSBzdGFuZGFyZFByb3BzLnN0YXJ0ID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuc3RhcnQpIDogbnVsbDtcbiAgICBsZXQgZW5kTWV0YSA9IHN0YW5kYXJkUHJvcHMuZW5kID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuZW5kKSA6IG51bGw7XG4gICAgbGV0IHsgYWxsRGF5IH0gPSBzdGFuZGFyZFByb3BzO1xuICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICBhbGxEYXkgPSAoc3RhcnRNZXRhICYmIHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcbiAgICAgICAgICAgICghZW5kTWV0YSB8fCBlbmRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyByYW5nZToge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5tYXJrZXIgOiBudWxsLFxuICAgICAgICAgICAgZW5kOiBlbmRNZXRhID8gZW5kTWV0YS5tYXJrZXIgOiBudWxsLFxuICAgICAgICB9LCBhbGxEYXkgfSwgZXh0cmEpO1xufVxuZnVuY3Rpb24gaXNEYXRlU3BhbnNFcXVhbChzcGFuMCwgc3BhbjEpIHtcbiAgICByZXR1cm4gcmFuZ2VzRXF1YWwoc3BhbjAucmFuZ2UsIHNwYW4xLnJhbmdlKSAmJlxuICAgICAgICBzcGFuMC5hbGxEYXkgPT09IHNwYW4xLmFsbERheSAmJlxuICAgICAgICBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wLCBzcGFuMSk7XG59XG4vLyB0aGUgTk9OLURBVEUtUkVMQVRFRCBwcm9wc1xuZnVuY3Rpb24gaXNTcGFuUHJvcHNFcXVhbChzcGFuMCwgc3BhbjEpIHtcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBzcGFuMSkge1xuICAgICAgICBpZiAocHJvcE5hbWUgIT09ICdyYW5nZScgJiYgcHJvcE5hbWUgIT09ICdhbGxEYXknKSB7XG4gICAgICAgICAgICBpZiAoc3BhbjBbcHJvcE5hbWVdICE9PSBzcGFuMVtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYXJlIHRoZXJlIGFueSBwcm9wcyB0aGF0IHNwYW4wIGhhcyB0aGF0IHNwYW4xIERPRVNOJ1QgaGF2ZT9cbiAgICAvLyBib3RoIGhhdmUgcmFuZ2UvYWxsRGF5LCBzbyBubyBuZWVkIHRvIHNwZWNpYWwtY2FzZS5cbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBzcGFuMCkge1xuICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiBzcGFuMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVNwYW5BcGkoc3BhbiwgZGF0ZUVudikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkoc3Bhbi5yYW5nZSwgZGF0ZUVudiwgc3Bhbi5hbGxEYXkpKSwgeyBhbGxEYXk6IHNwYW4uYWxsRGF5IH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkpLCB7IHRpbWVab25lOiBkYXRlRW52LnRpbWVab25lIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSYW5nZUFwaShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxuICAgICAgICBlbmQ6IGRhdGVFbnYudG9EYXRlKHJhbmdlLmVuZCksXG4gICAgICAgIHN0YXJ0U3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCwgeyBvbWl0VGltZSB9KSxcbiAgICAgICAgZW5kU3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQsIHsgb21pdFRpbWUgfSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZhYnJpY2F0ZUV2ZW50UmFuZ2UoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29udGV4dCkge1xuICAgIGxldCByZXMgPSByZWZpbmVFdmVudERlZih7IGVkaXRhYmxlOiBmYWxzZSB9LCBjb250ZXh0KTtcbiAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZXMucmVmaW5lZCwgcmVzLmV4dHJhLCAnJywgLy8gc291cmNlSWRcbiAgICBkYXRlU3Bhbi5hbGxEYXksIHRydWUsIC8vIGhhc0VuZFxuICAgIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZixcbiAgICAgICAgdWk6IGNvbXBpbGVFdmVudFVpKGRlZiwgZXZlbnRVaUJhc2VzKSxcbiAgICAgICAgaW5zdGFuY2U6IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBkYXRlU3Bhbi5yYW5nZSksXG4gICAgICAgIHJhbmdlOiBkYXRlU3Bhbi5yYW5nZSxcbiAgICAgICAgaXNTdGFydDogdHJ1ZSxcbiAgICAgICAgaXNFbmQ6IHRydWUsXG4gICAgfTtcbn1cblxuLypcbmdpdmVuIGEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyBhIHJlc3VsdCBhc3luY2hyb25vdXNseS5cbnRoZSBmdW5jdGlvbiBjYW4gZWl0aGVyIGNhbGwgcGFzc2VkLWluIHN1Y2Nlc3MgYW5kIGZhaWx1cmUgY2FsbGJhY2tzLFxub3IgaXQgY2FuIHJldHVybiBhIHByb21pc2UuXG5pZiB5b3UgbmVlZCB0byBwYXNzIGFkZGl0aW9uYWwgcGFyYW1zIHRvIGZ1bmMsIGJpbmQgdGhlbSBmaXJzdC5cbiovXG5mdW5jdGlvbiB1bnByb21pc2lmeShmdW5jLCBub3JtYWxpemVkU3VjY2Vzc0NhbGxiYWNrLCBub3JtYWxpemVkRmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCBzdWNjZXNzL2ZhaWx1cmUgY2FsbGJhY2tzIGJlaW5nIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICAgIC8vIGFuZCBndWFyZCBhZ2FpbnN0IGEgcHJvbWlzZSBBTkQgY2FsbGJhY2sgYmVpbmcgdXNlZCB0b2dldGhlci5cbiAgICBsZXQgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgIGxldCB3cmFwcGVkU3VjY2VzcyA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRTdWNjZXNzQ2FsbGJhY2socmVzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHdyYXBwZWRGYWlsdXJlID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBub3JtYWxpemVkRmFpbHVyZUNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHJlcyA9IGZ1bmMod3JhcHBlZFN1Y2Nlc3MsIHdyYXBwZWRGYWlsdXJlKTtcbiAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMudGhlbih3cmFwcGVkU3VjY2Vzcywgd3JhcHBlZEZhaWx1cmUpO1xuICAgIH1cbn1cblxuY2xhc3MgSnNvblJlcXVlc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZXNwb25zZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVlc3RKc29uKG1ldGhvZCwgdXJsLCBwYXJhbXMpIHtcbiAgICBtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZCxcbiAgICB9O1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICtcbiAgICAgICAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZldGNoT3B0aW9ucy5ib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoKHVybCwgZmV0Y2hPcHRpb25zKS50aGVuKChmZXRjaFJlcykgPT4ge1xuICAgICAgICBpZiAoZmV0Y2hSZXMub2spIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFJlcy5qc29uKCkudGhlbigocGFyc2VkUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3BhcnNlZFJlc3BvbnNlLCBmZXRjaFJlc107XG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25SZXF1ZXN0RXJyb3IoJ0ZhaWx1cmUgcGFyc2luZyBKU09OJywgZmV0Y2hSZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSnNvblJlcXVlc3RFcnJvcignUmVxdWVzdCBmYWlsZWQnLCBmZXRjaFJlcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxubGV0IGNhblZHcm93V2l0aGluQ2VsbDtcbmZ1bmN0aW9uIGdldENhblZHcm93V2l0aGluQ2VsbCgpIHtcbiAgICBpZiAoY2FuVkdyb3dXaXRoaW5DZWxsID09IG51bGwpIHtcbiAgICAgICAgY2FuVkdyb3dXaXRoaW5DZWxsID0gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuVkdyb3dXaXRoaW5DZWxsO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpIHtcbiAgICAvLyBmb3IgU1NSLCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgY2FsbCBpbW1lZGlhdGVseSBhdCB0b3AtbGV2ZWxcbiAgICAvLyBUT0RPOiBqdXN0IG1ha2UgdGhpcyBsb2dpYyBleGVjdXRlIHRvcC1sZXZlbCwgaW1tZWRpYXRlbHksIGluc3RlYWQgb2YgZG9pbmcgbGF6aWx5XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbC5zdHlsZS50b3AgPSAnMHB4JztcbiAgICBlbC5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgZWwuaW5uZXJIVE1MID0gJzx0YWJsZT48dHI+PHRkPjxkaXY+PC9kaXY+PC90ZD48L3RyPjwvdGFibGU+JztcbiAgICBlbC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpLnN0eWxlLmhlaWdodCA9ICcxMDBweCc7XG4gICAgZWwucXVlcnlTZWxlY3RvcignZGl2Jykuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIGxldCBkaXYgPSBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcbiAgICBsZXQgcG9zc2libGUgPSBkaXYub2Zmc2V0SGVpZ2h0ID4gMDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gcG9zc2libGU7XG59XG5cbmNsYXNzIENhbGVuZGFyUm9vdCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZm9yUHJpbnQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUJlZm9yZVByaW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZm9yUHJpbnQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVBZnRlclByaW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZm9yUHJpbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgeyBmb3JQcmludCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IGlzSGVpZ2h0QXV0byA9IGZvclByaW50IHx8IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy5jb250ZW50SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgICAgIGxldCBoZWlnaHQgPSAoIWlzSGVpZ2h0QXV0byAmJiBvcHRpb25zLmhlaWdodCAhPSBudWxsKSA/IG9wdGlvbnMuaGVpZ2h0IDogJyc7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjJyxcbiAgICAgICAgICAgIGZvclByaW50ID8gJ2ZjLW1lZGlhLXByaW50JyA6ICdmYy1tZWRpYS1zY3JlZW4nLFxuICAgICAgICAgICAgYGZjLWRpcmVjdGlvbi0ke29wdGlvbnMuZGlyZWN0aW9ufWAsXG4gICAgICAgICAgICBwcm9wcy50aGVtZS5nZXRDbGFzcygncm9vdCcpLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoIWdldENhblZHcm93V2l0aGluQ2VsbCgpKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWxpcXVpZC1oYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBsZXQgeyBlbWl0dGVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBlbWl0dGVyLm9uKCdfYmVmb3JlcHJpbnQnLCB0aGlzLmhhbmRsZUJlZm9yZVByaW50KTtcbiAgICAgICAgZW1pdHRlci5vbignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgZW1pdHRlci5vZmYoJ19iZWZvcmVwcmludCcsIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQpO1xuICAgICAgICBlbWl0dGVyLm9mZignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xuICAgIH1cbn1cblxuY2xhc3MgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xuICAgICAgICB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkID0gc2V0dGluZ3MuaXNIaXRDb21ib0FsbG93ZWQgfHwgbnVsbDtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MoY29tcG9uZW50LCBpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgZWw6IGlucHV0LmVsLFxuICAgICAgICB1c2VFdmVudENlbnRlcjogaW5wdXQudXNlRXZlbnRDZW50ZXIgIT0gbnVsbCA/IGlucHV0LnVzZUV2ZW50Q2VudGVyIDogdHJ1ZSxcbiAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IGlucHV0LmlzSGl0Q29tYm9BbGxvd2VkIHx8IG51bGwsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW3NldHRpbmdzLmNvbXBvbmVudC51aWRdOiBzZXR0aW5ncyxcbiAgICB9O1xufVxuLy8gZ2xvYmFsIHN0YXRlXG5jb25zdCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUgPSB7fTtcblxuY2xhc3MgQ2FsZW5kYXJJbXBsIHtcbiAgICBnZXRDdXJyZW50RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmdldEN1cnJlbnREYXRhKCk7XG4gICAgfVxuICAgIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5kaXNwYXRjaChhY3Rpb24pO1xuICAgIH1cbiAgICBnZXQgdmlldygpIHsgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3QXBpOyB9XG4gICAgYmF0Y2hSZW5kZXJpbmcoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgdXBkYXRlU2l6ZSgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdfcmVzaXplJywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIE9wdGlvbnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNldE9wdGlvbihuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICAgICAgICBvcHRpb25OYW1lOiBuYW1lLFxuICAgICAgICAgICAgcmF3T3B0aW9uVmFsdWU6IHZhbCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE9wdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbbmFtZV07XG4gICAgfVxuICAgIGdldEF2YWlsYWJsZUxvY2FsZUNvZGVzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRDdXJyZW50RGF0YSgpLmF2YWlsYWJsZVJhd0xvY2FsZXMpO1xuICAgIH1cbiAgICAvLyBUcmlnZ2VyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBvbihoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICBsZXQgeyBjdXJyZW50RGF0YU1hbmFnZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChjdXJyZW50RGF0YU1hbmFnZXIuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzW2hhbmRsZXJOYW1lXSkge1xuICAgICAgICAgICAgY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub24oaGFuZGxlck5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIGxpc3RlbmVyIG5hbWUgJyR7aGFuZGxlck5hbWV9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9mZihoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5lbWl0dGVyLm9mZihoYW5kbGVyTmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8vIG5vdCBtZWFudCBmb3IgcHVibGljIHVzZVxuICAgIHRyaWdnZXIoaGFuZGxlck5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZW1pdHRlci50cmlnZ2VyKGhhbmRsZXJOYW1lLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLy8gVmlld1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY2hhbmdlVmlldyh2aWV3VHlwZSwgZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5iYXRjaFJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2Uuc3RhcnQgJiYgZGF0ZU9yUmFuZ2UuZW5kKSB7IC8vIGEgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9PUFRJT04nLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uTmFtZTogJ3Zpc2libGVSYW5nZScsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdPcHRpb25WYWx1ZTogZGF0ZU9yUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogZGF0ZUVudi5jcmVhdGVNYXJrZXIoZGF0ZU9yUmFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEZvcmNlcyBuYXZpZ2F0aW9uIHRvIGEgdmlldyBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gICAgLy8gYHZpZXdUeXBlYCBjYW4gYmUgYSBzcGVjaWZpYyB2aWV3IG5hbWUgb3IgYSBnZW5lcmljIG9uZSBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIuXG4gICAgLy8gbmVlZHMgdG8gY2hhbmdlXG4gICAgem9vbVRvKGRhdGVNYXJrZXIsIHZpZXdUeXBlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IHNwZWM7XG4gICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgJ2RheSc7IC8vIGRheSBpcyBkZWZhdWx0IHpvb21cbiAgICAgICAgc3BlYyA9IHN0YXRlLnZpZXdTcGVjc1t2aWV3VHlwZV0gfHwgdGhpcy5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgdmlld1R5cGU6IHNwZWMudHlwZSxcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHaXZlbiBhIGR1cmF0aW9uIHNpbmd1bGFyIHVuaXQsIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIiwgZmluZHMgYSBtYXRjaGluZyB2aWV3IHNwZWMuXG4gICAgLy8gUHJlZmVyZW5jZSBpcyBnaXZlbiB0byB2aWV3cyB0aGF0IGhhdmUgY29ycmVzcG9uZGluZyBidXR0b25zLlxuICAgIGdldFVuaXRWaWV3U3BlYyh1bml0KSB7XG4gICAgICAgIGxldCB7IHZpZXdTcGVjcywgdG9vbGJhckNvbmZpZyB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgdmlld1R5cGVzID0gW10uY29uY2F0KHRvb2xiYXJDb25maWcuaGVhZGVyID8gdG9vbGJhckNvbmZpZy5oZWFkZXIudmlld3NXaXRoQnV0dG9ucyA6IFtdLCB0b29sYmFyQ29uZmlnLmZvb3RlciA/IHRvb2xiYXJDb25maWcuZm9vdGVyLnZpZXdzV2l0aEJ1dHRvbnMgOiBbXSk7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgc3BlYztcbiAgICAgICAgZm9yIChsZXQgdmlld1R5cGUgaW4gdmlld1NwZWNzKSB7XG4gICAgICAgICAgICB2aWV3VHlwZXMucHVzaCh2aWV3VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpZXdUeXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgc3BlYyA9IHZpZXdTcGVjc1t2aWV3VHlwZXNbaV1dO1xuICAgICAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5zaW5nbGVVbml0ID09PSB1bml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gQ3VycmVudCBEYXRlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwcmV2KCkge1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUFJFVicgfSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdORVhUJyB9KTtcbiAgICB9XG4gICAgcHJldlllYXIoKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmFkZFllYXJzKHN0YXRlLmN1cnJlbnREYXRlLCAtMSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZXh0WWVhcigpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkWWVhcnMoc3RhdGUuY3VycmVudERhdGUsIDEpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9kYXkoKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBnZXROb3coc3RhdGUuY2FsZW5kYXJPcHRpb25zLm5vdywgc3RhdGUuZGF0ZUVudiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnb3RvRGF0ZSh6b25lZERhdGVJbnB1dCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5jcmVhdGVNYXJrZXIoem9uZWREYXRlSW5wdXQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5jcmVtZW50RGF0ZShkZWx0YUlucHV0KSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBlbHNlLCB3YXJuIGFib3V0IGludmFsaWQgaW5wdXQ/XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkKHN0YXRlLmN1cnJlbnREYXRlLCBkZWx0YSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREYXRlKCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS5kYXRlRW52LnRvRGF0ZShzdGF0ZS5jdXJyZW50RGF0ZSk7XG4gICAgfVxuICAgIC8vIERhdGUgRm9ybWF0dGluZyBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZm9ybWF0RGF0ZShkLCBmb3JtYXR0ZXIpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIGNyZWF0ZUZvcm1hdHRlcihmb3JtYXR0ZXIpKTtcbiAgICB9XG4gICAgLy8gYHNldHRpbmdzYCBpcyBmb3IgZm9ybWF0dGVyIEFORCBpc0VuZEV4Y2x1c2l2ZVxuICAgIGZvcm1hdFJhbmdlKGQwLCBkMSwgc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShkYXRlRW52LmNyZWF0ZU1hcmtlcihkMCksIGRhdGVFbnYuY3JlYXRlTWFya2VyKGQxKSwgY3JlYXRlRm9ybWF0dGVyKHNldHRpbmdzKSwgc2V0dGluZ3MpO1xuICAgIH1cbiAgICBmb3JtYXRJc28oZCwgb21pdFRpbWUpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRJc28oZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIHsgb21pdFRpbWUgfSk7XG4gICAgfVxuICAgIC8vIERhdGUgU2VsZWN0aW9uIC8gRXZlbnQgU2VsZWN0aW9uIC8gRGF5Q2xpY2tcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNlbGVjdChkYXRlT3JPYmosIGVuZERhdGUpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbklucHV0O1xuICAgICAgICBpZiAoZW5kRGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZU9yT2JqLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IGRhdGVPck9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogZGF0ZU9yT2JqLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXG4gICAgICAgICAgICAgICAgZW5kOiBlbmREYXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBwYXJzZURhdGVTcGFuKHNlbGVjdGlvbklucHV0LCBzdGF0ZS5kYXRlRW52LCBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSkpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7IC8vIHRocm93IHBhcnNlIGVycm9yIG90aGVyd2lzZT9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0RBVEVTJywgc2VsZWN0aW9uIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uLCBudWxsLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zZWxlY3QocGV2KSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVVbnNlbGVjdChwZXYsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQdWJsaWMgRXZlbnRzIEFQSVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYWRkRXZlbnQoZXZlbnRJbnB1dCwgc291cmNlSW5wdXQpIHtcbiAgICAgICAgaWYgKGV2ZW50SW5wdXQgaW5zdGFuY2VvZiBFdmVudEltcGwpIHtcbiAgICAgICAgICAgIGxldCBkZWYgPSBldmVudElucHV0Ll9kZWY7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudElucHV0Ll9pbnN0YW5jZTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50RGF0YSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxuICAgICAgICAgICAgaWYgKCFjdXJyZW50RGF0YS5ldmVudFN0b3JlLmRlZnNbZGVmLmRlZklkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHsgZGVmLCBpbnN0YW5jZSB9KSwgLy8gVE9ETzogYmV0dGVyIHV0aWwgZm9yIHR3byBhcmdzP1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKGV2ZW50SW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50SW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgZXZlbnRTb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlSW1wbCkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VJbnB1dCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSW5wdXQpIHsgLy8gdHJ1ZS4gcGFydCBvZiB0aGUgZmlyc3QgZXZlbnQgc291cmNlXG4gICAgICAgICAgICAgICAgW2V2ZW50U291cmNlXSA9IGhhc2hWYWx1ZXNUb0FycmF5KHN0YXRlLmV2ZW50U291cmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc291cmNlSW5wdXQgIT0gbnVsbCkgeyAvLyBhbiBJRC4gYWNjZXB0cyBhIG51bWJlciB0b29cbiAgICAgICAgICAgIGxldCBzb3VyY2VBcGkgPSB0aGlzLmdldEV2ZW50U291cmNlQnlJZChzb3VyY2VJbnB1dCk7IC8vIFRPRE86IHVzZSBhbiBpbnRlcm5hbCBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFzb3VyY2VBcGkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIGFuIGV2ZW50IHNvdXJjZSB3aXRoIElEIFwiJHtzb3VyY2VJbnB1dH1cImApOyAvLyBUT0RPOiB0ZXN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudFNvdXJjZSA9IHNvdXJjZUFwaS5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0dXBsZSA9IHBhcnNlRXZlbnQoZXZlbnRJbnB1dCwgZXZlbnRTb3VyY2UsIHN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICh0dXBsZSkge1xuICAgICAgICAgICAgbGV0IG5ld0V2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChzdGF0ZSwgdHVwbGUuZGVmLCB0dXBsZS5kZWYucmVjdXJyaW5nRGVmID8gbnVsbCA6IHR1cGxlLmluc3RhbmNlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKG5ld0V2ZW50QXBpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdFdmVudEFwaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJpZ2dlckV2ZW50QWRkKGV2ZW50QXBpKSB7XG4gICAgICAgIGxldCB7IGVtaXR0ZXIgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudEFkZCcsIHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgcmV2ZXJ0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBvcHRpbWl6ZVxuICAgIGdldEV2ZW50QnlJZChpZCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gc3RhdGUuZXZlbnRTdG9yZTtcbiAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgICAgICBpZiAoZGVmLnB1YmxpY0lkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRJbXBsKHN0YXRlLCBkZWYsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5kZWZJZCA9PT0gZGVmLmRlZklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50SW1wbChzdGF0ZSwgZGVmLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEV2ZW50cygpIHtcbiAgICAgICAgbGV0IGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gYnVpbGRFdmVudEFwaXMoY3VycmVudERhdGEuZXZlbnRTdG9yZSwgY3VycmVudERhdGEpO1xuICAgIH1cbiAgICByZW1vdmVBbGxFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVFMnIH0pO1xuICAgIH1cbiAgICAvLyBQdWJsaWMgRXZlbnQgU291cmNlcyBBUElcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGdldEV2ZW50U291cmNlcygpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgbGV0IHNvdXJjZUFwaXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW50ZXJuYWxJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBzb3VyY2VBcGlzLnB1c2gobmV3IEV2ZW50U291cmNlSW1wbChzdGF0ZSwgc291cmNlSGFzaFtpbnRlcm5hbElkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VBcGlzO1xuICAgIH1cbiAgICBnZXRFdmVudFNvdXJjZUJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgICBmb3IgKGxldCBzb3VyY2VJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSGFzaFtzb3VyY2VJZF0ucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUltcGwoc3RhdGUsIHNvdXJjZUhhc2hbc291cmNlSWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYWRkRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBpZiAoc291cmNlSW5wdXQgaW5zdGFuY2VvZiBFdmVudFNvdXJjZUltcGwpIHtcbiAgICAgICAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5ldmVudFNvdXJjZXNbc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVF9TT1VSQ0VTJyxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlczogW3NvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2VdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZUlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudFNvdXJjZSA9IHBhcnNlRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQsIHN0YXRlKTtcbiAgICAgICAgaWYgKGV2ZW50U291cmNlKSB7IC8vIFRPRE86IGVycm9yIG90aGVyd2lzZT9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLCBzb3VyY2VzOiBbZXZlbnRTb3VyY2VdIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUltcGwoc3RhdGUsIGV2ZW50U291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVtb3ZlQWxsRXZlbnRTb3VyY2VzKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUycgfSk7XG4gICAgfVxuICAgIHJlZmV0Y2hFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsIGlzUmVmZXRjaDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gU2Nyb2xsXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBzY3JvbGxUb1RpbWUodGltZUlucHV0KSB7XG4gICAgICAgIGxldCB0aW1lID0gY3JlYXRlRHVyYXRpb24odGltZUlucHV0KTtcbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignX3Njcm9sbFJlcXVlc3QnLCB7IHRpbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBvaW50SW5zaWRlUmVjdChwb2ludCwgcmVjdCkge1xuICAgIHJldHVybiBwb2ludC5sZWZ0ID49IHJlY3QubGVmdCAmJlxuICAgICAgICBwb2ludC5sZWZ0IDwgcmVjdC5yaWdodCAmJlxuICAgICAgICBwb2ludC50b3AgPj0gcmVjdC50b3AgJiZcbiAgICAgICAgcG9pbnQudG9wIDwgcmVjdC5ib3R0b207XG59XG4vLyBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB0aGF0IGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByZWN0YW5nbGVzLiBJZiB0aGV5IGRvbid0IGludGVyc2VjdCwgcmV0dXJucyBmYWxzZVxuZnVuY3Rpb24gaW50ZXJzZWN0UmVjdHMocmVjdDEsIHJlY3QyKSB7XG4gICAgbGV0IHJlcyA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCksXG4gICAgICAgIHJpZ2h0OiBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpLFxuICAgICAgICB0b3A6IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKSxcbiAgICAgICAgYm90dG9tOiBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSksXG4gICAgfTtcbiAgICBpZiAocmVzLmxlZnQgPCByZXMucmlnaHQgJiYgcmVzLnRvcCA8IHJlcy5ib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHJhbnNsYXRlUmVjdChyZWN0LCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIGRlbHRhWCxcbiAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBkZWx0YVgsXG4gICAgICAgIHRvcDogcmVjdC50b3AgKyBkZWx0YVksXG4gICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyBkZWx0YVksXG4gICAgfTtcbn1cbi8vIFJldHVybnMgYSBuZXcgcG9pbnQgdGhhdCB3aWxsIGhhdmUgYmVlbiBtb3ZlZCB0byByZXNpZGUgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGNvbnN0cmFpblBvaW50KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQubGVmdCwgcmVjdC5sZWZ0KSwgcmVjdC5yaWdodCksXG4gICAgICAgIHRvcDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQudG9wLCByZWN0LnRvcCksIHJlY3QuYm90dG9tKSxcbiAgICB9O1xufVxuLy8gUmV0dXJucyBhIHBvaW50IHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXG5mdW5jdGlvbiBnZXRSZWN0Q2VudGVyKHJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLFxuICAgICAgICB0b3A6IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDIsXG4gICAgfTtcbn1cbi8vIFN1YnRyYWN0cyBwb2ludDIncyBjb29yZGluYXRlcyBmcm9tIHBvaW50MSdzIGNvb3JkaW5hdGVzLCByZXR1cm5pbmcgYSBkZWx0YVxuZnVuY3Rpb24gZGlmZlBvaW50cyhwb2ludDEsIHBvaW50Mikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHBvaW50MS5sZWZ0IC0gcG9pbnQyLmxlZnQsXG4gICAgICAgIHRvcDogcG9pbnQxLnRvcCAtIHBvaW50Mi50b3AsXG4gICAgfTtcbn1cblxuY29uc3QgRU1QVFlfRVZFTlRfU1RPUkUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTsgLy8gZm9yIHB1cmVjb21wb25lbnRzLiBUT0RPOiBrZWVwIGVsc2V3aGVyZVxuY2xhc3MgU3BsaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmdldEtleXNGb3JFdmVudERlZnMgPSBtZW1vaXplKHRoaXMuX2dldEtleXNGb3JFdmVudERlZnMpO1xuICAgICAgICB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc3BsaXREYXRlU3Bhbik7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEV2ZW50U3RvcmUpO1xuICAgICAgICB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEluZGl2aWR1YWxVaSk7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IHt9OyAvLyBUT0RPOiB0eXBlc2NyaXB0IHByb3RlY3Rpb25cbiAgICB9XG4gICAgc3BsaXRQcm9wcyhwcm9wcykge1xuICAgICAgICBsZXQga2V5SW5mb3MgPSB0aGlzLmdldEtleUluZm8ocHJvcHMpO1xuICAgICAgICBsZXQgZGVmS2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyhwcm9wcy5ldmVudFN0b3JlKTtcbiAgICAgICAgbGV0IGRhdGVTZWxlY3Rpb25zID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbik7XG4gICAgICAgIGxldCBpbmRpdmlkdWFsVWkgPSB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpKHByb3BzLmV2ZW50VWlCYXNlcywgZGVmS2V5cyk7IC8vIHRoZSBpbmRpdmlkdWFsICpiYXNlcypcbiAgICAgICAgbGV0IGV2ZW50U3RvcmVzID0gdGhpcy5zcGxpdEV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZGVmS2V5cyk7XG4gICAgICAgIGxldCBldmVudERyYWdzID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcpO1xuICAgICAgICBsZXQgZXZlbnRSZXNpemVzID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplKTtcbiAgICAgICAgbGV0IHNwbGl0UHJvcHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmVudFVpQnVpbGRlcnMgPSBtYXBIYXNoKGtleUluZm9zLCAoaW5mbywga2V5KSA9PiB0aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldIHx8IG1lbW9pemUoYnVpbGRFdmVudFVpRm9yS2V5KSk7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBrZXlJbmZvcykge1xuICAgICAgICAgICAgbGV0IGtleUluZm8gPSBrZXlJbmZvc1trZXldO1xuICAgICAgICAgICAgbGV0IGV2ZW50U3RvcmUgPSBldmVudFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFO1xuICAgICAgICAgICAgbGV0IGJ1aWxkRXZlbnRVaSA9IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV07XG4gICAgICAgICAgICBzcGxpdFByb3BzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgYnVzaW5lc3NIb3Vyczoga2V5SW5mby5idXNpbmVzc0hvdXJzIHx8IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbnNba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmUsXG4gICAgICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBidWlsZEV2ZW50VWkocHJvcHMuZXZlbnRVaUJhc2VzWycnXSwga2V5SW5mby51aSwgaW5kaXZpZHVhbFVpW2tleV0pLFxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBldmVudFN0b3JlLmluc3RhbmNlc1twcm9wcy5ldmVudFNlbGVjdGlvbl0gPyBwcm9wcy5ldmVudFNlbGVjdGlvbiA6ICcnLFxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogZXZlbnREcmFnc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFByb3BzO1xuICAgIH1cbiAgICBfc3BsaXREYXRlU3BhbihkYXRlU3Bhbikge1xuICAgICAgICBsZXQgZGF0ZVNwYW5zID0ge307XG4gICAgICAgIGlmIChkYXRlU3Bhbikge1xuICAgICAgICAgICAgbGV0IGtleXMgPSB0aGlzLmdldEtleXNGb3JEYXRlU3BhbihkYXRlU3Bhbik7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgICAgIGRhdGVTcGFuc1trZXldID0gZGF0ZVNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVTcGFucztcbiAgICB9XG4gICAgX2dldEtleXNGb3JFdmVudERlZnMoZXZlbnRTdG9yZSkge1xuICAgICAgICByZXR1cm4gbWFwSGFzaChldmVudFN0b3JlLmRlZnMsIChldmVudERlZikgPT4gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpKTtcbiAgICB9XG4gICAgX3NwbGl0RXZlbnRTdG9yZShldmVudFN0b3JlLCBkZWZLZXlzKSB7XG4gICAgICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcbiAgICAgICAgbGV0IHNwbGl0U3RvcmVzID0ge307XG4gICAgICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBkZWZLZXlzW2RlZklkXSkge1xuICAgICAgICAgICAgICAgIGlmICghc3BsaXRTdG9yZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uZGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGRlZktleXNbaW5zdGFuY2UuZGVmSWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0U3RvcmVzW2tleV0pIHsgLy8gbXVzdCBoYXZlIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFN0b3JlcztcbiAgICB9XG4gICAgX3NwbGl0SW5kaXZpZHVhbFVpKGV2ZW50VWlCYXNlcywgZGVmS2V5cykge1xuICAgICAgICBsZXQgc3BsaXRIYXNoZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRVaUJhc2VzKSB7XG4gICAgICAgICAgICBpZiAoZGVmSWQpIHsgLy8gbm90IHRoZSAnJyBrZXlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgZGVmS2V5c1tkZWZJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGxpdEhhc2hlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdEhhc2hlc1trZXldID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XVtkZWZJZF0gPSBldmVudFVpQmFzZXNbZGVmSWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRIYXNoZXM7XG4gICAgfVxuICAgIF9zcGxpdEludGVyYWN0aW9uKGludGVyYWN0aW9uKSB7XG4gICAgICAgIGxldCBzcGxpdFN0YXRlcyA9IHt9O1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBhZmZlY3RlZFN0b3JlcyA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cywgdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cykpO1xuICAgICAgICAgICAgLy8gY2FuJ3QgcmVseSBvbiBkZWZLZXlzIGJlY2F1c2UgZXZlbnQgZGF0YSBpcyBtdXRhdGVkXG4gICAgICAgICAgICBsZXQgbXV0YXRlZEtleXNCeURlZklkID0gdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzKTtcbiAgICAgICAgICAgIGxldCBtdXRhdGVkU3RvcmVzID0gdGhpcy5fc3BsaXRFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIG11dGF0ZWRLZXlzQnlEZWZJZCk7XG4gICAgICAgICAgICBsZXQgcG9wdWxhdGUgPSAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcGxpdFN0YXRlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RhdGVzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogYWZmZWN0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG11dGF0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBhZmZlY3RlZFN0b3Jlcykge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gbXV0YXRlZFN0b3Jlcykge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0U3RhdGVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaSwgZXZlbnRVaUZvcktleSwgaW5kaXZpZHVhbFVpKSB7XG4gICAgbGV0IGJhc2VQYXJ0cyA9IFtdO1xuICAgIGlmIChhbGxVaSkge1xuICAgICAgICBiYXNlUGFydHMucHVzaChhbGxVaSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpRm9yS2V5KSB7XG4gICAgICAgIGJhc2VQYXJ0cy5wdXNoKGV2ZW50VWlGb3JLZXkpO1xuICAgIH1cbiAgICBsZXQgc3R1ZmYgPSB7XG4gICAgICAgICcnOiBjb21iaW5lRXZlbnRVaXMoYmFzZVBhcnRzKSxcbiAgICB9O1xuICAgIGlmIChpbmRpdmlkdWFsVWkpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHVmZiwgaW5kaXZpZHVhbFVpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0dWZmO1xufVxuXG5mdW5jdGlvbiBnZXREYXRlTWV0YShkYXRlLCB0b2RheVJhbmdlLCBub3dEYXRlLCBkYXRlUHJvZmlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvdzogZGF0ZS5nZXRVVENEYXkoKSxcbiAgICAgICAgaXNEaXNhYmxlZDogQm9vbGVhbihkYXRlUHJvZmlsZSAmJiAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgZGF0ZSkpLFxuICAgICAgICBpc090aGVyOiBCb29sZWFuKGRhdGVQcm9maWxlICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgZGF0ZSkpLFxuICAgICAgICBpc1RvZGF5OiBCb29sZWFuKHRvZGF5UmFuZ2UgJiYgcmFuZ2VDb250YWluc01hcmtlcih0b2RheVJhbmdlLCBkYXRlKSksXG4gICAgICAgIGlzUGFzdDogQm9vbGVhbihub3dEYXRlID8gKGRhdGUgPCBub3dEYXRlKSA6IHRvZGF5UmFuZ2UgPyAoZGF0ZSA8IHRvZGF5UmFuZ2Uuc3RhcnQpIDogZmFsc2UpLFxuICAgICAgICBpc0Z1dHVyZTogQm9vbGVhbihub3dEYXRlID8gKGRhdGUgPiBub3dEYXRlKSA6IHRvZGF5UmFuZ2UgPyAoZGF0ZSA+PSB0b2RheVJhbmdlLmVuZCkgOiBmYWxzZSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERheUNsYXNzTmFtZXMobWV0YSwgdGhlbWUpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLWRheScsXG4gICAgICAgIGBmYy1kYXktJHtEQVlfSURTW21ldGEuZG93XX1gLFxuICAgIF07XG4gICAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1kaXNhYmxlZCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1ldGEuaXNUb2RheSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1wYXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LWZ1dHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzT3RoZXIpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LW90aGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRTbG90Q2xhc3NOYW1lcyhtZXRhLCB0aGVtZSkge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2xvdCcsXG4gICAgICAgIGBmYy1zbG90LSR7REFZX0lEU1ttZXRhLmRvd119YCxcbiAgICBdO1xuICAgIGlmIChtZXRhLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LWRpc2FibGVkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobWV0YS5pc1RvZGF5KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtcGFzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzRnV0dXJlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZnV0dXJlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5cbmNvbnN0IERBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0pO1xuY29uc3QgV0VFS19GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnbG9uZycgfSk7XG5mdW5jdGlvbiBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlTWFya2VyLCB2aWV3VHlwZSA9ICdkYXknLCBpc1RhYmJhYmxlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgZGF0ZUVudiwgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGRhdGVTdHIgPSBkYXRlRW52LmZvcm1hdChkYXRlTWFya2VyLCB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gV0VFS19GT1JNQVQgOiBEQVlfRk9STUFUKTtcbiAgICBpZiAob3B0aW9ucy5uYXZMaW5rcykge1xuICAgICAgICBsZXQgem9uZWREYXRlID0gZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlcik7XG4gICAgICAgIGNvbnN0IGhhbmRsZUludGVyYWN0aW9uID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VzdG9tQWN0aW9uID0gdmlld1R5cGUgPT09ICdkYXknID8gb3B0aW9ucy5uYXZMaW5rRGF5Q2xpY2sgOlxuICAgICAgICAgICAgICAgIHZpZXdUeXBlID09PSAnd2VlaycgPyBvcHRpb25zLm5hdkxpbmtXZWVrQ2xpY2sgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjdXN0b21BY3Rpb24uY2FsbChjYWxlbmRhckFwaSwgZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlciksIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IGN1c3RvbUFjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGkuem9vbVRvKGRhdGVNYXJrZXIsIHZpZXdUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0aXRsZTogZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubmF2TGlua0hpbnQsIFtkYXRlU3RyLCB6b25lZERhdGVdLCBkYXRlU3RyKSwgJ2RhdGEtbmF2bGluayc6ICcnIH0sIChpc1RhYmJhYmxlXG4gICAgICAgICAgICA/IGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZUludGVyYWN0aW9uKVxuICAgICAgICAgICAgOiB7IG9uQ2xpY2s6IGhhbmRsZUludGVyYWN0aW9uIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgJ2FyaWEtbGFiZWwnOiBkYXRlU3RyIH07XG59XG5cbmxldCBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBudWxsO1xuZnVuY3Rpb24gZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQoKSB7XG4gICAgaWYgKF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9PT0gbnVsbCkge1xuICAgICAgICBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9pc1J0bFNjcm9sbGJhck9uTGVmdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcbiAgICBsZXQgb3V0ZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGFwcGx5U3R5bGUob3V0ZXJFbCwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAtMTAwMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXG4gICAgICAgIGRpcmVjdGlvbjogJ3J0bCcsXG4gICAgfSk7XG4gICAgb3V0ZXJFbC5pbm5lckhUTUwgPSAnPGRpdj48L2Rpdj4nO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXJFbCk7XG4gICAgbGV0IGlubmVyRWwgPSBvdXRlckVsLmZpcnN0Q2hpbGQ7XG4gICAgbGV0IHJlcyA9IGlubmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IG91dGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICByZW1vdmVFbGVtZW50KG91dGVyRWwpO1xuICAgIHJldHVybiByZXM7XG59XG5cbmxldCBfc2Nyb2xsYmFyV2lkdGhzO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGhzKCkge1xuICAgIGlmICghX3Njcm9sbGJhcldpZHRocykge1xuICAgICAgICBfc2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRocygpO1xuICAgIH1cbiAgICByZXR1cm4gX3Njcm9sbGJhcldpZHRocztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHMoKSB7XG4gICAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcbiAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZWwuc3R5bGUudG9wID0gJy05OTk5cHgnO1xuICAgIGVsLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgbGV0IHJlcyA9IGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIFdBUk5JTkc6IHdpbGwgaW5jbHVkZSBib3JkZXJcbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGVsLm9mZnNldEhlaWdodCAtIGVsLmNsaWVudEhlaWdodCxcbiAgICAgICAgeTogZWwub2Zmc2V0V2lkdGggLSBlbC5jbGllbnRXaWR0aCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRWRnZXMoZWwsIGdldFBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIGxldCBib3JkZXJMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwO1xuICAgIGxldCBib3JkZXJSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCwgMTApIHx8IDA7XG4gICAgbGV0IGJvcmRlclRvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKSB8fCAwO1xuICAgIGxldCBib3JkZXJCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCkgfHwgMDtcbiAgICBsZXQgYmFkU2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTsgLy8gaW5jbHVkZXMgYm9yZGVyIVxuICAgIGxldCBzY3JvbGxiYXJMZWZ0UmlnaHQgPSBiYWRTY3JvbGxiYXJXaWR0aHMueSAtIGJvcmRlckxlZnQgLSBib3JkZXJSaWdodDtcbiAgICBsZXQgc2Nyb2xsYmFyQm90dG9tID0gYmFkU2Nyb2xsYmFyV2lkdGhzLnggLSBib3JkZXJUb3AgLSBib3JkZXJCb3R0b207XG4gICAgbGV0IHJlcyA9IHtcbiAgICAgICAgYm9yZGVyTGVmdCxcbiAgICAgICAgYm9yZGVyUmlnaHQsXG4gICAgICAgIGJvcmRlclRvcCxcbiAgICAgICAgYm9yZGVyQm90dG9tLFxuICAgICAgICBzY3JvbGxiYXJCb3R0b20sXG4gICAgICAgIHNjcm9sbGJhckxlZnQ6IDAsXG4gICAgICAgIHNjcm9sbGJhclJpZ2h0OiAwLFxuICAgIH07XG4gICAgaWYgKGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgJiYgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIGlzIHRoZSBzY3JvbGxiYXIgb24gdGhlIGxlZnQgc2lkZT9cbiAgICAgICAgcmVzLnNjcm9sbGJhckxlZnQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMuc2Nyb2xsYmFyUmlnaHQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGlmIChnZXRQYWRkaW5nKSB7XG4gICAgICAgIHJlcy5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1RvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCwgMTApIHx8IDA7XG4gICAgICAgIHJlcy5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tLCAxMCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJbm5lclJlY3QoZWwsIGdvV2l0aGluUGFkZGluZyA9IGZhbHNlLCBkb0Zyb21XaW5kb3dWaWV3cG9ydCkge1xuICAgIGxldCBvdXRlclJlY3QgPSBkb0Zyb21XaW5kb3dWaWV3cG9ydCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogY29tcHV0ZVJlY3QoZWwpO1xuICAgIGxldCBlZGdlcyA9IGNvbXB1dGVFZGdlcyhlbCwgZ29XaXRoaW5QYWRkaW5nKTtcbiAgICBsZXQgcmVzID0ge1xuICAgICAgICBsZWZ0OiBvdXRlclJlY3QubGVmdCArIGVkZ2VzLmJvcmRlckxlZnQgKyBlZGdlcy5zY3JvbGxiYXJMZWZ0LFxuICAgICAgICByaWdodDogb3V0ZXJSZWN0LnJpZ2h0IC0gZWRnZXMuYm9yZGVyUmlnaHQgLSBlZGdlcy5zY3JvbGxiYXJSaWdodCxcbiAgICAgICAgdG9wOiBvdXRlclJlY3QudG9wICsgZWRnZXMuYm9yZGVyVG9wLFxuICAgICAgICBib3R0b206IG91dGVyUmVjdC5ib3R0b20gLSBlZGdlcy5ib3JkZXJCb3R0b20gLSBlZGdlcy5zY3JvbGxiYXJCb3R0b20sXG4gICAgfTtcbiAgICBpZiAoZ29XaXRoaW5QYWRkaW5nKSB7XG4gICAgICAgIHJlcy5sZWZ0ICs9IGVkZ2VzLnBhZGRpbmdMZWZ0O1xuICAgICAgICByZXMucmlnaHQgLT0gZWRnZXMucGFkZGluZ1JpZ2h0O1xuICAgICAgICByZXMudG9wICs9IGVkZ2VzLnBhZGRpbmdUb3A7XG4gICAgICAgIHJlcy5ib3R0b20gLT0gZWRnZXMucGFkZGluZ0JvdHRvbTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSZWN0KGVsKSB7XG4gICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICByaWdodDogcmVjdC5yaWdodCArIHdpbmRvdy5zY3JvbGxYLFxuICAgICAgICBib3R0b206IHJlY3QuYm90dG9tICsgd2luZG93LnNjcm9sbFksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChlbCkge1xuICAgIGxldCBjbGlwcGluZ1BhcmVudHMgPSBnZXRDbGlwcGluZ1BhcmVudHMoZWwpO1xuICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgZm9yIChsZXQgY2xpcHBpbmdQYXJlbnQgb2YgY2xpcHBpbmdQYXJlbnRzKSB7XG4gICAgICAgIGxldCBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSZWN0cyhyZWN0LCBjbGlwcGluZ1BhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlY3QgPSBpbnRlcnNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjdDtcbn1cbi8vIGRvZXMgbm90IHJldHVybiB3aW5kb3dcbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbCkge1xuICAgIGxldCBwYXJlbnRzID0gW107XG4gICAgd2hpbGUgKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHsgLy8gd2lsbCBzdG9wIHdoZW4gZ2V0cyB0byBkb2N1bWVudCBvciBudWxsXG4gICAgICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgICBpZiAoY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgvKGF1dG98c2Nyb2xsKS8pLnRlc3QoY29tcHV0ZWRTdHlsZS5vdmVyZmxvdyArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dZICsgY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG59XG5cbi8qXG5SZWNvcmRzIG9mZnNldCBpbmZvcm1hdGlvbiBmb3IgYSBzZXQgb2YgZWxlbWVudHMsIHJlbGF0aXZlIHRvIGFuIG9yaWdpbiBlbGVtZW50LlxuQ2FuIHJlY29yZCB0aGUgbGVmdC9yaWdodCBPUiB0aGUgdG9wL2JvdHRvbSBPUiBib3RoLlxuUHJvdmlkZXMgbWV0aG9kcyBmb3IgcXVlcnlpbmcgdGhlIGNhY2hlIGJ5IHBvc2l0aW9uLlxuKi9cbmNsYXNzIFBvc2l0aW9uQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbkVsLCBlbHMsIGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCkge1xuICAgICAgICB0aGlzLmVscyA9IGVscztcbiAgICAgICAgbGV0IG9yaWdpbkNsaWVudFJlY3QgPSB0aGlzLm9yaWdpbkNsaWVudFJlY3QgPSBvcmlnaW5FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gcmVsYXRpdmUgdG8gdmlld3BvcnQgdG9wLWxlZnRcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEVsSG9yaXpvbnRhbHMob3JpZ2luQ2xpZW50UmVjdC5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEVsVmVydGljYWxzKG9yaWdpbkNsaWVudFJlY3QudG9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgdGhlIGxlZnQvcmlnaHQgaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcbiAgICBidWlsZEVsSG9yaXpvbnRhbHMob3JpZ2luQ2xpZW50TGVmdCkge1xuICAgICAgICBsZXQgbGVmdHMgPSBbXTtcbiAgICAgICAgbGV0IHJpZ2h0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBlbCBvZiB0aGlzLmVscykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGxlZnRzLnB1c2gocmVjdC5sZWZ0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgICAgICByaWdodHMucHVzaChyZWN0LnJpZ2h0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0cyA9IGxlZnRzO1xuICAgICAgICB0aGlzLnJpZ2h0cyA9IHJpZ2h0cztcbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIHRoZSB0b3AvYm90dG9tIGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG4gICAgYnVpbGRFbFZlcnRpY2FscyhvcmlnaW5DbGllbnRUb3ApIHtcbiAgICAgICAgbGV0IHRvcHMgPSBbXTtcbiAgICAgICAgbGV0IGJvdHRvbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWwgb2YgdGhpcy5lbHMpIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0b3BzLnB1c2gocmVjdC50b3AgLSBvcmlnaW5DbGllbnRUb3ApO1xuICAgICAgICAgICAgYm90dG9tcy5wdXNoKHJlY3QuYm90dG9tIC0gb3JpZ2luQ2xpZW50VG9wKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvcHMgPSB0b3BzO1xuICAgICAgICB0aGlzLmJvdHRvbXMgPSBib3R0b21zO1xuICAgIH1cbiAgICAvLyBHaXZlbiBhIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0cy5cbiAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgbGVmdFRvSW5kZXgobGVmdFBvc2l0aW9uKSB7XG4gICAgICAgIGxldCB7IGxlZnRzLCByaWdodHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBsZW4gPSBsZWZ0cy5sZW5ndGg7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0UG9zaXRpb24gPj0gbGVmdHNbaV0gJiYgbGVmdFBvc2l0aW9uIDwgcmlnaHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVE9ETzogYmV0dGVyXG4gICAgfVxuICAgIC8vIEdpdmVuIGEgdG9wIG9mZnNldCAoZnJvbSBkb2N1bWVudCB0b3ApLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCB2ZXJ0aWNhbGx5IGludGVyc2VjdHMuXG4gICAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgIHRvcFRvSW5kZXgodG9wUG9zaXRpb24pIHtcbiAgICAgICAgbGV0IHsgdG9wcywgYm90dG9tcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxlbiA9IHRvcHMubGVuZ3RoO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodG9wUG9zaXRpb24gPj0gdG9wc1tpXSAmJiB0b3BQb3NpdGlvbiA8IGJvdHRvbXNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBUT0RPOiBiZXR0ZXJcbiAgICB9XG4gICAgLy8gR2V0cyB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgZ2V0V2lkdGgobGVmdEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdIC0gdGhpcy5sZWZ0c1tsZWZ0SW5kZXhdO1xuICAgIH1cbiAgICAvLyBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgZ2V0SGVpZ2h0KHRvcEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy50b3BzW3RvcEluZGV4XTtcbiAgICB9XG4gICAgc2ltaWxhclRvKG90aGVyQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIHNpbWlsYXJOdW1BcnJheXModGhpcy50b3BzIHx8IFtdLCBvdGhlckNhY2hlLnRvcHMgfHwgW10pICYmXG4gICAgICAgICAgICBzaW1pbGFyTnVtQXJyYXlzKHRoaXMuYm90dG9tcyB8fCBbXSwgb3RoZXJDYWNoZS5ib3R0b21zIHx8IFtdKSAmJlxuICAgICAgICAgICAgc2ltaWxhck51bUFycmF5cyh0aGlzLmxlZnRzIHx8IFtdLCBvdGhlckNhY2hlLmxlZnRzIHx8IFtdKSAmJlxuICAgICAgICAgICAgc2ltaWxhck51bUFycmF5cyh0aGlzLnJpZ2h0cyB8fCBbXSwgb3RoZXJDYWNoZS5yaWdodHMgfHwgW10pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNpbWlsYXJOdW1BcnJheXMoYSwgYikge1xuICAgIGNvbnN0IGxlbiA9IGEubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoTWF0aC5yb3VuZChhW2ldKSAhPT0gTWF0aC5yb3VuZChiW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IFwib2ZmXCIgKi9cbi8qXG5BbiBvYmplY3QgZm9yIGdldHRpbmcvc2V0dGluZyBzY3JvbGwtcmVsYXRlZCBpbmZvcm1hdGlvbiBmb3IgYW4gZWxlbWVudC5cbkludGVybmFsbHksIHRoaXMgaXMgZG9uZSB2ZXJ5IGRpZmZlcmVudGx5IGZvciB3aW5kb3cgdmVyc3VzIERPTSBlbGVtZW50LFxuc28gdGhpcyBvYmplY3Qgc2VydmVzIGFzIGEgY29tbW9uIGludGVyZmFjZS5cbiovXG5jbGFzcyBTY3JvbGxDb250cm9sbGVyIHtcbiAgICBnZXRNYXhTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbEhlaWdodCgpIC0gdGhpcy5nZXRDbGllbnRIZWlnaHQoKTtcbiAgICB9XG4gICAgZ2V0TWF4U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsV2lkdGgoKSAtIHRoaXMuZ2V0Q2xpZW50V2lkdGgoKTtcbiAgICB9XG4gICAgY2FuU2Nyb2xsVmVydGljYWxseSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkgPiAwO1xuICAgIH1cbiAgICBjYW5TY3JvbGxIb3Jpem9udGFsbHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbExlZnQoKSA+IDA7XG4gICAgfVxuICAgIGNhblNjcm9sbFVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxUb3AoKSA+IDA7XG4gICAgfVxuICAgIGNhblNjcm9sbERvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxUb3AoKTtcbiAgICB9XG4gICAgY2FuU2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpID4gMDtcbiAgICB9XG4gICAgY2FuU2Nyb2xsUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbExlZnQoKSA8IHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpO1xuICAgIH1cbn1cbmNsYXNzIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyIGV4dGVuZHMgU2Nyb2xsQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgIH1cbiAgICBnZXRTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbFRvcDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsVG9wKHRvcCkge1xuICAgICAgICB0aGlzLmVsLnNjcm9sbFRvcCA9IHRvcDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsTGVmdChsZWZ0KSB7XG4gICAgICAgIHRoaXMuZWwuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgfVxuICAgIGdldFNjcm9sbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxXaWR0aDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuICAgIGdldENsaWVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50V2lkdGg7XG4gICAgfVxufVxuY2xhc3MgV2luZG93U2Nyb2xsQ29udHJvbGxlciBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xuICAgIGdldFNjcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZO1xuICAgIH1cbiAgICBnZXRTY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFg7XG4gICAgfVxuICAgIHNldFNjcm9sbFRvcChuKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwod2luZG93LnNjcm9sbFgsIG4pO1xuICAgIH1cbiAgICBzZXRTY3JvbGxMZWZ0KG4pIHtcbiAgICAgICAgd2luZG93LnNjcm9sbChuLCB3aW5kb3cuc2Nyb2xsWSk7XG4gICAgfVxuICAgIGdldFNjcm9sbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgIH1cbiAgICBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICB9XG59XG5cbi8qXG5hbiBJTlRFUkFDVEFCTEUgZGF0ZSBjb21wb25lbnRcblxuUFVSUE9TRVM6XG4tIGhvb2sgdXAgdG8gZmcsIGZpbGwsIGFuZCBtaXJyb3IgcmVuZGVyZXJzXG4tIGludGVyZmFjZSBmb3IgZHJhZ2dpbmcgYW5kIGhpdHNcbiovXG5jbGFzcyBEYXRlQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudWlkID0gZ3VpZCgpO1xuICAgIH1cbiAgICAvLyBIaXQgU3lzdGVtXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwcmVwYXJlSGl0cygpIHtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgZWxXaWR0aCwgZWxIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIHRoaXMgc2hvdWxkIGJlIGFic3RyYWN0XG4gICAgfVxuICAgIC8vIFBvaW50ZXIgSW50ZXJhY3Rpb24gVXRpbHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGlzVmFsaWRTZWdEb3duRWwoZWwpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnByb3BzLmV2ZW50RHJhZyAmJiAvLyBIQUNLXG4gICAgICAgICAgICAhdGhpcy5wcm9wcy5ldmVudFJlc2l6ZSAmJiAvLyBIQUNLXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQtbWlycm9yJyk7XG4gICAgfVxuICAgIGlzVmFsaWREYXRlRG93bkVsKGVsKSB7XG4gICAgICAgIHJldHVybiAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQ6bm90KC5mYy1iZy1ldmVudCknKSAmJlxuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLW1vcmUtbGluaycpICYmIC8vIGEgXCJtb3JlLi5cIiBsaW5rXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICdhW2RhdGEtbmF2bGlua10nKSAmJiAvLyBhIGNsaWNrYWJsZSBuYXYgbGlua1xuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLXBvcG92ZXInKTsgLy8gaGFja1xuICAgIH1cbn1cblxuY2xhc3MgTmFtZWRUaW1lWm9uZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHRpbWVab25lTmFtZSkge1xuICAgICAgICB0aGlzLnRpbWVab25lTmFtZSA9IHRpbWVab25lTmFtZTtcbiAgICB9XG59XG5cbmNsYXNzIFNlZ0hpZXJhcmNoeSB7XG4gICAgY29uc3RydWN0b3IoZ2V0RW50cnlUaGlja25lc3MgPSAoZW50cnkpID0+IHtcbiAgICAgICAgLy8gaWYgbm8gdGhpY2tuZXNzIGtub3duLCBhc3N1bWUgMSAoaWYgMCwgc28gc21hbGwgaXQgYWx3YXlzIGZpdHMpXG4gICAgICAgIHJldHVybiBlbnRyeS50aGlja25lc3MgfHwgMTtcbiAgICB9KSB7XG4gICAgICAgIHRoaXMuZ2V0RW50cnlUaGlja25lc3MgPSBnZXRFbnRyeVRoaWNrbmVzcztcbiAgICAgICAgLy8gc2V0dGluZ3NcbiAgICAgICAgdGhpcy5zdHJpY3RPcmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbG93UmVzbGljaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF4Q29vcmQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubWF4U3RhY2tDbnQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubGV2ZWxDb29yZHMgPSBbXTsgLy8gb3JkZXJlZFxuICAgICAgICB0aGlzLmVudHJpZXNCeUxldmVsID0gW107IC8vIHBhcmFsbGVsIHdpdGggbGV2ZWxDb29yZHNcbiAgICAgICAgdGhpcy5zdGFja0NudHMgPSB7fTsgLy8gVE9ETzogdXNlIGJldHRlciB0ZWNobmlxdWUhP1xuICAgIH1cbiAgICBhZGRTZWdzKGlucHV0cykge1xuICAgICAgICBsZXQgaGlkZGVuRW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RW50cnkoaW5wdXQsIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWRkZW5FbnRyaWVzO1xuICAgIH1cbiAgICBpbnNlcnRFbnRyeShlbnRyeSwgaGlkZGVuRW50cmllcykge1xuICAgICAgICBsZXQgaW5zZXJ0aW9uID0gdGhpcy5maW5kSW5zZXJ0aW9uKGVudHJ5KTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnNlcnRpb25WYWxpZChpbnNlcnRpb24sIGVudHJ5KSkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzSW5zZXJ0aW9uVmFsaWQoaW5zZXJ0aW9uLCBlbnRyeSkge1xuICAgICAgICByZXR1cm4gKHRoaXMubWF4Q29vcmQgPT09IC0xIHx8IGluc2VydGlvbi5sZXZlbENvb3JkICsgdGhpcy5nZXRFbnRyeVRoaWNrbmVzcyhlbnRyeSkgPD0gdGhpcy5tYXhDb29yZCkgJiZcbiAgICAgICAgICAgICh0aGlzLm1heFN0YWNrQ250ID09PSAtMSB8fCBpbnNlcnRpb24uc3RhY2tDbnQgPCB0aGlzLm1heFN0YWNrQ250KTtcbiAgICB9XG4gICAgaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmFsbG93UmVzbGljaW5nICYmIGluc2VydGlvbi50b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICBjb25zdCBoaWRkZW5FbnRyeSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZW50cnkpLCB7IHNwYW46IGludGVyc2VjdFNwYW5zKGVudHJ5LnNwYW4sIGluc2VydGlvbi50b3VjaGluZ0VudHJ5LnNwYW4pIH0pO1xuICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGhpZGRlbkVudHJ5KTtcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFbnRyeShlbnRyeSwgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgIERvZXMgTk9UIGFkZCB3aGF0IGhpdCB0aGUgYGJhcnJpZXJgIGludG8gaGlkZGVuRW50cmllcy4gU2hvdWxkIGFscmVhZHkgYmUgZG9uZS5cbiAgICAqL1xuICAgIHNwbGl0RW50cnkoZW50cnksIGJhcnJpZXIsIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgbGV0IGVudHJ5U3BhbiA9IGVudHJ5LnNwYW47XG4gICAgICAgIGxldCBiYXJyaWVyU3BhbiA9IGJhcnJpZXIuc3BhbjtcbiAgICAgICAgaWYgKGVudHJ5U3Bhbi5zdGFydCA8IGJhcnJpZXJTcGFuLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEVudHJ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgc3BhbjogeyBzdGFydDogZW50cnlTcGFuLnN0YXJ0LCBlbmQ6IGJhcnJpZXJTcGFuLnN0YXJ0IH0sXG4gICAgICAgICAgICB9LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnlTcGFuLmVuZCA+IGJhcnJpZXJTcGFuLmVuZCkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeSh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxuICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZW50cnkudGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgIHNwYW46IHsgc3RhcnQ6IGJhcnJpZXJTcGFuLmVuZCwgZW5kOiBlbnRyeVNwYW4uZW5kIH0sXG4gICAgICAgICAgICB9LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pIHtcbiAgICAgICAgbGV0IHsgZW50cmllc0J5TGV2ZWwsIGxldmVsQ29vcmRzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaW5zZXJ0aW9uLmxhdGVyYWwgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGxldmVsQ29vcmRzLCBpbnNlcnRpb24ubGV2ZWwsIGluc2VydGlvbi5sZXZlbENvb3JkKTtcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsLCBpbnNlcnRpb24ubGV2ZWwsIFtlbnRyeV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGludG8gZXhpc3RpbmcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsW2luc2VydGlvbi5sZXZlbF0sIGluc2VydGlvbi5sYXRlcmFsLCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFja0NudHNbYnVpbGRFbnRyeUtleShlbnRyeSldID0gaW5zZXJ0aW9uLnN0YWNrQ250O1xuICAgIH1cbiAgICAvKlxuICAgIGRvZXMgbm90IGNhcmUgYWJvdXQgbGltaXRzXG4gICAgKi9cbiAgICBmaW5kSW5zZXJ0aW9uKG5ld0VudHJ5KSB7XG4gICAgICAgIGxldCB7IGxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCwgc3RyaWN0T3JkZXIsIHN0YWNrQ250cyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxldmVsQ250ID0gbGV2ZWxDb29yZHMubGVuZ3RoO1xuICAgICAgICBsZXQgY2FuZGlkYXRlQ29vcmQgPSAwO1xuICAgICAgICBsZXQgdG91Y2hpbmdMZXZlbCA9IC0xO1xuICAgICAgICBsZXQgdG91Y2hpbmdMYXRlcmFsID0gLTE7XG4gICAgICAgIGxldCB0b3VjaGluZ0VudHJ5ID0gbnVsbDtcbiAgICAgICAgbGV0IHN0YWNrQ250ID0gMDtcbiAgICAgICAgZm9yIChsZXQgdHJhY2tpbmdMZXZlbCA9IDA7IHRyYWNraW5nTGV2ZWwgPCBsZXZlbENudDsgdHJhY2tpbmdMZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFja2luZ0Nvb3JkID0gbGV2ZWxDb29yZHNbdHJhY2tpbmdMZXZlbF07XG4gICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBsZXZlbCBpcyBwYXN0IHRoZSBwbGFjZWQgZW50cnksIHdlIGhhdmUgZm91bmQgYSBnb29kIGVtcHR5IHNwYWNlIGFuZCBjYW4gc3RvcC5cbiAgICAgICAgICAgIC8vIGlmIHN0cmljdE9yZGVyLCBrZWVwIGZpbmRpbmcgbW9yZSBsYXRlcmFsIGludGVyc2VjdGlvbnMuXG4gICAgICAgICAgICBpZiAoIXN0cmljdE9yZGVyICYmIHRyYWNraW5nQ29vcmQgPj0gY2FuZGlkYXRlQ29vcmQgKyB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKG5ld0VudHJ5KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cmllcyA9IGVudHJpZXNCeUxldmVsW3RyYWNraW5nTGV2ZWxdO1xuICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cnk7XG4gICAgICAgICAgICBsZXQgc2VhcmNoUmVzID0gYmluYXJ5U2VhcmNoKHRyYWNraW5nRW50cmllcywgbmV3RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTsgLy8gZmluZCBmaXJzdCBlbnRyeSBhZnRlciBuZXdFbnRyeSdzIGVuZFxuICAgICAgICAgICAgbGV0IGxhdGVyYWxJbmRleCA9IHNlYXJjaFJlc1swXSArIHNlYXJjaFJlc1sxXTsgLy8gaWYgZXhhY3QgbWF0Y2ggKHdoaWNoIGRvZXNuJ3QgY29sbGlkZSksIGdvIHRvIG5leHQgb25lXG4gICAgICAgICAgICB3aGlsZSAoIC8vIGxvb3AgdGhyb3VnaCBlbnRyaWVzIHRoYXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdFxuICAgICAgICAgICAgKHRyYWNraW5nRW50cnkgPSB0cmFja2luZ0VudHJpZXNbbGF0ZXJhbEluZGV4XSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBlbnRyeSBsaXN0XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdFbnRyeS5zcGFuLnN0YXJ0IDwgbmV3RW50cnkuc3Bhbi5lbmQgLy8gYW5kIG5vdCBlbnRpcmVseSBwYXN0IG5ld0VudHJ5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhY2tpbmdFbnRyeUJvdHRvbSA9IHRyYWNraW5nQ29vcmQgKyB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKHRyYWNraW5nRW50cnkpO1xuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdHMgaW50byB0aGUgdG9wIG9mIHRoZSBjYW5kaWRhdGU/XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPiBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVDb29yZCA9IHRyYWNraW5nRW50cnlCb3R0b207XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nRW50cnkgPSB0cmFja2luZ0VudHJ5O1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0xldmVsID0gdHJhY2tpbmdMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdMYXRlcmFsID0gbGF0ZXJhbEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBidXR0cyB1cCBhZ2FpbnN0IHRvcCBvZiBjYW5kaWRhdGU/ICh3aWxsIGhhcHBlbiBpZiBqdXN0IGludGVyc2VjdGVkIGFzIHdlbGwpXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPT09IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY3VtdWxhdGUgdGhlIGhpZ2hlc3QgcG9zc2libGUgc3RhY2tDbnQgb2YgdGhlIHRyYWNraW5nRW50cmllcyB0aGF0IGJ1dHQgdXBcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tDbnQgPSBNYXRoLm1heChzdGFja0NudCwgc3RhY2tDbnRzW2J1aWxkRW50cnlLZXkodHJhY2tpbmdFbnRyeSldICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhdGVyYWxJbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBkZXN0aW5hdGlvbiBsZXZlbCB3aWxsIGJlIGFmdGVyIHRvdWNoaW5nRW50cnkncyBsZXZlbC4gZmluZCBpdFxuICAgICAgICBsZXQgZGVzdExldmVsID0gMDtcbiAgICAgICAgaWYgKHRvdWNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIGRlc3RMZXZlbCA9IHRvdWNoaW5nTGV2ZWwgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGRlc3RMZXZlbCA8IGxldmVsQ250ICYmIGxldmVsQ29vcmRzW2Rlc3RMZXZlbF0gPCBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgIGRlc3RMZXZlbCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFkZGluZyB0byBhbiBleGlzdGluZyBsZXZlbCwgZmluZCB3aGVyZSB0byBpbnNlcnRcbiAgICAgICAgbGV0IGRlc3RMYXRlcmFsID0gLTE7XG4gICAgICAgIGlmIChkZXN0TGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tkZXN0TGV2ZWxdID09PSBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgZGVzdExhdGVyYWwgPSBiaW5hcnlTZWFyY2goZW50cmllc0J5TGV2ZWxbZGVzdExldmVsXSwgbmV3RW50cnkuc3Bhbi5lbmQsIGdldEVudHJ5U3BhbkVuZClbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvdWNoaW5nTGV2ZWwsXG4gICAgICAgICAgICB0b3VjaGluZ0xhdGVyYWwsXG4gICAgICAgICAgICB0b3VjaGluZ0VudHJ5LFxuICAgICAgICAgICAgc3RhY2tDbnQsXG4gICAgICAgICAgICBsZXZlbENvb3JkOiBjYW5kaWRhdGVDb29yZCxcbiAgICAgICAgICAgIGxldmVsOiBkZXN0TGV2ZWwsXG4gICAgICAgICAgICBsYXRlcmFsOiBkZXN0TGF0ZXJhbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gc29ydGVkIGJ5IGxldmVsQ29vcmQgKGxvd2VzdCB0byBoaWdoZXN0KVxuICAgIHRvUmVjdHMoKSB7XG4gICAgICAgIGxldCB7IGVudHJpZXNCeUxldmVsLCBsZXZlbENvb3JkcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxldmVsQ250ID0gZW50cmllc0J5TGV2ZWwubGVuZ3RoO1xuICAgICAgICBsZXQgcmVjdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IGxldmVsQ250OyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBsZXQgZW50cmllcyA9IGVudHJpZXNCeUxldmVsW2xldmVsXTtcbiAgICAgICAgICAgIGxldCBsZXZlbENvb3JkID0gbGV2ZWxDb29yZHNbbGV2ZWxdO1xuICAgICAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIHJlY3RzLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnRyeSksIHsgdGhpY2tuZXNzOiB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKGVudHJ5KSwgbGV2ZWxDb29yZCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3RzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVudHJ5U3BhbkVuZChlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5zcGFuLmVuZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRW50cnlLZXkoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuaW5kZXggKyAnOicgKyBlbnRyeS5zcGFuLnN0YXJ0O1xufVxuLy8gcmV0dXJucyBncm91cHMgd2l0aCBlbnRyaWVzIHNvcnRlZCBieSBpbnB1dCBvcmRlclxuZnVuY3Rpb24gZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzKGVudHJpZXMpIHtcbiAgICBsZXQgbWVyZ2VzID0gW107XG4gICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBsZXQgZmlsdGVyZWRNZXJnZXMgPSBbXTtcbiAgICAgICAgbGV0IGh1bmdyeU1lcmdlID0ge1xuICAgICAgICAgICAgc3BhbjogZW50cnkuc3BhbixcbiAgICAgICAgICAgIGVudHJpZXM6IFtlbnRyeV0sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IG1lcmdlIG9mIG1lcmdlcykge1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdFNwYW5zKG1lcmdlLnNwYW4sIGh1bmdyeU1lcmdlLnNwYW4pKSB7XG4gICAgICAgICAgICAgICAgaHVuZ3J5TWVyZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXM6IG1lcmdlLmVudHJpZXMuY29uY2F0KGh1bmdyeU1lcmdlLmVudHJpZXMpLFxuICAgICAgICAgICAgICAgICAgICBzcGFuOiBqb2luU3BhbnMobWVyZ2Uuc3BhbiwgaHVuZ3J5TWVyZ2Uuc3BhbiksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkTWVyZ2VzLnB1c2gobWVyZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbHRlcmVkTWVyZ2VzLnB1c2goaHVuZ3J5TWVyZ2UpO1xuICAgICAgICBtZXJnZXMgPSBmaWx0ZXJlZE1lcmdlcztcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlcztcbn1cbmZ1bmN0aW9uIGpvaW5TcGFucyhzcGFuMCwgc3BhbjEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogTWF0aC5taW4oc3BhbjAuc3RhcnQsIHNwYW4xLnN0YXJ0KSxcbiAgICAgICAgZW5kOiBNYXRoLm1heChzcGFuMC5lbmQsIHNwYW4xLmVuZCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFNwYW5zKHNwYW4wLCBzcGFuMSkge1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHNwYW4wLnN0YXJ0LCBzcGFuMS5zdGFydCk7XG4gICAgbGV0IGVuZCA9IE1hdGgubWluKHNwYW4wLmVuZCwgc3BhbjEuZW5kKTtcbiAgICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIGdlbmVyYWwgdXRpbFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpbnNlcnRBdChhcnIsIGluZGV4LCBpdGVtKSB7XG4gICAgYXJyLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG59XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2goYSwgc2VhcmNoVmFsLCBnZXRJdGVtVmFsKSB7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICAgIGxldCBlbmRJbmRleCA9IGEubGVuZ3RoOyAvLyBleGNsdXNpdmVcbiAgICBpZiAoIWVuZEluZGV4IHx8IHNlYXJjaFZhbCA8IGdldEl0ZW1WYWwoYVtzdGFydEluZGV4XSkpIHsgLy8gbm8gaXRlbXMgT1IgYmVmb3JlIGZpcnN0IGl0ZW1cbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG4gICAgaWYgKHNlYXJjaFZhbCA+IGdldEl0ZW1WYWwoYVtlbmRJbmRleCAtIDFdKSkgeyAvLyBhZnRlciBsYXN0IGl0ZW1cbiAgICAgICAgcmV0dXJuIFtlbmRJbmRleCwgMF07XG4gICAgfVxuICAgIHdoaWxlIChzdGFydEluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgbGV0IG1pZGRsZUluZGV4ID0gTWF0aC5mbG9vcihzdGFydEluZGV4ICsgKGVuZEluZGV4IC0gc3RhcnRJbmRleCkgLyAyKTtcbiAgICAgICAgbGV0IG1pZGRsZVZhbCA9IGdldEl0ZW1WYWwoYVttaWRkbGVJbmRleF0pO1xuICAgICAgICBpZiAoc2VhcmNoVmFsIDwgbWlkZGxlVmFsKSB7XG4gICAgICAgICAgICBlbmRJbmRleCA9IG1pZGRsZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlYXJjaFZhbCA+IG1pZGRsZVZhbCkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IG1pZGRsZUluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gZXF1YWwhXG4gICAgICAgICAgICByZXR1cm4gW21pZGRsZUluZGV4LCAxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3N0YXJ0SW5kZXgsIDBdO1xufVxuXG4vKlxuQW4gYWJzdHJhY3Rpb24gZm9yIGEgZHJhZ2dpbmcgaW50ZXJhY3Rpb24gb3JpZ2luYXRpbmcgb24gYW4gZXZlbnQuXG5Eb2VzIGhpZ2hlci1sZXZlbCB0aGluZ3MgdGhhbiBQb2ludGVyRHJhZ2dlciwgc3VjaCBhcyBwb3NzaWJseTpcbi0gYSBcIm1pcnJvclwiIHRoYXQgbW92ZXMgd2l0aCB0aGUgcG9pbnRlclxuLSBhIG1pbmltdW0gbnVtYmVyIG9mIHBpeGVscyBvciBvdGhlciBjcml0ZXJpYSBmb3IgYSB0cnVlIGRyYWcgdG8gYmVnaW5cblxuc3ViY2xhc3NlcyBtdXN0IGVtaXQ6XG4tIHBvaW50ZXJkb3duXG4tIGRyYWdzdGFydFxuLSBkcmFnbW92ZVxuLSBwb2ludGVydXBcbi0gZHJhZ2VuZFxuKi9cbmNsYXNzIEVsZW1lbnREcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgfVxuICAgIHNldE1pcnJvcklzVmlzaWJsZShib29sKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXG4gICAgfVxuICAgIHNldE1pcnJvck5lZWRzUmV2ZXJ0KGJvb2wpIHtcbiAgICAgICAgLy8gb3B0aW9uYWwgaWYgc3ViY2xhc3MgZG9lc24ndCB3YW50IHRvIHN1cHBvcnQgYSBtaXJyb3JcbiAgICB9XG4gICAgc2V0QXV0b1Njcm9sbEVuYWJsZWQoYm9vbCkge1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgIH1cbn1cblxuLy8gVE9ETzogZ2V0IHJpZCBvZiB0aGlzIGluIGZhdm9yIG9mIG9wdGlvbnMgc3lzdGVtLFxuLy8gdGhvIGl0J3MgcmVhbGx5IGVhc3kgdG8gYWNjZXNzIHRoaXMgZ2xvYmFsbHkgcmF0aGVyIHRoYW4gcGFzcyB0aHJ1IG9wdGlvbnMuXG5jb25zdCBjb25maWcgPSB7fTtcblxuLypcbkluZm9ybWF0aW9uIGFib3V0IHdoYXQgd2lsbCBoYXBwZW4gd2hlbiBhbiBleHRlcm5hbCBlbGVtZW50IGlzIGRyYWdnZWQtYW5kLWRyb3BwZWRcbm9udG8gYSBjYWxlbmRhci4gQ29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGNyZWF0aW5nIGFuIGV2ZW50LlxuKi9cbmNvbnN0IERSQUdfTUVUQV9SRUZJTkVSUyA9IHtcbiAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBjcmVhdGU6IEJvb2xlYW4sXG4gICAgc291cmNlSWQ6IFN0cmluZyxcbn07XG5mdW5jdGlvbiBwYXJzZURyYWdNZXRhKHJhdykge1xuICAgIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVQcm9wcyhyYXcsIERSQUdfTUVUQV9SRUZJTkVSUyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICBkdXJhdGlvbjogcmVmaW5lZC5kdXJhdGlvbiB8fCBudWxsLFxuICAgICAgICBjcmVhdGU6IHJlZmluZWQuY3JlYXRlICE9IG51bGwgPyByZWZpbmVkLmNyZWF0ZSA6IHRydWUsXG4gICAgICAgIHNvdXJjZUlkOiByZWZpbmVkLnNvdXJjZUlkLFxuICAgICAgICBsZWZ0b3ZlclByb3BzOiBleHRyYSxcbiAgICB9O1xufVxuXG4vLyBDb21wdXRlcyBhIGRlZmF1bHQgY29sdW1uIGhlYWRlciBmb3JtYXR0aW5nIHN0cmluZyBpZiBgY29sRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXG5mdW5jdGlvbiBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRheUNudCkge1xuICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgd2VlayByb3csIG9yIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBjb2x1bW5zIHdpdGggbm90IG11Y2ggc3BhY2UsXG4gICAgLy8gcHV0IGp1c3QgdGhlIGRheSBudW1iZXJzIHdpbGwgYmUgaW4gZWFjaCBjZWxsXG4gICAgaWYgKCFkYXRlc1JlcERpc3RpbmN0RGF5cyB8fCBkYXlDbnQgPiAxMCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JyB9KTsgLy8gXCJTYXRcIlxuICAgIH1cbiAgICBpZiAoZGF5Q250ID4gMSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdudW1lcmljJywgZGF5OiAnbnVtZXJpYycsIG9taXRDb21tYXM6IHRydWUgfSk7IC8vIFwiU2F0IDExLzEyXCJcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdsb25nJyB9KTsgLy8gXCJTYXR1cmRheVwiXG59XG5cbmNvbnN0IENMQVNTX05BTUUgPSAnZmMtY29sLWhlYWRlci1jZWxsJzsgLy8gZG8gdGhlIGN1c2hpb24gdG9vPyBub1xuZnVuY3Rpb24gcmVuZGVySW5uZXIkMShyZW5kZXJQcm9wcykge1xuICAgIHJldHVybiByZW5kZXJQcm9wcy50ZXh0O1xufVxuXG4vLyBCQUQgbmFtZSBmb3IgdGhpcyBjbGFzcyBub3cuIHVzZWQgaW4gdGhlIEhlYWRlclxuY2xhc3MgVGFibGVEYXRlQ2VsbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucywgdGhlbWUsIHZpZXdBcGkgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGUsIGRhdGVQcm9maWxlIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCBwcm9wcy50b2RheVJhbmdlLCBudWxsLCBkYXRlUHJvZmlsZSk7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW0NMQVNTX05BTUVdLmNvbmNhdChnZXREYXlDbGFzc05hbWVzKGRheU1ldGEsIHRoZW1lKSk7XG4gICAgICAgIGxldCB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgcHJvcHMuZGF5SGVhZGVyRm9ybWF0KTtcbiAgICAgICAgLy8gaWYgY29sQ250IGlzIDEsIHdlIGFyZSBhbHJlYWR5IGluIGEgZGF5LXZpZXcgYW5kIGRvbid0IG5lZWQgYSBuYXZsaW5rXG4gICAgICAgIGxldCBuYXZMaW5rQXR0cnMgPSAoIWRheU1ldGEuaXNEaXNhYmxlZCAmJiBwcm9wcy5jb2xDbnQgPiAxKVxuICAgICAgICAgICAgPyBidWlsZE5hdkxpbmtBdHRycyh0aGlzLmNvbnRleHQsIGRhdGUpXG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLCB2aWV3OiB2aWV3QXBpIH0sIHByb3BzLmV4dHJhUmVuZGVyUHJvcHMpLCB7IHRleHQgfSksIGRheU1ldGEpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0aFwiLCBlbENsYXNzZXM6IGNsYXNzTmFtZXMsIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oeyByb2xlOiAnY29sdW1uaGVhZGVyJywgY29sU3BhbjogcHJvcHMuY29sU3BhbiwgJ2RhdGEtZGF0ZSc6ICFkYXlNZXRhLmlzRGlzYWJsZWQgPyBmb3JtYXREYXlTdHJpbmcoZGF0ZSkgOiB1bmRlZmluZWQgfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZGF5SGVhZGVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXIkMSwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRheUhlYWRlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudCB9LCAoSW5uZXJDb250YWluZXIpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiIH0sICFkYXlNZXRhLmlzRGlzYWJsZWQgJiYgKGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250YWluZXIsIHsgZWxUYWc6IFwiYVwiLCBlbEF0dHJzOiBuYXZMaW5rQXR0cnMsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgJiYgJ2ZjLXN0aWNreScsXG4gICAgICAgICAgICBdIH0pKSkpKSk7XG4gICAgfVxufVxuXG5jb25zdCBXRUVLREFZX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdsb25nJyB9KTtcbmNsYXNzIFRhYmxlRG93Q2VsbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIHRoZW1lLCB2aWV3QXBpLCBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBkYXRlID0gYWRkRGF5cyhuZXcgRGF0ZSgyNTkyMDAwMDApLCBwcm9wcy5kb3cpOyAvLyBzdGFydCB3aXRoIFN1biwgMDQgSmFuIDE5NzAgMDA6MDA6MDAgR01UXG4gICAgICAgIGxldCBkYXRlTWV0YSA9IHtcbiAgICAgICAgICAgIGRvdzogcHJvcHMuZG93LFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBpc0Z1dHVyZTogZmFsc2UsXG4gICAgICAgICAgICBpc1Bhc3Q6IGZhbHNlLFxuICAgICAgICAgICAgaXNUb2RheTogZmFsc2UsXG4gICAgICAgICAgICBpc090aGVyOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpO1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgLy8gVE9ETzogbWFrZSB0aGlzIHB1YmxpYz9cbiAgICAgICAgICAgIGRhdGUgfSwgZGF0ZU1ldGEpLCB7IHZpZXc6IHZpZXdBcGkgfSksIHByb3BzLmV4dHJhUmVuZGVyUHJvcHMpLCB7IHRleHQgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRoXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgIENMQVNTX05BTUUsXG4gICAgICAgICAgICAgICAgLi4uZ2V0RGF5Q2xhc3NOYW1lcyhkYXRlTWV0YSwgdGhlbWUpLFxuICAgICAgICAgICAgICAgIC4uLihwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pLFxuICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbih7IHJvbGU6ICdjb2x1bW5oZWFkZXInLCBjb2xTcGFuOiBwcm9wcy5jb2xTcGFuIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUhlYWRlckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyJDEsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmlzU3RpY2t5ICYmICdmYy1zdGlja3knLFxuICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiBkYXRlRW52LmZvcm1hdChkYXRlLCBXRUVLREFZX0ZPUk1BVCksXG4gICAgICAgICAgICAgICAgfSB9KSkpKSk7XG4gICAgfVxufVxuXG5jbGFzcyBOb3dUaW1lciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLmluaXRpYWxOb3dEYXRlID0gZ2V0Tm93KGNvbnRleHQub3B0aW9ucy5ub3csIGNvbnRleHQuZGF0ZUVudik7XG4gICAgICAgIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5jb21wdXRlVGltaW5nKCkuY3VycmVudFN0YXRlO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHN0YXRlLm5vd0RhdGUsIHN0YXRlLnRvZGF5UmFuZ2UpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHByZXZQcm9wcy51bml0ICE9PSB0aGlzLnByb3BzLnVuaXQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB9XG4gICAgY29tcHV0ZVRpbWluZygpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB1bnJvdW5kZWROb3cgPSBhZGRNcyh0aGlzLmluaXRpYWxOb3dEYXRlLCBuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyk7XG4gICAgICAgIGxldCBjdXJyZW50VW5pdFN0YXJ0ID0gY29udGV4dC5kYXRlRW52LnN0YXJ0T2YodW5yb3VuZGVkTm93LCBwcm9wcy51bml0KTtcbiAgICAgICAgbGV0IG5leHRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuYWRkKGN1cnJlbnRVbml0U3RhcnQsIGNyZWF0ZUR1cmF0aW9uKDEsIHByb3BzLnVuaXQpKTtcbiAgICAgICAgbGV0IHdhaXRNcyA9IG5leHRVbml0U3RhcnQudmFsdWVPZigpIC0gdW5yb3VuZGVkTm93LnZhbHVlT2YoKTtcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBtYXggc2V0VGltZW91dCBtcyB2YWx1ZSAoaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0Njg2NTAvOTYzNDIpXG4gICAgICAgIC8vIGVuc3VyZSBubyBsb25nZXIgdGhhbiBhIGRheVxuICAgICAgICB3YWl0TXMgPSBNYXRoLm1pbigxMDAwICogNjAgKiA2MCAqIDI0LCB3YWl0TXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlOiB7IG5vd0RhdGU6IGN1cnJlbnRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UoY3VycmVudFVuaXRTdGFydCkgfSxcbiAgICAgICAgICAgIG5leHRTdGF0ZTogeyBub3dEYXRlOiBuZXh0VW5pdFN0YXJ0LCB0b2RheVJhbmdlOiBidWlsZERheVJhbmdlKG5leHRVbml0U3RhcnQpIH0sXG4gICAgICAgICAgICB3YWl0TXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldFRpbWVvdXQoKSB7XG4gICAgICAgIGxldCB7IG5leHRTdGF0ZSwgd2FpdE1zIH0gPSB0aGlzLmNvbXB1dGVUaW1pbmcoKTtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgd2FpdE1zKTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Ob3dUaW1lci5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbmZ1bmN0aW9uIGJ1aWxkRGF5UmFuZ2UoZGF0ZSkge1xuICAgIGxldCBzdGFydCA9IHN0YXJ0T2ZEYXkoZGF0ZSk7XG4gICAgbGV0IGVuZCA9IGFkZERheXMoc3RhcnQsIDEpO1xuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cblxuY2xhc3MgRGF5SGVhZGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyID0gbWVtb2l6ZShjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVzLCBkYXRlUHJvZmlsZSwgZGF0ZXNSZXBEaXN0aW5jdERheXMsIHJlbmRlckludHJvIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgZGF5SGVhZGVyRm9ybWF0ID0gdGhpcy5jcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIoY29udGV4dC5vcHRpb25zLmRheUhlYWRlckZvcm1hdCwgZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChOb3dUaW1lciwgeyB1bml0OiBcImRheVwiIH0sIChub3dEYXRlLCB0b2RheVJhbmdlKSA9PiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJyb3dcIiB9LFxuICAgICAgICAgICAgcmVuZGVySW50cm8gJiYgcmVuZGVySW50cm8oJ2RheScpLFxuICAgICAgICAgICAgZGF0ZXMubWFwKChkYXRlKSA9PiAoZGF0ZXNSZXBEaXN0aW5jdERheXMgPyAoY3JlYXRlRWxlbWVudChUYWJsZURhdGVDZWxsLCB7IGtleTogZGF0ZS50b0lTT1N0cmluZygpLCBkYXRlOiBkYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIGNvbENudDogZGF0ZXMubGVuZ3RoLCBkYXlIZWFkZXJGb3JtYXQ6IGRheUhlYWRlckZvcm1hdCB9KSkgOiAoY3JlYXRlRWxlbWVudChUYWJsZURvd0NlbGwsIHsga2V5OiBkYXRlLmdldFVUQ0RheSgpLCBkb3c6IGRhdGUuZ2V0VVRDRGF5KCksIGRheUhlYWRlckZvcm1hdDogZGF5SGVhZGVyRm9ybWF0IH0pKSkpKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIoZXhwbGljaXRGb3JtYXQsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlQ250KSB7XG4gICAgcmV0dXJuIGV4cGxpY2l0Rm9ybWF0IHx8IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdChkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZUNudCk7XG59XG5cbmNsYXNzIERheVNlcmllc01vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICAgICAgbGV0IGRhdGUgPSByYW5nZS5zdGFydDtcbiAgICAgICAgbGV0IHsgZW5kIH0gPSByYW5nZTtcbiAgICAgICAgbGV0IGluZGljZXMgPSBbXTtcbiAgICAgICAgbGV0IGRhdGVzID0gW107XG4gICAgICAgIGxldCBkYXlJbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoZGF0ZSA8IGVuZCkgeyAvLyBsb29wIGVhY2ggZGF5IGZyb20gc3RhcnQgdG8gZW5kXG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGVHZW5lcmF0b3IuaXNIaWRkZW5EYXkoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXggKyAwLjUpOyAvLyBtYXJrIHRoYXQgaXQncyBiZXR3ZWVuIGluZGljZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRheUluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4KTtcbiAgICAgICAgICAgICAgICBkYXRlcy5wdXNoKGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRlcyA9IGRhdGVzO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzO1xuICAgICAgICB0aGlzLmNudCA9IGRhdGVzLmxlbmd0aDtcbiAgICB9XG4gICAgc2xpY2VSYW5nZShyYW5nZSkge1xuICAgICAgICBsZXQgZmlyc3RJbmRleCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KHJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XG4gICAgICAgIGxldCBsYXN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChhZGREYXlzKHJhbmdlLmVuZCwgLTEpKTsgLy8gaW5jbHVzaXZlIGxhc3QgaW5kZXhcbiAgICAgICAgbGV0IGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5tYXgoMCwgZmlyc3RJbmRleCk7XG4gICAgICAgIGxldCBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5taW4odGhpcy5jbnQgLSAxLCBsYXN0SW5kZXgpO1xuICAgICAgICAvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXG4gICAgICAgIGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5jZWlsKGNsaXBwZWRGaXJzdEluZGV4KTsgLy8gaW4tYmV0d2VlbiBzdGFydHMgcm91bmQgdG8gbmV4dCBjZWxsXG4gICAgICAgIGNsaXBwZWRMYXN0SW5kZXggPSBNYXRoLmZsb29yKGNsaXBwZWRMYXN0SW5kZXgpOyAvLyBpbi1iZXR3ZWVuIGVuZHMgcm91bmQgdG8gcHJldiBjZWxsXG4gICAgICAgIGlmIChjbGlwcGVkRmlyc3RJbmRleCA8PSBjbGlwcGVkTGFzdEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZpcnN0SW5kZXg6IGNsaXBwZWRGaXJzdEluZGV4LFxuICAgICAgICAgICAgICAgIGxhc3RJbmRleDogY2xpcHBlZExhc3RJbmRleCxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmaXJzdEluZGV4ID09PSBjbGlwcGVkRmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICBpc0VuZDogbGFzdEluZGV4ID09PSBjbGlwcGVkTGFzdEluZGV4LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gR2l2ZW4gYSBkYXRlLCByZXR1cm5zIGl0cyBjaHJvbm9sb2NpYWwgY2VsbC1pbmRleCBmcm9tIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBncmlkLlxuICAgIC8vIElmIHRoZSBkYXRlIGxpZXMgYmV0d2VlbiBjZWxscyAoYmVjYXVzZSBvZiBoaWRkZW5EYXlzKSwgcmV0dXJucyBhIGZsb2F0aW5nLXBvaW50IHZhbHVlIGJldHdlZW4gb2Zmc2V0cy5cbiAgICAvLyBJZiBiZWZvcmUgdGhlIGZpcnN0IG9mZnNldCwgcmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlci5cbiAgICAvLyBJZiBhZnRlciB0aGUgbGFzdCBvZmZzZXQsIHJldHVybnMgYW4gb2Zmc2V0IHBhc3QgdGhlIGxhc3QgY2VsbCBvZmZzZXQuXG4gICAgLy8gT25seSB3b3JrcyBmb3IgKnN0YXJ0KiBkYXRlcyBvZiBjZWxscy4gV2lsbCBub3Qgd29yayBmb3IgZXhjbHVzaXZlIGVuZCBkYXRlcyBmb3IgY2VsbHMuXG4gICAgZ2V0RGF0ZURheUluZGV4KGRhdGUpIHtcbiAgICAgICAgbGV0IHsgaW5kaWNlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGRheU9mZnNldCA9IE1hdGguZmxvb3IoZGlmZkRheXModGhpcy5kYXRlc1swXSwgZGF0ZSkpO1xuICAgICAgICBpZiAoZGF5T2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGljZXNbMF0gLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlPZmZzZXQgPj0gaW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRpY2VzW2RheU9mZnNldF07XG4gICAgfVxufVxuXG5jbGFzcyBEYXlUYWJsZU1vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcihkYXlTZXJpZXMsIGJyZWFrT25XZWVrcykge1xuICAgICAgICBsZXQgeyBkYXRlcyB9ID0gZGF5U2VyaWVzO1xuICAgICAgICBsZXQgZGF5c1BlclJvdztcbiAgICAgICAgbGV0IGZpcnN0RGF5O1xuICAgICAgICBsZXQgcm93Q250O1xuICAgICAgICBpZiAoYnJlYWtPbldlZWtzKSB7XG4gICAgICAgICAgICAvLyBjb3VudCBjb2x1bW5zIHVudGlsIHRoZSBkYXktb2Ytd2VlayByZXBlYXRzXG4gICAgICAgICAgICBmaXJzdERheSA9IGRhdGVzWzBdLmdldFVUQ0RheSgpO1xuICAgICAgICAgICAgZm9yIChkYXlzUGVyUm93ID0gMTsgZGF5c1BlclJvdyA8IGRhdGVzLmxlbmd0aDsgZGF5c1BlclJvdyArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVzW2RheXNQZXJSb3ddLmdldFVUQ0RheSgpID09PSBmaXJzdERheSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dDbnQgPSBNYXRoLmNlaWwoZGF0ZXMubGVuZ3RoIC8gZGF5c1BlclJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3dDbnQgPSAxO1xuICAgICAgICAgICAgZGF5c1BlclJvdyA9IGRhdGVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd0NudCA9IHJvd0NudDtcbiAgICAgICAgdGhpcy5jb2xDbnQgPSBkYXlzUGVyUm93O1xuICAgICAgICB0aGlzLmRheVNlcmllcyA9IGRheVNlcmllcztcbiAgICAgICAgdGhpcy5jZWxscyA9IHRoaXMuYnVpbGRDZWxscygpO1xuICAgICAgICB0aGlzLmhlYWRlckRhdGVzID0gdGhpcy5idWlsZEhlYWRlckRhdGVzKCk7XG4gICAgfVxuICAgIGJ1aWxkQ2VsbHMoKSB7XG4gICAgICAgIGxldCByb3dzID0gW107XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGNlbGxzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKHRoaXMuYnVpbGRDZWxsKHJvdywgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dzLnB1c2goY2VsbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dzO1xuICAgIH1cbiAgICBidWlsZENlbGwocm93LCBjb2wpIHtcbiAgICAgICAgbGV0IGRhdGUgPSB0aGlzLmRheVNlcmllcy5kYXRlc1tyb3cgKiB0aGlzLmNvbENudCArIGNvbF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGJ1aWxkSGVhZGVyRGF0ZXMoKSB7XG4gICAgICAgIGxldCBkYXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIGRhdGVzLnB1c2godGhpcy5jZWxsc1swXVtjb2xdLmRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlcztcbiAgICB9XG4gICAgc2xpY2VSYW5nZShyYW5nZSkge1xuICAgICAgICBsZXQgeyBjb2xDbnQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZXJpZXNTZWcgPSB0aGlzLmRheVNlcmllcy5zbGljZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgbGV0IHNlZ3MgPSBbXTtcbiAgICAgICAgaWYgKHNlcmllc1NlZykge1xuICAgICAgICAgICAgbGV0IHsgZmlyc3RJbmRleCwgbGFzdEluZGV4IH0gPSBzZXJpZXNTZWc7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBmaXJzdEluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDw9IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gY29sQ250KTtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gTWF0aC5taW4oKHJvdyArIDEpICogY29sQ250LCBsYXN0SW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q29sOiBpbmRleCAlIGNvbENudCxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbDogKG5leHRJbmRleCAtIDEpICUgY29sQ250LFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZXJpZXNTZWcuaXNTdGFydCAmJiBpbmRleCA9PT0gZmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlcmllc1NlZy5pc0VuZCAmJiAobmV4dEluZGV4IC0gMSkgPT09IGxhc3RJbmRleCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9XG59XG5cbmNsYXNzIFNsaWNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2xpY2VCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZSh0aGlzLl9zbGljZUJ1c2luZXNzSG91cnMpO1xuICAgICAgICB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc2xpY2VEYXRlU3Bhbik7XG4gICAgICAgIHRoaXMuc2xpY2VFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zbGljZUV2ZW50U3RvcmUpO1xuICAgICAgICB0aGlzLnNsaWNlRXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5zbGljZUV2ZW50UmVzaXplID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gPSBmYWxzZTsgLy8gaGFja1xuICAgIH1cbiAgICBzbGljZVByb3BzKHByb3BzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIGxldCB7IGV2ZW50VWlCYXNlcyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBldmVudFNlZ3MgPSB0aGlzLnNsaWNlRXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvblNlZ3M6IHRoaXMuc2xpY2VEYXRlU2VsZWN0aW9uKHByb3BzLmRhdGVTZWxlY3Rpb24sIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBldmVudFVpQmFzZXMsIGNvbnRleHQsIC4uLmV4dHJhQXJncyksXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJTZWdzOiB0aGlzLnNsaWNlQnVzaW5lc3NIb3Vycyhwcm9wcy5idXNpbmVzc0hvdXJzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGZnRXZlbnRTZWdzOiBldmVudFNlZ3MuZmcsXG4gICAgICAgICAgICBiZ0V2ZW50U2VnczogZXZlbnRTZWdzLmJnLFxuICAgICAgICAgICAgZXZlbnREcmFnOiB0aGlzLnNsaWNlRXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZywgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiB0aGlzLnNsaWNlRXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncyksXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sXG4gICAgICAgIH07IC8vIFRPRE86IGdpdmUgaW50ZXJhY3Rpb25TZWdzP1xuICAgIH1cbiAgICBzbGljZU5vd0RhdGUoLy8gZG9lcyBub3QgbWVtb2l6ZVxuICAgIGRhdGUsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlRGF0ZVNwYW4oeyByYW5nZTogeyBzdGFydDogZGF0ZSwgZW5kOiBhZGRNcyhkYXRlLCAxKSB9LCBhbGxEYXk6IGZhbHNlIH0sIC8vIGFkZCAxIG1zLCBwcm90ZWN0IGFnYWluc3QgbnVsbCByYW5nZVxuICAgICAgICBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwge30sIGNvbnRleHQsIC4uLmV4dHJhQXJncyk7XG4gICAgfVxuICAgIF9zbGljZUJ1c2luZXNzSG91cnMoYnVzaW5lc3NIb3VycywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBpZiAoIWJ1c2luZXNzSG91cnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2xpY2VFdmVudFN0b3JlKGV4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBjb250ZXh0KSwge30sIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpLmJnO1xuICAgIH1cbiAgICBfc2xpY2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBpZiAoZXZlbnRTdG9yZSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlUmVzID0gc2xpY2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgbmV4dERheVRocmVzaG9sZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuYmcsIGV4dHJhQXJncyksXG4gICAgICAgICAgICAgICAgZmc6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5mZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYmc6IFtdLCBmZzogW10gfTtcbiAgICB9XG4gICAgX3NsaWNlSW50ZXJhY3Rpb24oaW50ZXJhY3Rpb24sIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBpZiAoIWludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZ2VSZXMgPSBzbGljZUV2ZW50U3RvcmUoaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cywgZXZlbnRVaUJhc2VzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBuZXh0RGF5VGhyZXNob2xkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlZ3M6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5mZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMsXG4gICAgICAgICAgICBpc0V2ZW50OiBpbnRlcmFjdGlvbi5pc0V2ZW50LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfc2xpY2VEYXRlU3BhbihkYXRlU3BhbiwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGV2ZW50VWlCYXNlcywgY29udGV4dCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIGlmICghZGF0ZVNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aXZlUmFuZ2UgPSBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpO1xuICAgICAgICBsZXQgYWN0aXZlRGF0ZVNwYW5SYW5nZSA9IGludGVyc2VjdFJhbmdlcyhkYXRlU3Bhbi5yYW5nZSwgYWN0aXZlUmFuZ2UpO1xuICAgICAgICBpZiAoYWN0aXZlRGF0ZVNwYW5SYW5nZSkge1xuICAgICAgICAgICAgZGF0ZVNwYW4gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGVTcGFuKSwgeyByYW5nZTogYWN0aXZlRGF0ZVNwYW5SYW5nZSB9KTtcbiAgICAgICAgICAgIGxldCBldmVudFJhbmdlID0gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGxldCBzZWdzID0gdGhpcy5zbGljZVJhbmdlKGRhdGVTcGFuLnJhbmdlLCAuLi5leHRyYUFyZ3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8qXG4gICAgXCJjb21wbGV0ZVwiIHNlZyBtZWFucyBpdCBoYXMgY29tcG9uZW50IGFuZCBldmVudFJhbmdlXG4gICAgKi9cbiAgICBzbGljZUV2ZW50UmFuZ2VzKGV2ZW50UmFuZ2VzLCBleHRyYUFyZ3MpIHtcbiAgICAgICAgbGV0IHNlZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZXZlbnRSYW5nZSBvZiBldmVudFJhbmdlcykge1xuICAgICAgICAgICAgc2Vncy5wdXNoKC4uLnRoaXMuc2xpY2VFdmVudFJhbmdlKGV2ZW50UmFuZ2UsIGV4dHJhQXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbiAgICAvKlxuICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAgICovXG4gICAgc2xpY2VFdmVudFJhbmdlKGV2ZW50UmFuZ2UsIGV4dHJhQXJncykge1xuICAgICAgICBsZXQgZGF0ZVJhbmdlID0gZXZlbnRSYW5nZS5yYW5nZTtcbiAgICAgICAgLy8gaGFjayB0byBtYWtlIG11bHRpLWRheSBldmVudHMgdGhhdCBhcmUgYmVpbmcgZm9yY2UtZGlzcGxheWVkIGFzIGxpc3QtaXRlbXMgdG8gdGFrZSB1cCBvbmx5IG9uZSBkYXlcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtICYmIGV2ZW50UmFuZ2UudWkuZGlzcGxheSA9PT0gJ2xpc3QtaXRlbScpIHtcbiAgICAgICAgICAgIGRhdGVSYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZVJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogYWRkRGF5cyhkYXRlUmFuZ2Uuc3RhcnQsIDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VncyA9IHRoaXMuc2xpY2VSYW5nZShkYXRlUmFuZ2UsIC4uLmV4dHJhQXJncyk7XG4gICAgICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgICAgICBzZWcuaXNTdGFydCA9IGV2ZW50UmFuZ2UuaXNTdGFydCAmJiBzZWcuaXNTdGFydDtcbiAgICAgICAgICAgIHNlZy5pc0VuZCA9IGV2ZW50UmFuZ2UuaXNFbmQgJiYgc2VnLmlzRW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbn1cbi8qXG5mb3IgaW5jb3Jwb3JhdGluZyBzbG90TWluVGltZS9zbG90TWF4VGltZSBpZiBhcHByb3ByaWF0ZVxuVE9ETzogc2hvdWxkIGJlIHBhcnQgb2YgRGF0ZVByb2ZpbGUhXG5UaW1lbGluZURhdGVQcm9maWxlIGFscmVhZHkgZG9lcyB0aGlzIGJ0d1xuKi9cbmZ1bmN0aW9uIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgaXNDb21wb25lbnRBbGxEYXkpIHtcbiAgICBsZXQgcmFuZ2UgPSBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZTtcbiAgICBpZiAoaXNDb21wb25lbnRBbGxEYXkpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogYWRkTXMocmFuZ2Uuc3RhcnQsIGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lLm1pbGxpc2Vjb25kcyksXG4gICAgICAgIGVuZDogYWRkTXMocmFuZ2UuZW5kLCBkYXRlUHJvZmlsZS5zbG90TWF4VGltZS5taWxsaXNlY29uZHMgLSA4NjRlNSksIC8vIDg2NGU1ID0gbXMgaW4gYSBkYXlcbiAgICB9O1xufVxuXG4vLyBoaWdoLWxldmVsIHNlZ21lbnRpbmctYXdhcmUgdGVzdGVyIGZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgaW5zdGFuY2VzIH0gPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzO1xuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGlmICghcmFuZ2VDb250YWluc1JhbmdlKGRhdGVQcm9maWxlLnZhbGlkUmFuZ2UsIGluc3RhbmNlc1tpbnN0YW5jZUlkXS5yYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNOZXdQcm9wc1ZhbGlkKHsgZXZlbnREcmFnOiBpbnRlcmFjdGlvbiB9LCBjb250ZXh0KTsgLy8gSEFDSzogdGhlIGV2ZW50RHJhZyBwcm9wcyBpcyB1c2VkIGZvciBBTEwgaW50ZXJhY3Rpb25zXG59XG5mdW5jdGlvbiBpc0RhdGVTZWxlY3Rpb25WYWxpZChkYXRlU2VsZWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGlmICghcmFuZ2VDb250YWluc1JhbmdlKGRhdGVQcm9maWxlLnZhbGlkUmFuZ2UsIGRhdGVTZWxlY3Rpb24ucmFuZ2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTmV3UHJvcHNWYWxpZCh7IGRhdGVTZWxlY3Rpb24gfSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc05ld1Byb3BzVmFsaWQobmV3UHJvcHMsIGNvbnRleHQpIHtcbiAgICBsZXQgY2FsZW5kYXJTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKHsgYnVzaW5lc3NIb3VyczogY2FsZW5kYXJTdGF0ZS5idXNpbmVzc0hvdXJzLCBkYXRlU2VsZWN0aW9uOiAnJywgZXZlbnRTdG9yZTogY2FsZW5kYXJTdGF0ZS5ldmVudFN0b3JlLCBldmVudFVpQmFzZXM6IGNhbGVuZGFyU3RhdGUuZXZlbnRVaUJhc2VzLCBldmVudFNlbGVjdGlvbjogJycsIGV2ZW50RHJhZzogbnVsbCwgZXZlbnRSZXNpemU6IG51bGwgfSwgbmV3UHJvcHMpO1xuICAgIHJldHVybiAoY29udGV4dC5wbHVnaW5Ib29rcy5pc1Byb3BzVmFsaWQgfHwgaXNQcm9wc1ZhbGlkKShwcm9wcywgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc1Byb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSA9IHt9LCBmaWx0ZXJDb25maWcpIHtcbiAgICBpZiAoc3RhdGUuZXZlbnREcmFnICYmICFpc0ludGVyYWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24gJiYgIWlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gTW92aW5nIEV2ZW50IFZhbGlkYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgbGV0IGN1cnJlbnRTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICBsZXQgaW50ZXJhY3Rpb24gPSBzdGF0ZS5ldmVudERyYWc7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xuICAgIGxldCBzdWJqZWN0RXZlbnRTdG9yZSA9IGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHM7XG4gICAgbGV0IHN1YmplY3REZWZzID0gc3ViamVjdEV2ZW50U3RvcmUuZGVmcztcbiAgICBsZXQgc3ViamVjdEluc3RhbmNlcyA9IHN1YmplY3RFdmVudFN0b3JlLmluc3RhbmNlcztcbiAgICBsZXQgc3ViamVjdENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoc3ViamVjdERlZnMsIGludGVyYWN0aW9uLmlzRXZlbnQgP1xuICAgICAgICBzdGF0ZS5ldmVudFVpQmFzZXMgOlxuICAgICAgICB7ICcnOiBjdXJyZW50U3RhdGUuc2VsZWN0aW9uQ29uZmlnIH0pO1xuICAgIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgc3ViamVjdENvbmZpZ3MgPSBtYXBIYXNoKHN1YmplY3RDb25maWdzLCBmaWx0ZXJDb25maWcpO1xuICAgIH1cbiAgICAvLyBleGNsdWRlIHRoZSBzdWJqZWN0IGV2ZW50cy4gVE9ETzogZXhjbHVkZSBkZWZzIHRvbz9cbiAgICBsZXQgb3RoZXJFdmVudFN0b3JlID0gZXhjbHVkZUluc3RhbmNlcyhzdGF0ZS5ldmVudFN0b3JlLCBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMpO1xuICAgIGxldCBvdGhlckRlZnMgPSBvdGhlckV2ZW50U3RvcmUuZGVmcztcbiAgICBsZXQgb3RoZXJJbnN0YW5jZXMgPSBvdGhlckV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIGxldCBvdGhlckNvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMob3RoZXJEZWZzLCBzdGF0ZS5ldmVudFVpQmFzZXMpO1xuICAgIGZvciAobGV0IHN1YmplY3RJbnN0YW5jZUlkIGluIHN1YmplY3RJbnN0YW5jZXMpIHtcbiAgICAgICAgbGV0IHN1YmplY3RJbnN0YW5jZSA9IHN1YmplY3RJbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdO1xuICAgICAgICBsZXQgc3ViamVjdFJhbmdlID0gc3ViamVjdEluc3RhbmNlLnJhbmdlO1xuICAgICAgICBsZXQgc3ViamVjdENvbmZpZyA9IHN1YmplY3RDb25maWdzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGxldCBzdWJqZWN0RGVmID0gc3ViamVjdERlZnNbc3ViamVjdEluc3RhbmNlLmRlZklkXTtcbiAgICAgICAgLy8gY29uc3RyYWludFxuICAgICAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzdWJqZWN0Q29uZmlnLmNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgc3RhdGUuYnVzaW5lc3NIb3VycywgY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdmVybGFwXG4gICAgICAgIGxldCB7IGV2ZW50T3ZlcmxhcCB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICBsZXQgZXZlbnRPdmVybGFwRnVuYyA9IHR5cGVvZiBldmVudE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBldmVudE92ZXJsYXAgOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBvdGhlckluc3RhbmNlSWQgaW4gb3RoZXJJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGxldCBvdGhlckluc3RhbmNlID0gb3RoZXJJbnN0YW5jZXNbb3RoZXJJbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICAgICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc3ViamVjdFJhbmdlLCBvdGhlckluc3RhbmNlLnJhbmdlKSkge1xuICAgICAgICAgICAgICAgIGxldCBvdGhlck92ZXJsYXAgPSBvdGhlckNvbmZpZ3Nbb3RoZXJJbnN0YW5jZS5kZWZJZF0ub3ZlcmxhcDtcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgb3RoZXIgZXZlbnQncyBvdmVybGFwLiBvbmx5IGRvIHRoaXMgaWYgdGhlIHN1YmplY3QgZXZlbnQgaXMgYSBcInJlYWxcIiBldmVudFxuICAgICAgICAgICAgICAgIGlmIChvdGhlck92ZXJsYXAgPT09IGZhbHNlICYmIGludGVyYWN0aW9uLmlzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3ViamVjdENvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudE92ZXJsYXBGdW5jICYmICFldmVudE92ZXJsYXBGdW5jKG5ldyBFdmVudEltcGwoY29udGV4dCwgb3RoZXJEZWZzW290aGVySW5zdGFuY2UuZGVmSWRdLCBvdGhlckluc3RhbmNlKSwgLy8gc3RpbGwgZXZlbnRcbiAgICAgICAgICAgICAgICBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHN1YmplY3REZWYsIHN1YmplY3RJbnN0YW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxsb3cgKGEgZnVuY3Rpb24pXG4gICAgICAgIGxldCBjYWxlbmRhckV2ZW50U3RvcmUgPSBjdXJyZW50U3RhdGUuZXZlbnRTdG9yZTsgLy8gbmVlZCBnbG9iYWwtdG8tY2FsZW5kYXIsIG5vdCBsb2NhbCB0byBjb21wb25lbnQgKHNwbGl0dGFibGUpc3RhdGVcbiAgICAgICAgZm9yIChsZXQgc3ViamVjdEFsbG93IG9mIHN1YmplY3RDb25maWcuYWxsb3dzKSB7XG4gICAgICAgICAgICBsZXQgc3ViamVjdERhdGVTcGFuID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRlU3Bhbk1ldGEpLCB7IHJhbmdlOiBzdWJqZWN0SW5zdGFuY2UucmFuZ2UsIGFsbERheTogc3ViamVjdERlZi5hbGxEYXkgfSk7XG4gICAgICAgICAgICBsZXQgb3JpZ0RlZiA9IGNhbGVuZGFyRXZlbnRTdG9yZS5kZWZzW3N1YmplY3REZWYuZGVmSWRdO1xuICAgICAgICAgICAgbGV0IG9yaWdJbnN0YW5jZSA9IGNhbGVuZGFyRXZlbnRTdG9yZS5pbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdO1xuICAgICAgICAgICAgbGV0IGV2ZW50QXBpO1xuICAgICAgICAgICAgaWYgKG9yaWdEZWYpIHsgLy8gd2FzIHByZXZpb3VzbHkgaW4gdGhlIGNhbGVuZGFyXG4gICAgICAgICAgICAgICAgZXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIG9yaWdEZWYsIG9yaWdJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gd2FzIGFuIGV4dGVybmFsIGV2ZW50XG4gICAgICAgICAgICAgICAgZXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHN1YmplY3REZWYpOyAvLyBubyBpbnN0YW5jZSwgYmVjYXVzZSBoYWQgbm8gZGF0ZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3ViamVjdEFsbG93KGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChzdWJqZWN0RGF0ZVNwYW4sIGNvbnRleHQpLCBldmVudEFwaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBEYXRlIFNlbGVjdGlvbiBWYWxpZGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgbGV0IHJlbGV2YW50RXZlbnRTdG9yZSA9IHN0YXRlLmV2ZW50U3RvcmU7XG4gICAgbGV0IHJlbGV2YW50RGVmcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5kZWZzO1xuICAgIGxldCByZWxldmFudEluc3RhbmNlcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHN0YXRlLmRhdGVTZWxlY3Rpb247XG4gICAgbGV0IHNlbGVjdGlvblJhbmdlID0gc2VsZWN0aW9uLnJhbmdlO1xuICAgIGxldCB7IHNlbGVjdGlvbkNvbmZpZyB9ID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnID0gZmlsdGVyQ29uZmlnKHNlbGVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIC8vIGNvbnN0cmFpbnRcbiAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzZWxlY3Rpb25Db25maWcuY29uc3RyYWludHMsIHNlbGVjdGlvblJhbmdlLCByZWxldmFudEV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gb3ZlcmxhcFxuICAgIGxldCB7IHNlbGVjdE92ZXJsYXAgfSA9IGNvbnRleHQub3B0aW9ucztcbiAgICBsZXQgc2VsZWN0T3ZlcmxhcEZ1bmMgPSB0eXBlb2Ygc2VsZWN0T3ZlcmxhcCA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdE92ZXJsYXAgOiBudWxsO1xuICAgIGZvciAobGV0IHJlbGV2YW50SW5zdGFuY2VJZCBpbiByZWxldmFudEluc3RhbmNlcykge1xuICAgICAgICBsZXQgcmVsZXZhbnRJbnN0YW5jZSA9IHJlbGV2YW50SW5zdGFuY2VzW3JlbGV2YW50SW5zdGFuY2VJZF07XG4gICAgICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICAgICAgaWYgKHJhbmdlc0ludGVyc2VjdChzZWxlY3Rpb25SYW5nZSwgcmVsZXZhbnRJbnN0YW5jZS5yYW5nZSkpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Db25maWcub3ZlcmxhcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0T3ZlcmxhcEZ1bmMgJiYgIXNlbGVjdE92ZXJsYXBGdW5jKG5ldyBFdmVudEltcGwoY29udGV4dCwgcmVsZXZhbnREZWZzW3JlbGV2YW50SW5zdGFuY2UuZGVmSWRdLCByZWxldmFudEluc3RhbmNlKSwgbnVsbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWxsb3cgKGEgZnVuY3Rpb24pXG4gICAgZm9yIChsZXQgc2VsZWN0aW9uQWxsb3cgb2Ygc2VsZWN0aW9uQ29uZmlnLmFsbG93cykge1xuICAgICAgICBsZXQgZnVsbERhdGVTcGFuID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRlU3Bhbk1ldGEpLCBzZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbkFsbG93KGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChmdWxsRGF0ZVNwYW4sIGNvbnRleHQpLCBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gQ29uc3RyYWludCBVdGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBhbGxDb25zdHJhaW50c1Bhc3MoY29uc3RyYWludHMsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgY29udGV4dCkge1xuICAgIGZvciAobGV0IGNvbnN0cmFpbnQgb2YgY29uc3RyYWludHMpIHtcbiAgICAgICAgaWYgKCFhbnlSYW5nZXNDb250YWluUmFuZ2UoY29uc3RyYWludFRvUmFuZ2VzKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgY29udGV4dCksIHN1YmplY3RSYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnN0cmFpbnRUb1Jhbmdlcyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIC8vIGZvciBleHBhbmRpbmcgYSByZWN1cnJpbmcgY29uc3RyYWludCwgb3IgZXhwYW5kaW5nIGJ1c2luZXNzIGhvdXJzXG5vdGhlckV2ZW50U3RvcmUsIC8vIGZvciBpZiBjb25zdHJhaW50IGlzIGFuIGV2ZW4gZ3JvdXAgSURcbmJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCAvLyBmb3IgaWYgY29uc3RyYWludCBpcyAnYnVzaW5lc3NIb3VycydcbmNvbnRleHQpIHtcbiAgICBpZiAoY29uc3RyYWludCA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XG4gICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZXhwYW5kUmVjdXJyaW5nKGJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCBzdWJqZWN0UmFuZ2UsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnc3RyaW5nJykgeyAvLyBhbiBncm91cCBJRFxuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGZpbHRlckV2ZW50U3RvcmVEZWZzKG90aGVyRXZlbnRTdG9yZSwgKGV2ZW50RGVmKSA9PiBldmVudERlZi5ncm91cElkID09PSBjb25zdHJhaW50KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ29iamVjdCcgJiYgY29uc3RyYWludCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhleHBhbmRSZWN1cnJpbmcoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBbXTsgLy8gaWYgaXQncyBmYWxzZVxufVxuLy8gVE9ETzogbW92ZSB0byBldmVudC1zdG9yZSBmaWxlP1xuZnVuY3Rpb24gZXZlbnRTdG9yZVRvUmFuZ2VzKGV2ZW50U3RvcmUpIHtcbiAgICBsZXQgeyBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmU7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKGluc3RhbmNlc1tpbnN0YW5jZUlkXS5yYW5nZSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG4vLyBUT0RPOiBtb3ZlIHRvIGdlb20gZmlsZT9cbmZ1bmN0aW9uIGFueVJhbmdlc0NvbnRhaW5SYW5nZShvdXRlclJhbmdlcywgaW5uZXJSYW5nZSkge1xuICAgIGZvciAobGV0IG91dGVyUmFuZ2Ugb2Ygb3V0ZXJSYW5nZXMpIHtcbiAgICAgICAgaWYgKHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlLCBpbm5lclJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBWSVNJQkxFX0hJRERFTl9SRSA9IC9eKHZpc2libGV8aGlkZGVuKSQvO1xuY2xhc3MgU2Nyb2xsZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgbGlxdWlkLCBsaXF1aWRJc0Fic29sdXRlIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGlzQWJzb2x1dGUgPSBsaXF1aWQgJiYgbGlxdWlkSXNBYnNvbHV0ZTtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IFsnZmMtc2Nyb2xsZXInXTtcbiAgICAgICAgaWYgKGxpcXVpZCkge1xuICAgICAgICAgICAgaWYgKGxpcXVpZElzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUucHVzaCgnZmMtc2Nyb2xsZXItbGlxdWlkLWFic29sdXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUucHVzaCgnZmMtc2Nyb2xsZXItbGlxdWlkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmhhbmRsZUVsLCBjbGFzc05hbWU6IGNsYXNzTmFtZS5qb2luKCcgJyksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiBwcm9wcy5vdmVyZmxvd1gsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dZOiBwcm9wcy5vdmVyZmxvd1ksXG4gICAgICAgICAgICAgICAgbGVmdDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUxlZnQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAoaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lUmlnaHQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUJvdHRvbSB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVMZWZ0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVSaWdodCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAoIWlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUJvdHRvbSB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBwcm9wcy5tYXhIZWlnaHQgfHwgJycsXG4gICAgICAgICAgICB9IH0sIHByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIG5lZWRzWFNjcm9sbGluZygpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdGluZyBzY3JvbGxXaWR0aD5jbGllbnRXaWR0aCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAgICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICAgIGxldCB7IGVsIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcmVhbENsaWVudFdpZHRoID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIHRoaXMuZ2V0WVNjcm9sbGJhcldpZHRoKCk7XG4gICAgICAgIGxldCB7IGNoaWxkcmVuIH0gPSBlbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkRWwgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoID4gcmVhbENsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBuZWVkc1lTY3JvbGxpbmcoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3Rpbmcgc2Nyb2xsSGVpZ2h0PmNsaWVudEhlaWdodCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAgICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICAgIGxldCB7IGVsIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcmVhbENsaWVudEhlaWdodCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IC0gdGhpcy5nZXRYU2Nyb2xsYmFyV2lkdGgoKTtcbiAgICAgICAgbGV0IHsgY2hpbGRyZW4gfSA9IGVsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRFbCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ID4gcmVhbENsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0WFNjcm9sbGJhcldpZHRoKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm9mZnNldEhlaWdodCAtIHRoaXMuZWwuY2xpZW50SGVpZ2h0OyAvLyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2UgZ3VhcmFudGVlIG5vIGJvcmRlcnMuIFRPRE86IGFkZCB0byBDU1Mgd2l0aCBpbXBvcnRhbnQ/XG4gICAgfVxuICAgIGdldFlTY3JvbGxiYXJXaWR0aCgpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1kpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbC5vZmZzZXRXaWR0aCAtIHRoaXMuZWwuY2xpZW50V2lkdGg7IC8vIG9ubHkgd29ya3MgYmVjYXVzZSB3ZSBndWFyYW50ZWUgbm8gYm9yZGVycy4gVE9ETzogYWRkIHRvIENTUyB3aXRoIGltcG9ydGFudD9cbiAgICB9XG59XG5cbi8qXG5UT0RPOiBzb21laG93IGluZmVyIE90aGVyQXJncyBmcm9tIG1hc3RlckNhbGxiYWNrP1xuVE9ETzogaW5mZXIgUmVmVHlwZSBmcm9tIG1hc3RlckNhbGxiYWNrIGlmIHByb3ZpZGVkXG4qL1xuY2xhc3MgUmVmTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihtYXN0ZXJDYWxsYmFjaykge1xuICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrID0gbWFzdGVyQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMuY3VycmVudE1hcCA9IHt9O1xuICAgICAgICB0aGlzLmRlcHRocyA9IHt9O1xuICAgICAgICB0aGlzLmNhbGxiYWNrTWFwID0ge307XG4gICAgICAgIHRoaXMuaGFuZGxlVmFsdWUgPSAodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGRlcHRocywgY3VycmVudE1hcCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCByZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgYnVnLi4uIEFDVFVBTExZOiBjYW4gcHJvYmFibHkgZG8gYXdheSB3aXRoIHRoaXMgbm93IHRoYXQgY2FsbGVycyBkb24ndCBzaGFyZSBudW1lcmljIGluZGljZXMgYW55bW9yZVxuICAgICAgICAgICAgICAgIHJlbW92ZWQgPSAoa2V5IGluIGN1cnJlbnRNYXApO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXBba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICBkZXB0aHNba2V5XSA9IChkZXB0aHNba2V5XSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGhzW2tleV0gLT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1hc3RlckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayhudWxsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrKHZhbCwgU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlUmVmKGtleSkge1xuICAgICAgICBsZXQgcmVmQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XG4gICAgICAgIGlmICghcmVmQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldID0gKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsdWUodmFsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZDYWxsYmFjaztcbiAgICB9XG4gICAgLy8gVE9ETzogY2hlY2sgY2FsbGVycyB0aGF0IGRvbid0IGNhcmUgYWJvdXQgb3JkZXIuIHNob3VsZCB1c2UgZ2V0QWxsIGluc3RlYWRcbiAgICAvLyBOT1RFOiB0aGlzIG1ldGhvZCBoYXMgYmVjb21lIGxlc3MgdmFsdWFibGUgbm93IHRoYXQgd2UgYXJlIGVuY291cmFnZWQgdG8gbWFwIG9yZGVyIGJ5IHNvbWUgb3RoZXIgaW5kZXhcbiAgICAvLyBUT0RPOiBwcm92aWRlIE9ORSBhcnJheS1leHBvcnQgZnVuY3Rpb24sIGJ1aWxkQXJyYXksIHdoaWNoIGZhaWxzIG9uIG5vbi1udW1lcmljIGluZGV4ZXMuIGNhbGxlciBjYW4gbWFuaXB1bGF0ZSBhbmQgXCJjb2xsZWN0XCJcbiAgICBjb2xsZWN0KHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0RnJvbUhhc2godGhpcy5jdXJyZW50TWFwLCBzdGFydEluZGV4LCBlbmRJbmRleCwgc3RlcCk7XG4gICAgfVxuICAgIGdldEFsbCgpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hWYWx1ZXNUb0FycmF5KHRoaXMuY3VycmVudE1hcCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlU2hyaW5rV2lkdGgoY2h1bmtFbHMpIHtcbiAgICBsZXQgc2hyaW5rQ2VsbHMgPSBmaW5kRWxlbWVudHMoY2h1bmtFbHMsICcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnKTtcbiAgICBsZXQgbGFyZ2VzdFdpZHRoID0gMDtcbiAgICBmb3IgKGxldCBzaHJpbmtDZWxsIG9mIHNocmlua0NlbGxzKSB7XG4gICAgICAgIGxhcmdlc3RXaWR0aCA9IE1hdGgubWF4KGxhcmdlc3RXaWR0aCwgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKHNocmlua0NlbGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguY2VpbChsYXJnZXN0V2lkdGgpOyAvLyA8dGFibGU+IGVsZW1lbnRzIHdvcmsgYmVzdCB3aXRoIGludGVnZXJzLiByb3VuZCB1cCB0byBlbnN1cmUgY29udGVudHMgZml0c1xufVxuZnVuY3Rpb24gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBwcm9wcy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQ7IC8vIGRvZXMgdGhlIHNlY3Rpb24gZG8gbGlxdWlkLWhlaWdodD8gKG5lZWQgdG8gaGF2ZSB3aG9sZSBzY3JvbGxncmlkIGxpcXVpZC1oZWlnaHQgYXMgd2VsbClcbn1cbmZ1bmN0aW9uIGdldEFsbG93WVNjcm9sbGluZyhwcm9wcywgc2VjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCAhPSBudWxsIHx8IC8vIGlmIGl0cyBwb3NzaWJsZSBmb3IgdGhlIGhlaWdodCB0byBtYXggb3V0LCB3ZSBtaWdodCBuZWVkIHNjcm9sbGJhcnNcbiAgICAgICAgZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7IC8vIGlmIHRoZSBzZWN0aW9uIGlzIGxpcXVpZCBoZWlnaHQsIGl0IG1pZ2h0IGNvbmRlbnNlIGVub3VnaCB0byByZXF1aXJlIHNjcm9sbGJhcnNcbn1cbi8vIFRPRE86IE9OTFkgdXNlIGBhcmdgLiBmb3JjZSBvdXQgaW50ZXJuYWwgZnVuY3Rpb24gdG8gdXNlIHNhbWUgQVBJXG5mdW5jdGlvbiByZW5kZXJDaHVua0NvbnRlbnQoc2VjdGlvbkNvbmZpZywgY2h1bmtDb25maWcsIGFyZywgaXNIZWFkZXIpIHtcbiAgICBsZXQgeyBleHBhbmRSb3dzIH0gPSBhcmc7XG4gICAgbGV0IGNvbnRlbnQgPSB0eXBlb2YgY2h1bmtDb25maWcuY29udGVudCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIGNodW5rQ29uZmlnLmNvbnRlbnQoYXJnKSA6XG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoJ3RhYmxlJywge1xuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXG4gICAgICAgICAgICBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICBjaHVua0NvbmZpZy50YWJsZUNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBzZWN0aW9uQ29uZmlnLnN5bmNSb3dIZWlnaHRzID8gJ2ZjLXNjcm9sbGdyaWQtc3luYy10YWJsZScgOiAnJyxcbiAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogYXJnLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGFyZy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGV4cGFuZFJvd3MgPyBhcmcuY2xpZW50SGVpZ2h0IDogJycsIC8vIGNzcyBgaGVpZ2h0YCBvbiBhIDx0YWJsZT4gc2VydmVzIGFzIGEgbWluLWhlaWdodFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgYXJnLnRhYmxlQ29sR3JvdXBOb2RlLCBjcmVhdGVFbGVtZW50KGlzSGVhZGVyID8gJ3RoZWFkJyA6ICd0Ym9keScsIHtcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxuICAgICAgICB9LCB0eXBlb2YgY2h1bmtDb25maWcucm93Q29udGVudCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBjaHVua0NvbmZpZy5yb3dDb250ZW50KGFyZylcbiAgICAgICAgICAgIDogY2h1bmtDb25maWcucm93Q29udGVudCkpO1xuICAgIHJldHVybiBjb250ZW50O1xufVxuZnVuY3Rpb24gaXNDb2xQcm9wc0VxdWFsKGNvbHMwLCBjb2xzMSkge1xuICAgIHJldHVybiBpc0FycmF5c0VxdWFsKGNvbHMwLCBjb2xzMSwgaXNQcm9wc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHJlbmRlck1pY3JvQ29sR3JvdXAoY29scywgc2hyaW5rV2lkdGgpIHtcbiAgICBsZXQgY29sTm9kZXMgPSBbXTtcbiAgICAvKlxuICAgIGZvciBDb2xQcm9wcyB3aXRoIHNwYW5zLCBpdCB3b3VsZCBoYXZlIGJlZW4gZ3JlYXQgdG8gbWFrZSBhIHNpbmdsZSA8Y29sIHNwYW49XCJcIj5cbiAgICBIT1dFVkVSLCBDaHJvbWUgd2FzIGdldHRpbmcgbWVzc2luZyB1cCBkaXN0cmlidXRpbmcgdGhlIHdpZHRoIHRvIDx0ZD4vPHRoPiBlbGVtZW50cyB3aXRoIGNvbHNwYW5zLlxuICAgIFNPTFVUSU9OOiBtYWtpbmcgaW5kaXZpZHVhbCA8Y29sPiBlbGVtZW50cyBtYWtlcyBDaHJvbWUgYmVoYXZlLlxuICAgICovXG4gICAgZm9yIChsZXQgY29sUHJvcHMgb2YgY29scykge1xuICAgICAgICBsZXQgc3BhbiA9IGNvbFByb3BzLnNwYW4gfHwgMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbE5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChcImNvbFwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2xQcm9wcy53aWR0aCA9PT0gJ3NocmluaycgPyBzYW5pdGl6ZVNocmlua1dpZHRoKHNocmlua1dpZHRoKSA6IChjb2xQcm9wcy53aWR0aCB8fCAnJyksXG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBjb2xQcm9wcy5taW5XaWR0aCB8fCAnJyxcbiAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnY29sZ3JvdXAnLCB7fSwgLi4uY29sTm9kZXMpO1xufVxuZnVuY3Rpb24gc2FuaXRpemVTaHJpbmtXaWR0aChzaHJpbmtXaWR0aCkge1xuICAgIC8qIHdoeSA0PyBpZiB3ZSBkbyAwLCBpdCB3aWxsIGtpbGwgYW55IGJvcmRlciwgd2hpY2ggYXJlIG5lZWRlZCBmb3IgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoXG4gICAgNCBhY2NvdW50cyBmb3IgMiAyLXBpeGVsIGJvcmRlcnMuIFRPRE86IGJldHRlciBzb2x1dGlvbj8gKi9cbiAgICByZXR1cm4gc2hyaW5rV2lkdGggPT0gbnVsbCA/IDQgOiBzaHJpbmtXaWR0aDtcbn1cbmZ1bmN0aW9uIGhhc1Nocmlua1dpZHRoKGNvbHMpIHtcbiAgICBmb3IgKGxldCBjb2wgb2YgY29scykge1xuICAgICAgICBpZiAoY29sLndpZHRoID09PSAnc2hyaW5rJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMobGlxdWlkLCBjb250ZXh0KSB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICdmYy1zY3JvbGxncmlkJyxcbiAgICAgICAgY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGUnKSxcbiAgICBdO1xuICAgIGlmIChsaXF1aWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLWxpcXVpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIGdldFNlY3Rpb25DbGFzc05hbWVzKHNlY3Rpb25Db25maWcsIHdob2xlVGFibGVWR3Jvdykge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uJyxcbiAgICAgICAgYGZjLXNjcm9sbGdyaWQtc2VjdGlvbi0ke3NlY3Rpb25Db25maWcudHlwZX1gLFxuICAgICAgICBzZWN0aW9uQ29uZmlnLmNsYXNzTmFtZSwgLy8gdXNlZD9cbiAgICBdO1xuICAgIGlmICh3aG9sZVRhYmxlVkdyb3cgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbi1saXF1aWQnKTtcbiAgICB9XG4gICAgaWYgKHNlY3Rpb25Db25maWcuaXNTdGlja3kpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5Jyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gcmVuZGVyU2Nyb2xsU2hpbShhcmcpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbVwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IGFyZy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIG1pbldpZHRoOiBhcmcudGFibGVNaW5XaWR0aCxcbiAgICAgICAgfSB9KSk7XG59XG5mdW5jdGlvbiBnZXRTdGlja3lIZWFkZXJEYXRlcyhvcHRpb25zKSB7XG4gICAgbGV0IHsgc3RpY2t5SGVhZGVyRGF0ZXMgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHN0aWNreUhlYWRlckRhdGVzID09IG51bGwgfHwgc3RpY2t5SGVhZGVyRGF0ZXMgPT09ICdhdXRvJykge1xuICAgICAgICBzdGlja3lIZWFkZXJEYXRlcyA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgfVxuICAgIHJldHVybiBzdGlja3lIZWFkZXJEYXRlcztcbn1cbmZ1bmN0aW9uIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihvcHRpb25zKSB7XG4gICAgbGV0IHsgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIH0gPSBvcHRpb25zO1xuICAgIGlmIChzdGlja3lGb290ZXJTY3JvbGxiYXIgPT0gbnVsbCB8fCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPT09ICdhdXRvJykge1xuICAgICAgICBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMudmlld0hlaWdodCA9PT0gJ2F1dG8nO1xuICAgIH1cbiAgICByZXR1cm4gc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyO1xufVxuXG5jbGFzcyBTaW1wbGVTY3JvbGxHcmlkIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0NvbHMgPSBtZW1vaXplKChhKSA9PiBhLCBpc0NvbFByb3BzRXF1YWwpOyAvLyBzbyB3ZSBnZXQgc2FtZSBgY29sc2AgcHJvcHMgZXZlcnkgdGltZVxuICAgICAgICAvLyB5dWNreSB0byBtZW1vaXplIFZOb2RlcywgYnV0IG11Y2ggbW9yZSBlZmZpY2llbnQgZm9yIGNvbnN1bWVyc1xuICAgICAgICB0aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAgPSBtZW1vaXplKHJlbmRlck1pY3JvQ29sR3JvdXApO1xuICAgICAgICB0aGlzLnNjcm9sbGVyUmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxlckVsUmVmcyA9IG5ldyBSZWZNYXAodGhpcy5faGFuZGxlU2Nyb2xsZXJFbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNocmlua1dpZHRoOiBudWxsLFxuICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFyczogZmFsc2UsXG4gICAgICAgICAgICBzY3JvbGxlckNsaWVudFdpZHRoczoge30sXG4gICAgICAgICAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiBjYW4gZG8gYSByZWFsbHkgc2ltcGxlIHByaW50LXZpZXcuIGRvbnQgbmVlZCB0byBqb2luIHJvd3NcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVTZXRTdGF0ZShPYmplY3QuYXNzaWduKHsgc2hyaW5rV2lkdGg6IHRoaXMuY29tcHV0ZVNocmlua1dpZHRoKCkgfSwgdGhpcy5jb21wdXRlU2Nyb2xsZXJEaW1zKCkpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZWN0aW9uQ29uZmlncyA9IHByb3BzLnNlY3Rpb25zIHx8IFtdO1xuICAgICAgICBsZXQgY29scyA9IHRoaXMucHJvY2Vzc0NvbHMocHJvcHMuY29scyk7XG4gICAgICAgIGxldCBtaWNyb0NvbEdyb3VwTm9kZSA9IHRoaXMucmVuZGVyTWljcm9Db2xHcm91cChjb2xzLCBzdGF0ZS5zaHJpbmtXaWR0aCk7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMocHJvcHMubGlxdWlkLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHByb3BzLmNvbGxhcHNpYmxlV2lkdGgpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1jb2xsYXBzaWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IG1ha2UgRFJZXG4gICAgICAgIGxldCBjb25maWdDbnQgPSBzZWN0aW9uQ29uZmlncy5sZW5ndGg7XG4gICAgICAgIGxldCBjb25maWdJID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRDb25maWc7XG4gICAgICAgIGxldCBoZWFkU2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIGxldCBib2R5U2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIGxldCBmb290U2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdoZWFkZXInKSB7XG4gICAgICAgICAgICBoZWFkU2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCB0cnVlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNvbmZpZ0kgPCBjb25maWdDbnQgJiYgKGN1cnJlbnRDb25maWcgPSBzZWN0aW9uQ29uZmlnc1tjb25maWdJXSkudHlwZSA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICBib2R5U2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBmYWxzZSkpO1xuICAgICAgICAgICAgY29uZmlnSSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdmb290ZXInKSB7XG4gICAgICAgICAgICBmb290U2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCB0cnVlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlyZWZveCBidWc6IHdoZW4gc2V0dGluZyBoZWlnaHQgb24gdGFibGUgYW5kIHRoZXJlIGlzIGEgdGhlYWQgb3IgdGZvb3QsXG4gICAgICAgIC8vIHRoZSBuZWNlc3NhcnkgaGVpZ2h0OjEwMCUgb24gdGhlIGxpcXVpZC1oZWlnaHQgYm9keSBzZWN0aW9uIGZvcmNlcyB0aGUgKndob2xlKiB0YWJsZSB0byBiZSB0YWxsZXIuIChidWcgIzU1MjQpXG4gICAgICAgIC8vIHVzZSBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwgYXMgYSB3YXkgdG8gZGV0ZWN0IHRhYmxlLXN0dXBpZCBmaXJlZm94LlxuICAgICAgICAvLyBpZiBzbywgdXNlIGEgc2ltcGxlciBkb20gc3RydWN0dXJlLCBqYW0gZXZlcnl0aGluZyBpbnRvIGEgbG9uZSB0Ym9keS5cbiAgICAgICAgbGV0IGlzQnVnZ3kgPSAhZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCk7XG4gICAgICAgIGNvbnN0IHJvbGVBdHRycyA9IHsgcm9sZTogJ3Jvd2dyb3VwJyB9O1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgndGFibGUnLCB7XG4gICAgICAgICAgICByb2xlOiAnZ3JpZCcsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLFxuICAgICAgICAgICAgc3R5bGU6IHsgaGVpZ2h0OiBwcm9wcy5oZWlnaHQgfSxcbiAgICAgICAgfSwgQm9vbGVhbighaXNCdWdneSAmJiBoZWFkU2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgY3JlYXRlRWxlbWVudCgndGhlYWQnLCByb2xlQXR0cnMsIC4uLmhlYWRTZWN0aW9uTm9kZXMpLCBCb29sZWFuKCFpc0J1Z2d5ICYmIGJvZHlTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiBjcmVhdGVFbGVtZW50KCd0Ym9keScsIHJvbGVBdHRycywgLi4uYm9keVNlY3Rpb25Ob2RlcyksIEJvb2xlYW4oIWlzQnVnZ3kgJiYgZm9vdFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIGNyZWF0ZUVsZW1lbnQoJ3Rmb290Jywgcm9sZUF0dHJzLCAuLi5mb290U2VjdGlvbk5vZGVzKSwgaXNCdWdneSAmJiBjcmVhdGVFbGVtZW50KCd0Ym9keScsIHJvbGVBdHRycywgLi4uaGVhZFNlY3Rpb25Ob2RlcywgLi4uYm9keVNlY3Rpb25Ob2RlcywgLi4uZm9vdFNlY3Rpb25Ob2RlcykpO1xuICAgIH1cbiAgICByZW5kZXJTZWN0aW9uKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBpc0hlYWRlcikge1xuICAgICAgICBpZiAoJ291dGVyQ29udGVudCcgaW4gc2VjdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXkgfSwgc2VjdGlvbkNvbmZpZy5vdXRlckNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXksIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgdGhpcy5wcm9wcy5saXF1aWQpLmpvaW4oJyAnKSB9LCB0aGlzLnJlbmRlckNodW5rVGQoc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHNlY3Rpb25Db25maWcuY2h1bmssIGlzSGVhZGVyKSkpO1xuICAgIH1cbiAgICByZW5kZXJDaHVua1RkKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBjaHVua0NvbmZpZywgaXNIZWFkZXIpIHtcbiAgICAgICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIGNodW5rQ29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmtDb25maWcub3V0ZXJDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBmb3JjZVlTY3JvbGxiYXJzLCBzY3JvbGxlckNsaWVudFdpZHRocywgc2Nyb2xsZXJDbGllbnRIZWlnaHRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgbmVlZHNZU2Nyb2xsaW5nID0gZ2V0QWxsb3dZU2Nyb2xsaW5nKHByb3BzLCBzZWN0aW9uQ29uZmlnKTsgLy8gVE9ETzogZG8gbGF6aWx5LiBkbyBpbiBzZWN0aW9uIGNvbmZpZz9cbiAgICAgICAgbGV0IGlzTGlxdWlkID0gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7XG4gICAgICAgIC8vIGZvciBgIXByb3BzLmxpcXVpZGAgLSBpcyBXSE9MRSBzY3JvbGxncmlkIG5hdHVyYWwgaGVpZ2h0P1xuICAgICAgICAvLyBUT0RPOiBkbyBzYW1lIHRoaW5nIGluIGFkdmFuY2VkIHNjcm9sbGdyaWQ/IHByb2xseSBub3QgYi9jIGFsd2F5cyBoYXMgaG9yaXpvbnRhbCBzY3JvbGxiYXJzXG4gICAgICAgIGxldCBvdmVyZmxvd1kgPSAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDpcbiAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnMgPyAnc2Nyb2xsJyA6XG4gICAgICAgICAgICAgICAgIW5lZWRzWVNjcm9sbGluZyA/ICdoaWRkZW4nIDpcbiAgICAgICAgICAgICAgICAgICAgJ2F1dG8nO1xuICAgICAgICBsZXQgc2VjdGlvbktleSA9IHNlY3Rpb25Db25maWcua2V5O1xuICAgICAgICBsZXQgY29udGVudCA9IHJlbmRlckNodW5rQ29udGVudChzZWN0aW9uQ29uZmlnLCBjaHVua0NvbmZpZywge1xuICAgICAgICAgICAgdGFibGVDb2xHcm91cE5vZGU6IG1pY3JvQ29sR3JvdXBOb2RlLFxuICAgICAgICAgICAgdGFibGVNaW5XaWR0aDogJycsXG4gICAgICAgICAgICBjbGllbnRXaWR0aDogKCFwcm9wcy5jb2xsYXBzaWJsZVdpZHRoICYmIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldICE9PSB1bmRlZmluZWQpID8gc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gOiBudWxsLFxuICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gIT09IHVuZGVmaW5lZCA/IHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA6IG51bGwsXG4gICAgICAgICAgICBleHBhbmRSb3dzOiBzZWN0aW9uQ29uZmlnLmV4cGFuZFJvd3MsXG4gICAgICAgICAgICBzeW5jUm93SGVpZ2h0czogZmFsc2UsXG4gICAgICAgICAgICByb3dTeW5jSGVpZ2h0czogW10sXG4gICAgICAgICAgICByZXBvcnRSb3dIZWlnaHRDaGFuZ2U6ICgpID0+IHsgfSxcbiAgICAgICAgfSwgaXNIZWFkZXIpO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChpc0hlYWRlciA/ICd0aCcgOiAndGQnLCB7XG4gICAgICAgICAgICByZWY6IGNodW5rQ29uZmlnLmVsUmVmLFxuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXG4gICAgICAgIH0sIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGBmYy1zY3JvbGxlci1oYXJuZXNzJHtpc0xpcXVpZCA/ICcgZmMtc2Nyb2xsZXItaGFybmVzcy1saXF1aWQnIDogJyd9YCB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChTY3JvbGxlciwgeyByZWY6IHRoaXMuc2Nyb2xsZXJSZWZzLmNyZWF0ZVJlZihzZWN0aW9uS2V5KSwgZWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZnMuY3JlYXRlUmVmKHNlY3Rpb25LZXkpLCBvdmVyZmxvd1k6IG92ZXJmbG93WSwgb3ZlcmZsb3dYOiAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDogJ2hpZGRlbicgLyogbmF0dXJhbCBoZWlnaHQ/ICovLCBtYXhIZWlnaHQ6IHNlY3Rpb25Db25maWcubWF4SGVpZ2h0LCBsaXF1aWQ6IGlzTGlxdWlkLCBsaXF1aWRJc0Fic29sdXRlIC8vIGJlY2F1c2UgaXRzIHdpdGhpbiBhIGhhcm5lc3NcbiAgICAgICAgICAgICAgICA6IHRydWUgfSwgY29udGVudCkpKTtcbiAgICB9XG4gICAgX2hhbmRsZVNjcm9sbGVyRWwoc2Nyb2xsZXJFbCwga2V5KSB7XG4gICAgICAgIGxldCBzZWN0aW9uID0gZ2V0U2VjdGlvbkJ5S2V5KHRoaXMucHJvcHMuc2VjdGlvbnMsIGtleSk7XG4gICAgICAgIGlmIChzZWN0aW9uKSB7XG4gICAgICAgICAgICBzZXRSZWYoc2VjdGlvbi5jaHVuay5zY3JvbGxlckVsUmVmLCBzY3JvbGxlckVsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVTaXppbmcpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIC8vIFRPRE86IG5lZWQgYmV0dGVyIHNvbHV0aW9uIHdoZW4gc3RhdGUgY29udGFpbnMgbm9uLXNpemluZyB0aGluZ3NcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcbiAgICB9XG4gICAgY29tcHV0ZVNocmlua1dpZHRoKCkge1xuICAgICAgICByZXR1cm4gaGFzU2hyaW5rV2lkdGgodGhpcy5wcm9wcy5jb2xzKVxuICAgICAgICAgICAgPyBjb21wdXRlU2hyaW5rV2lkdGgodGhpcy5zY3JvbGxlckVsUmVmcy5nZXRBbGwoKSlcbiAgICAgICAgICAgIDogMDtcbiAgICB9XG4gICAgY29tcHV0ZVNjcm9sbGVyRGltcygpIHtcbiAgICAgICAgbGV0IHNjcm9sbGJhcldpZHRoID0gZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XG4gICAgICAgIGxldCB7IHNjcm9sbGVyUmVmcywgc2Nyb2xsZXJFbFJlZnMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBmb3JjZVlTY3JvbGxiYXJzID0gZmFsc2U7XG4gICAgICAgIGxldCBzY3JvbGxlckNsaWVudFdpZHRocyA9IHt9O1xuICAgICAgICBsZXQgc2Nyb2xsZXJDbGllbnRIZWlnaHRzID0ge307XG4gICAgICAgIGZvciAobGV0IHNlY3Rpb25LZXkgaW4gc2Nyb2xsZXJSZWZzLmN1cnJlbnRNYXApIHtcbiAgICAgICAgICAgIGxldCBzY3JvbGxlciA9IHNjcm9sbGVyUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyICYmIHNjcm9sbGVyLm5lZWRzWVNjcm9sbGluZygpKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc2VjdGlvbiBvZiB0aGlzLnByb3BzLnNlY3Rpb25zKSB7XG4gICAgICAgICAgICBsZXQgc2VjdGlvbktleSA9IHNlY3Rpb24ua2V5O1xuICAgICAgICAgICAgbGV0IHNjcm9sbGVyRWwgPSBzY3JvbGxlckVsUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyRWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFybmVzc0VsID0gc2Nyb2xsZXJFbC5wYXJlbnROb2RlOyAvLyBUT0RPOiB3ZWlyZCB3YXkgdG8gZ2V0IHRoaXMuIG5lZWQgaGFybmVzcyBiL2MgZG9lc24ndCBpbmNsdWRlIHRhYmxlIGJvcmRlcnNcbiAgICAgICAgICAgICAgICBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gKGZvcmNlWVNjcm9sbGJhcnNcbiAgICAgICAgICAgICAgICAgICAgPyBzY3JvbGxiYXJXaWR0aC55IC8vIHVzZSBnbG9iYWwgYmVjYXVzZSBzY3JvbGxlciBtaWdodCBub3QgaGF2ZSBzY3JvbGxiYXJzIHlldCBidXQgd2lsbCBuZWVkIHRoZW0gaW4gZnV0dXJlXG4gICAgICAgICAgICAgICAgICAgIDogMCkpO1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9yY2VZU2Nyb2xsYmFycywgc2Nyb2xsZXJDbGllbnRXaWR0aHMsIHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyB9O1xuICAgIH1cbn1cblNpbXBsZVNjcm9sbEdyaWQuYWRkU3RhdGVFcXVhbGl0eSh7XG4gICAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IGlzUHJvcHNFcXVhbCxcbiAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuZnVuY3Rpb24gZ2V0U2VjdGlvbkJ5S2V5KHNlY3Rpb25zLCBrZXkpIHtcbiAgICBmb3IgKGxldCBzZWN0aW9uIG9mIHNlY3Rpb25zKSB7XG4gICAgICAgIGlmIChzZWN0aW9uLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY2xhc3MgRXZlbnRDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgc2V0RWxTZWcoZWwsIHRoaXMucHJvcHMuc2VnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHsgc2VnIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgeyBldmVudFJhbmdlIH0gPSBzZWc7XG4gICAgICAgIGNvbnN0IHsgdWkgfSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgIGNvbnN0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgdGltZVRleHQ6IHByb3BzLnRpbWVUZXh0LFxuICAgICAgICAgICAgdGV4dENvbG9yOiB1aS50ZXh0Q29sb3IsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHVpLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiB1aS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlOiAhcHJvcHMuZGlzYWJsZURyYWdnaW5nICYmIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSxcbiAgICAgICAgICAgIGlzU3RhcnRSZXNpemFibGU6ICFwcm9wcy5kaXNhYmxlUmVzaXppbmcgJiYgY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZywgY29udGV4dCksXG4gICAgICAgICAgICBpc0VuZFJlc2l6YWJsZTogIXByb3BzLmRpc2FibGVSZXNpemluZyAmJiBjb21wdXRlU2VnRW5kUmVzaXphYmxlKHNlZyksXG4gICAgICAgICAgICBpc01pcnJvcjogQm9vbGVhbihwcm9wcy5pc0RyYWdnaW5nIHx8IHByb3BzLmlzUmVzaXppbmcgfHwgcHJvcHMuaXNEYXRlU2VsZWN0aW5nKSxcbiAgICAgICAgICAgIGlzU3RhcnQ6IEJvb2xlYW4oc2VnLmlzU3RhcnQpLFxuICAgICAgICAgICAgaXNFbmQ6IEJvb2xlYW4oc2VnLmlzRW5kKSxcbiAgICAgICAgICAgIGlzUGFzdDogQm9vbGVhbihwcm9wcy5pc1Bhc3QpLFxuICAgICAgICAgICAgaXNGdXR1cmU6IEJvb2xlYW4ocHJvcHMuaXNGdXR1cmUpLFxuICAgICAgICAgICAgaXNUb2RheTogQm9vbGVhbihwcm9wcy5pc1RvZGF5KSxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IEJvb2xlYW4ocHJvcHMuaXNTZWxlY3RlZCksXG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBCb29sZWFuKHByb3BzLmlzRHJhZ2dpbmcpLFxuICAgICAgICAgICAgaXNSZXNpemluZzogQm9vbGVhbihwcm9wcy5pc1Jlc2l6aW5nKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGNvbnRhaW5zIGNoaWxkcmVuICovLCB7IGVsUmVmOiB0aGlzLmhhbmRsZUVsLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAuLi5nZXRFdmVudENsYXNzTmFtZXMocmVuZGVyUHJvcHMpLFxuICAgICAgICAgICAgICAgIC4uLnNlZy5ldmVudFJhbmdlLnVpLmNsYXNzTmFtZXMsXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICBdLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZXZlbnRDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5ldmVudENvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHByb3BzLmRlZmF1bHRHZW5lcmF0b3IsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5ldmVudENsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmV2ZW50RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmV2ZW50V2lsbFVubW91bnQgfSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5lbCAmJiB0aGlzLnByb3BzLnNlZyAhPT0gcHJldlByb3BzLnNlZykge1xuICAgICAgICAgICAgc2V0RWxTZWcodGhpcy5lbCwgdGhpcy5wcm9wcy5zZWcpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBzaG91bGQgbm90IGJlIGEgcHVyZWNvbXBvbmVudFxuY2xhc3MgU3RhbmRhcmRFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IHNlZyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB7IHVpIH0gPSBzZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgbGV0IHRpbWVGb3JtYXQgPSBvcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCBwcm9wcy5kZWZhdWx0VGltZUZvcm1hdDtcbiAgICAgICAgbGV0IHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyAvKiBpbmNsdWRlcyBlbFJlZiAqLywgeyBlbFRhZzogXCJhXCIsIGVsU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogdWkuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB1aS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICB9LCBlbEF0dHJzOiBnZXRTZWdBbmNob3JBdHRycyhzZWcsIGNvbnRleHQpLCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQkMSwgdGltZVRleHQ6IHRpbWVUZXh0IH0pLCAoSW5uZXJDb250ZW50LCBldmVudENvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy1ldmVudC1tYWluJ10sIGVsU3R5bGU6IHsgY29sb3I6IGV2ZW50Q29udGVudEFyZy50ZXh0Q29sb3IgfSB9KSxcbiAgICAgICAgICAgIEJvb2xlYW4oZXZlbnRDb250ZW50QXJnLmlzU3RhcnRSZXNpemFibGUpICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXJlc2l6ZXIgZmMtZXZlbnQtcmVzaXplci1zdGFydFwiIH0pKSxcbiAgICAgICAgICAgIEJvb2xlYW4oZXZlbnRDb250ZW50QXJnLmlzRW5kUmVzaXphYmxlKSAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1yZXNpemVyIGZjLWV2ZW50LXJlc2l6ZXItZW5kXCIgfSkpKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQkMShpbm5lclByb3BzKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LW1haW4tZnJhbWVcIiB9LFxuICAgICAgICBpbm5lclByb3BzLnRpbWVUZXh0ICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpbWVcIiB9LCBpbm5lclByb3BzLnRpbWVUZXh0KSksXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGUtY29udGFpbmVyXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGUgZmMtc3RpY2t5XCIgfSwgaW5uZXJQcm9wcy5ldmVudC50aXRsZSB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSkpO1xufVxuXG5jb25zdCBOb3dJbmRpY2F0b3JDb250YWluZXIgPSAocHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgaXNBeGlzOiBwcm9wcy5pc0F4aXMsXG4gICAgICAgIGRhdGU6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocHJvcHMuZGF0ZSksXG4gICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICB9O1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyAvKiBpbmNsdWRlcyBjaGlsZHJlbiAqLywgeyBlbFRhZzogcHJvcHMuZWxUYWcgfHwgJ2RpdicsIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJub3dJbmRpY2F0b3JDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5ub3dJbmRpY2F0b3JDb250ZW50LCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMubm93SW5kaWNhdG9yQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMubm93SW5kaWNhdG9yRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLm5vd0luZGljYXRvcldpbGxVbm1vdW50IH0pKSk7XG59KSk7XG5cbmNvbnN0IERBWV9OVU1fRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgZGF5OiAnbnVtZXJpYycgfSk7XG5jbGFzcyBEYXlDZWxsQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmVmaW5lUmVuZGVyUHJvcHMgPSBtZW1vaXplT2JqQXJnKHJlZmluZVJlbmRlclByb3BzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0gdGhpcy5yZWZpbmVSZW5kZXJQcm9wcyh7XG4gICAgICAgICAgICBkYXRlOiBwcm9wcy5kYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSxcbiAgICAgICAgICAgIGlzTW9udGhTdGFydDogcHJvcHMuaXNNb250aFN0YXJ0IHx8IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcixcbiAgICAgICAgICAgIGV4dHJhUmVuZGVyUHJvcHM6IHByb3BzLmV4dHJhUmVuZGVyUHJvcHMsXG4gICAgICAgICAgICB2aWV3QXBpOiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICBkYXRlRW52OiBjb250ZXh0LmRhdGVFbnYsXG4gICAgICAgICAgICBtb250aFN0YXJ0Rm9ybWF0OiBvcHRpb25zLm1vbnRoU3RhcnRGb3JtYXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogaW5jbHVkZXMgY2hpbGRyZW4gKi8sIHsgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgLi4uZ2V0RGF5Q2xhc3NOYW1lcyhyZW5kZXJQcm9wcywgY29udGV4dC50aGVtZSksXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICBdLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzLmVsQXR0cnMpLCAocmVuZGVyUHJvcHMuaXNEaXNhYmxlZCA/IHt9IDogeyAnZGF0YS1kYXRlJzogZm9ybWF0RGF5U3RyaW5nKHByb3BzLmRhdGUpIH0pKSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUNlbGxDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5kYXlDZWxsQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcHJvcHMuZGVmYXVsdEdlbmVyYXRvciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBcbiAgICAgICAgICAgIC8vIGRvbid0IHVzZSBjdXN0b20gY2xhc3NOYW1lcyBpZiBkaXNhYmxlZFxuICAgICAgICAgICAgcmVuZGVyUHJvcHMuaXNEaXNhYmxlZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuZGF5Q2VsbENsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRheUNlbGxEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5Q2VsbFdpbGxVbm1vdW50IH0pKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQob3B0aW9ucykge1xuICAgIHJldHVybiBCb29sZWFuKG9wdGlvbnMuZGF5Q2VsbENvbnRlbnQgfHwgaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcignZGF5Q2VsbENvbnRlbnQnLCBvcHRpb25zKSk7XG59XG5mdW5jdGlvbiByZWZpbmVSZW5kZXJQcm9wcyhyYXcpIHtcbiAgICBsZXQgeyBkYXRlLCBkYXRlRW52LCBkYXRlUHJvZmlsZSwgaXNNb250aFN0YXJ0IH0gPSByYXc7XG4gICAgbGV0IGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCByYXcudG9kYXlSYW5nZSwgbnVsbCwgZGF0ZVByb2ZpbGUpO1xuICAgIGxldCBkYXlOdW1iZXJUZXh0ID0gcmF3LnNob3dEYXlOdW1iZXIgPyAoZGF0ZUVudi5mb3JtYXQoZGF0ZSwgaXNNb250aFN0YXJ0ID8gcmF3Lm1vbnRoU3RhcnRGb3JtYXQgOiBEQVlfTlVNX0ZPUk1BVCkpIDogJyc7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgZGF0ZTogZGF0ZUVudi50b0RhdGUoZGF0ZSksIHZpZXc6IHJhdy52aWV3QXBpIH0sIGRheU1ldGEpLCB7IGlzTW9udGhTdGFydCxcbiAgICAgICAgZGF5TnVtYmVyVGV4dCB9KSwgcmF3LmV4dHJhUmVuZGVyUHJvcHMpO1xufVxuXG5jbGFzcyBCZ0V2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgc2VnIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtYmctZXZlbnQnXSwgZWxTdHlsZTogeyBiYWNrZ3JvdW5kQ29sb3I6IHNlZy5ldmVudFJhbmdlLnVpLmJhY2tncm91bmRDb2xvciB9LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQsIHNlZzogc2VnLCB0aW1lVGV4dDogXCJcIiwgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBmYWxzZSwgaXNQYXN0OiBwcm9wcy5pc1Bhc3QsIGlzRnV0dXJlOiBwcm9wcy5pc0Z1dHVyZSwgaXNUb2RheTogcHJvcHMuaXNUb2RheSwgZGlzYWJsZURyYWdnaW5nOiB0cnVlLCBkaXNhYmxlUmVzaXppbmc6IHRydWUgfSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChwcm9wcykge1xuICAgIGxldCB7IHRpdGxlIH0gPSBwcm9wcy5ldmVudDtcbiAgICByZXR1cm4gdGl0bGUgJiYgKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGVcIiB9LCBwcm9wcy5ldmVudC50aXRsZSkpO1xufVxuZnVuY3Rpb24gcmVuZGVyRmlsbChmaWxsVHlwZSkge1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogYGZjLSR7ZmlsbFR5cGV9YCB9KSk7XG59XG5cbmNvbnN0IFdlZWtOdW1iZXJDb250YWluZXIgPSAocHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCB7IGRhdGUgfSA9IHByb3BzO1xuICAgIGxldCBmb3JtYXQgPSBvcHRpb25zLndlZWtOdW1iZXJGb3JtYXQgfHwgcHJvcHMuZGVmYXVsdEZvcm1hdDtcbiAgICBsZXQgbnVtID0gZGF0ZUVudi5jb21wdXRlV2Vla051bWJlcihkYXRlKTsgLy8gVE9ETzogc29tZWhvdyB1c2UgZm9yIGZvcm1hdHRpbmcgYXMgd2VsbD9cbiAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIGZvcm1hdCk7XG4gICAgbGV0IHJlbmRlclByb3BzID0geyBudW0sIHRleHQsIGRhdGUgfTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciAvLyB3aHkgaXNuJ3QgV2Vla051bWJlckNvbnRlbnRBcmcgYmVpbmcgYXV0by1kZXRlY3RlZD9cbiAgICAsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGNoaWxkcmVuICovLCB7IHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJ3ZWVrTnVtYmVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMud2Vla051bWJlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMud2Vla051bWJlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLndlZWtOdW1iZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMud2Vla051bWJlcldpbGxVbm1vdW50IH0pKSk7XG59KSk7XG5mdW5jdGlvbiByZW5kZXJJbm5lcihpbm5lclByb3BzKSB7XG4gICAgcmV0dXJuIGlubmVyUHJvcHMudGV4dDtcbn1cblxuY29uc3QgUEFERElOR19GUk9NX1ZJRVdQT1JUID0gMTA7XG5jbGFzcyBQb3BvdmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB0aXRsZUlkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJvb3RFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb290RWwgPSBlbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzICphbnl3aGVyZSogaW4gdGhlIGRvY3VtZW50LCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmVcbiAgICAgICAgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgLy8gb25seSBoaWRlIHRoZSBwb3BvdmVyIGlmIHRoZSBjbGljayBoYXBwZW5lZCBvdXRzaWRlIHRoZSBwb3BvdmVyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldFZpYVJvb3QoZXYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb3RFbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDbG9zZUNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXYua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VDbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNsb3NlQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvbkNsb3NlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgdGhlbWUsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy1wb3BvdmVyJyxcbiAgICAgICAgICAgIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyJyksXG4gICAgICAgIF0uY29uY2F0KHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5leHRyYUF0dHJzLCB7IGlkOiBwcm9wcy5pZCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgXCJhcmlhLWxhYmVsbGVkYnlcIjogc3RhdGUudGl0bGVJZCwgcmVmOiB0aGlzLmhhbmRsZVJvb3RFbCB9KSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWhlYWRlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJIZWFkZXInKSB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImZjLXBvcG92ZXItdGl0bGVcIiwgaWQ6IHN0YXRlLnRpdGxlSWQgfSwgcHJvcHMudGl0bGUpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1jbG9zZSAnICsgdGhlbWUuZ2V0SWNvbkNsYXNzKCdjbG9zZScpLCB0aXRsZTogb3B0aW9ucy5jbG9zZUhpbnQsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xvc2VDbGljayB9KSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1ib2R5ICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckNvbnRlbnQnKSB9LCBwcm9wcy5jaGlsZHJlbikpLCBwcm9wcy5wYXJlbnRFbCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcbiAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcbiAgICB9XG4gICAgdXBkYXRlU2l6ZSgpIHtcbiAgICAgICAgbGV0IHsgaXNSdGwgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHsgcm9vdEVsIH0gPSB0aGlzO1xuICAgICAgICBsZXQgYWxpZ25tZW50UmVjdCA9IGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChhbGlnbm1lbnRFbCk7XG4gICAgICAgIGlmIChhbGlnbm1lbnRSZWN0KSB7XG4gICAgICAgICAgICBsZXQgcG9wb3ZlckRpbXMgPSByb290RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAvLyBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgICAgICAgICAgbGV0IHBvcG92ZXJUb3AgPSBhbGlnbkdyaWRUb3BcbiAgICAgICAgICAgICAgICA/IGVsZW1lbnRDbG9zZXN0KGFsaWdubWVudEVsLCAnLmZjLXNjcm9sbGdyaWQnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgICAgICAgICAgICAgICA6IGFsaWdubWVudFJlY3QudG9wO1xuICAgICAgICAgICAgbGV0IHBvcG92ZXJMZWZ0ID0gaXNSdGwgPyBhbGlnbm1lbnRSZWN0LnJpZ2h0IC0gcG9wb3ZlckRpbXMud2lkdGggOiBhbGlnbm1lbnRSZWN0LmxlZnQ7XG4gICAgICAgICAgICAvLyBjb25zdHJhaW5cbiAgICAgICAgICAgIHBvcG92ZXJUb3AgPSBNYXRoLm1heChwb3BvdmVyVG9wLCBQQURESU5HX0ZST01fVklFV1BPUlQpO1xuICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1pbihwb3BvdmVyTGVmdCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gUEFERElOR19GUk9NX1ZJRVdQT1JUIC0gcG9wb3ZlckRpbXMud2lkdGgpO1xuICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1heChwb3BvdmVyTGVmdCwgUEFERElOR19GUk9NX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgIGxldCBvcmlnaW4gPSByb290RWwub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgYXBwbHlTdHlsZShyb290RWwsIHtcbiAgICAgICAgICAgICAgICB0b3A6IHBvcG92ZXJUb3AgLSBvcmlnaW4udG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHBvcG92ZXJMZWZ0IC0gb3JpZ2luLmxlZnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgTW9yZVBvcG92ZXIgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb290RWwgPSAocm9vdEVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbCA9IHJvb3RFbDtcbiAgICAgICAgICAgIGlmIChyb290RWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgICAgIHVzZUV2ZW50Q2VudGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgZGF0ZUVudiB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgc3RhcnREYXRlLCB0b2RheVJhbmdlLCBkYXRlUHJvZmlsZSB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB0aXRsZSA9IGRhdGVFbnYuZm9ybWF0KHN0YXJ0RGF0ZSwgb3B0aW9ucy5kYXlQb3BvdmVyRm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KERheUNlbGxDb250YWluZXIsIHsgZWxSZWY6IHRoaXMuaGFuZGxlUm9vdEVsLCBkYXRlOiBzdGFydERhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSB9LCAoSW5uZXJDb250ZW50LCByZW5kZXJQcm9wcywgZWxBdHRycykgPT4gKGNyZWF0ZUVsZW1lbnQoUG9wb3ZlciwgeyBlbFJlZjogZWxBdHRycy5yZWYsIGlkOiBwcm9wcy5pZCwgdGl0bGU6IHRpdGxlLCBleHRyYUNsYXNzTmFtZXM6IFsnZmMtbW9yZS1wb3BvdmVyJ10uY29uY2F0KGVsQXR0cnMuY2xhc3NOYW1lIHx8IFtdKSwgZXh0cmFBdHRyczogZWxBdHRycyAvKiBUT0RPOiBtYWtlIHRoZXNlIHRpbWUtYmFzZWQgd2hlbiBub3Qgd2hvbGUtZGF5PyAqLywgcGFyZW50RWw6IHByb3BzLnBhcmVudEVsLCBhbGlnbm1lbnRFbDogcHJvcHMuYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcDogcHJvcHMuYWxpZ25HcmlkVG9wLCBvbkNsb3NlOiBwcm9wcy5vbkNsb3NlIH0sXG4gICAgICAgICAgICBoYXNDdXN0b21EYXlDZWxsQ29udGVudChvcHRpb25zKSAmJiAoY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy1tb3JlLXBvcG92ZXItbWlzYyddIH0pKSxcbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuKSkpKTtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgZWxXaWR0aCwgZWxIZWlnaHQpIHtcbiAgICAgICAgbGV0IHsgcm9vdEVsLCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHBvc2l0aW9uTGVmdCA+PSAwICYmIHBvc2l0aW9uTGVmdCA8IGVsV2lkdGggJiZcbiAgICAgICAgICAgIHBvc2l0aW9uVG9wID49IDAgJiYgcG9zaXRpb25Ub3AgPCBlbEhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IE9iamVjdC5hc3NpZ24oeyBhbGxEYXk6ICFwcm9wcy5mb3JjZVRpbWVkLCByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHByb3BzLnN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJvcHMuZW5kRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSB9LCBwcm9wcy5leHRyYURhdGVTcGFuKSxcbiAgICAgICAgICAgICAgICBkYXlFbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogZWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBlbEhlaWdodCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxheWVyOiAxLCAvLyBpbXBvcnRhbnQgd2hlbiBjb21wYXJpbmcgd2l0aCBoaXRzIGZyb20gb3RoZXIgY29tcG9uZW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmNsYXNzIE1vcmVMaW5rQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpc1BvcG92ZXJPcGVuOiBmYWxzZSxcbiAgICAgICAgICAgIHBvcG92ZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVMaW5rRWwgPSAobGlua0VsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxpbmtFbCA9IGxpbmtFbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGxpbmtFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpY2sgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgbW9yZUxpbmtDbGljayB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICAgICAgbGV0IGRhdGUgPSBjb21wdXRlUmFuZ2UocHJvcHMpLnN0YXJ0O1xuICAgICAgICAgICAgZnVuY3Rpb24gYnVpbGRQdWJsaWNTZWcoc2VnKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZGVmLCBpbnN0YW5jZSwgcmFuZ2UgfSA9IHNlZy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogY29udGV4dC5kYXRlRW52LnRvRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogY29udGV4dC5kYXRlRW52LnRvRGF0ZShyYW5nZS5lbmQpLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWcuaXNTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZy5pc0VuZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb3JlTGlua0NsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbW9yZUxpbmtDbGljayA9IG1vcmVMaW5rQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgICAgICAgICBhbGxEYXk6IEJvb2xlYW4ocHJvcHMuYWxsRGF5RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGFsbFNlZ3M6IHByb3BzLmFsbFNlZ3MubWFwKGJ1aWxkUHVibGljU2VnKSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuU2VnczogcHJvcHMuaGlkZGVuU2Vncy5tYXAoYnVpbGRQdWJsaWNTZWcpLFxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtb3JlTGlua0NsaWNrIHx8IG1vcmVMaW5rQ2xpY2sgPT09ICdwb3BvdmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc1BvcG92ZXJPcGVuOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1vcmVMaW5rQ2xpY2sgPT09ICdzdHJpbmcnKSB7IC8vIGEgdmlldyBuYW1lXG4gICAgICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS56b29tVG8oZGF0ZSwgbW9yZUxpbmtDbGljayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9wb3ZlckNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlzUG9wb3Zlck9wZW46IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGxldCB7IHZpZXdBcGksIG9wdGlvbnMsIGNhbGVuZGFyQXBpIH0gPSBjb250ZXh0O1xuICAgICAgICAgICAgbGV0IHsgbW9yZUxpbmtUZXh0IH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbGV0IHsgbW9yZUNudCB9ID0gcHJvcHM7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBjb21wdXRlUmFuZ2UocHJvcHMpO1xuICAgICAgICAgICAgbGV0IHRleHQgPSB0eXBlb2YgbW9yZUxpbmtUZXh0ID09PSAnZnVuY3Rpb24nIC8vIFRPRE86IGV2ZW50dWFsbHkgdXNlIGZvcm1hdFdpdGhPcmRpbmFsc1xuICAgICAgICAgICAgICAgID8gbW9yZUxpbmtUZXh0LmNhbGwoY2FsZW5kYXJBcGksIG1vcmVDbnQpXG4gICAgICAgICAgICAgICAgOiBgKyR7bW9yZUNudH0gJHttb3JlTGlua1RleHR9YDtcbiAgICAgICAgICAgIGxldCBoaW50ID0gZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubW9yZUxpbmtIaW50LCBbbW9yZUNudF0sIHRleHQpO1xuICAgICAgICAgICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgIG51bTogbW9yZUNudCxcbiAgICAgICAgICAgICAgICBzaG9ydFRleHQ6IGArJHttb3JlQ250fWAsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB2aWV3OiB2aWV3QXBpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICBCb29sZWFuKHByb3BzLm1vcmVDbnQpICYmIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdhJywgZWxSZWY6IHRoaXMuaGFuZGxlTGlua0VsLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLihwcm9wcy5lbENsYXNzZXMgfHwgW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLW1vcmUtbGluaycsXG4gICAgICAgICAgICAgICAgICAgIF0sIGVsU3R5bGU6IHByb3BzLmVsU3R5bGUsIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5lbEF0dHJzKSwgY3JlYXRlQXJpYUNsaWNrQXR0cnModGhpcy5oYW5kbGVDbGljaykpLCB7IHRpdGxlOiBoaW50LCAnYXJpYS1leHBhbmRlZCc6IHN0YXRlLmlzUG9wb3Zlck9wZW4sICdhcmlhLWNvbnRyb2xzJzogc3RhdGUuaXNQb3BvdmVyT3BlbiA/IHN0YXRlLnBvcG92ZXJJZCA6ICcnIH0pLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwibW9yZUxpbmtDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5tb3JlTGlua0NvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHByb3BzLmRlZmF1bHRHZW5lcmF0b3IgfHwgcmVuZGVyTW9yZUxpbmtJbm5lciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLm1vcmVMaW5rQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMubW9yZUxpbmtEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMubW9yZUxpbmtXaWxsVW5tb3VudCB9LCBwcm9wcy5jaGlsZHJlbikpLFxuICAgICAgICAgICAgICAgIHN0YXRlLmlzUG9wb3Zlck9wZW4gJiYgKGNyZWF0ZUVsZW1lbnQoTW9yZVBvcG92ZXIsIHsgaWQ6IHN0YXRlLnBvcG92ZXJJZCwgc3RhcnREYXRlOiByYW5nZS5zdGFydCwgZW5kRGF0ZTogcmFuZ2UuZW5kLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIHBhcmVudEVsOiB0aGlzLnBhcmVudEVsLCBhbGlnbm1lbnRFbDogcHJvcHMuYWxpZ25tZW50RWxSZWYgP1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuYWxpZ25tZW50RWxSZWYuY3VycmVudCA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtFbCwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIGZvcmNlVGltZWQ6IHByb3BzLmZvcmNlVGltZWQsIG9uQ2xvc2U6IHRoaXMuaGFuZGxlUG9wb3ZlckNsb3NlIH0sIHByb3BzLnBvcG92ZXJDb250ZW50KCkpKSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcmVudEVsKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJlbnRFbCgpO1xuICAgIH1cbiAgICB1cGRhdGVQYXJlbnRFbCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlua0VsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEVsID0gZWxlbWVudENsb3Nlc3QodGhpcy5saW5rRWwsICcuZmMtdmlldy1oYXJuZXNzJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJNb3JlTGlua0lubmVyKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRleHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlUmFuZ2UocHJvcHMpIHtcbiAgICBpZiAocHJvcHMuYWxsRGF5RGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHByb3BzLmFsbERheURhdGUsXG4gICAgICAgICAgICBlbmQ6IGFkZERheXMocHJvcHMuYWxsRGF5RGF0ZSwgMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCB7IGhpZGRlblNlZ3MgfSA9IHByb3BzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBjb21wdXRlRWFybGllc3RTZWdTdGFydChoaWRkZW5TZWdzKSxcbiAgICAgICAgZW5kOiBjb21wdXRlTGF0ZXN0U2VnRW5kKGhpZGRlblNlZ3MpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlRWFybGllc3RTZWdTdGFydChzZWdzKSB7XG4gICAgcmV0dXJuIHNlZ3MucmVkdWNlKHBpY2tFYXJsaWVzdFN0YXJ0KS5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0O1xufVxuZnVuY3Rpb24gcGlja0VhcmxpZXN0U3RhcnQoc2VnMCwgc2VnMSkge1xuICAgIHJldHVybiBzZWcwLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQgPCBzZWcxLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQgPyBzZWcwIDogc2VnMTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMYXRlc3RTZWdFbmQoc2Vncykge1xuICAgIHJldHVybiBzZWdzLnJlZHVjZShwaWNrTGF0ZXN0RW5kKS5ldmVudFJhbmdlLnJhbmdlLmVuZDtcbn1cbmZ1bmN0aW9uIHBpY2tMYXRlc3RFbmQoc2VnMCwgc2VnMSkge1xuICAgIHJldHVybiBzZWcwLmV2ZW50UmFuZ2UucmFuZ2UuZW5kID4gc2VnMS5ldmVudFJhbmdlLnJhbmdlLmVuZCA/IHNlZzAgOiBzZWcxO1xufVxuXG5jbGFzcyBTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICB9XG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgdGhpcy5oYW5kbGVycykge1xuICAgICAgICAgICAgaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGFuZGxlcih0aGlzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qXG5TdWJzY3JpYmVycyB3aWxsIGdldCBhIExJU1Qgb2YgQ3VzdG9tUmVuZGVyaW5nc1xuKi9cbmNsYXNzIEN1c3RvbVJlbmRlcmluZ1N0b3JlIGV4dGVuZHMgU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLy8gZm9yIGNvbnNpc3RlbnQgb3JkZXJcbiAgICBoYW5kbGUoY3VzdG9tUmVuZGVyaW5nKSB7XG4gICAgICAgIGNvbnN0IHsgbWFwIH0gPSB0aGlzO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoY3VzdG9tUmVuZGVyaW5nLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGN1c3RvbVJlbmRlcmluZy5pZCwgY3VzdG9tUmVuZGVyaW5nKTtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcC5oYXMoY3VzdG9tUmVuZGVyaW5nLmlkKSkge1xuICAgICAgICAgICAgbWFwLmRlbGV0ZShjdXN0b21SZW5kZXJpbmcuaWQpO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KG1hcCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IGVsZW1lbnRDbG9zZXN0IGFzICQsIG1lbW9pemVPYmpBcmcgYXMgQSwgQmFzZUNvbXBvbmVudCBhcyBCLCBDb250ZW50Q29udGFpbmVyIGFzIEMsIERlbGF5ZWRSdW5uZXIgYXMgRCwgaXNQcm9wc0VxdWFsIGFzIEUsIEVtaXR0ZXIgYXMgRiwgZ2V0SW5pdGlhbERhdGUgYXMgRywgcmFuZ2VDb250YWluc01hcmtlciBhcyBILCBjcmVhdGVFbXB0eUV2ZW50U3RvcmUgYXMgSSwgcmVkdWNlQ3VycmVudERhdGUgYXMgSiwgcmVkdWNlRXZlbnRTdG9yZSBhcyBLLCByZXpvbmVFdmVudFN0b3JlRGF0ZXMgYXMgTCwgbWVyZ2VSYXdPcHRpb25zIGFzIE0sIEJBU0VfT1BUSU9OX1JFRklORVJTIGFzIE4sIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTIGFzIE8sIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyBhcyBQLCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyBhcyBRLCBWSUVXX09QVElPTl9SRUZJTkVSUyBhcyBSLCBEYXRlRW52IGFzIFMsIFRoZW1lIGFzIFQsIERhdGVQcm9maWxlR2VuZXJhdG9yIGFzIFUsIFZpZXdDb250ZXh0VHlwZSBhcyBWLCBjcmVhdGVFdmVudFVpIGFzIFcsIHBhcnNlQnVzaW5lc3NIb3VycyBhcyBYLCBzZXRSZWYgYXMgWSwgSW50ZXJhY3Rpb24gYXMgWiwgZ2V0RWxTZWcgYXMgXywgbWFwSGFzaCBhcyBhLCBnZXRTbG90Q2xhc3NOYW1lcyBhcyBhJCwgRXZlbnRJbXBsIGFzIGEwLCBsaXN0ZW5CeVNlbGVjdG9yIGFzIGExLCBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvciBhcyBhMiwgUHVyZUNvbXBvbmVudCBhcyBhMywgYnVpbGRWaWV3Q29udGV4dCBhcyBhNCwgZ2V0VW5pcXVlRG9tSWQgYXMgYTUsIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyBhcyBhNiwgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlIGFzIGE3LCBnZXROb3cgYXMgYTgsIENhbGVuZGFySW1wbCBhcyBhOSwgZGlmZkRhdGVzIGFzIGFBLCByZW1vdmVFeGFjdCBhcyBhQiwgbWVtb2l6ZUFycmF5bGlrZSBhcyBhQywgbWVtb2l6ZUhhc2hsaWtlIGFzIGFELCBpbnRlcnNlY3RSZWN0cyBhcyBhRSwgcG9pbnRJbnNpZGVSZWN0IGFzIGFGLCBjb25zdHJhaW5Qb2ludCBhcyBhRywgZ2V0UmVjdENlbnRlciBhcyBhSCwgZGlmZlBvaW50cyBhcyBhSSwgdHJhbnNsYXRlUmVjdCBhcyBhSiwgY29tcGFyZU9ianMgYXMgYUssIGNvbGxlY3RGcm9tSGFzaCBhcyBhTCwgZmluZEVsZW1lbnRzIGFzIGFNLCBmaW5kRGlyZWN0Q2hpbGRyZW4gYXMgYU4sIHJlbW92ZUVsZW1lbnQgYXMgYU8sIGFwcGx5U3R5bGUgYXMgYVAsIGVsZW1lbnRNYXRjaGVzIGFzIGFRLCBnZXRFdmVudFRhcmdldFZpYVJvb3QgYXMgYVIsIHBhcnNlQ2xhc3NOYW1lcyBhcyBhUywgZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIGFzIGFULCBtZXJnZUV2ZW50U3RvcmVzIGFzIGFVLCBnZXRSZWxldmFudEV2ZW50cyBhcyBhViwgZXZlbnRUdXBsZVRvU3RvcmUgYXMgYVcsIGNvbWJpbmVFdmVudFVpcyBhcyBhWCwgU3BsaXR0ZXIgYXMgYVksIGdldERheUNsYXNzTmFtZXMgYXMgYVosIGdldERhdGVNZXRhIGFzIGFfLCBmbHVzaFN5bmMgYXMgYWEsIENhbGVuZGFyUm9vdCBhcyBhYiwgUmVuZGVySWQgYXMgYWMsIGVuc3VyZUVsSGFzU3R5bGVzIGFzIGFkLCBhcHBseVN0eWxlUHJvcCBhcyBhZSwgc2xpY2VFdmVudFN0b3JlIGFzIGFmLCBKc29uUmVxdWVzdEVycm9yIGFzIGFnLCBjcmVhdGVDb250ZXh0IGFzIGFoLCByZWZpbmVQcm9wcyBhcyBhaSwgY3JlYXRlRXZlbnRJbnN0YW5jZSBhcyBhaiwgcGFyc2VFdmVudERlZiBhcyBhaywgcmVmaW5lRXZlbnREZWYgYXMgYWwsIHBhZFN0YXJ0IGFzIGFtLCBpc0ludCBhcyBhbiwgcGFyc2VGaWVsZFNwZWNzIGFzIGFvLCBjb21wYXJlQnlGaWVsZFNwZWNzIGFzIGFwLCBmbGV4aWJsZUNvbXBhcmUgYXMgYXEsIHByZXZlbnRTZWxlY3Rpb24gYXMgYXIsIGFsbG93U2VsZWN0aW9uIGFzIGFzLCBwcmV2ZW50Q29udGV4dE1lbnUgYXMgYXQsIGFsbG93Q29udGV4dE1lbnUgYXMgYXUsIGNvbXBhcmVOdW1iZXJzIGFzIGF2LCBlbmFibGVDdXJzb3IgYXMgYXcsIGRpc2FibGVDdXJzb3IgYXMgYXgsIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UgYXMgYXksIGlzTXVsdGlEYXlSYW5nZSBhcyBheiwgYnVpbGRWaWV3Q2xhc3NOYW1lcyBhcyBiLCBTaW1wbGVTY3JvbGxHcmlkIGFzIGIkLCBidWlsZE5hdkxpbmtBdHRycyBhcyBiMCwgcHJldmVudERlZmF1bHQgYXMgYjEsIHdoZW5UcmFuc2l0aW9uRG9uZSBhcyBiMiwgY29tcHV0ZUlubmVyUmVjdCBhcyBiMywgY29tcHV0ZUVkZ2VzIGFzIGI0LCBnZXRDbGlwcGluZ1BhcmVudHMgYXMgYjUsIGNvbXB1dGVSZWN0IGFzIGI2LCByYW5nZXNFcXVhbCBhcyBiNywgcmFuZ2VzSW50ZXJzZWN0IGFzIGI4LCByYW5nZUNvbnRhaW5zUmFuZ2UgYXMgYjksIFNlZ0hpZXJhcmNoeSBhcyBiQSwgYnVpbGRFbnRyeUtleSBhcyBiQiwgZ2V0RW50cnlTcGFuRW5kIGFzIGJDLCBiaW5hcnlTZWFyY2ggYXMgYkQsIGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyBhcyBiRSwgaW50ZXJzZWN0U3BhbnMgYXMgYkYsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlIGFzIGJHLCBFbGVtZW50RHJhZ2dpbmcgYXMgYkgsIGNvbmZpZyBhcyBiSSwgcGFyc2VEcmFnTWV0YSBhcyBiSiwgRGF5SGVhZGVyIGFzIGJLLCBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQgYXMgYkwsIFRhYmxlRGF0ZUNlbGwgYXMgYk0sIFRhYmxlRG93Q2VsbCBhcyBiTiwgRGF5U2VyaWVzTW9kZWwgYXMgYk8sIGhhc0JnUmVuZGVyaW5nIGFzIGJQLCBidWlsZFNlZ1RpbWVUZXh0IGFzIGJRLCBzb3J0RXZlbnRTZWdzIGFzIGJSLCBnZXRTZWdNZXRhIGFzIGJTLCBidWlsZEV2ZW50UmFuZ2VLZXkgYXMgYlQsIGdldFNlZ0FuY2hvckF0dHJzIGFzIGJVLCBEYXlUYWJsZU1vZGVsIGFzIGJWLCBTbGljZXIgYXMgYlcsIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUgYXMgYlgsIGlzUHJvcHNWYWxpZCBhcyBiWSwgaXNJbnRlcmFjdGlvblZhbGlkIGFzIGJaLCBpc0RhdGVTZWxlY3Rpb25WYWxpZCBhcyBiXywgUG9zaXRpb25DYWNoZSBhcyBiYSwgU2Nyb2xsQ29udHJvbGxlciBhcyBiYiwgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIgYXMgYmMsIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIgYXMgYmQsIERhdGVDb21wb25lbnQgYXMgYmUsIGlzRGF0ZVNwYW5zRXF1YWwgYXMgYmYsIGFkZE1zIGFzIGJnLCBhZGRXZWVrcyBhcyBiaCwgZGlmZldlZWtzIGFzIGJpLCBkaWZmV2hvbGVXZWVrcyBhcyBiaiwgZGlmZkRheUFuZFRpbWUgYXMgYmssIGRpZmZEYXlzIGFzIGJsLCBpc1ZhbGlkRGF0ZSBhcyBibSwgYXNDbGVhbkRheXMgYXMgYm4sIG11bHRpcGx5RHVyYXRpb24gYXMgYm8sIGFkZER1cmF0aW9ucyBhcyBicCwgYXNSb3VnaE1pbnV0ZXMgYXMgYnEsIGFzUm91Z2hTZWNvbmRzIGFzIGJyLCBhc1JvdWdoTXMgYXMgYnMsIHdob2xlRGl2aWRlRHVyYXRpb25zIGFzIGJ0LCBmb3JtYXRJc29UaW1lU3RyaW5nIGFzIGJ1LCBmb3JtYXREYXlTdHJpbmcgYXMgYnYsIGJ1aWxkSXNvU3RyaW5nIGFzIGJ3LCBmb3JtYXRJc29Nb250aFN0ciBhcyBieCwgTmFtZWRUaW1lWm9uZUltcGwgYXMgYnksIHBhcnNlIGFzIGJ6LCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IgYXMgYywgaGFzU2hyaW5rV2lkdGggYXMgYzAsIHJlbmRlck1pY3JvQ29sR3JvdXAgYXMgYzEsIGdldFNjcm9sbEdyaWRDbGFzc05hbWVzIGFzIGMyLCBnZXRTZWN0aW9uQ2xhc3NOYW1lcyBhcyBjMywgZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodCBhcyBjNCwgZ2V0QWxsb3dZU2Nyb2xsaW5nIGFzIGM1LCByZW5kZXJDaHVua0NvbnRlbnQgYXMgYzYsIGNvbXB1dGVTaHJpbmtXaWR0aCBhcyBjNywgc2FuaXRpemVTaHJpbmtXaWR0aCBhcyBjOCwgaXNDb2xQcm9wc0VxdWFsIGFzIGM5LCByZW5kZXJTY3JvbGxTaGltIGFzIGNhLCBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIgYXMgY2IsIGdldFN0aWNreUhlYWRlckRhdGVzIGFzIGNjLCBTY3JvbGxlciBhcyBjZCwgZ2V0U2Nyb2xsYmFyV2lkdGhzIGFzIGNlLCBSZWZNYXAgYXMgY2YsIGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0IGFzIGNnLCBOb3dUaW1lciBhcyBjaCwgU2Nyb2xsUmVzcG9uZGVyIGFzIGNpLCBTdGFuZGFyZEV2ZW50IGFzIGNqLCBOb3dJbmRpY2F0b3JDb250YWluZXIgYXMgY2ssIERheUNlbGxDb250YWluZXIgYXMgY2wsIGhhc0N1c3RvbURheUNlbGxDb250ZW50IGFzIGNtLCBFdmVudENvbnRhaW5lciBhcyBjbiwgcmVuZGVyRmlsbCBhcyBjbywgQmdFdmVudCBhcyBjcCwgV2Vla051bWJlckNvbnRhaW5lciBhcyBjcSwgTW9yZUxpbmtDb250YWluZXIgYXMgY3IsIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0IGFzIGNzLCBWaWV3Q29udGFpbmVyIGFzIGN0LCB0cmlnZ2VyRGF0ZVNlbGVjdCBhcyBjdSwgZ2V0RGVmYXVsdEV2ZW50RW5kIGFzIGN2LCBpbmplY3RTdHlsZXMgYXMgY3csIGJ1aWxkRWxBdHRycyBhcyBjeCwgQ3VzdG9tUmVuZGVyaW5nU3RvcmUgYXMgY3ksIGNyZWF0ZUR1cmF0aW9uIGFzIGQsIEJBU0VfT1BUSU9OX0RFRkFVTFRTIGFzIGUsIGFycmF5VG9IYXNoIGFzIGYsIGd1aWQgYXMgZywgZmlsdGVySGFzaCBhcyBoLCBpc0FycmF5c0VxdWFsIGFzIGksIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyBhcyBqLCBmb3JtYXRXaXRoT3JkaW5hbHMgYXMgaywgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZSBhcyBsLCBtZXJnZVByb3BzIGFzIG0sIGlkZW50aXR5IGFzIG4sIGludGVyc2VjdFJhbmdlcyBhcyBvLCBwYXJzZUV2ZW50U291cmNlIGFzIHAsIHN0YXJ0T2ZEYXkgYXMgcSwgcmVxdWVzdEpzb24gYXMgciwgc3VidHJhY3REdXJhdGlvbnMgYXMgcywgYWRkRGF5cyBhcyB0LCB1bnByb21pc2lmeSBhcyB1LCBoYXNoVmFsdWVzVG9BcnJheSBhcyB2LCBidWlsZEV2ZW50QXBpcyBhcyB3LCBjcmVhdGVGb3JtYXR0ZXIgYXMgeCwgZGlmZldob2xlRGF5cyBhcyB5LCBtZW1vaXplIGFzIHogfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@fullcalendar/core/internal-common.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@fullcalendar/daygrid/index.js":
/*!******************************************************!*\
  !*** ../node_modules/@fullcalendar/daygrid/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ index; }\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_core_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/core/index.js */ \"(app-pages-browser)/../node_modules/@fullcalendar/core/index.js\");\n/* harmony import */ var _internal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal.js */ \"(app-pages-browser)/../node_modules/@fullcalendar/daygrid/internal.js\");\n\n\n\n\n\nvar index = (0,_fullcalendar_core_index_js__WEBPACK_IMPORTED_MODULE_0__.createPlugin)({\n    name: '@fullcalendar/daygrid',\n    initialView: 'dayGridMonth',\n    views: {\n        dayGrid: {\n            component: _internal_js__WEBPACK_IMPORTED_MODULE_1__.DayGridView,\n            dateProfileGeneratorClass: _internal_js__WEBPACK_IMPORTED_MODULE_1__.TableDateProfileGenerator,\n        },\n        dayGridDay: {\n            type: 'dayGrid',\n            duration: { days: 1 },\n        },\n        dayGridWeek: {\n            type: 'dayGrid',\n            duration: { weeks: 1 },\n        },\n        dayGridMonth: {\n            type: 'dayGrid',\n            duration: { months: 1 },\n            fixedWeekCount: true,\n        },\n        dayGridYear: {\n            type: 'dayGrid',\n            duration: { years: 1 },\n        },\n    },\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyRDtBQUM0QjtBQUMvQztBQUNGOztBQUV0QyxZQUFZLHlFQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFEQUFZO0FBQ25DLHVDQUF1QyxtRUFBeUI7QUFDaEUsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQzs7QUFFMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2RheWdyaWQvaW5kZXguanM/ZmIyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgRGF5R3JpZFZpZXcgYXMgRGF5VGFibGVWaWV3LCBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIH0gZnJvbSAnLi9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuXG52YXIgaW5kZXggPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdAZnVsbGNhbGVuZGFyL2RheWdyaWQnLFxuICAgIGluaXRpYWxWaWV3OiAnZGF5R3JpZE1vbnRoJyxcbiAgICB2aWV3czoge1xuICAgICAgICBkYXlHcmlkOiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IERheVRhYmxlVmlldyxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWREYXk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF5R3JpZFdlZWs6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWRNb250aDoge1xuICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgbW9udGhzOiAxIH0sXG4gICAgICAgICAgICBmaXhlZFdlZWtDb3VudDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF5R3JpZFllYXI6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHllYXJzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBpbmRleCBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@fullcalendar/daygrid/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@fullcalendar/daygrid/internal.js":
/*!*********************************************************!*\
  !*** ../node_modules/@fullcalendar/daygrid/internal.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DayGridView: function() { return /* binding */ DayTableView; },\n/* harmony export */   DayTable: function() { return /* binding */ DayTable; },\n/* harmony export */   DayTableSlicer: function() { return /* binding */ DayTableSlicer; },\n/* harmony export */   Table: function() { return /* binding */ Table; },\n/* harmony export */   TableDateProfileGenerator: function() { return /* binding */ TableDateProfileGenerator; },\n/* harmony export */   TableRows: function() { return /* binding */ TableRows; },\n/* harmony export */   TableView: function() { return /* binding */ TableView; },\n/* harmony export */   buildDayTableModel: function() { return /* binding */ buildDayTableModel; },\n/* harmony export */   buildDayTableRenderRange: function() { return /* binding */ buildDayTableRenderRange; }\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/core/internal.js */ \"(app-pages-browser)/../node_modules/@fullcalendar/core/internal-common.js\");\n/* harmony import */ var _fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/core/preact.js */ \"(app-pages-browser)/../node_modules/preact/dist/preact.module.js\");\n\n\n\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/\n// It is a manager for a Table subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\nclass TableView extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor() {\n        super(...arguments);\n        this.headerElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    }\n    renderSimpleLayout(headerRowContent, bodyContent) {\n        let { props, context } = this;\n        let sections = [];\n        let stickyHeaderDates = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cc)(context.options);\n        if (headerRowContent) {\n            sections.push({\n                type: 'header',\n                key: 'header',\n                isSticky: stickyHeaderDates,\n                chunk: {\n                    elRef: this.headerElRef,\n                    tableClassName: 'fc-col-header',\n                    rowContent: headerRowContent,\n                },\n            });\n        }\n        sections.push({\n            type: 'body',\n            key: 'body',\n            liquid: true,\n            chunk: { content: bodyContent },\n        });\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ct, { elClasses: ['fc-daygrid'], viewSpec: context.viewSpec },\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b$, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [] /* TODO: make optional? */, sections: sections })));\n    }\n    renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {\n        let ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n        if (!ScrollGrid) {\n            throw new Error('No ScrollGrid implementation');\n        }\n        let { props, context } = this;\n        let stickyHeaderDates = !props.forPrint && (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cc)(context.options);\n        let stickyFooterScrollbar = !props.forPrint && (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cb)(context.options);\n        let sections = [];\n        if (headerRowContent) {\n            sections.push({\n                type: 'header',\n                key: 'header',\n                isSticky: stickyHeaderDates,\n                chunks: [{\n                        key: 'main',\n                        elRef: this.headerElRef,\n                        tableClassName: 'fc-col-header',\n                        rowContent: headerRowContent,\n                    }],\n            });\n        }\n        sections.push({\n            type: 'body',\n            key: 'body',\n            liquid: true,\n            chunks: [{\n                    key: 'main',\n                    content: bodyContent,\n                }],\n        });\n        if (stickyFooterScrollbar) {\n            sections.push({\n                type: 'footer',\n                key: 'footer',\n                isSticky: true,\n                chunks: [{\n                        key: 'main',\n                        content: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ca,\n                    }],\n            });\n        }\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ct, { elClasses: ['fc-daygrid'], viewSpec: context.viewSpec },\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: props.forPrint, colGroups: [{ cols: [{ span: colCnt, minWidth: dayMinWidth }] }], sections: sections })));\n    }\n}\n\nfunction splitSegsByRow(segs, rowCnt) {\n    let byRow = [];\n    for (let i = 0; i < rowCnt; i += 1) {\n        byRow[i] = [];\n    }\n    for (let seg of segs) {\n        byRow[seg.row].push(seg);\n    }\n    return byRow;\n}\nfunction splitSegsByFirstCol(segs, colCnt) {\n    let byCol = [];\n    for (let i = 0; i < colCnt; i += 1) {\n        byCol[i] = [];\n    }\n    for (let seg of segs) {\n        byCol[seg.firstCol].push(seg);\n    }\n    return byCol;\n}\nfunction splitInteractionByRow(ui, rowCnt) {\n    let byRow = [];\n    if (!ui) {\n        for (let i = 0; i < rowCnt; i += 1) {\n            byRow[i] = null;\n        }\n    }\n    else {\n        for (let i = 0; i < rowCnt; i += 1) {\n            byRow[i] = {\n                affectedInstances: ui.affectedInstances,\n                isEvent: ui.isEvent,\n                segs: [],\n            };\n        }\n        for (let seg of ui.segs) {\n            byRow[seg.row].segs.push(seg);\n        }\n    }\n    return byRow;\n}\n\nconst DEFAULT_TABLE_EVENT_TIME_FORMAT = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)({\n    hour: 'numeric',\n    minute: '2-digit',\n    omitZeroMinute: true,\n    meridiem: 'narrow',\n});\nfunction hasListItemDisplay(seg) {\n    let { display } = seg.eventRange.ui;\n    return display === 'list-item' || (display === 'auto' &&\n        !seg.eventRange.def.allDay &&\n        seg.firstCol === seg.lastCol && // can't be multi-day\n        seg.isStart && // \"\n        seg.isEnd // \"\n    );\n}\n\nclass TableBlockEvent extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { props } = this;\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cj, Object.assign({}, props, { elClasses: ['fc-daygrid-event', 'fc-daygrid-block-event', 'fc-h-event'], defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT, defaultDisplayEventEnd: props.defaultDisplayEventEnd, disableResizing: !props.seg.eventRange.def.allDay })));\n    }\n}\n\nclass TableListItemEvent extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let { seg } = props;\n        let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n        let timeText = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bQ)(seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cn, Object.assign({}, props, { elTag: \"a\", elClasses: ['fc-daygrid-event', 'fc-daygrid-dot-event'], elAttrs: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bU)(props.seg, context), defaultGenerator: renderInnerContent, timeText: timeText, isResizing: false, isDateSelecting: false })));\n    }\n}\nfunction renderInnerContent(renderProps) {\n    return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null,\n        (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-daygrid-event-dot\", style: { borderColor: renderProps.borderColor || renderProps.backgroundColor } }),\n        renderProps.timeText && ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-event-time\" }, renderProps.timeText)),\n        (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-event-title\" }, renderProps.event.title || (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\u00A0\"))));\n}\n\nclass TableCellMoreLink extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    constructor() {\n        super(...arguments);\n        this.compileSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(compileSegs);\n    }\n    render() {\n        let { props } = this;\n        let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cr, { elClasses: ['fc-daygrid-more-link'], dateProfile: props.dateProfile, todayRange: props.todayRange, allDayDate: props.allDayDate, moreCnt: props.moreCnt, allSegs: allSegs, hiddenSegs: invisibleSegs, alignmentElRef: props.alignmentElRef, alignGridTop: props.alignGridTop, extraDateSpan: props.extraDateSpan, popoverContent: () => {\n                let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) ||\n                    (props.eventResize ? props.eventResize.affectedInstances : null) ||\n                    {};\n                return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, allSegs.map((seg) => {\n                    let instanceId = seg.eventRange.instance.instanceId;\n                    return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-daygrid-event-harness\", key: instanceId, style: {\n                            visibility: isForcedInvisible[instanceId] ? 'hidden' : '',\n                        } }, hasListItemDisplay(seg) ? ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableListItemEvent, Object.assign({ seg: seg, isDragging: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, props.todayRange)))) : ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableBlockEvent, Object.assign({ seg: seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, props.todayRange))))));\n                })));\n            } }));\n    }\n}\nfunction compileSegs(singlePlacements) {\n    let allSegs = [];\n    let invisibleSegs = [];\n    for (let placement of singlePlacements) {\n        allSegs.push(placement.seg);\n        if (!placement.isVisible) {\n            invisibleSegs.push(placement.seg);\n        }\n    }\n    return { allSegs, invisibleSegs };\n}\n\nconst DEFAULT_WEEK_NUM_FORMAT = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)({ week: 'narrow' });\nclass TableCell extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor() {\n        super(...arguments);\n        this.rootElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.state = {\n            dayNumberId: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a5)(),\n        };\n        this.handleRootEl = (el) => {\n            (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.Y)(this.rootElRef, el);\n            (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.Y)(this.props.elRef, el);\n        };\n    }\n    render() {\n        let { context, props, state, rootElRef } = this;\n        let { options, dateEnv } = context;\n        let { date, dateProfile } = props;\n        // TODO: memoize this?\n        const isMonthStart = props.showDayNumber &&\n            shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cl, { elTag: \"td\", elRef: this.handleRootEl, elClasses: [\n                'fc-daygrid-day',\n                ...(props.extraClassNames || []),\n            ], elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), (props.showDayNumber ? { 'aria-labelledby': state.dayNumberId } : {})), { role: 'gridcell' }), defaultGenerator: renderTopInner, date: date, dateProfile: dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, isMonthStart: isMonthStart, extraRenderProps: props.extraRenderProps }, (InnerContent, renderProps) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { ref: props.innerElRef, className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\", style: { minHeight: props.minHeight } },\n            props.showWeekNumber && ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cq, { elTag: \"a\", elClasses: ['fc-daygrid-week-number'], elAttrs: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b0)(context, date, 'week'), date: date, defaultFormat: DEFAULT_WEEK_NUM_FORMAT })),\n            !renderProps.isDisabled &&\n                (props.showDayNumber || (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cm)(options) || props.forceDayTop) ? ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-daygrid-day-top\" },\n                (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(InnerContent, { elTag: \"a\", elClasses: [\n                        'fc-daygrid-day-number',\n                        isMonthStart && 'fc-daygrid-month-start',\n                    ], elAttrs: Object.assign(Object.assign({}, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b0)(context, date)), { id: state.dayNumberId }) }))) : props.showDayNumber ? (\n            // for creating correct amount of space (see issue #7162)\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-daygrid-day-top\", style: { visibility: 'hidden' } },\n                (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", { className: \"fc-daygrid-day-number\" }, \"\\u00A0\"))) : undefined,\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-daygrid-day-events\", ref: props.fgContentElRef },\n                props.fgContent,\n                (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-daygrid-day-bottom\", style: { marginTop: props.moreMarginTop } },\n                    (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCellMoreLink, { allDayDate: date, singlePlacements: props.singlePlacements, moreCnt: props.moreCnt, alignmentElRef: rootElRef, alignGridTop: !props.showDayNumber, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange }))),\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-daygrid-day-bg\" }, props.bgContent)))));\n    }\n}\nfunction renderTopInner(props) {\n    return props.dayNumberText || (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\u00A0\");\n}\nfunction shouldDisplayMonthStart(date, currentRange, dateEnv) {\n    const { start: currentStart, end: currentEnd } = currentRange;\n    const currentEndIncl = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bg)(currentEnd, -1);\n    const currentFirstYear = dateEnv.getYear(currentStart);\n    const currentFirstMonth = dateEnv.getMonth(currentStart);\n    const currentLastYear = dateEnv.getYear(currentEndIncl);\n    const currentLastMonth = dateEnv.getMonth(currentEndIncl);\n    // spans more than one month?\n    return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) &&\n        Boolean(\n        // first date in current view?\n        date.valueOf() === currentStart.valueOf() ||\n            // a month-start that's within the current range?\n            (dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf()));\n}\n\nfunction generateSegKey(seg) {\n    return seg.eventRange.instance.instanceId + ':' + seg.firstCol;\n}\nfunction generateSegUid(seg) {\n    return generateSegKey(seg) + ':' + seg.lastCol;\n}\nfunction computeFgSegPlacement(segs, // assumed already sorted\ndayMaxEvents, dayMaxEventRows, strictOrder, segHeights, maxContentHeight, cells) {\n    let hierarchy = new DayGridSegHierarchy((segEntry) => {\n        // TODO: more DRY with generateSegUid\n        let segUid = segs[segEntry.index].eventRange.instance.instanceId +\n            ':' + segEntry.span.start +\n            ':' + (segEntry.span.end - 1);\n        // if no thickness known, assume 1 (if 0, so small it always fits)\n        return segHeights[segUid] || 1;\n    });\n    hierarchy.allowReslicing = true;\n    hierarchy.strictOrder = strictOrder;\n    if (dayMaxEvents === true || dayMaxEventRows === true) {\n        hierarchy.maxCoord = maxContentHeight;\n        hierarchy.hiddenConsumes = true;\n    }\n    else if (typeof dayMaxEvents === 'number') {\n        hierarchy.maxStackCnt = dayMaxEvents;\n    }\n    else if (typeof dayMaxEventRows === 'number') {\n        hierarchy.maxStackCnt = dayMaxEventRows;\n        hierarchy.hiddenConsumes = true;\n    }\n    // create segInputs only for segs with known heights\n    let segInputs = [];\n    let unknownHeightSegs = [];\n    for (let i = 0; i < segs.length; i += 1) {\n        let seg = segs[i];\n        let segUid = generateSegUid(seg);\n        let eventHeight = segHeights[segUid];\n        if (eventHeight != null) {\n            segInputs.push({\n                index: i,\n                span: {\n                    start: seg.firstCol,\n                    end: seg.lastCol + 1,\n                },\n            });\n        }\n        else {\n            unknownHeightSegs.push(seg);\n        }\n    }\n    let hiddenEntries = hierarchy.addSegs(segInputs);\n    let segRects = hierarchy.toRects();\n    let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);\n    let moreCnts = [];\n    let moreMarginTops = [];\n    // add segs with unknown heights\n    for (let seg of unknownHeightSegs) {\n        multiColPlacements[seg.firstCol].push({\n            seg,\n            isVisible: false,\n            isAbsolute: true,\n            absoluteTop: 0,\n            marginTop: 0,\n        });\n        for (let col = seg.firstCol; col <= seg.lastCol; col += 1) {\n            singleColPlacements[col].push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: false,\n                isAbsolute: false,\n                absoluteTop: 0,\n                marginTop: 0,\n            });\n        }\n    }\n    // add the hidden entries\n    for (let col = 0; col < cells.length; col += 1) {\n        moreCnts.push(0);\n    }\n    for (let hiddenEntry of hiddenEntries) {\n        let seg = segs[hiddenEntry.index];\n        let hiddenSpan = hiddenEntry.span;\n        multiColPlacements[hiddenSpan.start].push({\n            seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),\n            isVisible: false,\n            isAbsolute: true,\n            absoluteTop: 0,\n            marginTop: 0,\n        });\n        for (let col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {\n            moreCnts[col] += 1;\n            singleColPlacements[col].push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: false,\n                isAbsolute: false,\n                absoluteTop: 0,\n                marginTop: 0,\n            });\n        }\n    }\n    // deal with leftover margins\n    for (let col = 0; col < cells.length; col += 1) {\n        moreMarginTops.push(leftoverMargins[col]);\n    }\n    return { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops };\n}\n// rects ordered by top coord, then left\nfunction placeRects(allRects, segs, cells) {\n    let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);\n    let singleColPlacements = [];\n    let multiColPlacements = [];\n    let leftoverMargins = [];\n    for (let col = 0; col < cells.length; col += 1) {\n        let rects = rectsByEachCol[col];\n        // compute all static segs in singlePlacements\n        let singlePlacements = [];\n        let currentHeight = 0;\n        let currentMarginTop = 0;\n        for (let rect of rects) {\n            let seg = segs[rect.index];\n            singlePlacements.push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: true,\n                isAbsolute: false,\n                absoluteTop: rect.levelCoord,\n                marginTop: rect.levelCoord - currentHeight,\n            });\n            currentHeight = rect.levelCoord + rect.thickness;\n        }\n        // compute mixed static/absolute segs in multiPlacements\n        let multiPlacements = [];\n        currentHeight = 0;\n        currentMarginTop = 0;\n        for (let rect of rects) {\n            let seg = segs[rect.index];\n            let isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?\n            let isFirstCol = rect.span.start === col;\n            currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg\n            currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg\n            if (isAbsolute) {\n                currentMarginTop += rect.thickness;\n                if (isFirstCol) {\n                    multiPlacements.push({\n                        seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                        isVisible: true,\n                        isAbsolute: true,\n                        absoluteTop: rect.levelCoord,\n                        marginTop: 0,\n                    });\n                }\n            }\n            else if (isFirstCol) {\n                multiPlacements.push({\n                    seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                    isVisible: true,\n                    isAbsolute: false,\n                    absoluteTop: rect.levelCoord,\n                    marginTop: currentMarginTop, // claim the margin\n                });\n                currentMarginTop = 0;\n            }\n        }\n        singleColPlacements.push(singlePlacements);\n        multiColPlacements.push(multiPlacements);\n        leftoverMargins.push(currentMarginTop);\n    }\n    return { singleColPlacements, multiColPlacements, leftoverMargins };\n}\nfunction groupRectsByEachCol(rects, colCnt) {\n    let rectsByEachCol = [];\n    for (let col = 0; col < colCnt; col += 1) {\n        rectsByEachCol.push([]);\n    }\n    for (let rect of rects) {\n        for (let col = rect.span.start; col < rect.span.end; col += 1) {\n            rectsByEachCol[col].push(rect);\n        }\n    }\n    return rectsByEachCol;\n}\nfunction resliceSeg(seg, spanStart, spanEnd, cells) {\n    if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {\n        return seg;\n    }\n    let eventRange = seg.eventRange;\n    let origRange = eventRange.range;\n    let slicedRange = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.o)(origRange, {\n        start: cells[spanStart].date,\n        end: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.t)(cells[spanEnd - 1].date, 1),\n    });\n    return Object.assign(Object.assign({}, seg), { firstCol: spanStart, lastCol: spanEnd - 1, eventRange: {\n            def: eventRange.def,\n            ui: Object.assign(Object.assign({}, eventRange.ui), { durationEditable: false }),\n            instance: eventRange.instance,\n            range: slicedRange,\n        }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() });\n}\nclass DayGridSegHierarchy extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bA {\n    constructor() {\n        super(...arguments);\n        // config\n        this.hiddenConsumes = false;\n        // allows us to keep hidden entries in the hierarchy so they take up space\n        this.forceHidden = {};\n    }\n    addSegs(segInputs) {\n        const hiddenSegs = super.addSegs(segInputs);\n        const { entriesByLevel } = this;\n        const excludeHidden = (entry) => !this.forceHidden[(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bB)(entry)];\n        // remove the forced-hidden segs\n        for (let level = 0; level < entriesByLevel.length; level += 1) {\n            entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);\n        }\n        return hiddenSegs;\n    }\n    handleInvalidInsertion(insertion, entry, hiddenEntries) {\n        const { entriesByLevel, forceHidden } = this;\n        const { touchingEntry, touchingLevel, touchingLateral } = insertion;\n        // the entry that the new insertion is touching must be hidden\n        if (this.hiddenConsumes && touchingEntry) {\n            const touchingEntryId = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bB)(touchingEntry);\n            if (!forceHidden[touchingEntryId]) {\n                if (this.allowReslicing) {\n                    // split up the touchingEntry, reinsert it\n                    const hiddenEntry = Object.assign(Object.assign({}, touchingEntry), { span: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bF)(touchingEntry.span, entry.span) });\n                    // reinsert the area that turned into a \"more\" link (so no other entries try to\n                    // occupy the space) but mark it forced-hidden\n                    const hiddenEntryId = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bB)(hiddenEntry);\n                    forceHidden[hiddenEntryId] = true;\n                    entriesByLevel[touchingLevel][touchingLateral] = hiddenEntry;\n                    hiddenEntries.push(hiddenEntry);\n                    this.splitEntry(touchingEntry, entry, hiddenEntries);\n                }\n                else {\n                    forceHidden[touchingEntryId] = true;\n                    hiddenEntries.push(touchingEntry);\n                }\n            }\n        }\n        // will try to reslice...\n        super.handleInvalidInsertion(insertion, entry, hiddenEntries);\n    }\n}\n\nclass TableRow extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor() {\n        super(...arguments);\n        this.cellElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf(); // the <td>\n        this.frameElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf(); // the fc-daygrid-day-frame\n        this.fgElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf(); // the fc-daygrid-day-events\n        this.segHarnessRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf(); // indexed by \"instanceId:firstCol\"\n        this.rootElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.state = {\n            framePositions: null,\n            maxContentHeight: null,\n            segHeights: {},\n        };\n        this.handleResize = (isForced) => {\n            if (isForced) {\n                this.updateSizing(true); // isExternal=true\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { options } = context;\n        let colCnt = props.cells.length;\n        let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n        let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n        let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n        let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n        let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bR)(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.segHeights, state.maxContentHeight, props.cells);\n        let isForcedInvisible = // TODO: messy way to compute this\n         (props.eventDrag && props.eventDrag.affectedInstances) ||\n            (props.eventResize && props.eventResize.affectedInstances) ||\n            {};\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", { ref: this.rootElRef, role: \"row\" },\n            props.renderIntro && props.renderIntro(),\n            props.cells.map((cell, col) => {\n                let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);\n                let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n                return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCell, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), innerElRef: this.frameElRefs.createRef(cell.key) /* FF <td> problem, but okay to use for left/right. TODO: rename prop */, dateProfile: props.dateProfile, date: cell.date, showDayNumber: props.showDayNumbers, showWeekNumber: props.showWeekNumbers && col === 0, forceDayTop: props.showWeekNumbers /* even displaying weeknum for row, not necessarily day */, todayRange: props.todayRange, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, moreCnt: moreCnts[col], moreMarginTop: moreMarginTops[col], singlePlacements: singleColPlacements[col], fgContentElRef: this.fgElRefs.createRef(cell.key), fgContent: ( // Fragment scopes the keys\n                    (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null,\n                        (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, normalFgNodes),\n                        (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, mirrorFgNodes))), bgContent: ( // Fragment scopes the keys\n                    (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null,\n                        this.renderFillSegs(highlightSegsByCol[col], 'highlight'),\n                        this.renderFillSegs(businessHoursByCol[col], 'non-business'),\n                        this.renderFillSegs(bgEventSegsByCol[col], 'bg-event'))), minHeight: props.cellMinHeight }));\n            })));\n    }\n    componentDidMount() {\n        this.updateSizing(true);\n        this.context.addResizeHandler(this.handleResize);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        let currentProps = this.props;\n        this.updateSizing(!(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.E)(prevProps, currentProps));\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleResize);\n    }\n    getHighlightSegs() {\n        let { props } = this;\n        if (props.eventDrag && props.eventDrag.segs.length) { // messy check\n            return props.eventDrag.segs;\n        }\n        if (props.eventResize && props.eventResize.segs.length) { // messy check\n            return props.eventResize.segs;\n        }\n        return props.dateSelectionSegs;\n    }\n    getMirrorSegs() {\n        let { props } = this;\n        if (props.eventResize && props.eventResize.segs.length) { // messy check\n            return props.eventResize.segs;\n        }\n        return [];\n    }\n    renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n        let { context } = this;\n        let { eventSelection } = this.props;\n        let { framePositions } = this.state;\n        let defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n        let isMirror = isDragging || isResizing || isDateSelecting;\n        let nodes = [];\n        if (framePositions) {\n            for (let placement of segPlacements) {\n                let { seg } = placement;\n                let { instanceId } = seg.eventRange.instance;\n                let isVisible = placement.isVisible && !isForcedInvisible[instanceId];\n                let isAbsolute = placement.isAbsolute;\n                let left = '';\n                let right = '';\n                if (isAbsolute) {\n                    if (context.isRtl) {\n                        right = 0;\n                        left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n                    }\n                    else {\n                        left = 0;\n                        right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n                    }\n                }\n                /*\n                known bug: events that are force to be list-item but span multiple days still take up space in later columns\n                todo: in print view, for multi-day events, don't display title within non-start/end segs\n                */\n                nodes.push((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''), key: generateSegKey(seg), ref: isMirror ? null : this.segHarnessRefs.createRef(generateSegUid(seg)), style: {\n                        visibility: isVisible ? '' : 'hidden',\n                        marginTop: isAbsolute ? '' : placement.marginTop,\n                        top: isAbsolute ? placement.absoluteTop : '',\n                        left,\n                        right,\n                    } }, hasListItemDisplay(seg) ? ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableListItemEvent, Object.assign({ seg: seg, isDragging: isDragging, isSelected: instanceId === eventSelection, defaultDisplayEventEnd: defaultDisplayEventEnd }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, todayRange)))) : ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableBlockEvent, Object.assign({ seg: seg, isDragging: isDragging, isResizing: isResizing, isDateSelecting: isDateSelecting, isSelected: instanceId === eventSelection, defaultDisplayEventEnd: defaultDisplayEventEnd }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, todayRange))))));\n            }\n        }\n        return nodes;\n    }\n    renderFillSegs(segs, fillType) {\n        let { isRtl } = this.context;\n        let { todayRange } = this.props;\n        let { framePositions } = this.state;\n        let nodes = [];\n        if (framePositions) {\n            for (let seg of segs) {\n                let leftRightCss = isRtl ? {\n                    right: 0,\n                    left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol],\n                } : {\n                    left: 0,\n                    right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol],\n                };\n                nodes.push((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { key: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bT)(seg.eventRange), className: \"fc-daygrid-bg-harness\", style: leftRightCss }, fillType === 'bg-event' ?\n                    (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cp, Object.assign({ seg: seg }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bS)(seg, todayRange))) :\n                    (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.co)(fillType)));\n            }\n        }\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, {}, ...nodes);\n    }\n    updateSizing(isExternalSizingChange) {\n        let { props, state, frameElRefs } = this;\n        if (!props.forPrint &&\n            props.clientWidth !== null // positioning ready?\n        ) {\n            if (isExternalSizingChange) {\n                let frameEls = props.cells.map((cell) => frameElRefs.currentMap[cell.key]);\n                if (frameEls.length) {\n                    let originEl = this.rootElRef.current;\n                    let newPositionCache = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ba(originEl, frameEls, true, // isHorizontal\n                    false);\n                    if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {\n                        this.setState({\n                            framePositions: new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ba(originEl, frameEls, true, // isHorizontal\n                            false),\n                        });\n                    }\n                }\n            }\n            const oldSegHeights = this.state.segHeights;\n            const newSegHeights = this.querySegHeights();\n            const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n            this.safeSetState({\n                // HACK to prevent oscillations of events being shown/hidden from max-event-rows\n                // Essentially, once you compute an element's height, never null-out.\n                // TODO: always display all events, as visibility:hidden?\n                segHeights: Object.assign(Object.assign({}, oldSegHeights), newSegHeights),\n                maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null,\n            });\n        }\n    }\n    querySegHeights() {\n        let segElMap = this.segHarnessRefs.currentMap;\n        let segHeights = {};\n        // get the max height amongst instance segs\n        for (let segUid in segElMap) {\n            let height = Math.round(segElMap[segUid].getBoundingClientRect().height);\n            segHeights[segUid] = Math.max(segHeights[segUid] || 0, height);\n        }\n        return segHeights;\n    }\n    computeMaxContentHeight() {\n        let firstKey = this.props.cells[0].key;\n        let cellEl = this.cellElRefs.currentMap[firstKey];\n        let fcContainerEl = this.fgElRefs.currentMap[firstKey];\n        return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n    }\n    getCellEls() {\n        let elMap = this.cellElRefs.currentMap;\n        return this.props.cells.map((cell) => elMap[cell.key]);\n    }\n}\nTableRow.addStateEquality({\n    segHeights: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.E,\n});\nfunction buildMirrorPlacements(mirrorSegs, colPlacements) {\n    if (!mirrorSegs.length) {\n        return [];\n    }\n    let topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?\n    return mirrorSegs.map((seg) => ({\n        seg,\n        isVisible: true,\n        isAbsolute: true,\n        absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],\n        marginTop: 0,\n    }));\n}\nfunction buildAbsoluteTopHash(colPlacements) {\n    let topsByInstanceId = {};\n    for (let placements of colPlacements) {\n        for (let placement of placements) {\n            topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;\n        }\n    }\n    return topsByInstanceId;\n}\n\nclass TableRows extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor() {\n        super(...arguments);\n        this.splitBusinessHourSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitBgEventSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitFgEventSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitDateSelectionSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByRow);\n        this.splitEventDrag = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitInteractionByRow);\n        this.splitEventResize = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitInteractionByRow);\n        this.rowRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cf();\n    }\n    render() {\n        let { props, context } = this;\n        let rowCnt = props.cells.length;\n        let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n        let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n        let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n        let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n        let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n        let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n        // for DayGrid view with many rows, force a min-height on cells so doesn't appear squished\n        // choose 7 because a month view will have max 6 rows\n        let cellMinHeight = (rowCnt >= 7 && props.clientWidth) ?\n            props.clientWidth / context.options.aspectRatio / 6 :\n            null;\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ch, { unit: \"day\" }, (nowDate, todayRange) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, props.cells.map((cells, row) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableRow, { ref: this.rowRefs.createRef(row), key: cells.length\n                ? cells[0].date.toISOString() /* best? or put key on cell? or use diff formatter? */\n                : row // in case there are no cells (like when resource view is loading)\n            , showDayNumbers: rowCnt > 1, showWeekNumbers: props.showWeekNumbers, todayRange: todayRange, dateProfile: props.dateProfile, cells: cells, renderIntro: props.renderRowIntro, businessHourSegs: businessHourSegsByRow[row], eventSelection: props.eventSelection, bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay) /* hack */, fgEventSegs: fgEventSegsByRow[row], dateSelectionSegs: dateSelectionSegsByRow[row], eventDrag: eventDragByRow[row], eventResize: eventResizeByRow[row], dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, clientWidth: props.clientWidth, clientHeight: props.clientHeight, cellMinHeight: cellMinHeight, forPrint: props.forPrint })))))));\n    }\n    componentDidMount() {\n        this.registerInteractiveComponent();\n    }\n    componentDidUpdate() {\n        // for if started with zero cells\n        this.registerInteractiveComponent();\n    }\n    registerInteractiveComponent() {\n        if (!this.rootEl) {\n            // HACK: need a daygrid wrapper parent to do positioning\n            // NOTE: a daygrid resource view w/o resources can have zero cells\n            const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];\n            const rootEl = firstCellEl ? firstCellEl.closest('.fc-daygrid-body') : null;\n            if (rootEl) {\n                this.rootEl = rootEl;\n                this.context.registerInteractiveComponent(this, {\n                    el: rootEl,\n                    isHitComboAllowed: this.props.isHitComboAllowed,\n                });\n            }\n        }\n    }\n    componentWillUnmount() {\n        if (this.rootEl) {\n            this.context.unregisterInteractiveComponent(this);\n            this.rootEl = null;\n        }\n    }\n    // Hit System\n    // ----------------------------------------------------------------------------------------------------\n    prepareHits() {\n        this.rowPositions = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ba(this.rootEl, this.rowRefs.collect().map((rowObj) => rowObj.getCellEls()[0]), // first cell el in each row. TODO: not optimal\n        false, true);\n        this.colPositions = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ba(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), // cell els in first row\n        true, // horizontal\n        false);\n    }\n    queryHit(positionLeft, positionTop) {\n        let { colPositions, rowPositions } = this;\n        let col = colPositions.leftToIndex(positionLeft);\n        let row = rowPositions.topToIndex(positionTop);\n        if (row != null && col != null) {\n            let cell = this.props.cells[row][col];\n            return {\n                dateProfile: this.props.dateProfile,\n                dateSpan: Object.assign({ range: this.getCellRange(row, col), allDay: true }, cell.extraDateSpan),\n                dayEl: this.getCellEl(row, col),\n                rect: {\n                    left: colPositions.lefts[col],\n                    right: colPositions.rights[col],\n                    top: rowPositions.tops[row],\n                    bottom: rowPositions.bottoms[row],\n                },\n                layer: 0,\n            };\n        }\n        return null;\n    }\n    getCellEl(row, col) {\n        return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n    }\n    getCellRange(row, col) {\n        let start = this.props.cells[row][col].date;\n        let end = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.t)(start, 1);\n        return { start, end };\n    }\n}\nfunction isSegAllDay(seg) {\n    return seg.eventRange.def.allDay;\n}\n\nclass Table extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor() {\n        super(...arguments);\n        this.elRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.needsScrollReset = false;\n    }\n    render() {\n        let { props } = this;\n        let { dayMaxEventRows, dayMaxEvents, expandRows } = props;\n        let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;\n        // if rows can't expand to fill fixed height, can't do balanced-height event limit\n        // TODO: best place to normalize these options?\n        if (limitViaBalanced && !expandRows) {\n            limitViaBalanced = false;\n            dayMaxEventRows = null;\n            dayMaxEvents = null;\n        }\n        let classNames = [\n            'fc-daygrid-body',\n            limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced',\n            expandRows ? '' : 'fc-daygrid-body-natural', // will height of one row depend on the others?\n        ];\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { ref: this.elRef, className: classNames.join(' '), style: {\n                // these props are important to give this wrapper correct dimensions for interactions\n                // TODO: if we set it here, can we avoid giving to inner tables?\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth,\n            } },\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", { role: \"presentation\", className: \"fc-scrollgrid-sync-table\", style: {\n                    width: props.clientWidth,\n                    minWidth: props.tableMinWidth,\n                    height: expandRows ? props.clientHeight : '',\n                } },\n                props.colGroupNode,\n                (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", { role: \"presentation\" },\n                    (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableRows, { dateProfile: props.dateProfile, cells: props.cells, renderRowIntro: props.renderRowIntro, showWeekNumbers: props.showWeekNumbers, clientWidth: props.clientWidth, clientHeight: props.clientHeight, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, dayMaxEvents: dayMaxEvents, dayMaxEventRows: dayMaxEventRows, forPrint: props.forPrint, isHitComboAllowed: props.isHitComboAllowed })))));\n    }\n    componentDidMount() {\n        this.requestScrollReset();\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.dateProfile !== this.props.dateProfile) {\n            this.requestScrollReset();\n        }\n        else {\n            this.flushScrollReset();\n        }\n    }\n    requestScrollReset() {\n        this.needsScrollReset = true;\n        this.flushScrollReset();\n    }\n    flushScrollReset() {\n        if (this.needsScrollReset &&\n            this.props.clientWidth // sizes computed?\n        ) {\n            const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);\n            if (subjectEl) {\n                const originEl = subjectEl.closest('.fc-daygrid-body');\n                const scrollEl = originEl.closest('.fc-scroller');\n                const scrollTop = subjectEl.getBoundingClientRect().top -\n                    originEl.getBoundingClientRect().top;\n                scrollEl.scrollTop = scrollTop ? (scrollTop + 1) : 0; // overcome border\n            }\n            this.needsScrollReset = false;\n        }\n    }\n}\nfunction getScrollSubjectEl(containerEl, dateProfile) {\n    let el;\n    if (dateProfile.currentRangeUnit.match(/year|month/)) {\n        el = containerEl.querySelector(`[data-date=\"${(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bx)(dateProfile.currentDate)}-01\"]`);\n        // even if view is month-based, first-of-month might be hidden...\n    }\n    if (!el) {\n        el = containerEl.querySelector(`[data-date=\"${(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bv)(dateProfile.currentDate)}\"]`);\n        // could still be hidden if an interior-view hidden day\n    }\n    return el;\n}\n\nclass DayTableSlicer extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bW {\n    constructor() {\n        super(...arguments);\n        this.forceDayIfListItem = true;\n    }\n    sliceRange(dateRange, dayTableModel) {\n        return dayTableModel.sliceRange(dateRange);\n    }\n}\n\nclass DayTable extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.be {\n    constructor() {\n        super(...arguments);\n        this.slicer = new DayTableSlicer();\n        this.tableRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    }\n    render() {\n        let { props, context } = this;\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Table, Object.assign({ ref: this.tableRef }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), { dateProfile: props.dateProfile, cells: props.dayTableModel.cells, colGroupNode: props.colGroupNode, tableMinWidth: props.tableMinWidth, renderRowIntro: props.renderRowIntro, dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, showWeekNumbers: props.showWeekNumbers, expandRows: props.expandRows, headerAlignElRef: props.headerAlignElRef, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: props.forPrint })));\n    }\n}\n\nclass DayTableView extends TableView {\n    constructor() {\n        super(...arguments);\n        this.buildDayTableModel = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildDayTableModel);\n        this.headerRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.tableRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        // can't override any lifecycle methods from parent\n    }\n    render() {\n        let { options, dateProfileGenerator } = this.context;\n        let { props } = this;\n        let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n        let headerContent = options.dayHeaders && ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bK, { ref: this.headerRef, dateProfile: props.dateProfile, dates: dayTableModel.headerDates, datesRepDistinctDays: dayTableModel.rowCnt === 1 }));\n        let bodyContent = (contentArg) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayTable, { ref: this.tableRef, dateProfile: props.dateProfile, dayTableModel: dayTableModel, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, nextDayThreshold: options.nextDayThreshold, colGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, dayMaxEvents: options.dayMaxEvents, dayMaxEventRows: options.dayMaxEventRows, showWeekNumbers: options.weekNumbers, expandRows: !props.isHeightAuto, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint }));\n        return options.dayMinWidth\n            ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth)\n            : this.renderSimpleLayout(headerContent, bodyContent);\n    }\n}\nfunction buildDayTableModel(dateProfile, dateProfileGenerator) {\n    let daySeries = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bO(dateProfile.renderRange, dateProfileGenerator);\n    return new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bV(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\n\nclass TableDateProfileGenerator extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.U {\n    // Computes the date range that will be rendered\n    buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {\n        let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);\n        let { props } = this;\n        return buildDayTableRenderRange({\n            currentRange: renderRange,\n            snapToWeek: /^(year|month)$/.test(currentRangeUnit),\n            fixedWeekCount: props.fixedWeekCount,\n            dateEnv: props.dateEnv,\n        });\n    }\n}\nfunction buildDayTableRenderRange(props) {\n    let { dateEnv, currentRange } = props;\n    let { start, end } = currentRange;\n    let endOfWeek;\n    // year and month views should be aligned with weeks. this is already done for week\n    if (props.snapToWeek) {\n        start = dateEnv.startOfWeek(start);\n        // make end-of-week if not already\n        endOfWeek = dateEnv.startOfWeek(end);\n        if (endOfWeek.valueOf() !== end.valueOf()) {\n            end = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bh)(endOfWeek, 1);\n        }\n    }\n    // ensure 6 weeks\n    if (props.fixedWeekCount) {\n        // TODO: instead of these date-math gymnastics (for multimonth view),\n        // compute dateprofiles of all months, then use start of first and end of last.\n        let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.t)(currentRange.end, -1)));\n        let rowCnt = Math.ceil(// could be partial weeks due to hiddenDays\n        (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bi)(lastMonthRenderStart, end));\n        end = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bh)(end, 6 - rowCnt);\n    }\n    return { start, end };\n}\n\nvar css_248z = \":root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:\\\"\\\";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:\\\"\\\";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}\";\n(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cw)(css_248z);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL2ludGVybmFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTZ0QjtBQUMzb0I7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhEQUFhO0FBQ3JDO0FBQ0E7QUFDQSwyQkFBMkIsdUVBQVM7QUFDcEM7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0EsZ0NBQWdDLGtFQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDLFNBQVM7QUFDVCxnQkFBZ0IsMkVBQWEsQ0FBQyw4REFBYSxJQUFJLHVEQUF1RDtBQUN0RyxZQUFZLDJFQUFhLENBQUMsOERBQWdCLElBQUksMklBQTJJO0FBQ3pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CLG1EQUFtRCxrRUFBb0I7QUFDdkUsdURBQXVELGtFQUF3QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw4REFBZ0I7QUFDakQscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYjtBQUNBLGdCQUFnQiwyRUFBYSxDQUFDLDhEQUFhLElBQUksdURBQXVEO0FBQ3RHLFlBQVksMkVBQWEsZUFBZSwwSEFBMEgsU0FBUyxxQ0FBcUMsR0FBRyx1QkFBdUI7QUFDMU87QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsaUVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLDZEQUFhO0FBQzNDO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQiwyRUFBYSxDQUFDLDhEQUFhLGtCQUFrQixXQUFXLHNPQUFzTztBQUM5UztBQUNBOztBQUVBLGlDQUFpQyw2REFBYTtBQUM5QztBQUNBLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWMsVUFBVTtBQUN4QixjQUFjLE1BQU07QUFDcEI7QUFDQSx1QkFBdUIsa0VBQWdCO0FBQ3ZDLGdCQUFnQiwyRUFBYSxDQUFDLDhEQUFjLGtCQUFrQixXQUFXLDhFQUE4RSxrRUFBaUIsMkhBQTJIO0FBQ25TO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkVBQWEsQ0FBQyxrRUFBUTtBQUNsQyxRQUFRLDJFQUFhLFVBQVUsNENBQTRDLHVFQUF1RTtBQUNsSixpQ0FBaUMsMkVBQWEsVUFBVSw0QkFBNEI7QUFDcEYsUUFBUSwyRUFBYSxVQUFVLDZCQUE2Qiw2QkFBNkIsMkVBQWEsQ0FBQyxrRUFBUTtBQUMvRzs7QUFFQSxnQ0FBZ0MsNkRBQWE7QUFDN0M7QUFDQTtBQUNBLDJCQUEyQixpRUFBTztBQUNsQztBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMseUJBQXlCO0FBQ3ZDLGdCQUFnQiwyRUFBYSxDQUFDLDhEQUFpQixJQUFJO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyRUFBYSxDQUFDLGtFQUFRO0FBQzlDO0FBQ0EsNEJBQTRCLDJFQUFhLFVBQVU7QUFDbkQ7QUFDQSwyQkFBMkIsNkJBQTZCLDJFQUFhLHFDQUFxQyw2R0FBNkcsRUFBRSxrRUFBVSw4QkFBOEIsMkVBQWEsa0NBQWtDLHdKQUF3SixFQUFFLGtFQUFVO0FBQ3BkLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSxnQ0FBZ0MsaUVBQWUsR0FBRyxnQkFBZ0I7QUFDbEUsd0JBQXdCLDhEQUFhO0FBQ3JDO0FBQ0E7QUFDQSx5QkFBeUIsdUVBQVM7QUFDbEM7QUFDQSx5QkFBeUIsa0VBQWM7QUFDdkM7QUFDQTtBQUNBLFlBQVksaUVBQU07QUFDbEIsWUFBWSxpRUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1DQUFtQztBQUNqRCxjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkVBQWEsQ0FBQyw4REFBZ0IsSUFBSTtBQUNsRDtBQUNBO0FBQ0Esb0VBQW9FLGtEQUFrRCx1Q0FBdUMsSUFBSSxNQUFNLGtCQUFrQixtTkFBbU4sa0NBQWtDLDJFQUFhLFVBQVUsNEZBQTRGLDhCQUE4QjtBQUMvakIscUNBQXFDLDJFQUFhLENBQUMsOERBQW1CLElBQUksNERBQTRELGtFQUFpQiw2RUFBNkU7QUFDcE87QUFDQSx3Q0FBd0Msa0VBQXVCLG1DQUFtQywyRUFBYSxVQUFVLGlDQUFpQztBQUMxSixnQkFBZ0IsMkVBQWEsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSw4REFBOEQsRUFBRSxrRUFBaUIsb0JBQW9CLHVCQUF1QixHQUFHO0FBQy9IO0FBQ0EsWUFBWSwyRUFBYSxVQUFVLDBDQUEwQyx3QkFBd0I7QUFDckcsZ0JBQWdCLDJFQUFhLFFBQVEsb0NBQW9DO0FBQ3pFLFlBQVksMkVBQWEsVUFBVSwrREFBK0Q7QUFDbEc7QUFDQSxnQkFBZ0IsMkVBQWEsVUFBVSw2Q0FBNkMsa0NBQWtDO0FBQ3RILG9CQUFvQiwyRUFBYSxzQkFBc0IsdVZBQXVWO0FBQzlZLFlBQVksMkVBQWEsVUFBVSxnQ0FBZ0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJFQUFhLENBQUMsa0VBQVE7QUFDeEQ7QUFDQTtBQUNBLFlBQVksdUNBQXVDO0FBQ25ELDJCQUEyQixrRUFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyREFBMkQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlDQUF5QyxzQkFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsaUVBQWlFO0FBQ2pFLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpRUFBZTtBQUNyQztBQUNBLGFBQWEsaUVBQU87QUFDcEIsS0FBSztBQUNMLHlDQUF5QyxVQUFVO0FBQ25EO0FBQ0EsOENBQThDLG9CQUFvQix5QkFBeUI7QUFDM0Y7QUFDQTtBQUNBLFNBQVMsZ0tBQWdLO0FBQ3pLO0FBQ0Esa0NBQWtDLDhEQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsMkRBQTJELGtFQUFhO0FBQ3hFO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QyxnQkFBZ0IsZ0RBQWdEO0FBQ2hFO0FBQ0E7QUFDQSxvQ0FBb0Msa0VBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLG9CQUFvQixNQUFNLGtFQUFjLGtDQUFrQztBQUNoSjtBQUNBO0FBQ0EsMENBQTBDLGtFQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsOERBQWE7QUFDcEM7QUFDQTtBQUNBLDhCQUE4Qiw4REFBTSxJQUFJO0FBQ3hDLCtCQUErQiw4REFBTSxJQUFJO0FBQ3pDLDRCQUE0Qiw4REFBTSxJQUFJO0FBQ3RDLGtDQUFrQyw4REFBTSxJQUFJO0FBQzVDLHlCQUF5Qix1RUFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEMsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9FQUFvRSx3QkFBd0Isa0VBQWE7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkVBQWEsU0FBUyxrQ0FBa0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsZ0pBQWdKO0FBQ2hKLHdCQUF3QiwyRUFBYSxjQUFjO0FBQ25ELG9CQUFvQiwyRUFBYSxDQUFDLGtFQUFRO0FBQzFDLHdCQUF3QiwyRUFBYSxDQUFDLGtFQUFRO0FBQzlDLHdCQUF3QiwyRUFBYSxDQUFDLGtFQUFRO0FBQzlDLG9CQUFvQiwyRUFBYSxDQUFDLGtFQUFRO0FBQzFDO0FBQ0E7QUFDQSxrSEFBa0g7QUFDbEgsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlFQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QixjQUFjLGlCQUFpQjtBQUMvQixjQUFjLGlCQUFpQjtBQUMvQixvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QixzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkVBQWEsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QiwyRUFBYSxxQ0FBcUMsNkhBQTZILEVBQUUsa0VBQVUsd0JBQXdCLDJFQUFhLGtDQUFrQyx1TEFBdUwsRUFBRSxrRUFBVTtBQUN6ZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsYUFBYTtBQUMzQixjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJFQUFhLFVBQVUsS0FBSyxrRUFBa0IsMkVBQTJFO0FBQ3BKLG9CQUFvQiwyRUFBYSxDQUFDLDhEQUFPLGtCQUFrQixVQUFVLEVBQUUsa0VBQVU7QUFDakYsb0JBQW9CLGtFQUFVO0FBQzlCO0FBQ0E7QUFDQSxlQUFlLDJFQUFhLENBQUMsa0VBQVEsSUFBSTtBQUN6QztBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsOERBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDhEQUFhO0FBQzdEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2REFBWTtBQUM1QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qiw4REFBYTtBQUNyQztBQUNBO0FBQ0EscUNBQXFDLGlFQUFPO0FBQzVDLGdDQUFnQyxpRUFBTztBQUN2QyxnQ0FBZ0MsaUVBQU87QUFDdkMsc0NBQXNDLGlFQUFPO0FBQzdDLDhCQUE4QixpRUFBTztBQUNyQyxnQ0FBZ0MsaUVBQU87QUFDdkMsMkJBQTJCLDhEQUFNO0FBQ2pDO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkVBQWEsQ0FBQyw4REFBUSxJQUFJLGFBQWEsNEJBQTRCLDJFQUFhLENBQUMsa0VBQVEseUNBQXlDLDJFQUFhLGFBQWE7QUFDNUs7QUFDQTtBQUNBLDhxQkFBOHFCO0FBQzlxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOERBQWE7QUFDN0M7QUFDQSxnQ0FBZ0MsOERBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0RBQWtEO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFPO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw4REFBYTtBQUNqQztBQUNBO0FBQ0EscUJBQXFCLHVFQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLDRDQUE0QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyRUFBYSxVQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLFlBQVksMkVBQWEsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxnQkFBZ0IsMkVBQWEsWUFBWSxzQkFBc0I7QUFDL0Qsb0JBQW9CLDJFQUFhLGNBQWMsZ2tCQUFna0I7QUFDL21CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrRUFBaUIsMEJBQTBCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrRUFBZSwwQkFBMEI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLDhEQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDhEQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1RUFBUztBQUNqQztBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0IsZ0JBQWdCLDJFQUFhLHdCQUF3QixvQkFBb0IsNEdBQTRHLG9jQUFvYztBQUN6bkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUVBQU87QUFDekMseUJBQXlCLHVFQUFTO0FBQ2xDLHdCQUF3Qix1RUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQSxjQUFjLGdDQUFnQztBQUM5QyxjQUFjLFFBQVE7QUFDdEI7QUFDQSxtREFBbUQsMkVBQWEsQ0FBQyw4REFBUyxJQUFJLHlJQUF5STtBQUN2TiwyQ0FBMkMsMkVBQWEsYUFBYSw0dEJBQTR0QjtBQUNqeUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhEQUFjO0FBQ3RDLGVBQWUsOERBQWE7QUFDNUI7O0FBRUEsd0NBQXdDLDZEQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0VBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGlFQUFPO0FBQ25GO0FBQ0EsUUFBUSxrRUFBUztBQUNqQixjQUFjLGtFQUFRO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiOztBQUVBLHNCQUFzQixpQ0FBaUMscUxBQXFMLFdBQVcsYUFBYSxjQUFjLHFCQUFxQixrQkFBa0IsVUFBVSxpQ0FBaUMsMENBQTBDLDBCQUEwQixnQkFBZ0Isa0JBQWtCLHdCQUF3QixhQUFhLDJCQUEyQixzQ0FBc0MsV0FBVywyQkFBMkIsWUFBWSxrQkFBa0IsVUFBVSw0QkFBNEIsZ0JBQWdCLGdCQUFnQiwyQkFBMkIsZUFBZSxxREFBcUQsT0FBTyxrQkFBa0IsUUFBUSx1REFBdUQsZUFBZSxrQkFBa0Isb0RBQW9ELGtCQUFrQiw4QkFBOEIsa0JBQWtCLGtDQUFrQyxPQUFPLGtCQUFrQixRQUFRLE1BQU0sMkJBQTJCLFNBQVMsa0JBQWtCLE1BQU0sd0NBQXdDLFVBQVUsb0NBQW9DLFVBQVUscUNBQXFDLFVBQVUsc0JBQXNCLGVBQWUsVUFBVSxzQ0FBc0MsVUFBVSwyQkFBMkIsZ0JBQWdCLGFBQWEsbUVBQW1FLFdBQVcsYUFBYSxjQUFjLDBCQUEwQixrQkFBa0IsZUFBZSxjQUFjLGVBQWUsZUFBZSxnQkFBZ0IsWUFBWSxrQkFBa0IsbUJBQW1CLFVBQVUsZ0NBQWdDLGdDQUFnQyw0QkFBNEIsNENBQTRDLG1DQUFtQyxnQkFBZ0IsWUFBWSxrQkFBa0Isa0JBQWtCLE1BQU0sVUFBVSxzQ0FBc0MsZ0JBQWdCLGFBQWEsb0dBQW9HLGdCQUFnQixvR0FBb0csaUJBQWlCLHdDQUF3QyxXQUFXLDBDQUEwQyx3QkFBd0IsT0FBTyx3Q0FBd0MsWUFBWSwwQ0FBMEMsd0JBQXdCLFFBQVEsc0NBQXNDLGdCQUFnQixrQkFBa0Isa0JBQWtCLG9DQUFvQyxrQkFBa0IsbUJBQW1CLHVDQUF1QyxnQkFBZ0IsK0VBQStFLFlBQVksc0JBQXNCLG1CQUFtQixhQUFhLGNBQWMsc0NBQXNDLFlBQVksY0FBYyxnQkFBZ0IsWUFBWSxnQkFBZ0Isa0VBQWtFLDBCQUEwQiwrQ0FBK0MsYUFBYSxVQUFVLHNCQUFzQixvRkFBb0Ysd0RBQXdELHVCQUF1QixTQUFTLGFBQWEsUUFBUSxtREFBbUQsaUJBQWlCLG1EQUFtRCxnQkFBZ0I7QUFDcDlHLGtFQUFZOztBQUUySiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvZGF5Z3JpZC9pbnRlcm5hbC5qcz9hOGI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGVDb21wb25lbnQsIGdldFN0aWNreUhlYWRlckRhdGVzLCBWaWV3Q29udGFpbmVyLCBTaW1wbGVTY3JvbGxHcmlkLCBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIsIHJlbmRlclNjcm9sbFNoaW0sIGNyZWF0ZUZvcm1hdHRlciwgQmFzZUNvbXBvbmVudCwgU3RhbmRhcmRFdmVudCwgYnVpbGRTZWdUaW1lVGV4dCwgRXZlbnRDb250YWluZXIsIGdldFNlZ0FuY2hvckF0dHJzLCBtZW1vaXplLCBNb3JlTGlua0NvbnRhaW5lciwgZ2V0U2VnTWV0YSwgZ2V0VW5pcXVlRG9tSWQsIHNldFJlZiwgRGF5Q2VsbENvbnRhaW5lciwgV2Vla051bWJlckNvbnRhaW5lciwgYnVpbGROYXZMaW5rQXR0cnMsIGhhc0N1c3RvbURheUNlbGxDb250ZW50LCBhZGRNcywgaW50ZXJzZWN0UmFuZ2VzLCBhZGREYXlzLCBTZWdIaWVyYXJjaHksIGJ1aWxkRW50cnlLZXksIGludGVyc2VjdFNwYW5zLCBSZWZNYXAsIHNvcnRFdmVudFNlZ3MsIGlzUHJvcHNFcXVhbCwgYnVpbGRFdmVudFJhbmdlS2V5LCBCZ0V2ZW50LCByZW5kZXJGaWxsLCBQb3NpdGlvbkNhY2hlLCBOb3dUaW1lciwgZm9ybWF0SXNvTW9udGhTdHIsIGZvcm1hdERheVN0cmluZywgU2xpY2VyLCBEYXlIZWFkZXIsIERheVNlcmllc01vZGVsLCBEYXlUYWJsZU1vZGVsLCBEYXRlUHJvZmlsZUdlbmVyYXRvciwgYWRkV2Vla3MsIGRpZmZXZWVrcywgaW5qZWN0U3R5bGVzIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCB7IGNyZWF0ZVJlZiwgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvcHJlYWN0LmpzJztcblxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZm9yIHRoZSBkYXlncmlkIHZpZXdzLCBhcyB3ZWxsIGFzIG1vbnRoIHZpZXcuIFJlbmRlcnMgb25lIG9yIG1vcmUgcm93cyBvZiBkYXkgY2VsbHMuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIEl0IGlzIGEgbWFuYWdlciBmb3IgYSBUYWJsZSBzdWJjb21wb25lbnQsIHdoaWNoIGRvZXMgbW9zdCBvZiB0aGUgaGVhdnkgbGlmdGluZy5cbi8vIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXG5jbGFzcyBUYWJsZVZpZXcgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oZWFkZXJFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgIH1cbiAgICByZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYm9keUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgY2h1bms6IHtcbiAgICAgICAgICAgICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAga2V5OiAnYm9keScsXG4gICAgICAgICAgICBsaXF1aWQ6IHRydWUsXG4gICAgICAgICAgICBjaHVuazogeyBjb250ZW50OiBib2R5Q29udGVudCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2ltcGxlU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBwcm9wcy5mb3JQcmludCwgY29sczogW10gLyogVE9ETzogbWFrZSBvcHRpb25hbD8gKi8sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpO1xuICAgIH1cbiAgICByZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlclJvd0NvbnRlbnQsIGJvZHlDb250ZW50LCBjb2xDbnQsIGRheU1pbldpZHRoKSB7XG4gICAgICAgIGxldCBTY3JvbGxHcmlkID0gdGhpcy5jb250ZXh0LnBsdWdpbkhvb2tzLnNjcm9sbEdyaWRJbXBsO1xuICAgICAgICBpZiAoIVNjcm9sbEdyaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gU2Nyb2xsR3JpZCBpbXBsZW1lbnRhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgbGV0IHN0aWNreUZvb3RlclNjcm9sbGJhciA9ICFwcm9wcy5mb3JQcmludCAmJiBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGNodW5rczogW3tcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGJvZHlDb250ZW50LFxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhcikge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Zvb3RlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IHByb3BzLmZvclByaW50LCBjb2xHcm91cHM6IFt7IGNvbHM6IFt7IHNwYW46IGNvbENudCwgbWluV2lkdGg6IGRheU1pbldpZHRoIH1dIH1dLCBzZWN0aW9uczogc2VjdGlvbnMgfSkpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNwbGl0U2Vnc0J5Um93KHNlZ3MsIHJvd0NudCkge1xuICAgIGxldCBieVJvdyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgICAgYnlSb3dbaV0gPSBbXTtcbiAgICB9XG4gICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgYnlSb3dbc2VnLnJvd10ucHVzaChzZWcpO1xuICAgIH1cbiAgICByZXR1cm4gYnlSb3c7XG59XG5mdW5jdGlvbiBzcGxpdFNlZ3NCeUZpcnN0Q29sKHNlZ3MsIGNvbENudCkge1xuICAgIGxldCBieUNvbCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICAgICAgYnlDb2xbaV0gPSBbXTtcbiAgICB9XG4gICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgYnlDb2xbc2VnLmZpcnN0Q29sXS5wdXNoKHNlZyk7XG4gICAgfVxuICAgIHJldHVybiBieUNvbDtcbn1cbmZ1bmN0aW9uIHNwbGl0SW50ZXJhY3Rpb25CeVJvdyh1aSwgcm93Q250KSB7XG4gICAgbGV0IGJ5Um93ID0gW107XG4gICAgaWYgKCF1aSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ5Um93W2ldID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiB1aS5hZmZlY3RlZEluc3RhbmNlcyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiB1aS5pc0V2ZW50LFxuICAgICAgICAgICAgICAgIHNlZ3M6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzZWcgb2YgdWkuc2Vncykge1xuICAgICAgICAgICAgYnlSb3dbc2VnLnJvd10uc2Vncy5wdXNoKHNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ5Um93O1xufVxuXG5jb25zdCBERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgb21pdFplcm9NaW51dGU6IHRydWUsXG4gICAgbWVyaWRpZW06ICduYXJyb3cnLFxufSk7XG5mdW5jdGlvbiBoYXNMaXN0SXRlbURpc3BsYXkoc2VnKSB7XG4gICAgbGV0IHsgZGlzcGxheSB9ID0gc2VnLmV2ZW50UmFuZ2UudWk7XG4gICAgcmV0dXJuIGRpc3BsYXkgPT09ICdsaXN0LWl0ZW0nIHx8IChkaXNwbGF5ID09PSAnYXV0bycgJiZcbiAgICAgICAgIXNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXkgJiZcbiAgICAgICAgc2VnLmZpcnN0Q29sID09PSBzZWcubGFzdENvbCAmJiAvLyBjYW4ndCBiZSBtdWx0aS1kYXlcbiAgICAgICAgc2VnLmlzU3RhcnQgJiYgLy8gXCJcbiAgICAgICAgc2VnLmlzRW5kIC8vIFwiXG4gICAgKTtcbn1cblxuY2xhc3MgVGFibGVCbG9ja0V2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFN0YW5kYXJkRXZlbnQsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsQ2xhc3NlczogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtYmxvY2stZXZlbnQnLCAnZmMtaC1ldmVudCddLCBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCwgZGlzYWJsZVJlc2l6aW5nOiAhcHJvcHMuc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSB9KSkpO1xuICAgIH1cbn1cblxuY2xhc3MgVGFibGVMaXN0SXRlbUV2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHsgc2VnIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHRpbWVGb3JtYXQgPSBvcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCBERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUO1xuICAgICAgICBsZXQgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgdHJ1ZSwgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChFdmVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgZWxUYWc6IFwiYVwiLCBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZC1ldmVudCcsICdmYy1kYXlncmlkLWRvdC1ldmVudCddLCBlbEF0dHJzOiBnZXRTZWdBbmNob3JBdHRycyhwcm9wcy5zZWcsIGNvbnRleHQpLCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQsIHRpbWVUZXh0OiB0aW1lVGV4dCwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UgfSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQocmVuZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1ldmVudC1kb3RcIiwgc3R5bGU6IHsgYm9yZGVyQ29sb3I6IHJlbmRlclByb3BzLmJvcmRlckNvbG9yIHx8IHJlbmRlclByb3BzLmJhY2tncm91bmRDb2xvciB9IH0pLFxuICAgICAgICByZW5kZXJQcm9wcy50aW1lVGV4dCAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aW1lXCIgfSwgcmVuZGVyUHJvcHMudGltZVRleHQpKSxcbiAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZVwiIH0sIHJlbmRlclByb3BzLmV2ZW50LnRpdGxlIHx8IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFwiXFx1MDBBMFwiKSkpKTtcbn1cblxuY2xhc3MgVGFibGVDZWxsTW9yZUxpbmsgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jb21waWxlU2VncyA9IG1lbW9pemUoY29tcGlsZVNlZ3MpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBhbGxTZWdzLCBpbnZpc2libGVTZWdzIH0gPSB0aGlzLmNvbXBpbGVTZWdzKHByb3BzLnNpbmdsZVBsYWNlbWVudHMpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTW9yZUxpbmtDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtbW9yZS1saW5rJ10sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgYWxsRGF5RGF0ZTogcHJvcHMuYWxsRGF5RGF0ZSwgbW9yZUNudDogcHJvcHMubW9yZUNudCwgYWxsU2VnczogYWxsU2VncywgaGlkZGVuU2VnczogaW52aXNpYmxlU2VncywgYWxpZ25tZW50RWxSZWY6IHByb3BzLmFsaWdubWVudEVsUmVmLCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgcG9wb3ZlckNvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaXNGb3JjZWRJbnZpc2libGUgPSAocHJvcHMuZXZlbnREcmFnID8gcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplID8gcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxuICAgICAgICAgICAgICAgICAgICB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIGFsbFNlZ3MubWFwKChzZWcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlSWQgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzXCIsIGtleTogaW5zdGFuY2VJZCwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc0ZvcmNlZEludmlzaWJsZVtpbnN0YW5jZUlkXSA/ICdoaWRkZW4nIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0sIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpID8gKGNyZWF0ZUVsZW1lbnQoVGFibGVMaXN0SXRlbUV2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZmFsc2UgfSwgZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UpKSkpIDogKGNyZWF0ZUVsZW1lbnQoVGFibGVCbG9ja0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGZhbHNlIH0sIGdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlKSkpKSkpO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9IH0pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21waWxlU2VncyhzaW5nbGVQbGFjZW1lbnRzKSB7XG4gICAgbGV0IGFsbFNlZ3MgPSBbXTtcbiAgICBsZXQgaW52aXNpYmxlU2VncyA9IFtdO1xuICAgIGZvciAobGV0IHBsYWNlbWVudCBvZiBzaW5nbGVQbGFjZW1lbnRzKSB7XG4gICAgICAgIGFsbFNlZ3MucHVzaChwbGFjZW1lbnQuc2VnKTtcbiAgICAgICAgaWYgKCFwbGFjZW1lbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBpbnZpc2libGVTZWdzLnB1c2gocGxhY2VtZW50LnNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYWxsU2VncywgaW52aXNpYmxlU2VncyB9O1xufVxuXG5jb25zdCBERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICduYXJyb3cnIH0pO1xuY2xhc3MgVGFibGVDZWxsIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkYXlOdW1iZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb290RWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHNldFJlZih0aGlzLnJvb3RFbFJlZiwgZWwpO1xuICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcywgc3RhdGUsIHJvb3RFbFJlZiB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgZGF0ZUVudiB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHsgZGF0ZSwgZGF0ZVByb2ZpbGUgfSA9IHByb3BzO1xuICAgICAgICAvLyBUT0RPOiBtZW1vaXplIHRoaXM/XG4gICAgICAgIGNvbnN0IGlzTW9udGhTdGFydCA9IHByb3BzLnNob3dEYXlOdW1iZXIgJiZcbiAgICAgICAgICAgIHNob3VsZERpc3BsYXlNb250aFN0YXJ0KGRhdGUsIGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgZGF0ZUVudik7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChEYXlDZWxsQ29udGFpbmVyLCB7IGVsVGFnOiBcInRkXCIsIGVsUmVmOiB0aGlzLmhhbmRsZVJvb3RFbCwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgJ2ZjLWRheWdyaWQtZGF5JyxcbiAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKSxcbiAgICAgICAgICAgIF0sIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5leHRyYURhdGFBdHRycyksIChwcm9wcy5zaG93RGF5TnVtYmVyID8geyAnYXJpYS1sYWJlbGxlZGJ5Jzogc3RhdGUuZGF5TnVtYmVySWQgfSA6IHt9KSksIHsgcm9sZTogJ2dyaWRjZWxsJyB9KSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVyVG9wSW5uZXIsIGRhdGU6IGRhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlciwgaXNNb250aFN0YXJ0OiBpc01vbnRoU3RhcnQsIGV4dHJhUmVuZGVyUHJvcHM6IHByb3BzLmV4dHJhUmVuZGVyUHJvcHMgfSwgKElubmVyQ29udGVudCwgcmVuZGVyUHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBwcm9wcy5pbm5lckVsUmVmLCBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktZnJhbWUgZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIsIHN0eWxlOiB7IG1pbkhlaWdodDogcHJvcHMubWluSGVpZ2h0IH0gfSxcbiAgICAgICAgICAgIHByb3BzLnNob3dXZWVrTnVtYmVyICYmIChjcmVhdGVFbGVtZW50KFdlZWtOdW1iZXJDb250YWluZXIsIHsgZWxUYWc6IFwiYVwiLCBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZC13ZWVrLW51bWJlciddLCBlbEF0dHJzOiBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlLCAnd2VlaycpLCBkYXRlOiBkYXRlLCBkZWZhdWx0Rm9ybWF0OiBERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCB9KSksXG4gICAgICAgICAgICAhcmVuZGVyUHJvcHMuaXNEaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgIChwcm9wcy5zaG93RGF5TnVtYmVyIHx8IGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpIHx8IHByb3BzLmZvcmNlRGF5VG9wKSA/IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LXRvcFwiIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiYVwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1kYXlncmlkLWRheS1udW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNNb250aFN0YXJ0ICYmICdmYy1kYXlncmlkLW1vbnRoLXN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlKSksIHsgaWQ6IHN0YXRlLmRheU51bWJlcklkIH0pIH0pKSkgOiBwcm9wcy5zaG93RGF5TnVtYmVyID8gKFxuICAgICAgICAgICAgLy8gZm9yIGNyZWF0aW5nIGNvcnJlY3QgYW1vdW50IG9mIHNwYWNlIChzZWUgaXNzdWUgIzcxNjIpXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LXRvcFwiLCBzdHlsZTogeyB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9IH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImFcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktbnVtYmVyXCIgfSwgXCJcXHUwMEEwXCIpKSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWV2ZW50c1wiLCByZWY6IHByb3BzLmZnQ29udGVudEVsUmVmIH0sXG4gICAgICAgICAgICAgICAgcHJvcHMuZmdDb250ZW50LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktYm90dG9tXCIsIHN0eWxlOiB7IG1hcmdpblRvcDogcHJvcHMubW9yZU1hcmdpblRvcCB9IH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGFibGVDZWxsTW9yZUxpbmssIHsgYWxsRGF5RGF0ZTogZGF0ZSwgc2luZ2xlUGxhY2VtZW50czogcHJvcHMuc2luZ2xlUGxhY2VtZW50cywgbW9yZUNudDogcHJvcHMubW9yZUNudCwgYWxpZ25tZW50RWxSZWY6IHJvb3RFbFJlZiwgYWxpZ25HcmlkVG9wOiAhcHJvcHMuc2hvd0RheU51bWJlciwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UgfSkpKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktYmdcIiB9LCBwcm9wcy5iZ0NvbnRlbnQpKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJUb3BJbm5lcihwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5kYXlOdW1iZXJUZXh0IHx8IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFwiXFx1MDBBMFwiKTtcbn1cbmZ1bmN0aW9uIHNob3VsZERpc3BsYXlNb250aFN0YXJ0KGRhdGUsIGN1cnJlbnRSYW5nZSwgZGF0ZUVudikge1xuICAgIGNvbnN0IHsgc3RhcnQ6IGN1cnJlbnRTdGFydCwgZW5kOiBjdXJyZW50RW5kIH0gPSBjdXJyZW50UmFuZ2U7XG4gICAgY29uc3QgY3VycmVudEVuZEluY2wgPSBhZGRNcyhjdXJyZW50RW5kLCAtMSk7XG4gICAgY29uc3QgY3VycmVudEZpcnN0WWVhciA9IGRhdGVFbnYuZ2V0WWVhcihjdXJyZW50U3RhcnQpO1xuICAgIGNvbnN0IGN1cnJlbnRGaXJzdE1vbnRoID0gZGF0ZUVudi5nZXRNb250aChjdXJyZW50U3RhcnQpO1xuICAgIGNvbnN0IGN1cnJlbnRMYXN0WWVhciA9IGRhdGVFbnYuZ2V0WWVhcihjdXJyZW50RW5kSW5jbCk7XG4gICAgY29uc3QgY3VycmVudExhc3RNb250aCA9IGRhdGVFbnYuZ2V0TW9udGgoY3VycmVudEVuZEluY2wpO1xuICAgIC8vIHNwYW5zIG1vcmUgdGhhbiBvbmUgbW9udGg/XG4gICAgcmV0dXJuICEoY3VycmVudEZpcnN0WWVhciA9PT0gY3VycmVudExhc3RZZWFyICYmIGN1cnJlbnRGaXJzdE1vbnRoID09PSBjdXJyZW50TGFzdE1vbnRoKSAmJlxuICAgICAgICBCb29sZWFuKFxuICAgICAgICAvLyBmaXJzdCBkYXRlIGluIGN1cnJlbnQgdmlldz9cbiAgICAgICAgZGF0ZS52YWx1ZU9mKCkgPT09IGN1cnJlbnRTdGFydC52YWx1ZU9mKCkgfHxcbiAgICAgICAgICAgIC8vIGEgbW9udGgtc3RhcnQgdGhhdCdzIHdpdGhpbiB0aGUgY3VycmVudCByYW5nZT9cbiAgICAgICAgICAgIChkYXRlRW52LmdldERheShkYXRlKSA9PT0gMSAmJiBkYXRlLnZhbHVlT2YoKSA8IGN1cnJlbnRFbmQudmFsdWVPZigpKSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2VnS2V5KHNlZykge1xuICAgIHJldHVybiBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkICsgJzonICsgc2VnLmZpcnN0Q29sO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVTZWdVaWQoc2VnKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlU2VnS2V5KHNlZykgKyAnOicgKyBzZWcubGFzdENvbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGZ1NlZ1BsYWNlbWVudChzZWdzLCAvLyBhc3N1bWVkIGFscmVhZHkgc29ydGVkXG5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93cywgc3RyaWN0T3JkZXIsIHNlZ0hlaWdodHMsIG1heENvbnRlbnRIZWlnaHQsIGNlbGxzKSB7XG4gICAgbGV0IGhpZXJhcmNoeSA9IG5ldyBEYXlHcmlkU2VnSGllcmFyY2h5KChzZWdFbnRyeSkgPT4ge1xuICAgICAgICAvLyBUT0RPOiBtb3JlIERSWSB3aXRoIGdlbmVyYXRlU2VnVWlkXG4gICAgICAgIGxldCBzZWdVaWQgPSBzZWdzW3NlZ0VudHJ5LmluZGV4XS5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQgK1xuICAgICAgICAgICAgJzonICsgc2VnRW50cnkuc3Bhbi5zdGFydCArXG4gICAgICAgICAgICAnOicgKyAoc2VnRW50cnkuc3Bhbi5lbmQgLSAxKTtcbiAgICAgICAgLy8gaWYgbm8gdGhpY2tuZXNzIGtub3duLCBhc3N1bWUgMSAoaWYgMCwgc28gc21hbGwgaXQgYWx3YXlzIGZpdHMpXG4gICAgICAgIHJldHVybiBzZWdIZWlnaHRzW3NlZ1VpZF0gfHwgMTtcbiAgICB9KTtcbiAgICBoaWVyYXJjaHkuYWxsb3dSZXNsaWNpbmcgPSB0cnVlO1xuICAgIGhpZXJhcmNoeS5zdHJpY3RPcmRlciA9IHN0cmljdE9yZGVyO1xuICAgIGlmIChkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhDb29yZCA9IG1heENvbnRlbnRIZWlnaHQ7XG4gICAgICAgIGhpZXJhcmNoeS5oaWRkZW5Db25zdW1lcyA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXlNYXhFdmVudHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IGRheU1heEV2ZW50cztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRheU1heEV2ZW50Um93cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaGllcmFyY2h5Lm1heFN0YWNrQ250ID0gZGF5TWF4RXZlbnRSb3dzO1xuICAgICAgICBoaWVyYXJjaHkuaGlkZGVuQ29uc3VtZXMgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgc2VnSW5wdXRzIG9ubHkgZm9yIHNlZ3Mgd2l0aCBrbm93biBoZWlnaHRzXG4gICAgbGV0IHNlZ0lucHV0cyA9IFtdO1xuICAgIGxldCB1bmtub3duSGVpZ2h0U2VncyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgbGV0IHNlZ1VpZCA9IGdlbmVyYXRlU2VnVWlkKHNlZyk7XG4gICAgICAgIGxldCBldmVudEhlaWdodCA9IHNlZ0hlaWdodHNbc2VnVWlkXTtcbiAgICAgICAgaWYgKGV2ZW50SGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNlZ0lucHV0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICBzcGFuOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWcuZmlyc3RDb2wsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogc2VnLmxhc3RDb2wgKyAxLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVua25vd25IZWlnaHRTZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgaGlkZGVuRW50cmllcyA9IGhpZXJhcmNoeS5hZGRTZWdzKHNlZ0lucHV0cyk7XG4gICAgbGV0IHNlZ1JlY3RzID0gaGllcmFyY2h5LnRvUmVjdHMoKTtcbiAgICBsZXQgeyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIGxlZnRvdmVyTWFyZ2lucyB9ID0gcGxhY2VSZWN0cyhzZWdSZWN0cywgc2VncywgY2VsbHMpO1xuICAgIGxldCBtb3JlQ250cyA9IFtdO1xuICAgIGxldCBtb3JlTWFyZ2luVG9wcyA9IFtdO1xuICAgIC8vIGFkZCBzZWdzIHdpdGggdW5rbm93biBoZWlnaHRzXG4gICAgZm9yIChsZXQgc2VnIG9mIHVua25vd25IZWlnaHRTZWdzKSB7XG4gICAgICAgIG11bHRpQ29sUGxhY2VtZW50c1tzZWcuZmlyc3RDb2xdLnB1c2goe1xuICAgICAgICAgICAgc2VnLFxuICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IHNlZy5maXJzdENvbDsgY29sIDw9IHNlZy5sYXN0Q29sOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIHRoZSBoaWRkZW4gZW50cmllc1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgbW9yZUNudHMucHVzaCgwKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaGlkZGVuRW50cnkgb2YgaGlkZGVuRW50cmllcykge1xuICAgICAgICBsZXQgc2VnID0gc2Vnc1toaWRkZW5FbnRyeS5pbmRleF07XG4gICAgICAgIGxldCBoaWRkZW5TcGFuID0gaGlkZGVuRW50cnkuc3BhbjtcbiAgICAgICAgbXVsdGlDb2xQbGFjZW1lbnRzW2hpZGRlblNwYW4uc3RhcnRdLnB1c2goe1xuICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgaGlkZGVuU3Bhbi5zdGFydCwgaGlkZGVuU3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSBoaWRkZW5TcGFuLnN0YXJ0OyBjb2wgPCBoaWRkZW5TcGFuLmVuZDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIG1vcmVDbnRzW2NvbF0gKz0gMTtcbiAgICAgICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRlYWwgd2l0aCBsZWZ0b3ZlciBtYXJnaW5zXG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICBtb3JlTWFyZ2luVG9wcy5wdXNoKGxlZnRvdmVyTWFyZ2luc1tjb2xdKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBtb3JlQ250cywgbW9yZU1hcmdpblRvcHMgfTtcbn1cbi8vIHJlY3RzIG9yZGVyZWQgYnkgdG9wIGNvb3JkLCB0aGVuIGxlZnRcbmZ1bmN0aW9uIHBsYWNlUmVjdHMoYWxsUmVjdHMsIHNlZ3MsIGNlbGxzKSB7XG4gICAgbGV0IHJlY3RzQnlFYWNoQ29sID0gZ3JvdXBSZWN0c0J5RWFjaENvbChhbGxSZWN0cywgY2VsbHMubGVuZ3RoKTtcbiAgICBsZXQgc2luZ2xlQ29sUGxhY2VtZW50cyA9IFtdO1xuICAgIGxldCBtdWx0aUNvbFBsYWNlbWVudHMgPSBbXTtcbiAgICBsZXQgbGVmdG92ZXJNYXJnaW5zID0gW107XG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICBsZXQgcmVjdHMgPSByZWN0c0J5RWFjaENvbFtjb2xdO1xuICAgICAgICAvLyBjb21wdXRlIGFsbCBzdGF0aWMgc2VncyBpbiBzaW5nbGVQbGFjZW1lbnRzXG4gICAgICAgIGxldCBzaW5nbGVQbGFjZW1lbnRzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xuICAgICAgICBmb3IgKGxldCByZWN0IG9mIHJlY3RzKSB7XG4gICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tyZWN0LmluZGV4XTtcbiAgICAgICAgICAgIHNpbmdsZVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiByZWN0LmxldmVsQ29vcmQgLSBjdXJyZW50SGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50SGVpZ2h0ID0gcmVjdC5sZXZlbENvb3JkICsgcmVjdC50aGlja25lc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcHV0ZSBtaXhlZCBzdGF0aWMvYWJzb2x1dGUgc2VncyBpbiBtdWx0aVBsYWNlbWVudHNcbiAgICAgICAgbGV0IG11bHRpUGxhY2VtZW50cyA9IFtdO1xuICAgICAgICBjdXJyZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgY3VycmVudE1hcmdpblRvcCA9IDA7XG4gICAgICAgIGZvciAobGV0IHJlY3Qgb2YgcmVjdHMpIHtcbiAgICAgICAgICAgIGxldCBzZWcgPSBzZWdzW3JlY3QuaW5kZXhdO1xuICAgICAgICAgICAgbGV0IGlzQWJzb2x1dGUgPSByZWN0LnNwYW4uZW5kIC0gcmVjdC5zcGFuLnN0YXJ0ID4gMTsgLy8gbXVsdGktY29sdW1uP1xuICAgICAgICAgICAgbGV0IGlzRmlyc3RDb2wgPSByZWN0LnNwYW4uc3RhcnQgPT09IGNvbDtcbiAgICAgICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgKz0gcmVjdC5sZXZlbENvb3JkIC0gY3VycmVudEhlaWdodDsgLy8gYW1vdW50IG9mIHNwYWNlIHNpbmNlIGJvdHRvbSBvZiBwcmV2aW91cyBzZWdcbiAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgPSByZWN0LmxldmVsQ29vcmQgKyByZWN0LnRoaWNrbmVzczsgLy8gaGVpZ2h0IHdpbGwgbm93IGJlIGJvdHRvbSBvZiBjdXJyZW50IHNlZ1xuICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wICs9IHJlY3QudGhpY2tuZXNzO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0Q29sKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIHJlY3Quc3Bhbi5zdGFydCwgcmVjdC5zcGFuLmVuZCwgY2VsbHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlyc3RDb2wpIHtcbiAgICAgICAgICAgICAgICBtdWx0aVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIHJlY3Quc3Bhbi5zdGFydCwgcmVjdC5zcGFuLmVuZCwgY2VsbHMpLFxuICAgICAgICAgICAgICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IGN1cnJlbnRNYXJnaW5Ub3AsIC8vIGNsYWltIHRoZSBtYXJnaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzLnB1c2goc2luZ2xlUGxhY2VtZW50cyk7XG4gICAgICAgIG11bHRpQ29sUGxhY2VtZW50cy5wdXNoKG11bHRpUGxhY2VtZW50cyk7XG4gICAgICAgIGxlZnRvdmVyTWFyZ2lucy5wdXNoKGN1cnJlbnRNYXJnaW5Ub3ApO1xuICAgIH1cbiAgICByZXR1cm4geyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIGxlZnRvdmVyTWFyZ2lucyB9O1xufVxuZnVuY3Rpb24gZ3JvdXBSZWN0c0J5RWFjaENvbChyZWN0cywgY29sQ250KSB7XG4gICAgbGV0IHJlY3RzQnlFYWNoQ29sID0gW107XG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgICByZWN0c0J5RWFjaENvbC5wdXNoKFtdKTtcbiAgICB9XG4gICAgZm9yIChsZXQgcmVjdCBvZiByZWN0cykge1xuICAgICAgICBmb3IgKGxldCBjb2wgPSByZWN0LnNwYW4uc3RhcnQ7IGNvbCA8IHJlY3Quc3Bhbi5lbmQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICByZWN0c0J5RWFjaENvbFtjb2xdLnB1c2gocmVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlY3RzQnlFYWNoQ29sO1xufVxuZnVuY3Rpb24gcmVzbGljZVNlZyhzZWcsIHNwYW5TdGFydCwgc3BhbkVuZCwgY2VsbHMpIHtcbiAgICBpZiAoc2VnLmZpcnN0Q29sID09PSBzcGFuU3RhcnQgJiYgc2VnLmxhc3RDb2wgPT09IHNwYW5FbmQgLSAxKSB7XG4gICAgICAgIHJldHVybiBzZWc7XG4gICAgfVxuICAgIGxldCBldmVudFJhbmdlID0gc2VnLmV2ZW50UmFuZ2U7XG4gICAgbGV0IG9yaWdSYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgbGV0IHNsaWNlZFJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKG9yaWdSYW5nZSwge1xuICAgICAgICBzdGFydDogY2VsbHNbc3BhblN0YXJ0XS5kYXRlLFxuICAgICAgICBlbmQ6IGFkZERheXMoY2VsbHNbc3BhbkVuZCAtIDFdLmRhdGUsIDEpLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlZyksIHsgZmlyc3RDb2w6IHNwYW5TdGFydCwgbGFzdENvbDogc3BhbkVuZCAtIDEsIGV2ZW50UmFuZ2U6IHtcbiAgICAgICAgICAgIGRlZjogZXZlbnRSYW5nZS5kZWYsXG4gICAgICAgICAgICB1aTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFJhbmdlLnVpKSwgeyBkdXJhdGlvbkVkaXRhYmxlOiBmYWxzZSB9KSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBldmVudFJhbmdlLmluc3RhbmNlLFxuICAgICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlLFxuICAgICAgICB9LCBpc1N0YXJ0OiBzZWcuaXNTdGFydCAmJiBzbGljZWRSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5zdGFydC52YWx1ZU9mKCksIGlzRW5kOiBzZWcuaXNFbmQgJiYgc2xpY2VkUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gb3JpZ1JhbmdlLmVuZC52YWx1ZU9mKCkgfSk7XG59XG5jbGFzcyBEYXlHcmlkU2VnSGllcmFyY2h5IGV4dGVuZHMgU2VnSGllcmFyY2h5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gY29uZmlnXG4gICAgICAgIHRoaXMuaGlkZGVuQ29uc3VtZXMgPSBmYWxzZTtcbiAgICAgICAgLy8gYWxsb3dzIHVzIHRvIGtlZXAgaGlkZGVuIGVudHJpZXMgaW4gdGhlIGhpZXJhcmNoeSBzbyB0aGV5IHRha2UgdXAgc3BhY2VcbiAgICAgICAgdGhpcy5mb3JjZUhpZGRlbiA9IHt9O1xuICAgIH1cbiAgICBhZGRTZWdzKHNlZ0lucHV0cykge1xuICAgICAgICBjb25zdCBoaWRkZW5TZWdzID0gc3VwZXIuYWRkU2VncyhzZWdJbnB1dHMpO1xuICAgICAgICBjb25zdCB7IGVudHJpZXNCeUxldmVsIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBleGNsdWRlSGlkZGVuID0gKGVudHJ5KSA9PiAhdGhpcy5mb3JjZUhpZGRlbltidWlsZEVudHJ5S2V5KGVudHJ5KV07XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZm9yY2VkLWhpZGRlbiBzZWdzXG4gICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCBlbnRyaWVzQnlMZXZlbC5sZW5ndGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGVudHJpZXNCeUxldmVsW2xldmVsXSA9IGVudHJpZXNCeUxldmVsW2xldmVsXS5maWx0ZXIoZXhjbHVkZUhpZGRlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZGRlblNlZ3M7XG4gICAgfVxuICAgIGhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcykge1xuICAgICAgICBjb25zdCB7IGVudHJpZXNCeUxldmVsLCBmb3JjZUhpZGRlbiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB0b3VjaGluZ0VudHJ5LCB0b3VjaGluZ0xldmVsLCB0b3VjaGluZ0xhdGVyYWwgfSA9IGluc2VydGlvbjtcbiAgICAgICAgLy8gdGhlIGVudHJ5IHRoYXQgdGhlIG5ldyBpbnNlcnRpb24gaXMgdG91Y2hpbmcgbXVzdCBiZSBoaWRkZW5cbiAgICAgICAgaWYgKHRoaXMuaGlkZGVuQ29uc3VtZXMgJiYgdG91Y2hpbmdFbnRyeSkge1xuICAgICAgICAgICAgY29uc3QgdG91Y2hpbmdFbnRyeUlkID0gYnVpbGRFbnRyeUtleSh0b3VjaGluZ0VudHJ5KTtcbiAgICAgICAgICAgIGlmICghZm9yY2VIaWRkZW5bdG91Y2hpbmdFbnRyeUlkXSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsbG93UmVzbGljaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IHVwIHRoZSB0b3VjaGluZ0VudHJ5LCByZWluc2VydCBpdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoaWRkZW5FbnRyeSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdG91Y2hpbmdFbnRyeSksIHsgc3BhbjogaW50ZXJzZWN0U3BhbnModG91Y2hpbmdFbnRyeS5zcGFuLCBlbnRyeS5zcGFuKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVpbnNlcnQgdGhlIGFyZWEgdGhhdCB0dXJuZWQgaW50byBhIFwibW9yZVwiIGxpbmsgKHNvIG5vIG90aGVyIGVudHJpZXMgdHJ5IHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIG9jY3VweSB0aGUgc3BhY2UpIGJ1dCBtYXJrIGl0IGZvcmNlZC1oaWRkZW5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGlkZGVuRW50cnlJZCA9IGJ1aWxkRW50cnlLZXkoaGlkZGVuRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICBmb3JjZUhpZGRlbltoaWRkZW5FbnRyeUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXNCeUxldmVsW3RvdWNoaW5nTGV2ZWxdW3RvdWNoaW5nTGF0ZXJhbF0gPSBoaWRkZW5FbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGhpZGRlbkVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdEVudHJ5KHRvdWNoaW5nRW50cnksIGVudHJ5LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuW3RvdWNoaW5nRW50cnlJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2godG91Y2hpbmdFbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHdpbGwgdHJ5IHRvIHJlc2xpY2UuLi5cbiAgICAgICAgc3VwZXIuaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKTtcbiAgICB9XG59XG5cbmNsYXNzIFRhYmxlUm93IGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY2VsbEVsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIDx0ZD5cbiAgICAgICAgdGhpcy5mcmFtZUVsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIGZjLWRheWdyaWQtZGF5LWZyYW1lXG4gICAgICAgIHRoaXMuZmdFbFJlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIHRoZSBmYy1kYXlncmlkLWRheS1ldmVudHNcbiAgICAgICAgdGhpcy5zZWdIYXJuZXNzUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gaW5kZXhlZCBieSBcImluc3RhbmNlSWQ6Zmlyc3RDb2xcIlxuICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZnJhbWVQb3NpdGlvbnM6IG51bGwsXG4gICAgICAgICAgICBtYXhDb250ZW50SGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgc2VnSGVpZ2h0czoge30sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzaXplID0gKGlzRm9yY2VkKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNGb3JjZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemluZyh0cnVlKTsgLy8gaXNFeHRlcm5hbD10cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgY29sQ250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xuICAgICAgICBsZXQgYnVzaW5lc3NIb3Vyc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbChwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgYmdFdmVudFNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wocHJvcHMuYmdFdmVudFNlZ3MsIGNvbENudCk7XG4gICAgICAgIGxldCBoaWdobGlnaHRTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHRoaXMuZ2V0SGlnaGxpZ2h0U2VncygpLCBjb2xDbnQpO1xuICAgICAgICBsZXQgbWlycm9yU2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbCh0aGlzLmdldE1pcnJvclNlZ3MoKSwgY29sQ250KTtcbiAgICAgICAgbGV0IHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBtb3JlQ250cywgbW9yZU1hcmdpblRvcHMgfSA9IGNvbXB1dGVGZ1NlZ1BsYWNlbWVudChzb3J0RXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCBvcHRpb25zLmV2ZW50T3JkZXIpLCBwcm9wcy5kYXlNYXhFdmVudHMsIHByb3BzLmRheU1heEV2ZW50Um93cywgb3B0aW9ucy5ldmVudE9yZGVyU3RyaWN0LCBzdGF0ZS5zZWdIZWlnaHRzLCBzdGF0ZS5tYXhDb250ZW50SGVpZ2h0LCBwcm9wcy5jZWxscyk7XG4gICAgICAgIGxldCBpc0ZvcmNlZEludmlzaWJsZSA9IC8vIFRPRE86IG1lc3N5IHdheSB0byBjb21wdXRlIHRoaXNcbiAgICAgICAgIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAge307XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgcm9sZTogXCJyb3dcIiB9LFxuICAgICAgICAgICAgcHJvcHMucmVuZGVySW50cm8gJiYgcHJvcHMucmVuZGVySW50cm8oKSxcbiAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcCgoY2VsbCwgY29sKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5vcm1hbEZnTm9kZXMgPSB0aGlzLnJlbmRlckZnU2Vncyhjb2wsIHByb3BzLmZvclByaW50ID8gc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdIDogbXVsdGlDb2xQbGFjZW1lbnRzW2NvbF0sIHByb3BzLnRvZGF5UmFuZ2UsIGlzRm9yY2VkSW52aXNpYmxlKTtcbiAgICAgICAgICAgICAgICBsZXQgbWlycm9yRmdOb2RlcyA9IHRoaXMucmVuZGVyRmdTZWdzKGNvbCwgYnVpbGRNaXJyb3JQbGFjZW1lbnRzKG1pcnJvclNlZ3NCeUNvbFtjb2xdLCBtdWx0aUNvbFBsYWNlbWVudHMpLCBwcm9wcy50b2RheVJhbmdlLCB7fSwgQm9vbGVhbihwcm9wcy5ldmVudERyYWcpLCBCb29sZWFuKHByb3BzLmV2ZW50UmVzaXplKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChUYWJsZUNlbGwsIHsga2V5OiBjZWxsLmtleSwgZWxSZWY6IHRoaXMuY2VsbEVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBpbm5lckVsUmVmOiB0aGlzLmZyYW1lRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSkgLyogRkYgPHRkPiBwcm9ibGVtLCBidXQgb2theSB0byB1c2UgZm9yIGxlZnQvcmlnaHQuIFRPRE86IHJlbmFtZSBwcm9wICovLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGU6IGNlbGwuZGF0ZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcnMsIHNob3dXZWVrTnVtYmVyOiBwcm9wcy5zaG93V2Vla051bWJlcnMgJiYgY29sID09PSAwLCBmb3JjZURheVRvcDogcHJvcHMuc2hvd1dlZWtOdW1iZXJzIC8qIGV2ZW4gZGlzcGxheWluZyB3ZWVrbnVtIGZvciByb3csIG5vdCBuZWNlc3NhcmlseSBkYXkgKi8sIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgZXh0cmFSZW5kZXJQcm9wczogY2VsbC5leHRyYVJlbmRlclByb3BzLCBleHRyYURhdGFBdHRyczogY2VsbC5leHRyYURhdGFBdHRycywgZXh0cmFDbGFzc05hbWVzOiBjZWxsLmV4dHJhQ2xhc3NOYW1lcywgZXh0cmFEYXRlU3BhbjogY2VsbC5leHRyYURhdGVTcGFuLCBtb3JlQ250OiBtb3JlQ250c1tjb2xdLCBtb3JlTWFyZ2luVG9wOiBtb3JlTWFyZ2luVG9wc1tjb2xdLCBzaW5nbGVQbGFjZW1lbnRzOiBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0sIGZnQ29udGVudEVsUmVmOiB0aGlzLmZnRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSksIGZnQ29udGVudDogKCAvLyBGcmFnbWVudCBzY29wZXMgdGhlIGtleXNcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIG5vcm1hbEZnTm9kZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgbWlycm9yRmdOb2RlcykpKSwgYmdDb250ZW50OiAoIC8vIEZyYWdtZW50IHNjb3BlcyB0aGUga2V5c1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2VncyhoaWdobGlnaHRTZWdzQnlDb2xbY29sXSwgJ2hpZ2hsaWdodCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2VncyhidXNpbmVzc0hvdXJzQnlDb2xbY29sXSwgJ25vbi1idXNpbmVzcycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2VncyhiZ0V2ZW50U2Vnc0J5Q29sW2NvbF0sICdiZy1ldmVudCcpKSksIG1pbkhlaWdodDogcHJvcHMuY2VsbE1pbkhlaWdodCB9KSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcodHJ1ZSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIGxldCBjdXJyZW50UHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemluZyghaXNQcm9wc0VxdWFsKHByZXZQcm9wcywgY3VycmVudFByb3BzKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmNvbnRleHQucmVtb3ZlUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfVxuICAgIGdldEhpZ2hsaWdodFNlZ3MoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50RHJhZy5zZWdzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50UmVzaXplLnNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzO1xuICAgIH1cbiAgICBnZXRNaXJyb3JTZWdzKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnRSZXNpemUuc2VncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJlbmRlckZnU2Vncyhjb2wsIHNlZ1BsYWNlbWVudHMsIHRvZGF5UmFuZ2UsIGlzRm9yY2VkSW52aXNpYmxlLCBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3RpbmcpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZXZlbnRTZWxlY3Rpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IGZyYW1lUG9zaXRpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgZGVmYXVsdERpc3BsYXlFdmVudEVuZCA9IHRoaXMucHJvcHMuY2VsbHMubGVuZ3RoID09PSAxOyAvLyBjb2xDbnQgPT09IDFcbiAgICAgICAgbGV0IGlzTWlycm9yID0gaXNEcmFnZ2luZyB8fCBpc1Jlc2l6aW5nIHx8IGlzRGF0ZVNlbGVjdGluZztcbiAgICAgICAgbGV0IG5vZGVzID0gW107XG4gICAgICAgIGlmIChmcmFtZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgZm9yIChsZXQgcGxhY2VtZW50IG9mIHNlZ1BsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBzZWcgfSA9IHBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICBsZXQgeyBpbnN0YW5jZUlkIH0gPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBsZXQgaXNWaXNpYmxlID0gcGxhY2VtZW50LmlzVmlzaWJsZSAmJiAhaXNGb3JjZWRJbnZpc2libGVbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgbGV0IGlzQWJzb2x1dGUgPSBwbGFjZW1lbnQuaXNBYnNvbHV0ZTtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9ICcnO1xuICAgICAgICAgICAgICAgIGxldCByaWdodCA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmlzUnRsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmxhc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmZpcnN0Q29sXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmZpcnN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcubGFzdENvbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBrbm93biBidWc6IGV2ZW50cyB0aGF0IGFyZSBmb3JjZSB0byBiZSBsaXN0LWl0ZW0gYnV0IHNwYW4gbXVsdGlwbGUgZGF5cyBzdGlsbCB0YWtlIHVwIHNwYWNlIGluIGxhdGVyIGNvbHVtbnNcbiAgICAgICAgICAgICAgICB0b2RvOiBpbiBwcmludCB2aWV3LCBmb3IgbXVsdGktZGF5IGV2ZW50cywgZG9uJ3QgZGlzcGxheSB0aXRsZSB3aXRoaW4gbm9uLXN0YXJ0L2VuZCBzZWdzXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3MnICsgKGlzQWJzb2x1dGUgPyAnIGZjLWRheWdyaWQtZXZlbnQtaGFybmVzcy1hYnMnIDogJycpLCBrZXk6IGdlbmVyYXRlU2VnS2V5KHNlZyksIHJlZjogaXNNaXJyb3IgPyBudWxsIDogdGhpcy5zZWdIYXJuZXNzUmVmcy5jcmVhdGVSZWYoZ2VuZXJhdGVTZWdVaWQoc2VnKSksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBpc0Fic29sdXRlID8gJycgOiBwbGFjZW1lbnQubWFyZ2luVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBpc0Fic29sdXRlID8gcGxhY2VtZW50LmFic29sdXRlVG9wIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH0gfSwgaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykgPyAoY3JlYXRlRWxlbWVudChUYWJsZUxpc3RJdGVtRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkpIDogKGNyZWF0ZUVsZW1lbnQoVGFibGVCbG9ja0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsIGlzUmVzaXppbmc6IGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZzogaXNEYXRlU2VsZWN0aW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZGVmYXVsdERpc3BsYXlFdmVudEVuZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHJlbmRlckZpbGxTZWdzKHNlZ3MsIGZpbGxUeXBlKSB7XG4gICAgICAgIGxldCB7IGlzUnRsIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IHRvZGF5UmFuZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IGZyYW1lUG9zaXRpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICAgICAgaWYgKGZyYW1lUG9zaXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0UmlnaHRDc3MgPSBpc1J0bCA/IHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5sYXN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5maXJzdENvbF0sXG4gICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcuZmlyc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5sYXN0Q29sXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogYnVpbGRFdmVudFJhbmdlS2V5KHNlZy5ldmVudFJhbmdlKSwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtYmctaGFybmVzc1wiLCBzdHlsZTogbGVmdFJpZ2h0Q3NzIH0sIGZpbGxUeXBlID09PSAnYmctZXZlbnQnID9cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChCZ0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkgOlxuICAgICAgICAgICAgICAgICAgICByZW5kZXJGaWxsKGZpbGxUeXBlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgLi4ubm9kZXMpO1xuICAgIH1cbiAgICB1cGRhdGVTaXppbmcoaXNFeHRlcm5hbFNpemluZ0NoYW5nZSkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGZyYW1lRWxSZWZzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXByb3BzLmZvclByaW50ICYmXG4gICAgICAgICAgICBwcm9wcy5jbGllbnRXaWR0aCAhPT0gbnVsbCAvLyBwb3NpdGlvbmluZyByZWFkeT9cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoaXNFeHRlcm5hbFNpemluZ0NoYW5nZSkge1xuICAgICAgICAgICAgICAgIGxldCBmcmFtZUVscyA9IHByb3BzLmNlbGxzLm1hcCgoY2VsbCkgPT4gZnJhbWVFbFJlZnMuY3VycmVudE1hcFtjZWxsLmtleV0pO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZUVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWdpbkVsID0gdGhpcy5yb290RWxSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1Bvc2l0aW9uQ2FjaGUgPSBuZXcgUG9zaXRpb25DYWNoZShvcmlnaW5FbCwgZnJhbWVFbHMsIHRydWUsIC8vIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuZnJhbWVQb3NpdGlvbnMgfHwgIXN0YXRlLmZyYW1lUG9zaXRpb25zLnNpbWlsYXJUbyhuZXdQb3NpdGlvbkNhY2hlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVQb3NpdGlvbnM6IG5ldyBQb3NpdGlvbkNhY2hlKG9yaWdpbkVsLCBmcmFtZUVscywgdHJ1ZSwgLy8gaXNIb3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvbGRTZWdIZWlnaHRzID0gdGhpcy5zdGF0ZS5zZWdIZWlnaHRzO1xuICAgICAgICAgICAgY29uc3QgbmV3U2VnSGVpZ2h0cyA9IHRoaXMucXVlcnlTZWdIZWlnaHRzKCk7XG4gICAgICAgICAgICBjb25zdCBsaW1pdEJ5Q29udGVudEhlaWdodCA9IHByb3BzLmRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBwcm9wcy5kYXlNYXhFdmVudFJvd3MgPT09IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgLy8gSEFDSyB0byBwcmV2ZW50IG9zY2lsbGF0aW9ucyBvZiBldmVudHMgYmVpbmcgc2hvd24vaGlkZGVuIGZyb20gbWF4LWV2ZW50LXJvd3NcbiAgICAgICAgICAgICAgICAvLyBFc3NlbnRpYWxseSwgb25jZSB5b3UgY29tcHV0ZSBhbiBlbGVtZW50J3MgaGVpZ2h0LCBuZXZlciBudWxsLW91dC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhbHdheXMgZGlzcGxheSBhbGwgZXZlbnRzLCBhcyB2aXNpYmlsaXR5OmhpZGRlbj9cbiAgICAgICAgICAgICAgICBzZWdIZWlnaHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9sZFNlZ0hlaWdodHMpLCBuZXdTZWdIZWlnaHRzKSxcbiAgICAgICAgICAgICAgICBtYXhDb250ZW50SGVpZ2h0OiBsaW1pdEJ5Q29udGVudEhlaWdodCA/IHRoaXMuY29tcHV0ZU1heENvbnRlbnRIZWlnaHQoKSA6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWVyeVNlZ0hlaWdodHMoKSB7XG4gICAgICAgIGxldCBzZWdFbE1hcCA9IHRoaXMuc2VnSGFybmVzc1JlZnMuY3VycmVudE1hcDtcbiAgICAgICAgbGV0IHNlZ0hlaWdodHMgPSB7fTtcbiAgICAgICAgLy8gZ2V0IHRoZSBtYXggaGVpZ2h0IGFtb25nc3QgaW5zdGFuY2Ugc2Vnc1xuICAgICAgICBmb3IgKGxldCBzZWdVaWQgaW4gc2VnRWxNYXApIHtcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBNYXRoLnJvdW5kKHNlZ0VsTWFwW3NlZ1VpZF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcbiAgICAgICAgICAgIHNlZ0hlaWdodHNbc2VnVWlkXSA9IE1hdGgubWF4KHNlZ0hlaWdodHNbc2VnVWlkXSB8fCAwLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdIZWlnaHRzO1xuICAgIH1cbiAgICBjb21wdXRlTWF4Q29udGVudEhlaWdodCgpIHtcbiAgICAgICAgbGV0IGZpcnN0S2V5ID0gdGhpcy5wcm9wcy5jZWxsc1swXS5rZXk7XG4gICAgICAgIGxldCBjZWxsRWwgPSB0aGlzLmNlbGxFbFJlZnMuY3VycmVudE1hcFtmaXJzdEtleV07XG4gICAgICAgIGxldCBmY0NvbnRhaW5lckVsID0gdGhpcy5mZ0VsUmVmcy5jdXJyZW50TWFwW2ZpcnN0S2V5XTtcbiAgICAgICAgcmV0dXJuIGNlbGxFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLSBmY0NvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICB9XG4gICAgZ2V0Q2VsbEVscygpIHtcbiAgICAgICAgbGV0IGVsTWFwID0gdGhpcy5jZWxsRWxSZWZzLmN1cnJlbnRNYXA7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNlbGxzLm1hcCgoY2VsbCkgPT4gZWxNYXBbY2VsbC5rZXldKTtcbiAgICB9XG59XG5UYWJsZVJvdy5hZGRTdGF0ZUVxdWFsaXR5KHtcbiAgICBzZWdIZWlnaHRzOiBpc1Byb3BzRXF1YWwsXG59KTtcbmZ1bmN0aW9uIGJ1aWxkTWlycm9yUGxhY2VtZW50cyhtaXJyb3JTZWdzLCBjb2xQbGFjZW1lbnRzKSB7XG4gICAgaWYgKCFtaXJyb3JTZWdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCB0b3BzQnlJbnN0YW5jZUlkID0gYnVpbGRBYnNvbHV0ZVRvcEhhc2goY29sUGxhY2VtZW50cyk7IC8vIFRPRE86IGNhY2hlIHRoaXMgYXQgZmlyc3QgcmVuZGVyP1xuICAgIHJldHVybiBtaXJyb3JTZWdzLm1hcCgoc2VnKSA9PiAoe1xuICAgICAgICBzZWcsXG4gICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgYWJzb2x1dGVUb3A6IHRvcHNCeUluc3RhbmNlSWRbc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZF0sXG4gICAgICAgIG1hcmdpblRvcDogMCxcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBidWlsZEFic29sdXRlVG9wSGFzaChjb2xQbGFjZW1lbnRzKSB7XG4gICAgbGV0IHRvcHNCeUluc3RhbmNlSWQgPSB7fTtcbiAgICBmb3IgKGxldCBwbGFjZW1lbnRzIG9mIGNvbFBsYWNlbWVudHMpIHtcbiAgICAgICAgZm9yIChsZXQgcGxhY2VtZW50IG9mIHBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgIHRvcHNCeUluc3RhbmNlSWRbcGxhY2VtZW50LnNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRdID0gcGxhY2VtZW50LmFic29sdXRlVG9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3BzQnlJbnN0YW5jZUlkO1xufVxuXG5jbGFzcyBUYWJsZVJvd3MgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgdGhpcy5zcGxpdEJnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIHRoaXMuc3BsaXRGZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50RHJhZyA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Um93KTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50UmVzaXplID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlSb3cpO1xuICAgICAgICB0aGlzLnJvd1JlZnMgPSBuZXcgUmVmTWFwKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCByb3dDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XG4gICAgICAgIGxldCBidXNpbmVzc0hvdXJTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCByb3dDbnQpO1xuICAgICAgICBsZXQgYmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCZ0V2ZW50U2Vncyhwcm9wcy5iZ0V2ZW50U2Vncywgcm93Q250KTtcbiAgICAgICAgbGV0IGZnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0RmdFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIHJvd0NudCk7XG4gICAgICAgIGxldCBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93ID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCByb3dDbnQpO1xuICAgICAgICBsZXQgZXZlbnREcmFnQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZywgcm93Q250KTtcbiAgICAgICAgbGV0IGV2ZW50UmVzaXplQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUsIHJvd0NudCk7XG4gICAgICAgIC8vIGZvciBEYXlHcmlkIHZpZXcgd2l0aCBtYW55IHJvd3MsIGZvcmNlIGEgbWluLWhlaWdodCBvbiBjZWxscyBzbyBkb2Vzbid0IGFwcGVhciBzcXVpc2hlZFxuICAgICAgICAvLyBjaG9vc2UgNyBiZWNhdXNlIGEgbW9udGggdmlldyB3aWxsIGhhdmUgbWF4IDYgcm93c1xuICAgICAgICBsZXQgY2VsbE1pbkhlaWdodCA9IChyb3dDbnQgPj0gNyAmJiBwcm9wcy5jbGllbnRXaWR0aCkgP1xuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggLyBjb250ZXh0Lm9wdGlvbnMuYXNwZWN0UmF0aW8gLyA2IDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChOb3dUaW1lciwgeyB1bml0OiBcImRheVwiIH0sIChub3dEYXRlLCB0b2RheVJhbmdlKSA9PiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgcHJvcHMuY2VsbHMubWFwKChjZWxscywgcm93KSA9PiAoY3JlYXRlRWxlbWVudChUYWJsZVJvdywgeyByZWY6IHRoaXMucm93UmVmcy5jcmVhdGVSZWYocm93KSwga2V5OiBjZWxscy5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IGNlbGxzWzBdLmRhdGUudG9JU09TdHJpbmcoKSAvKiBiZXN0PyBvciBwdXQga2V5IG9uIGNlbGw/IG9yIHVzZSBkaWZmIGZvcm1hdHRlcj8gKi9cbiAgICAgICAgICAgICAgICA6IHJvdyAvLyBpbiBjYXNlIHRoZXJlIGFyZSBubyBjZWxscyAobGlrZSB3aGVuIHJlc291cmNlIHZpZXcgaXMgbG9hZGluZylcbiAgICAgICAgICAgICwgc2hvd0RheU51bWJlcnM6IHJvd0NudCA+IDEsIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBjZWxscywgcmVuZGVySW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBidXNpbmVzc0hvdXJTZWdzOiBidXNpbmVzc0hvdXJTZWdzQnlSb3dbcm93XSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBiZ0V2ZW50U2VnczogYmdFdmVudFNlZ3NCeVJvd1tyb3ddLmZpbHRlcihpc1NlZ0FsbERheSkgLyogaGFjayAqLywgZmdFdmVudFNlZ3M6IGZnRXZlbnRTZWdzQnlSb3dbcm93XSwgZGF0ZVNlbGVjdGlvblNlZ3M6IGRhdGVTZWxlY3Rpb25TZWdzQnlSb3dbcm93XSwgZXZlbnREcmFnOiBldmVudERyYWdCeVJvd1tyb3ddLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVCeVJvd1tyb3ddLCBkYXlNYXhFdmVudHM6IHByb3BzLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGNlbGxNaW5IZWlnaHQ6IGNlbGxNaW5IZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSkpKSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCgpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIC8vIGZvciBpZiBzdGFydGVkIHdpdGggemVybyBjZWxsc1xuICAgICAgICB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvb3RFbCkge1xuICAgICAgICAgICAgLy8gSEFDSzogbmVlZCBhIGRheWdyaWQgd3JhcHBlciBwYXJlbnQgdG8gZG8gcG9zaXRpb25pbmdcbiAgICAgICAgICAgIC8vIE5PVEU6IGEgZGF5Z3JpZCByZXNvdXJjZSB2aWV3IHcvbyByZXNvdXJjZXMgY2FuIGhhdmUgemVybyBjZWxsc1xuICAgICAgICAgICAgY29uc3QgZmlyc3RDZWxsRWwgPSB0aGlzLnJvd1JlZnMuY3VycmVudE1hcFswXS5nZXRDZWxsRWxzKClbMF07XG4gICAgICAgICAgICBjb25zdCByb290RWwgPSBmaXJzdENlbGxFbCA/IGZpcnN0Q2VsbEVsLmNsb3Nlc3QoJy5mYy1kYXlncmlkLWJvZHknKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAocm9vdEVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290RWwgPSByb290RWw7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogdGhpcy5wcm9wcy5pc0hpdENvbWJvQWxsb3dlZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdEVsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yb290RWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhpdCBTeXN0ZW1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcHJlcGFyZUhpdHMoKSB7XG4gICAgICAgIHRoaXMucm93UG9zaXRpb25zID0gbmV3IFBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWwsIHRoaXMucm93UmVmcy5jb2xsZWN0KCkubWFwKChyb3dPYmopID0+IHJvd09iai5nZXRDZWxsRWxzKClbMF0pLCAvLyBmaXJzdCBjZWxsIGVsIGluIGVhY2ggcm93LiBUT0RPOiBub3Qgb3B0aW1hbFxuICAgICAgICBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY29sUG9zaXRpb25zID0gbmV3IFBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWwsIHRoaXMucm93UmVmcy5jdXJyZW50TWFwWzBdLmdldENlbGxFbHMoKSwgLy8gY2VsbCBlbHMgaW4gZmlyc3Qgcm93XG4gICAgICAgIHRydWUsIC8vIGhvcml6b250YWxcbiAgICAgICAgZmFsc2UpO1xuICAgIH1cbiAgICBxdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wKSB7XG4gICAgICAgIGxldCB7IGNvbFBvc2l0aW9ucywgcm93UG9zaXRpb25zIH0gPSB0aGlzO1xuICAgICAgICBsZXQgY29sID0gY29sUG9zaXRpb25zLmxlZnRUb0luZGV4KHBvc2l0aW9uTGVmdCk7XG4gICAgICAgIGxldCByb3cgPSByb3dQb3NpdGlvbnMudG9wVG9JbmRleChwb3NpdGlvblRvcCk7XG4gICAgICAgIGlmIChyb3cgIT0gbnVsbCAmJiBjb2wgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGNlbGwgPSB0aGlzLnByb3BzLmNlbGxzW3Jvd11bY29sXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IE9iamVjdC5hc3NpZ24oeyByYW5nZTogdGhpcy5nZXRDZWxsUmFuZ2Uocm93LCBjb2wpLCBhbGxEYXk6IHRydWUgfSwgY2VsbC5leHRyYURhdGVTcGFuKSxcbiAgICAgICAgICAgICAgICBkYXlFbDogdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sUG9zaXRpb25zLmxlZnRzW2NvbF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjb2xQb3NpdGlvbnMucmlnaHRzW2NvbF0sXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcm93UG9zaXRpb25zLnRvcHNbcm93XSxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiByb3dQb3NpdGlvbnMuYm90dG9tc1tyb3ddLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGF5ZXI6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRDZWxsRWwocm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93UmVmcy5jdXJyZW50TWFwW3Jvd10uZ2V0Q2VsbEVscygpW2NvbF07IC8vIFRPRE86IG5vdCBvcHRpbWFsXG4gICAgfVxuICAgIGdldENlbGxSYW5nZShyb3csIGNvbCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnByb3BzLmNlbGxzW3Jvd11bY29sXS5kYXRlO1xuICAgICAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgMSk7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1NlZ0FsbERheShzZWcpIHtcbiAgICByZXR1cm4gc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheTtcbn1cblxuY2xhc3MgVGFibGUgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5lbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF5TWF4RXZlbnRSb3dzLCBkYXlNYXhFdmVudHMsIGV4cGFuZFJvd3MgfSA9IHByb3BzO1xuICAgICAgICBsZXQgbGltaXRWaWFCYWxhbmNlZCA9IGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWU7XG4gICAgICAgIC8vIGlmIHJvd3MgY2FuJ3QgZXhwYW5kIHRvIGZpbGwgZml4ZWQgaGVpZ2h0LCBjYW4ndCBkbyBiYWxhbmNlZC1oZWlnaHQgZXZlbnQgbGltaXRcbiAgICAgICAgLy8gVE9ETzogYmVzdCBwbGFjZSB0byBub3JtYWxpemUgdGhlc2Ugb3B0aW9ucz9cbiAgICAgICAgaWYgKGxpbWl0VmlhQmFsYW5jZWQgJiYgIWV4cGFuZFJvd3MpIHtcbiAgICAgICAgICAgIGxpbWl0VmlhQmFsYW5jZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRheU1heEV2ZW50Um93cyA9IG51bGw7XG4gICAgICAgICAgICBkYXlNYXhFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjLWRheWdyaWQtYm9keScsXG4gICAgICAgICAgICBsaW1pdFZpYUJhbGFuY2VkID8gJ2ZjLWRheWdyaWQtYm9keS1iYWxhbmNlZCcgOiAnZmMtZGF5Z3JpZC1ib2R5LXVuYmFsYW5jZWQnLFxuICAgICAgICAgICAgZXhwYW5kUm93cyA/ICcnIDogJ2ZjLWRheWdyaWQtYm9keS1uYXR1cmFsJywgLy8gd2lsbCBoZWlnaHQgb2Ygb25lIHJvdyBkZXBlbmQgb24gdGhlIG90aGVycz9cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmVsUmVmLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIC8vIHRoZXNlIHByb3BzIGFyZSBpbXBvcnRhbnQgdG8gZ2l2ZSB0aGlzIHdyYXBwZXIgY29ycmVjdCBkaW1lbnNpb25zIGZvciBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZiB3ZSBzZXQgaXQgaGVyZSwgY2FuIHdlIGF2b2lkIGdpdmluZyB0byBpbm5lciB0YWJsZXM/XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3luYy10YWJsZVwiLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGV4cGFuZFJvd3MgPyBwcm9wcy5jbGllbnRIZWlnaHQgOiAnJyxcbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgcHJvcHMuY29sR3JvdXBOb2RlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUYWJsZVJvd3MsIHsgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBjZWxsczogcHJvcHMuY2VsbHMsIHJlbmRlclJvd0ludHJvOiBwcm9wcy5yZW5kZXJSb3dJbnRybywgc2hvd1dlZWtOdW1iZXJzOiBwcm9wcy5zaG93V2Vla051bWJlcnMsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGJ1c2luZXNzSG91clNlZ3M6IHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGJnRXZlbnRTZWdzOiBwcm9wcy5iZ0V2ZW50U2VncywgZmdFdmVudFNlZ3M6IHByb3BzLmZnRXZlbnRTZWdzLCBkYXRlU2VsZWN0aW9uU2VnczogcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgZGF5TWF4RXZlbnRzOiBkYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogZGF5TWF4RXZlbnRSb3dzLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIGlzSGl0Q29tYm9BbGxvd2VkOiBwcm9wcy5pc0hpdENvbWJvQWxsb3dlZCB9KSkpKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RTY3JvbGxSZXNldCgpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGlmIChwcmV2UHJvcHMuZGF0ZVByb2ZpbGUgIT09IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFNjcm9sbFJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoU2Nyb2xsUmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0U2Nyb2xsUmVzZXQoKSB7XG4gICAgICAgIHRoaXMubmVlZHNTY3JvbGxSZXNldCA9IHRydWU7XG4gICAgICAgIHRoaXMuZmx1c2hTY3JvbGxSZXNldCgpO1xuICAgIH1cbiAgICBmbHVzaFNjcm9sbFJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5uZWVkc1Njcm9sbFJlc2V0ICYmXG4gICAgICAgICAgICB0aGlzLnByb3BzLmNsaWVudFdpZHRoIC8vIHNpemVzIGNvbXB1dGVkP1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmplY3RFbCA9IGdldFNjcm9sbFN1YmplY3RFbCh0aGlzLmVsUmVmLmN1cnJlbnQsIHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUpO1xuICAgICAgICAgICAgaWYgKHN1YmplY3RFbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbkVsID0gc3ViamVjdEVsLmNsb3Nlc3QoJy5mYy1kYXlncmlkLWJvZHknKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxFbCA9IG9yaWdpbkVsLmNsb3Nlc3QoJy5mYy1zY3JvbGxlcicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHN1YmplY3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLVxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgICAgICAgICAgc2Nyb2xsRWwuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wID8gKHNjcm9sbFRvcCArIDEpIDogMDsgLy8gb3ZlcmNvbWUgYm9yZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNjcm9sbFN1YmplY3RFbChjb250YWluZXJFbCwgZGF0ZVByb2ZpbGUpIHtcbiAgICBsZXQgZWw7XG4gICAgaWYgKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQubWF0Y2goL3llYXJ8bW9udGgvKSkge1xuICAgICAgICBlbCA9IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWRhdGU9XCIke2Zvcm1hdElzb01vbnRoU3RyKGRhdGVQcm9maWxlLmN1cnJlbnREYXRlKX0tMDFcIl1gKTtcbiAgICAgICAgLy8gZXZlbiBpZiB2aWV3IGlzIG1vbnRoLWJhc2VkLCBmaXJzdC1vZi1tb250aCBtaWdodCBiZSBoaWRkZW4uLi5cbiAgICB9XG4gICAgaWYgKCFlbCkge1xuICAgICAgICBlbCA9IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWRhdGU9XCIke2Zvcm1hdERheVN0cmluZyhkYXRlUHJvZmlsZS5jdXJyZW50RGF0ZSl9XCJdYCk7XG4gICAgICAgIC8vIGNvdWxkIHN0aWxsIGJlIGhpZGRlbiBpZiBhbiBpbnRlcmlvci12aWV3IGhpZGRlbiBkYXlcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xufVxuXG5jbGFzcyBEYXlUYWJsZVNsaWNlciBleHRlbmRzIFNsaWNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtID0gdHJ1ZTtcbiAgICB9XG4gICAgc2xpY2VSYW5nZShkYXRlUmFuZ2UsIGRheVRhYmxlTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGRheVRhYmxlTW9kZWwuc2xpY2VSYW5nZShkYXRlUmFuZ2UpO1xuICAgIH1cbn1cblxuY2xhc3MgRGF5VGFibGUgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zbGljZXIgPSBuZXcgRGF5VGFibGVTbGljZXIoKTtcbiAgICAgICAgdGhpcy50YWJsZVJlZiA9IGNyZWF0ZVJlZigpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGFibGUsIE9iamVjdC5hc3NpZ24oeyByZWY6IHRoaXMudGFibGVSZWYgfSwgdGhpcy5zbGljZXIuc2xpY2VQcm9wcyhwcm9wcywgcHJvcHMuZGF0ZVByb2ZpbGUsIHByb3BzLm5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIHByb3BzLmRheVRhYmxlTW9kZWwpLCB7IGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgY2VsbHM6IHByb3BzLmRheVRhYmxlTW9kZWwuY2VsbHMsIGNvbEdyb3VwTm9kZTogcHJvcHMuY29sR3JvdXBOb2RlLCB0YWJsZU1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLCByZW5kZXJSb3dJbnRybzogcHJvcHMucmVuZGVyUm93SW50cm8sIGRheU1heEV2ZW50czogcHJvcHMuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IHByb3BzLmRheU1heEV2ZW50Um93cywgc2hvd1dlZWtOdW1iZXJzOiBwcm9wcy5zaG93V2Vla051bWJlcnMsIGV4cGFuZFJvd3M6IHByb3BzLmV4cGFuZFJvd3MsIGhlYWRlckFsaWduRWxSZWY6IHByb3BzLmhlYWRlckFsaWduRWxSZWYsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSkpO1xuICAgIH1cbn1cblxuY2xhc3MgRGF5VGFibGVWaWV3IGV4dGVuZHMgVGFibGVWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5idWlsZERheVRhYmxlTW9kZWwgPSBtZW1vaXplKGJ1aWxkRGF5VGFibGVNb2RlbCk7XG4gICAgICAgIHRoaXMuaGVhZGVyUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMudGFibGVSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgLy8gY2FuJ3Qgb3ZlcnJpZGUgYW55IGxpZmVjeWNsZSBtZXRob2RzIGZyb20gcGFyZW50XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBkYXlUYWJsZU1vZGVsID0gdGhpcy5idWlsZERheVRhYmxlTW9kZWwocHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgbGV0IGhlYWRlckNvbnRlbnQgPSBvcHRpb25zLmRheUhlYWRlcnMgJiYgKGNyZWF0ZUVsZW1lbnQoRGF5SGVhZGVyLCB7IHJlZjogdGhpcy5oZWFkZXJSZWYsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZXM6IGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXMsIGRhdGVzUmVwRGlzdGluY3REYXlzOiBkYXlUYWJsZU1vZGVsLnJvd0NudCA9PT0gMSB9KSk7XG4gICAgICAgIGxldCBib2R5Q29udGVudCA9IChjb250ZW50QXJnKSA9PiAoY3JlYXRlRWxlbWVudChEYXlUYWJsZSwgeyByZWY6IHRoaXMudGFibGVSZWYsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgYnVzaW5lc3NIb3VyczogcHJvcHMuYnVzaW5lc3NIb3VycywgZGF0ZVNlbGVjdGlvbjogcHJvcHMuZGF0ZVNlbGVjdGlvbiwgZXZlbnRTdG9yZTogcHJvcHMuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzOiBwcm9wcy5ldmVudFVpQmFzZXMsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgbmV4dERheVRocmVzaG9sZDogb3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkLCBjb2xHcm91cE5vZGU6IGNvbnRlbnRBcmcudGFibGVDb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IGNvbnRlbnRBcmcudGFibGVNaW5XaWR0aCwgZGF5TWF4RXZlbnRzOiBvcHRpb25zLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBvcHRpb25zLmRheU1heEV2ZW50Um93cywgc2hvd1dlZWtOdW1iZXJzOiBvcHRpb25zLndlZWtOdW1iZXJzLCBleHBhbmRSb3dzOiAhcHJvcHMuaXNIZWlnaHRBdXRvLCBoZWFkZXJBbGlnbkVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLCBjbGllbnRXaWR0aDogY29udGVudEFyZy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBjb250ZW50QXJnLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGF5TWluV2lkdGhcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlckNvbnRlbnQsIGJvZHlDb250ZW50LCBkYXlUYWJsZU1vZGVsLmNvbENudCwgb3B0aW9ucy5kYXlNaW5XaWR0aClcbiAgICAgICAgICAgIDogdGhpcy5yZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyQ29udGVudCwgYm9keUNvbnRlbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRGF5VGFibGVNb2RlbChkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICBsZXQgZGF5U2VyaWVzID0gbmV3IERheVNlcmllc01vZGVsKGRhdGVQcm9maWxlLnJlbmRlclJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgcmV0dXJuIG5ldyBEYXlUYWJsZU1vZGVsKGRheVNlcmllcywgL3llYXJ8bW9udGh8d2Vlay8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSk7XG59XG5cbmNsYXNzIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IgZXh0ZW5kcyBEYXRlUHJvZmlsZUdlbmVyYXRvciB7XG4gICAgLy8gQ29tcHV0ZXMgdGhlIGRhdGUgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlbmRlcmVkXG4gICAgYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcbiAgICAgICAgbGV0IHJlbmRlclJhbmdlID0gc3VwZXIuYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpO1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGJ1aWxkRGF5VGFibGVSZW5kZXJSYW5nZSh7XG4gICAgICAgICAgICBjdXJyZW50UmFuZ2U6IHJlbmRlclJhbmdlLFxuICAgICAgICAgICAgc25hcFRvV2VlazogL14oeWVhcnxtb250aCkkLy50ZXN0KGN1cnJlbnRSYW5nZVVuaXQpLFxuICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHByb3BzLmZpeGVkV2Vla0NvdW50LFxuICAgICAgICAgICAgZGF0ZUVudjogcHJvcHMuZGF0ZUVudixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlKHByb3BzKSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgY3VycmVudFJhbmdlIH0gPSBwcm9wcztcbiAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBjdXJyZW50UmFuZ2U7XG4gICAgbGV0IGVuZE9mV2VlaztcbiAgICAvLyB5ZWFyIGFuZCBtb250aCB2aWV3cyBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHdlZWtzLiB0aGlzIGlzIGFscmVhZHkgZG9uZSBmb3Igd2Vla1xuICAgIGlmIChwcm9wcy5zbmFwVG9XZWVrKSB7XG4gICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mV2VlayhzdGFydCk7XG4gICAgICAgIC8vIG1ha2UgZW5kLW9mLXdlZWsgaWYgbm90IGFscmVhZHlcbiAgICAgICAgZW5kT2ZXZWVrID0gZGF0ZUVudi5zdGFydE9mV2VlayhlbmQpO1xuICAgICAgICBpZiAoZW5kT2ZXZWVrLnZhbHVlT2YoKSAhPT0gZW5kLnZhbHVlT2YoKSkge1xuICAgICAgICAgICAgZW5kID0gYWRkV2Vla3MoZW5kT2ZXZWVrLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlbnN1cmUgNiB3ZWVrc1xuICAgIGlmIChwcm9wcy5maXhlZFdlZWtDb3VudCkge1xuICAgICAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIHRoZXNlIGRhdGUtbWF0aCBneW1uYXN0aWNzIChmb3IgbXVsdGltb250aCB2aWV3KSxcbiAgICAgICAgLy8gY29tcHV0ZSBkYXRlcHJvZmlsZXMgb2YgYWxsIG1vbnRocywgdGhlbiB1c2Ugc3RhcnQgb2YgZmlyc3QgYW5kIGVuZCBvZiBsYXN0LlxuICAgICAgICBsZXQgbGFzdE1vbnRoUmVuZGVyU3RhcnQgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKGRhdGVFbnYuc3RhcnRPZk1vbnRoKGFkZERheXMoY3VycmVudFJhbmdlLmVuZCwgLTEpKSk7XG4gICAgICAgIGxldCByb3dDbnQgPSBNYXRoLmNlaWwoLy8gY291bGQgYmUgcGFydGlhbCB3ZWVrcyBkdWUgdG8gaGlkZGVuRGF5c1xuICAgICAgICBkaWZmV2Vla3MobGFzdE1vbnRoUmVuZGVyU3RhcnQsIGVuZCkpO1xuICAgICAgICBlbmQgPSBhZGRXZWVrcyhlbmQsIDYgLSByb3dDbnQpO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG5cbnZhciBjc3NfMjQ4eiA9IFwiOnJvb3R7LS1mYy1kYXlncmlkLWV2ZW50LWRvdC13aWR0aDo4cHh9LmZjLWRheWdyaWQtZGF5LWV2ZW50czphZnRlciwuZmMtZGF5Z3JpZC1kYXktZXZlbnRzOmJlZm9yZSwuZmMtZGF5Z3JpZC1kYXktZnJhbWU6YWZ0ZXIsLmZjLWRheWdyaWQtZGF5LWZyYW1lOmJlZm9yZSwuZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzOmFmdGVyLC5mYy1kYXlncmlkLWV2ZW50LWhhcm5lc3M6YmVmb3Jle2NsZWFyOmJvdGg7Y29udGVudDpcXFwiXFxcIjtkaXNwbGF5OnRhYmxlfS5mYyAuZmMtZGF5Z3JpZC1ib2R5e3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MX0uZmMgLmZjLWRheWdyaWQtZGF5LmZjLWRheS10b2RheXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLXRvZGF5LWJnLWNvbG9yKX0uZmMgLmZjLWRheWdyaWQtZGF5LWZyYW1le21pbi1oZWlnaHQ6MTAwJTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWRheWdyaWQtZGF5LXRvcHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2V9LmZjIC5mYy1kYXktb3RoZXIgLmZjLWRheWdyaWQtZGF5LXRvcHtvcGFjaXR5Oi4zfS5mYyAuZmMtZGF5Z3JpZC1kYXktbnVtYmVye3BhZGRpbmc6NHB4O3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6NH0uZmMgLmZjLWRheWdyaWQtbW9udGgtc3RhcnR7Zm9udC1zaXplOjEuMWVtO2ZvbnQtd2VpZ2h0OjcwMH0uZmMgLmZjLWRheWdyaWQtZGF5LWV2ZW50c3ttYXJnaW4tdG9wOjFweH0uZmMgLmZjLWRheWdyaWQtYm9keS1iYWxhbmNlZCAuZmMtZGF5Z3JpZC1kYXktZXZlbnRze2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowfS5mYyAuZmMtZGF5Z3JpZC1ib2R5LXVuYmFsYW5jZWQgLmZjLWRheWdyaWQtZGF5LWV2ZW50c3ttaW4taGVpZ2h0OjJlbTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWRheWdyaWQtYm9keS1uYXR1cmFsIC5mYy1kYXlncmlkLWRheS1ldmVudHN7bWFyZ2luLWJvdHRvbToxZW19LmZjIC5mYy1kYXlncmlkLWV2ZW50LWhhcm5lc3N7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy1kYXlncmlkLWV2ZW50LWhhcm5lc3MtYWJze2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtZGF5Z3JpZC1iZy1oYXJuZXNze2JvdHRvbTowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowfS5mYyAuZmMtZGF5Z3JpZC1kYXktYmcgLmZjLW5vbi1idXNpbmVzc3t6LWluZGV4OjF9LmZjIC5mYy1kYXlncmlkLWRheS1iZyAuZmMtYmctZXZlbnR7ei1pbmRleDoyfS5mYyAuZmMtZGF5Z3JpZC1kYXktYmcgLmZjLWhpZ2hsaWdodHt6LWluZGV4OjN9LmZjIC5mYy1kYXlncmlkLWV2ZW50e21hcmdpbi10b3A6MXB4O3otaW5kZXg6Nn0uZmMgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtbWlycm9ye3otaW5kZXg6N30uZmMgLmZjLWRheWdyaWQtZGF5LWJvdHRvbXtmb250LXNpemU6Ljg1ZW07bWFyZ2luOjAgMnB4fS5mYyAuZmMtZGF5Z3JpZC1kYXktYm90dG9tOmFmdGVyLC5mYyAuZmMtZGF5Z3JpZC1kYXktYm90dG9tOmJlZm9yZXtjbGVhcjpib3RoO2NvbnRlbnQ6XFxcIlxcXCI7ZGlzcGxheTp0YWJsZX0uZmMgLmZjLWRheWdyaWQtbW9yZS1saW5re2JvcmRlci1yYWRpdXM6M3B4O2N1cnNvcjpwb2ludGVyO2xpbmUtaGVpZ2h0OjE7bWFyZ2luLXRvcDoxcHg7bWF4LXdpZHRoOjEwMCU7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MnB4O3Bvc2l0aW9uOnJlbGF0aXZlO3doaXRlLXNwYWNlOm5vd3JhcDt6LWluZGV4OjR9LmZjIC5mYy1kYXlncmlkLW1vcmUtbGluazpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjEpfS5mYyAuZmMtZGF5Z3JpZC13ZWVrLW51bWJlcntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLW5ldXRyYWwtYmctY29sb3IpO2NvbG9yOnZhcigtLWZjLW5ldXRyYWwtdGV4dC1jb2xvcik7bWluLXdpZHRoOjEuNWVtO3BhZGRpbmc6MnB4O3Bvc2l0aW9uOmFic29sdXRlO3RleHQtYWxpZ246Y2VudGVyO3RvcDowO3otaW5kZXg6NX0uZmMgLmZjLW1vcmUtcG9wb3ZlciAuZmMtcG9wb3Zlci1ib2R5e21pbi13aWR0aDoyMjBweDtwYWRkaW5nOjEwcHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtc3RhcnQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtZW5ke21hcmdpbi1sZWZ0OjJweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1lbmQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtc3RhcnR7bWFyZ2luLXJpZ2h0OjJweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1tb3JlLWxpbmt7ZmxvYXQ6bGVmdH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC13ZWVrLW51bWJlcntib3JkZXItcmFkaXVzOjAgMCAzcHggMDtsZWZ0OjB9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtbW9yZS1saW5re2Zsb2F0OnJpZ2h0fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLXdlZWstbnVtYmVye2JvcmRlci1yYWRpdXM6MCAwIDAgM3B4O3JpZ2h0OjB9LmZjLWxpcXVpZC1oYWNrIC5mYy1kYXlncmlkLWRheS1mcmFtZXtwb3NpdGlvbjpzdGF0aWN9LmZjLWRheWdyaWQtZXZlbnR7Ym9yZGVyLXJhZGl1czozcHg7Zm9udC1zaXplOnZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSk7cG9zaXRpb246cmVsYXRpdmU7d2hpdGUtc3BhY2U6bm93cmFwfS5mYy1kYXlncmlkLWJsb2NrLWV2ZW50IC5mYy1ldmVudC10aW1le2ZvbnQtd2VpZ2h0OjcwMH0uZmMtZGF5Z3JpZC1ibG9jay1ldmVudCAuZmMtZXZlbnQtdGltZSwuZmMtZGF5Z3JpZC1ibG9jay1ldmVudCAuZmMtZXZlbnQtdGl0bGV7cGFkZGluZzoxcHh9LmZjLWRheWdyaWQtZG90LWV2ZW50e2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7cGFkZGluZzoycHggMH0uZmMtZGF5Z3JpZC1kb3QtZXZlbnQgLmZjLWV2ZW50LXRpdGxle2ZsZXgtZ3JvdzoxO2ZsZXgtc2hyaW5rOjE7Zm9udC13ZWlnaHQ6NzAwO21pbi13aWR0aDowO292ZXJmbG93OmhpZGRlbn0uZmMtZGF5Z3JpZC1kb3QtZXZlbnQuZmMtZXZlbnQtbWlycm9yLC5mYy1kYXlncmlkLWRvdC1ldmVudDpob3ZlcntiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjEpfS5mYy1kYXlncmlkLWRvdC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmV7Ym90dG9tOi0xMHB4O3RvcDotMTBweH0uZmMtZGF5Z3JpZC1ldmVudC1kb3R7Ym9yZGVyOmNhbGModmFyKC0tZmMtZGF5Z3JpZC1ldmVudC1kb3Qtd2lkdGgpLzIpIHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7Ym9yZGVyLXJhZGl1czpjYWxjKHZhcigtLWZjLWRheWdyaWQtZXZlbnQtZG90LXdpZHRoKS8yKTtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2hlaWdodDowO21hcmdpbjowIDRweDt3aWR0aDowfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWV2ZW50IC5mYy1ldmVudC10aW1le21hcmdpbi1yaWdodDozcHh9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtZXZlbnQgLmZjLWV2ZW50LXRpbWV7bWFyZ2luLWxlZnQ6M3B4fVwiO1xuaW5qZWN0U3R5bGVzKGNzc18yNDh6KTtcblxuZXhwb3J0IHsgRGF5VGFibGVWaWV3IGFzIERheUdyaWRWaWV3LCBEYXlUYWJsZSwgRGF5VGFibGVTbGljZXIsIFRhYmxlLCBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yLCBUYWJsZVJvd3MsIFRhYmxlVmlldywgYnVpbGREYXlUYWJsZU1vZGVsLCBidWlsZERheVRhYmxlUmVuZGVyUmFuZ2UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@fullcalendar/daygrid/internal.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@fullcalendar/react/dist/index.js":
/*!*********************************************************!*\
  !*** ../node_modules/@fullcalendar/react/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ FullCalendar; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _fullcalendar_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fullcalendar/core */ \"(app-pages-browser)/../node_modules/@fullcalendar/core/index.js\");\n/* harmony import */ var _fullcalendar_core_internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/core/internal */ \"(app-pages-browser)/../node_modules/@fullcalendar/core/internal-common.js\");\n\n\n\n\nconst reactMajorVersion = parseInt(String(react__WEBPACK_IMPORTED_MODULE_0__.version).split('.')[0]);\nconst syncRenderingByDefault = reactMajorVersion < 18;\nclass FullCalendar extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor() {\n        super(...arguments);\n        this.elRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n        this.isUpdating = false;\n        this.isUnmounting = false;\n        this.state = {\n            customRenderingMap: new Map()\n        };\n        this.requestResize = () => {\n            if (!this.isUnmounting) {\n                this.cancelResize();\n                this.resizeId = requestAnimationFrame(() => {\n                    this.doResize();\n                });\n            }\n        };\n    }\n    render() {\n        const customRenderingNodes = [];\n        for (const customRendering of this.state.customRenderingMap.values()) {\n            customRenderingNodes.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomRenderingComponent, { key: customRendering.id, customRendering: customRendering }));\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: this.elRef }, customRenderingNodes));\n    }\n    componentDidMount() {\n        // reset b/c react strict-mode calls componentWillUnmount/componentDidMount\n        this.isUnmounting = false;\n        const customRenderingStore = new _fullcalendar_core_internal__WEBPACK_IMPORTED_MODULE_2__.cy();\n        this.handleCustomRendering = customRenderingStore.handle.bind(customRenderingStore);\n        this.calendar = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_3__.Calendar(this.elRef.current, Object.assign(Object.assign({}, this.props), { handleCustomRendering: this.handleCustomRendering }));\n        this.calendar.render();\n        // attaching with .on() will cause this to fire AFTER internal preact rendering did flushSync\n        this.calendar.on('_beforeprint', () => {\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => {\n                // our `customRenderingMap` state will be flushed at this point\n            });\n        });\n        let lastRequestTimestamp;\n        customRenderingStore.subscribe((customRenderingMap) => {\n            const requestTimestamp = Date.now();\n            const isMounting = !lastRequestTimestamp;\n            const runFunc = (\n            // don't call flushSync if React version already does sync rendering by default\n            // guards against fatal errors:\n            // https://github.com/fullcalendar/fullcalendar/issues/7448\n            syncRenderingByDefault ||\n                //\n                isMounting ||\n                this.isUpdating ||\n                this.isUnmounting ||\n                (requestTimestamp - lastRequestTimestamp) < 100 // rerendering frequently\n            ) ? runNow // either sync rendering (first-time or React 16/17) or async (React 18)\n                : react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync; // guaranteed sync rendering\n            runFunc(() => {\n                this.setState({ customRenderingMap }, () => {\n                    lastRequestTimestamp = requestTimestamp;\n                    if (isMounting) {\n                        this.doResize();\n                    }\n                    else {\n                        this.requestResize();\n                    }\n                });\n            });\n        });\n    }\n    componentDidUpdate() {\n        this.isUpdating = true;\n        this.calendar.resetOptions(Object.assign(Object.assign({}, this.props), { handleCustomRendering: this.handleCustomRendering }));\n        this.isUpdating = false;\n    }\n    componentWillUnmount() {\n        this.isUnmounting = true;\n        this.cancelResize();\n        this.calendar.destroy();\n    }\n    doResize() {\n        this.calendar.updateSize();\n    }\n    cancelResize() {\n        if (this.resizeId !== undefined) {\n            cancelAnimationFrame(this.resizeId);\n            this.resizeId = undefined;\n        }\n    }\n    getApi() {\n        return this.calendar;\n    }\n}\nFullCalendar.act = runNow; // DEPRECATED. Not leveraged anymore\nclass CustomRenderingComponent extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    render() {\n        const { customRendering } = this.props;\n        const { generatorMeta } = customRendering;\n        const vnode = typeof generatorMeta === 'function' ?\n            generatorMeta(customRendering.renderProps) :\n            generatorMeta;\n        return (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(vnode, customRendering.containerEl);\n    }\n}\n// Util\n// -------------------------------------------------------------------------------------------------\nfunction runNow(f) {\n    f();\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1FO0FBQ2Y7QUFDTDtBQUNxQjtBQUNwRSwwQ0FBMEMsMENBQWE7QUFDdkQ7QUFDZSwyQkFBMkIsNENBQVM7QUFDbkQ7QUFDQTtBQUNBLHFCQUFxQixnREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0RBQW1CLDZCQUE2QiwyREFBMkQ7QUFDako7QUFDQSxnQkFBZ0IsZ0RBQW1CLFVBQVUsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDJEQUFvQjtBQUM3RDtBQUNBLDRCQUE0Qix3REFBUSxtREFBbUQsaUJBQWlCLG1EQUFtRDtBQUMzSjtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFTO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQVMsRUFBRTtBQUM3QjtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsaUJBQWlCLG1EQUFtRDtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLHVDQUF1QyxnREFBYTtBQUNwRDtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3JlYWN0L2Rpc3QvaW5kZXguanM/MzA5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBjcmVhdGVSZWYsIFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwsIGZsdXNoU3luYyB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBDYWxlbmRhciwgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUnO1xuaW1wb3J0IHsgQ3VzdG9tUmVuZGVyaW5nU3RvcmUsIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsJztcbmNvbnN0IHJlYWN0TWFqb3JWZXJzaW9uID0gcGFyc2VJbnQoU3RyaW5nKFJlYWN0LnZlcnNpb24pLnNwbGl0KCcuJylbMF0pO1xuY29uc3Qgc3luY1JlbmRlcmluZ0J5RGVmYXVsdCA9IHJlYWN0TWFqb3JWZXJzaW9uIDwgMTg7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGdWxsQ2FsZW5kYXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVW5tb3VudGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY3VzdG9tUmVuZGVyaW5nTWFwOiBuZXcgTWFwKClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVW5tb3VudGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsUmVzaXplKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9SZXNpemUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBjdXN0b21SZW5kZXJpbmdOb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGN1c3RvbVJlbmRlcmluZyBvZiB0aGlzLnN0YXRlLmN1c3RvbVJlbmRlcmluZ01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY3VzdG9tUmVuZGVyaW5nTm9kZXMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KEN1c3RvbVJlbmRlcmluZ0NvbXBvbmVudCwgeyBrZXk6IGN1c3RvbVJlbmRlcmluZy5pZCwgY3VzdG9tUmVuZGVyaW5nOiBjdXN0b21SZW5kZXJpbmcgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5lbFJlZiB9LCBjdXN0b21SZW5kZXJpbmdOb2RlcykpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgLy8gcmVzZXQgYi9jIHJlYWN0IHN0cmljdC1tb2RlIGNhbGxzIGNvbXBvbmVudFdpbGxVbm1vdW50L2NvbXBvbmVudERpZE1vdW50XG4gICAgICAgIHRoaXMuaXNVbm1vdW50aW5nID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGN1c3RvbVJlbmRlcmluZ1N0b3JlID0gbmV3IEN1c3RvbVJlbmRlcmluZ1N0b3JlKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ3VzdG9tUmVuZGVyaW5nID0gY3VzdG9tUmVuZGVyaW5nU3RvcmUuaGFuZGxlLmJpbmQoY3VzdG9tUmVuZGVyaW5nU3RvcmUpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyID0gbmV3IENhbGVuZGFyKHRoaXMuZWxSZWYuY3VycmVudCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzKSwgeyBoYW5kbGVDdXN0b21SZW5kZXJpbmc6IHRoaXMuaGFuZGxlQ3VzdG9tUmVuZGVyaW5nIH0pKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhci5yZW5kZXIoKTtcbiAgICAgICAgLy8gYXR0YWNoaW5nIHdpdGggLm9uKCkgd2lsbCBjYXVzZSB0aGlzIHRvIGZpcmUgQUZURVIgaW50ZXJuYWwgcHJlYWN0IHJlbmRlcmluZyBkaWQgZmx1c2hTeW5jXG4gICAgICAgIHRoaXMuY2FsZW5kYXIub24oJ19iZWZvcmVwcmludCcsICgpID0+IHtcbiAgICAgICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gb3VyIGBjdXN0b21SZW5kZXJpbmdNYXBgIHN0YXRlIHdpbGwgYmUgZmx1c2hlZCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsYXN0UmVxdWVzdFRpbWVzdGFtcDtcbiAgICAgICAgY3VzdG9tUmVuZGVyaW5nU3RvcmUuc3Vic2NyaWJlKChjdXN0b21SZW5kZXJpbmdNYXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgY29uc3QgaXNNb3VudGluZyA9ICFsYXN0UmVxdWVzdFRpbWVzdGFtcDtcbiAgICAgICAgICAgIGNvbnN0IHJ1bkZ1bmMgPSAoXG4gICAgICAgICAgICAvLyBkb24ndCBjYWxsIGZsdXNoU3luYyBpZiBSZWFjdCB2ZXJzaW9uIGFscmVhZHkgZG9lcyBzeW5jIHJlbmRlcmluZyBieSBkZWZhdWx0XG4gICAgICAgICAgICAvLyBndWFyZHMgYWdhaW5zdCBmYXRhbCBlcnJvcnM6XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvNzQ0OFxuICAgICAgICAgICAgc3luY1JlbmRlcmluZ0J5RGVmYXVsdCB8fFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaXNNb3VudGluZyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuaXNVcGRhdGluZyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuaXNVbm1vdW50aW5nIHx8XG4gICAgICAgICAgICAgICAgKHJlcXVlc3RUaW1lc3RhbXAgLSBsYXN0UmVxdWVzdFRpbWVzdGFtcCkgPCAxMDAgLy8gcmVyZW5kZXJpbmcgZnJlcXVlbnRseVxuICAgICAgICAgICAgKSA/IHJ1bk5vdyAvLyBlaXRoZXIgc3luYyByZW5kZXJpbmcgKGZpcnN0LXRpbWUgb3IgUmVhY3QgMTYvMTcpIG9yIGFzeW5jIChSZWFjdCAxOClcbiAgICAgICAgICAgICAgICA6IGZsdXNoU3luYzsgLy8gZ3VhcmFudGVlZCBzeW5jIHJlbmRlcmluZ1xuICAgICAgICAgICAgcnVuRnVuYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGN1c3RvbVJlbmRlcmluZ01hcCB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZXF1ZXN0VGltZXN0YW1wID0gcmVxdWVzdFRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW91bnRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9SZXNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWxlbmRhci5yZXNldE9wdGlvbnMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzKSwgeyBoYW5kbGVDdXN0b21SZW5kZXJpbmc6IHRoaXMuaGFuZGxlQ3VzdG9tUmVuZGVyaW5nIH0pKTtcbiAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmlzVW5tb3VudGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FuY2VsUmVzaXplKCk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkb1Jlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5jYWxlbmRhci51cGRhdGVTaXplKCk7XG4gICAgfVxuICAgIGNhbmNlbFJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXNpemVJZCk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZUlkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEFwaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXI7XG4gICAgfVxufVxuRnVsbENhbGVuZGFyLmFjdCA9IHJ1bk5vdzsgLy8gREVQUkVDQVRFRC4gTm90IGxldmVyYWdlZCBhbnltb3JlXG5jbGFzcyBDdXN0b21SZW5kZXJpbmdDb21wb25lbnQgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY3VzdG9tUmVuZGVyaW5nIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IGdlbmVyYXRvck1ldGEgfSA9IGN1c3RvbVJlbmRlcmluZztcbiAgICAgICAgY29uc3Qgdm5vZGUgPSB0eXBlb2YgZ2VuZXJhdG9yTWV0YSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICBnZW5lcmF0b3JNZXRhKGN1c3RvbVJlbmRlcmluZy5yZW5kZXJQcm9wcykgOlxuICAgICAgICAgICAgZ2VuZXJhdG9yTWV0YTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvcnRhbCh2bm9kZSwgY3VzdG9tUmVuZGVyaW5nLmNvbnRhaW5lckVsKTtcbiAgICB9XG59XG4vLyBVdGlsXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBydW5Ob3coZikge1xuICAgIGYoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@fullcalendar/react/dist/index.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fbryce%2FDocuments%2FRepos%2Ftimespark%2Ffrontend%2Fsrc%2Fapp%2F(pages)%2Fcalendar%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);